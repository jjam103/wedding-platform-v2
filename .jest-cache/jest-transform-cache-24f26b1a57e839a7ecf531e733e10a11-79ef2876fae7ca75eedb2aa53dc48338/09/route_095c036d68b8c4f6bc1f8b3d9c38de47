fee0ebb103afc589792151de1e05e128
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "POST", {
    enumerable: true,
    get: function() {
        return POST;
    }
});
const _supabaseServer = require("../../../../../lib/supabaseServer");
const _server = require("next/server");
const _zod = require("zod");
/**
 * POST /api/admin/guests/bulk-auth-method
 * 
 * Updates authentication method for multiple guests
 * 
 * Requirements: 22.7
 */ const bulkUpdateAuthMethodSchema = _zod.z.object({
    guest_ids: _zod.z.array(_zod.z.string().uuid()).min(1).max(100),
    auth_method: _zod.z.enum([
        'email_matching',
        'magic_link'
    ]),
    send_notification: _zod.z.boolean().optional().default(false)
});
function getStatusCode(errorCode) {
    const statusMap = {
        'VALIDATION_ERROR': 400,
        'UNAUTHORIZED': 401,
        'FORBIDDEN': 403,
        'DATABASE_ERROR': 500,
        'INTERNAL_ERROR': 500
    };
    return statusMap[errorCode] || 500;
}
async function POST(request) {
    try {
        // 1. AUTHENTICATION
        const supabase = await (0, _supabaseServer.createAuthenticatedClient)();
        const { data: { session }, error: authError } = await supabase.auth.getSession();
        if (authError || !session) {
            return _server.NextResponse.json({
                success: false,
                error: {
                    code: 'UNAUTHORIZED',
                    message: 'Authentication required'
                }
            }, {
                status: 401
            });
        }
        // 2. VALIDATION
        const body = await request.json();
        const validation = bulkUpdateAuthMethodSchema.safeParse(body);
        if (!validation.success) {
            return _server.NextResponse.json({
                success: false,
                error: {
                    code: 'VALIDATION_ERROR',
                    message: 'Invalid request data',
                    details: validation.error.issues
                }
            }, {
                status: 400
            });
        }
        const { guest_ids, auth_method, send_notification } = validation.data;
        // 3. SERVICE CALL
        // Update all guests in a single query
        const { data: updatedGuests, error: updateError } = await supabase.from('guests').update({
            auth_method
        }).in('id', guest_ids).select('id, email, first_name, last_name, auth_method');
        if (updateError) {
            return _server.NextResponse.json({
                success: false,
                error: {
                    code: 'DATABASE_ERROR',
                    message: 'Failed to update guests',
                    details: updateError
                }
            }, {
                status: 500
            });
        }
        // TODO: Send notification emails if requested (Task 8.3)
        // This will be implemented when email system is enhanced
        if (send_notification && updatedGuests && updatedGuests.length > 0) {
            // Future: Send email notifications to guests about auth method change
            console.log(`Would send notifications to ${updatedGuests.length} guests about auth method change`);
        }
        // 4. RESPONSE
        return _server.NextResponse.json({
            success: true,
            data: {
                updated_count: updatedGuests?.length || 0,
                guests: updatedGuests || []
            }
        }, {
            status: 200
        });
    } catch (error) {
        console.error('API Error:', {
            path: request.url,
            method: request.method,
            error
        });
        return _server.NextResponse.json({
            success: false,
            error: {
                code: 'INTERNAL_ERROR',
                message: 'An unexpected error occurred'
            }
        }, {
            status: 500
        });
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvYXBwL2FwaS9hZG1pbi9ndWVzdHMvYnVsay1hdXRoLW1ldGhvZC9yb3V0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVBdXRoZW50aWNhdGVkQ2xpZW50IH0gZnJvbSAnQC9saWIvc3VwYWJhc2VTZXJ2ZXInO1xuaW1wb3J0IHsgTmV4dFJlc3BvbnNlIH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xuaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5cbi8qKlxuICogUE9TVCAvYXBpL2FkbWluL2d1ZXN0cy9idWxrLWF1dGgtbWV0aG9kXG4gKiBcbiAqIFVwZGF0ZXMgYXV0aGVudGljYXRpb24gbWV0aG9kIGZvciBtdWx0aXBsZSBndWVzdHNcbiAqIFxuICogUmVxdWlyZW1lbnRzOiAyMi43XG4gKi9cblxuY29uc3QgYnVsa1VwZGF0ZUF1dGhNZXRob2RTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIGd1ZXN0X2lkczogei5hcnJheSh6LnN0cmluZygpLnV1aWQoKSkubWluKDEpLm1heCgxMDApLFxuICBhdXRoX21ldGhvZDogei5lbnVtKFsnZW1haWxfbWF0Y2hpbmcnLCAnbWFnaWNfbGluayddKSxcbiAgc2VuZF9ub3RpZmljYXRpb246IHouYm9vbGVhbigpLm9wdGlvbmFsKCkuZGVmYXVsdChmYWxzZSksXG59KTtcblxuZnVuY3Rpb24gZ2V0U3RhdHVzQ29kZShlcnJvckNvZGU6IHN0cmluZyk6IG51bWJlciB7XG4gIGNvbnN0IHN0YXR1c01hcDogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHtcbiAgICAnVkFMSURBVElPTl9FUlJPUic6IDQwMCxcbiAgICAnVU5BVVRIT1JJWkVEJzogNDAxLFxuICAgICdGT1JCSURERU4nOiA0MDMsXG4gICAgJ0RBVEFCQVNFX0VSUk9SJzogNTAwLFxuICAgICdJTlRFUk5BTF9FUlJPUic6IDUwMCxcbiAgfTtcbiAgcmV0dXJuIHN0YXR1c01hcFtlcnJvckNvZGVdIHx8IDUwMDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIFBPU1QocmVxdWVzdDogUmVxdWVzdCkge1xuICB0cnkge1xuICAgIC8vIDEuIEFVVEhFTlRJQ0FUSU9OXG4gICAgY29uc3Qgc3VwYWJhc2UgPSBhd2FpdCBjcmVhdGVBdXRoZW50aWNhdGVkQ2xpZW50KCk7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YTogeyBzZXNzaW9uIH0sXG4gICAgICBlcnJvcjogYXV0aEVycm9yLFxuICAgIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFNlc3Npb24oKTtcblxuICAgIGlmIChhdXRoRXJyb3IgfHwgIXNlc3Npb24pIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IHsgY29kZTogJ1VOQVVUSE9SSVpFRCcsIG1lc3NhZ2U6ICdBdXRoZW50aWNhdGlvbiByZXF1aXJlZCcgfSB9LFxuICAgICAgICB7IHN0YXR1czogNDAxIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gMi4gVkFMSURBVElPTlxuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKTtcbiAgICBjb25zdCB2YWxpZGF0aW9uID0gYnVsa1VwZGF0ZUF1dGhNZXRob2RTY2hlbWEuc2FmZVBhcnNlKGJvZHkpO1xuXG4gICAgaWYgKCF2YWxpZGF0aW9uLnN1Y2Nlc3MpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICBjb2RlOiAnVkFMSURBVElPTl9FUlJPUicsXG4gICAgICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCByZXF1ZXN0IGRhdGEnLFxuICAgICAgICAgICAgZGV0YWlsczogdmFsaWRhdGlvbi5lcnJvci5pc3N1ZXMsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHsgZ3Vlc3RfaWRzLCBhdXRoX21ldGhvZCwgc2VuZF9ub3RpZmljYXRpb24gfSA9IHZhbGlkYXRpb24uZGF0YTtcblxuICAgIC8vIDMuIFNFUlZJQ0UgQ0FMTFxuICAgIC8vIFVwZGF0ZSBhbGwgZ3Vlc3RzIGluIGEgc2luZ2xlIHF1ZXJ5XG4gICAgY29uc3QgeyBkYXRhOiB1cGRhdGVkR3Vlc3RzLCBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZ3Vlc3RzJylcbiAgICAgIC51cGRhdGUoeyBhdXRoX21ldGhvZCB9KVxuICAgICAgLmluKCdpZCcsIGd1ZXN0X2lkcylcbiAgICAgIC5zZWxlY3QoJ2lkLCBlbWFpbCwgZmlyc3RfbmFtZSwgbGFzdF9uYW1lLCBhdXRoX21ldGhvZCcpO1xuXG4gICAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogeyBjb2RlOiAnREFUQUJBU0VfRVJST1InLCBtZXNzYWdlOiAnRmFpbGVkIHRvIHVwZGF0ZSBndWVzdHMnLCBkZXRhaWxzOiB1cGRhdGVFcnJvciB9LFxuICAgICAgICB9LFxuICAgICAgICB7IHN0YXR1czogNTAwIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogU2VuZCBub3RpZmljYXRpb24gZW1haWxzIGlmIHJlcXVlc3RlZCAoVGFzayA4LjMpXG4gICAgLy8gVGhpcyB3aWxsIGJlIGltcGxlbWVudGVkIHdoZW4gZW1haWwgc3lzdGVtIGlzIGVuaGFuY2VkXG4gICAgaWYgKHNlbmRfbm90aWZpY2F0aW9uICYmIHVwZGF0ZWRHdWVzdHMgJiYgdXBkYXRlZEd1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBGdXR1cmU6IFNlbmQgZW1haWwgbm90aWZpY2F0aW9ucyB0byBndWVzdHMgYWJvdXQgYXV0aCBtZXRob2QgY2hhbmdlXG4gICAgICBjb25zb2xlLmxvZyhgV291bGQgc2VuZCBub3RpZmljYXRpb25zIHRvICR7dXBkYXRlZEd1ZXN0cy5sZW5ndGh9IGd1ZXN0cyBhYm91dCBhdXRoIG1ldGhvZCBjaGFuZ2VgKTtcbiAgICB9XG5cbiAgICAvLyA0LiBSRVNQT05TRVxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHVwZGF0ZWRfY291bnQ6IHVwZGF0ZWRHdWVzdHM/Lmxlbmd0aCB8fCAwLFxuICAgICAgICAgIGd1ZXN0czogdXBkYXRlZEd1ZXN0cyB8fCBbXSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7IHN0YXR1czogMjAwIH1cbiAgICApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBFcnJvcjonLCB7IHBhdGg6IHJlcXVlc3QudXJsLCBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLCBlcnJvciB9KTtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogeyBjb2RlOiAnSU5URVJOQUxfRVJST1InLCBtZXNzYWdlOiAnQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZCcgfSB9LFxuICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlBPU1QiLCJidWxrVXBkYXRlQXV0aE1ldGhvZFNjaGVtYSIsInoiLCJvYmplY3QiLCJndWVzdF9pZHMiLCJhcnJheSIsInN0cmluZyIsInV1aWQiLCJtaW4iLCJtYXgiLCJhdXRoX21ldGhvZCIsImVudW0iLCJzZW5kX25vdGlmaWNhdGlvbiIsImJvb2xlYW4iLCJvcHRpb25hbCIsImRlZmF1bHQiLCJnZXRTdGF0dXNDb2RlIiwiZXJyb3JDb2RlIiwic3RhdHVzTWFwIiwicmVxdWVzdCIsInN1cGFiYXNlIiwiY3JlYXRlQXV0aGVudGljYXRlZENsaWVudCIsImRhdGEiLCJzZXNzaW9uIiwiZXJyb3IiLCJhdXRoRXJyb3IiLCJhdXRoIiwiZ2V0U2Vzc2lvbiIsIk5leHRSZXNwb25zZSIsImpzb24iLCJzdWNjZXNzIiwiY29kZSIsIm1lc3NhZ2UiLCJzdGF0dXMiLCJib2R5IiwidmFsaWRhdGlvbiIsInNhZmVQYXJzZSIsImRldGFpbHMiLCJpc3N1ZXMiLCJ1cGRhdGVkR3Vlc3RzIiwidXBkYXRlRXJyb3IiLCJmcm9tIiwidXBkYXRlIiwiaW4iLCJzZWxlY3QiLCJsZW5ndGgiLCJjb25zb2xlIiwibG9nIiwidXBkYXRlZF9jb3VudCIsImd1ZXN0cyIsInBhdGgiLCJ1cmwiLCJtZXRob2QiXSwibWFwcGluZ3MiOiI7Ozs7K0JBNkJzQkE7OztlQUFBQTs7O2dDQTdCb0I7d0JBQ2I7cUJBQ1g7QUFFbEI7Ozs7OztDQU1DLEdBRUQsTUFBTUMsNkJBQTZCQyxNQUFDLENBQUNDLE1BQU0sQ0FBQztJQUMxQ0MsV0FBV0YsTUFBQyxDQUFDRyxLQUFLLENBQUNILE1BQUMsQ0FBQ0ksTUFBTSxHQUFHQyxJQUFJLElBQUlDLEdBQUcsQ0FBQyxHQUFHQyxHQUFHLENBQUM7SUFDakRDLGFBQWFSLE1BQUMsQ0FBQ1MsSUFBSSxDQUFDO1FBQUM7UUFBa0I7S0FBYTtJQUNwREMsbUJBQW1CVixNQUFDLENBQUNXLE9BQU8sR0FBR0MsUUFBUSxHQUFHQyxPQUFPLENBQUM7QUFDcEQ7QUFFQSxTQUFTQyxjQUFjQyxTQUFpQjtJQUN0QyxNQUFNQyxZQUFvQztRQUN4QyxvQkFBb0I7UUFDcEIsZ0JBQWdCO1FBQ2hCLGFBQWE7UUFDYixrQkFBa0I7UUFDbEIsa0JBQWtCO0lBQ3BCO0lBQ0EsT0FBT0EsU0FBUyxDQUFDRCxVQUFVLElBQUk7QUFDakM7QUFFTyxlQUFlakIsS0FBS21CLE9BQWdCO0lBQ3pDLElBQUk7UUFDRixvQkFBb0I7UUFDcEIsTUFBTUMsV0FBVyxNQUFNQyxJQUFBQSx5Q0FBeUI7UUFDaEQsTUFBTSxFQUNKQyxNQUFNLEVBQUVDLE9BQU8sRUFBRSxFQUNqQkMsT0FBT0MsU0FBUyxFQUNqQixHQUFHLE1BQU1MLFNBQVNNLElBQUksQ0FBQ0MsVUFBVTtRQUVsQyxJQUFJRixhQUFhLENBQUNGLFNBQVM7WUFDekIsT0FBT0ssb0JBQVksQ0FBQ0MsSUFBSSxDQUN0QjtnQkFBRUMsU0FBUztnQkFBT04sT0FBTztvQkFBRU8sTUFBTTtvQkFBZ0JDLFNBQVM7Z0JBQTBCO1lBQUUsR0FDdEY7Z0JBQUVDLFFBQVE7WUFBSTtRQUVsQjtRQUVBLGdCQUFnQjtRQUNoQixNQUFNQyxPQUFPLE1BQU1mLFFBQVFVLElBQUk7UUFDL0IsTUFBTU0sYUFBYWxDLDJCQUEyQm1DLFNBQVMsQ0FBQ0Y7UUFFeEQsSUFBSSxDQUFDQyxXQUFXTCxPQUFPLEVBQUU7WUFDdkIsT0FBT0Ysb0JBQVksQ0FBQ0MsSUFBSSxDQUN0QjtnQkFDRUMsU0FBUztnQkFDVE4sT0FBTztvQkFDTE8sTUFBTTtvQkFDTkMsU0FBUztvQkFDVEssU0FBU0YsV0FBV1gsS0FBSyxDQUFDYyxNQUFNO2dCQUNsQztZQUNGLEdBQ0E7Z0JBQUVMLFFBQVE7WUFBSTtRQUVsQjtRQUVBLE1BQU0sRUFBRTdCLFNBQVMsRUFBRU0sV0FBVyxFQUFFRSxpQkFBaUIsRUFBRSxHQUFHdUIsV0FBV2IsSUFBSTtRQUVyRSxrQkFBa0I7UUFDbEIsc0NBQXNDO1FBQ3RDLE1BQU0sRUFBRUEsTUFBTWlCLGFBQWEsRUFBRWYsT0FBT2dCLFdBQVcsRUFBRSxHQUFHLE1BQU1wQixTQUN2RHFCLElBQUksQ0FBQyxVQUNMQyxNQUFNLENBQUM7WUFBRWhDO1FBQVksR0FDckJpQyxFQUFFLENBQUMsTUFBTXZDLFdBQ1R3QyxNQUFNLENBQUM7UUFFVixJQUFJSixhQUFhO1lBQ2YsT0FBT1osb0JBQVksQ0FBQ0MsSUFBSSxDQUN0QjtnQkFDRUMsU0FBUztnQkFDVE4sT0FBTztvQkFBRU8sTUFBTTtvQkFBa0JDLFNBQVM7b0JBQTJCSyxTQUFTRztnQkFBWTtZQUM1RixHQUNBO2dCQUFFUCxRQUFRO1lBQUk7UUFFbEI7UUFFQSx5REFBeUQ7UUFDekQseURBQXlEO1FBQ3pELElBQUlyQixxQkFBcUIyQixpQkFBaUJBLGNBQWNNLE1BQU0sR0FBRyxHQUFHO1lBQ2xFLHNFQUFzRTtZQUN0RUMsUUFBUUMsR0FBRyxDQUFDLENBQUMsNEJBQTRCLEVBQUVSLGNBQWNNLE1BQU0sQ0FBQyxnQ0FBZ0MsQ0FBQztRQUNuRztRQUVBLGNBQWM7UUFDZCxPQUFPakIsb0JBQVksQ0FBQ0MsSUFBSSxDQUN0QjtZQUNFQyxTQUFTO1lBQ1RSLE1BQU07Z0JBQ0owQixlQUFlVCxlQUFlTSxVQUFVO2dCQUN4Q0ksUUFBUVYsaUJBQWlCLEVBQUU7WUFDN0I7UUFDRixHQUNBO1lBQUVOLFFBQVE7UUFBSTtJQUVsQixFQUFFLE9BQU9ULE9BQU87UUFDZHNCLFFBQVF0QixLQUFLLENBQUMsY0FBYztZQUFFMEIsTUFBTS9CLFFBQVFnQyxHQUFHO1lBQUVDLFFBQVFqQyxRQUFRaUMsTUFBTTtZQUFFNUI7UUFBTTtRQUMvRSxPQUFPSSxvQkFBWSxDQUFDQyxJQUFJLENBQ3RCO1lBQUVDLFNBQVM7WUFBT04sT0FBTztnQkFBRU8sTUFBTTtnQkFBa0JDLFNBQVM7WUFBK0I7UUFBRSxHQUM3RjtZQUFFQyxRQUFRO1FBQUk7SUFFbEI7QUFDRiJ9