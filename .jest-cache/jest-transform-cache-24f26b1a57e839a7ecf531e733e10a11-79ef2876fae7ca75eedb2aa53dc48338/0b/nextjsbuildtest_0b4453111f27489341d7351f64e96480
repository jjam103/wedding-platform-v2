1dcb7dd39afd6af8c0a702543d01d6ab
/**
 * Next.js Build Validation Tests
 * 
 * These tests validate that Next.js builds successfully.
 * They catch issues specific to Next.js compilation and static generation.
 * 
 * Why this exists:
 * - Next.js has its own compiler (Turbopack/Webpack)
 * - Static generation can fail even if TypeScript passes
 * - Build-time errors only appear during production build
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _child_process = require("child_process");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('Next.js Build', ()=>{
    it('should build successfully', ()=>{
        expect(()=>{
            (0, _child_process.execSync)('npm run build', {
                stdio: 'pipe',
                encoding: 'utf-8'
            });
        }).not.toThrow();
    }, 120000); // 2 minute timeout for full build
    it('should generate all static pages', ()=>{
        const output = (0, _child_process.execSync)('npm run build', {
            encoding: 'utf-8',
            stdio: 'pipe'
        });
        // Verify static generation completed
        expect(output).toContain('Generating static pages');
        expect(output).not.toContain('Failed to compile');
        expect(output).not.toContain('Error occurred prerendering page');
        // Check that we generated the expected number of pages
        // Adjust this number based on your actual page count
        expect(output).toMatch(/\(\d+\/\d+\)/);
    }, 120000);
    it('should not have any build warnings', ()=>{
        const output = (0, _child_process.execSync)('npm run build', {
            encoding: 'utf-8',
            stdio: 'pipe'
        });
        // Check for common warnings
        expect(output).not.toContain('Warning:');
        expect(output).not.toContain('deprecated');
        // Allow some warnings but fail if there are too many
        const warningCount = (output.match(/warn/gi) || []).length;
        expect(warningCount).toBeLessThan(5);
    }, 120000);
    it('should have reasonable build size', ()=>{
        const output = (0, _child_process.execSync)('npm run build', {
            encoding: 'utf-8',
            stdio: 'pipe'
        });
        // Extract build size information
        // This is a basic check - adjust thresholds based on your app
        const sizeMatch = output.match(/Total size: ([\d.]+) kB/);
        if (sizeMatch) {
            const totalSize = parseFloat(sizeMatch[1]);
            // Warn if bundle is getting too large (adjust threshold as needed)
            if (totalSize > 5000) {
                console.warn(`Warning: Total bundle size is ${totalSize} kB. Consider code splitting.`);
            }
            // Fail if bundle is unreasonably large
            expect(totalSize).toBeLessThan(10000); // 10 MB
        }
    }, 120000);
    it('should not have duplicate dependencies', ()=>{
        try {
            const output = (0, _child_process.execSync)('npm ls --depth=0', {
                encoding: 'utf-8',
                stdio: 'pipe'
            });
            // Check for duplicate packages
            expect(output).not.toContain('UNMET DEPENDENCY');
            expect(output).not.toContain('extraneous');
        } catch (error) {
            // npm ls returns non-zero if there are issues
            if (error.stdout) {
                fail(`Dependency issues found:\n${error.stdout}`);
            }
        }
    });
    it('should have valid next.config', async ()=>{
        const { readFile } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("node:fs/promises")));
        // Verify next.config.ts exists and is valid
        const configContent = await readFile('next.config.ts', 'utf-8');
        expect(configContent).toContain('NextConfig');
        expect(configContent).not.toContain('TODO');
        expect(configContent).not.toContain('FIXME');
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvX190ZXN0c19fL2J1aWxkL25leHRqcy5idWlsZC50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTmV4dC5qcyBCdWlsZCBWYWxpZGF0aW9uIFRlc3RzXG4gKiBcbiAqIFRoZXNlIHRlc3RzIHZhbGlkYXRlIHRoYXQgTmV4dC5qcyBidWlsZHMgc3VjY2Vzc2Z1bGx5LlxuICogVGhleSBjYXRjaCBpc3N1ZXMgc3BlY2lmaWMgdG8gTmV4dC5qcyBjb21waWxhdGlvbiBhbmQgc3RhdGljIGdlbmVyYXRpb24uXG4gKiBcbiAqIFdoeSB0aGlzIGV4aXN0czpcbiAqIC0gTmV4dC5qcyBoYXMgaXRzIG93biBjb21waWxlciAoVHVyYm9wYWNrL1dlYnBhY2spXG4gKiAtIFN0YXRpYyBnZW5lcmF0aW9uIGNhbiBmYWlsIGV2ZW4gaWYgVHlwZVNjcmlwdCBwYXNzZXNcbiAqIC0gQnVpbGQtdGltZSBlcnJvcnMgb25seSBhcHBlYXIgZHVyaW5nIHByb2R1Y3Rpb24gYnVpbGRcbiAqL1xuXG5pbXBvcnQgeyBleGVjU3luYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuXG5kZXNjcmliZSgnTmV4dC5qcyBCdWlsZCcsICgpID0+IHtcbiAgaXQoJ3Nob3VsZCBidWlsZCBzdWNjZXNzZnVsbHknLCAoKSA9PiB7XG4gICAgZXhwZWN0KCgpID0+IHtcbiAgICAgIGV4ZWNTeW5jKCducG0gcnVuIGJ1aWxkJywgeyBcbiAgICAgICAgc3RkaW86ICdwaXBlJyxcbiAgICAgICAgZW5jb2Rpbmc6ICd1dGYtOCdcbiAgICAgIH0pO1xuICAgIH0pLm5vdC50b1Rocm93KCk7XG4gIH0sIDEyMDAwMCk7IC8vIDIgbWludXRlIHRpbWVvdXQgZm9yIGZ1bGwgYnVpbGRcblxuICBpdCgnc2hvdWxkIGdlbmVyYXRlIGFsbCBzdGF0aWMgcGFnZXMnLCAoKSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0gZXhlY1N5bmMoJ25wbSBydW4gYnVpbGQnLCB7IFxuICAgICAgZW5jb2Rpbmc6ICd1dGYtOCcsXG4gICAgICBzdGRpbzogJ3BpcGUnXG4gICAgfSk7XG4gICAgXG4gICAgLy8gVmVyaWZ5IHN0YXRpYyBnZW5lcmF0aW9uIGNvbXBsZXRlZFxuICAgIGV4cGVjdChvdXRwdXQpLnRvQ29udGFpbignR2VuZXJhdGluZyBzdGF0aWMgcGFnZXMnKTtcbiAgICBleHBlY3Qob3V0cHV0KS5ub3QudG9Db250YWluKCdGYWlsZWQgdG8gY29tcGlsZScpO1xuICAgIGV4cGVjdChvdXRwdXQpLm5vdC50b0NvbnRhaW4oJ0Vycm9yIG9jY3VycmVkIHByZXJlbmRlcmluZyBwYWdlJyk7XG4gICAgXG4gICAgLy8gQ2hlY2sgdGhhdCB3ZSBnZW5lcmF0ZWQgdGhlIGV4cGVjdGVkIG51bWJlciBvZiBwYWdlc1xuICAgIC8vIEFkanVzdCB0aGlzIG51bWJlciBiYXNlZCBvbiB5b3VyIGFjdHVhbCBwYWdlIGNvdW50XG4gICAgZXhwZWN0KG91dHB1dCkudG9NYXRjaCgvXFwoXFxkK1xcL1xcZCtcXCkvKTtcbiAgfSwgMTIwMDAwKTtcblxuICBpdCgnc2hvdWxkIG5vdCBoYXZlIGFueSBidWlsZCB3YXJuaW5ncycsICgpID0+IHtcbiAgICBjb25zdCBvdXRwdXQgPSBleGVjU3luYygnbnBtIHJ1biBidWlsZCcsIHsgXG4gICAgICBlbmNvZGluZzogJ3V0Zi04JyxcbiAgICAgIHN0ZGlvOiAncGlwZSdcbiAgICB9KTtcbiAgICBcbiAgICAvLyBDaGVjayBmb3IgY29tbW9uIHdhcm5pbmdzXG4gICAgZXhwZWN0KG91dHB1dCkubm90LnRvQ29udGFpbignV2FybmluZzonKTtcbiAgICBleHBlY3Qob3V0cHV0KS5ub3QudG9Db250YWluKCdkZXByZWNhdGVkJyk7XG4gICAgXG4gICAgLy8gQWxsb3cgc29tZSB3YXJuaW5ncyBidXQgZmFpbCBpZiB0aGVyZSBhcmUgdG9vIG1hbnlcbiAgICBjb25zdCB3YXJuaW5nQ291bnQgPSAob3V0cHV0Lm1hdGNoKC93YXJuL2dpKSB8fCBbXSkubGVuZ3RoO1xuICAgIGV4cGVjdCh3YXJuaW5nQ291bnQpLnRvQmVMZXNzVGhhbig1KTtcbiAgfSwgMTIwMDAwKTtcblxuICBpdCgnc2hvdWxkIGhhdmUgcmVhc29uYWJsZSBidWlsZCBzaXplJywgKCkgPT4ge1xuICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKCducG0gcnVuIGJ1aWxkJywgeyBcbiAgICAgIGVuY29kaW5nOiAndXRmLTgnLFxuICAgICAgc3RkaW86ICdwaXBlJ1xuICAgIH0pO1xuICAgIFxuICAgIC8vIEV4dHJhY3QgYnVpbGQgc2l6ZSBpbmZvcm1hdGlvblxuICAgIC8vIFRoaXMgaXMgYSBiYXNpYyBjaGVjayAtIGFkanVzdCB0aHJlc2hvbGRzIGJhc2VkIG9uIHlvdXIgYXBwXG4gICAgY29uc3Qgc2l6ZU1hdGNoID0gb3V0cHV0Lm1hdGNoKC9Ub3RhbCBzaXplOiAoW1xcZC5dKykga0IvKTtcbiAgICBcbiAgICBpZiAoc2l6ZU1hdGNoKSB7XG4gICAgICBjb25zdCB0b3RhbFNpemUgPSBwYXJzZUZsb2F0KHNpemVNYXRjaFsxXSk7XG4gICAgICBcbiAgICAgIC8vIFdhcm4gaWYgYnVuZGxlIGlzIGdldHRpbmcgdG9vIGxhcmdlIChhZGp1c3QgdGhyZXNob2xkIGFzIG5lZWRlZClcbiAgICAgIGlmICh0b3RhbFNpemUgPiA1MDAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgV2FybmluZzogVG90YWwgYnVuZGxlIHNpemUgaXMgJHt0b3RhbFNpemV9IGtCLiBDb25zaWRlciBjb2RlIHNwbGl0dGluZy5gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRmFpbCBpZiBidW5kbGUgaXMgdW5yZWFzb25hYmx5IGxhcmdlXG4gICAgICBleHBlY3QodG90YWxTaXplKS50b0JlTGVzc1RoYW4oMTAwMDApOyAvLyAxMCBNQlxuICAgIH1cbiAgfSwgMTIwMDAwKTtcblxuICBpdCgnc2hvdWxkIG5vdCBoYXZlIGR1cGxpY2F0ZSBkZXBlbmRlbmNpZXMnLCAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKCducG0gbHMgLS1kZXB0aD0wJywgeyBcbiAgICAgICAgZW5jb2Rpbmc6ICd1dGYtOCcsXG4gICAgICAgIHN0ZGlvOiAncGlwZSdcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgZHVwbGljYXRlIHBhY2thZ2VzXG4gICAgICBleHBlY3Qob3V0cHV0KS5ub3QudG9Db250YWluKCdVTk1FVCBERVBFTkRFTkNZJyk7XG4gICAgICBleHBlY3Qob3V0cHV0KS5ub3QudG9Db250YWluKCdleHRyYW5lb3VzJyk7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgLy8gbnBtIGxzIHJldHVybnMgbm9uLXplcm8gaWYgdGhlcmUgYXJlIGlzc3Vlc1xuICAgICAgaWYgKGVycm9yLnN0ZG91dCkge1xuICAgICAgICBmYWlsKGBEZXBlbmRlbmN5IGlzc3VlcyBmb3VuZDpcXG4ke2Vycm9yLnN0ZG91dH1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgaGF2ZSB2YWxpZCBuZXh0LmNvbmZpZycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IHJlYWRGaWxlIH0gPSBhd2FpdCBpbXBvcnQoJ2ZzL3Byb21pc2VzJyk7XG4gICAgXG4gICAgLy8gVmVyaWZ5IG5leHQuY29uZmlnLnRzIGV4aXN0cyBhbmQgaXMgdmFsaWRcbiAgICBjb25zdCBjb25maWdDb250ZW50ID0gYXdhaXQgcmVhZEZpbGUoJ25leHQuY29uZmlnLnRzJywgJ3V0Zi04Jyk7XG4gICAgXG4gICAgZXhwZWN0KGNvbmZpZ0NvbnRlbnQpLnRvQ29udGFpbignTmV4dENvbmZpZycpO1xuICAgIGV4cGVjdChjb25maWdDb250ZW50KS5ub3QudG9Db250YWluKCdUT0RPJyk7XG4gICAgZXhwZWN0KGNvbmZpZ0NvbnRlbnQpLm5vdC50b0NvbnRhaW4oJ0ZJWE1FJyk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJpdCIsImV4cGVjdCIsImV4ZWNTeW5jIiwic3RkaW8iLCJlbmNvZGluZyIsIm5vdCIsInRvVGhyb3ciLCJvdXRwdXQiLCJ0b0NvbnRhaW4iLCJ0b01hdGNoIiwid2FybmluZ0NvdW50IiwibWF0Y2giLCJsZW5ndGgiLCJ0b0JlTGVzc1RoYW4iLCJzaXplTWF0Y2giLCJ0b3RhbFNpemUiLCJwYXJzZUZsb2F0IiwiY29uc29sZSIsIndhcm4iLCJlcnJvciIsInN0ZG91dCIsImZhaWwiLCJyZWFkRmlsZSIsImNvbmZpZ0NvbnRlbnQiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0NBVUM7Ozs7K0JBRXdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFekJBLFNBQVMsaUJBQWlCO0lBQ3hCQyxHQUFHLDZCQUE2QjtRQUM5QkMsT0FBTztZQUNMQyxJQUFBQSx1QkFBUSxFQUFDLGlCQUFpQjtnQkFDeEJDLE9BQU87Z0JBQ1BDLFVBQVU7WUFDWjtRQUNGLEdBQUdDLEdBQUcsQ0FBQ0MsT0FBTztJQUNoQixHQUFHLFNBQVMsa0NBQWtDO0lBRTlDTixHQUFHLG9DQUFvQztRQUNyQyxNQUFNTyxTQUFTTCxJQUFBQSx1QkFBUSxFQUFDLGlCQUFpQjtZQUN2Q0UsVUFBVTtZQUNWRCxPQUFPO1FBQ1Q7UUFFQSxxQ0FBcUM7UUFDckNGLE9BQU9NLFFBQVFDLFNBQVMsQ0FBQztRQUN6QlAsT0FBT00sUUFBUUYsR0FBRyxDQUFDRyxTQUFTLENBQUM7UUFDN0JQLE9BQU9NLFFBQVFGLEdBQUcsQ0FBQ0csU0FBUyxDQUFDO1FBRTdCLHVEQUF1RDtRQUN2RCxxREFBcUQ7UUFDckRQLE9BQU9NLFFBQVFFLE9BQU8sQ0FBQztJQUN6QixHQUFHO0lBRUhULEdBQUcsc0NBQXNDO1FBQ3ZDLE1BQU1PLFNBQVNMLElBQUFBLHVCQUFRLEVBQUMsaUJBQWlCO1lBQ3ZDRSxVQUFVO1lBQ1ZELE9BQU87UUFDVDtRQUVBLDRCQUE0QjtRQUM1QkYsT0FBT00sUUFBUUYsR0FBRyxDQUFDRyxTQUFTLENBQUM7UUFDN0JQLE9BQU9NLFFBQVFGLEdBQUcsQ0FBQ0csU0FBUyxDQUFDO1FBRTdCLHFEQUFxRDtRQUNyRCxNQUFNRSxlQUFlLEFBQUNILENBQUFBLE9BQU9JLEtBQUssQ0FBQyxhQUFhLEVBQUUsQUFBRCxFQUFHQyxNQUFNO1FBQzFEWCxPQUFPUyxjQUFjRyxZQUFZLENBQUM7SUFDcEMsR0FBRztJQUVIYixHQUFHLHFDQUFxQztRQUN0QyxNQUFNTyxTQUFTTCxJQUFBQSx1QkFBUSxFQUFDLGlCQUFpQjtZQUN2Q0UsVUFBVTtZQUNWRCxPQUFPO1FBQ1Q7UUFFQSxpQ0FBaUM7UUFDakMsOERBQThEO1FBQzlELE1BQU1XLFlBQVlQLE9BQU9JLEtBQUssQ0FBQztRQUUvQixJQUFJRyxXQUFXO1lBQ2IsTUFBTUMsWUFBWUMsV0FBV0YsU0FBUyxDQUFDLEVBQUU7WUFFekMsbUVBQW1FO1lBQ25FLElBQUlDLFlBQVksTUFBTTtnQkFDcEJFLFFBQVFDLElBQUksQ0FBQyxDQUFDLDhCQUE4QixFQUFFSCxVQUFVLDZCQUE2QixDQUFDO1lBQ3hGO1lBRUEsdUNBQXVDO1lBQ3ZDZCxPQUFPYyxXQUFXRixZQUFZLENBQUMsUUFBUSxRQUFRO1FBQ2pEO0lBQ0YsR0FBRztJQUVIYixHQUFHLDBDQUEwQztRQUMzQyxJQUFJO1lBQ0YsTUFBTU8sU0FBU0wsSUFBQUEsdUJBQVEsRUFBQyxvQkFBb0I7Z0JBQzFDRSxVQUFVO2dCQUNWRCxPQUFPO1lBQ1Q7WUFFQSwrQkFBK0I7WUFDL0JGLE9BQU9NLFFBQVFGLEdBQUcsQ0FBQ0csU0FBUyxDQUFDO1lBQzdCUCxPQUFPTSxRQUFRRixHQUFHLENBQUNHLFNBQVMsQ0FBQztRQUMvQixFQUFFLE9BQU9XLE9BQVk7WUFDbkIsOENBQThDO1lBQzlDLElBQUlBLE1BQU1DLE1BQU0sRUFBRTtnQkFDaEJDLEtBQUssQ0FBQywwQkFBMEIsRUFBRUYsTUFBTUMsTUFBTSxFQUFFO1lBQ2xEO1FBQ0Y7SUFDRjtJQUVBcEIsR0FBRyxpQ0FBaUM7UUFDbEMsTUFBTSxFQUFFc0IsUUFBUSxFQUFFLEdBQUcsTUFBTSxtRUFBQSxRQUFPO1FBRWxDLDRDQUE0QztRQUM1QyxNQUFNQyxnQkFBZ0IsTUFBTUQsU0FBUyxrQkFBa0I7UUFFdkRyQixPQUFPc0IsZUFBZWYsU0FBUyxDQUFDO1FBQ2hDUCxPQUFPc0IsZUFBZWxCLEdBQUcsQ0FBQ0csU0FBUyxDQUFDO1FBQ3BDUCxPQUFPc0IsZUFBZWxCLEdBQUcsQ0FBQ0csU0FBUyxDQUFDO0lBQ3RDO0FBQ0YifQ==