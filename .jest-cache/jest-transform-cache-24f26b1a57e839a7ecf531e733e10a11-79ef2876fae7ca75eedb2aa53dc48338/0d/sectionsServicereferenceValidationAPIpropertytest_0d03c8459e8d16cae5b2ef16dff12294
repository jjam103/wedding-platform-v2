4dc032b5bad164ba1701c2a4d8745fca
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _globals = require("@jest/globals");
const _sectionsService = require("./sectionsService");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
/**
 * Property 15: Reference Validation API
 * 
 * For any POST request to validate references, the API SHALL check that all 
 * referenced entities exist in the database and return broken references.
 * 
 * This test validates the API contract by testing the service layer behavior
 * that the API endpoint exposes. The API route (POST /api/admin/sections/validate-refs)
 * is a thin wrapper around the validateReferences service function.
 * 
 * Validates: Requirements 15.6
 */ // Mock Supabase before importing services
const mockFrom = _globals.jest.fn();
const mockSupabase = {
    from: mockFrom
};
_globals.jest.mock('../lib/supabase', ()=>({
        supabase: mockSupabase
    }));
// Helper to create properly typed mock chain
function createMockQueryChain(resolvedValue) {
    const mockSingle = _globals.jest.fn().mockResolvedValue(resolvedValue);
    const mockEq = _globals.jest.fn().mockReturnValue({
        single: mockSingle
    });
    const mockSelect = _globals.jest.fn().mockReturnValue({
        eq: mockEq
    });
    return {
        select: mockSelect
    };
}
(0, _globals.describe)('Feature: admin-backend-integration-cms, Property 15: Reference Validation API', ()=>{
    (0, _globals.beforeEach)(()=>{
        _globals.jest.clearAllMocks();
    });
    (0, _globals.it)('should validate all references and return broken references for any valid request', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.array(_fastcheck.record({
            type: _fastcheck.constantFrom('event', 'activity', 'accommodation', 'location'),
            id: _fastcheck.uuid(),
            label: _fastcheck.option(_fastcheck.string({
                minLength: 1,
                maxLength: 100
            })),
            exists: _fastcheck.boolean()
        }), {
            minLength: 1,
            maxLength: 20
        }), async (testReferences)=>{
            // Mock database lookups for each reference
            for (const ref of testReferences){
                mockFrom.mockReturnValueOnce(createMockQueryChain({
                    data: ref.exists ? {
                        id: ref.id
                    } : null,
                    error: ref.exists ? null : {
                        code: 'PGRST116',
                        message: 'Not found'
                    }
                }));
            }
            const references = testReferences.map((r)=>({
                    type: r.type,
                    id: r.id,
                    label: r.label || undefined
                }));
            const result = await (0, _sectionsService.validateReferences)(references);
            // Property: API validation operation should always succeed
            (0, _globals.expect)(result.success).toBe(true);
            if (!result.success) {
                return true;
            }
            // Property: All non-existent references should be detected as broken
            const expectedBrokenCount = testReferences.filter((r)=>!r.exists).length;
            (0, _globals.expect)(result.data.brokenReferences.length).toBe(expectedBrokenCount);
            // Property: Each broken reference should correspond to a non-existent entity
            for (const broken of result.data.brokenReferences){
                const original = testReferences.find((r)=>r.id === broken.id && r.type === broken.type);
                (0, _globals.expect)(original).toBeDefined();
                (0, _globals.expect)(original?.exists).toBe(false);
            }
            // Property: Validation is valid only when all entities exist
            const allExist = testReferences.every((r)=>r.exists);
            (0, _globals.expect)(result.data.valid).toBe(allExist);
            return true;
        }), {
            numRuns: 100
        });
    });
    (0, _globals.it)('should return valid=true when all referenced entities exist', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.array(_fastcheck.record({
            type: _fastcheck.constantFrom('event', 'activity', 'accommodation', 'location'),
            id: _fastcheck.uuid(),
            label: _fastcheck.option(_fastcheck.string({
                minLength: 1,
                maxLength: 100
            }))
        }), {
            minLength: 1,
            maxLength: 15
        }), async (testReferences)=>{
            // Mock all references as existing in database
            for (const ref of testReferences){
                mockFrom.mockReturnValueOnce(createMockQueryChain({
                    data: {
                        id: ref.id
                    },
                    error: null
                }));
            }
            const references = testReferences.map((r)=>({
                    type: r.type,
                    id: r.id,
                    label: r.label || undefined
                }));
            const result = await (0, _sectionsService.validateReferences)(references);
            // Property: API should return valid=true when all exist
            (0, _globals.expect)(result.success).toBe(true);
            if (!result.success) {
                return true;
            }
            (0, _globals.expect)(result.data.valid).toBe(true);
            (0, _globals.expect)(result.data.brokenReferences).toHaveLength(0);
            return true;
        }), {
            numRuns: 100
        });
    });
    (0, _globals.it)('should return valid=false and identify broken references when entities do not exist', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
            validRefs: _fastcheck.array(_fastcheck.record({
                type: _fastcheck.constantFrom('event', 'activity', 'accommodation', 'location'),
                id: _fastcheck.uuid(),
                label: _fastcheck.option(_fastcheck.string({
                    minLength: 1,
                    maxLength: 100
                }))
            }), {
                minLength: 0,
                maxLength: 5
            }),
            brokenRefs: _fastcheck.array(_fastcheck.record({
                type: _fastcheck.constantFrom('event', 'activity', 'accommodation', 'location'),
                id: _fastcheck.uuid(),
                label: _fastcheck.option(_fastcheck.string({
                    minLength: 1,
                    maxLength: 100
                }))
            }), {
                minLength: 1,
                maxLength: 5
            })
        }), async (testData)=>{
            // Mock valid references as existing
            for (const ref of testData.validRefs){
                mockFrom.mockReturnValueOnce(createMockQueryChain({
                    data: {
                        id: ref.id
                    },
                    error: null
                }));
            }
            // Mock broken references as not existing
            for (const ref of testData.brokenRefs){
                mockFrom.mockReturnValueOnce(createMockQueryChain({
                    data: null,
                    error: {
                        code: 'PGRST116',
                        message: 'Not found'
                    }
                }));
            }
            const references = [
                ...testData.validRefs.map((r)=>({
                        type: r.type,
                        id: r.id,
                        label: r.label || undefined
                    })),
                ...testData.brokenRefs.map((r)=>({
                        type: r.type,
                        id: r.id,
                        label: r.label || undefined
                    }))
            ];
            const result = await (0, _sectionsService.validateReferences)(references);
            // Property: API should return valid=false when any reference is broken
            (0, _globals.expect)(result.success).toBe(true);
            if (!result.success) {
                return true;
            }
            (0, _globals.expect)(result.data.valid).toBe(false);
            (0, _globals.expect)(result.data.brokenReferences.length).toBe(testData.brokenRefs.length);
            // Property: All broken references should be identified
            for (const brokenRef of testData.brokenRefs){
                const found = result.data.brokenReferences.find((r)=>r.id === brokenRef.id && r.type === brokenRef.type);
                (0, _globals.expect)(found).toBeDefined();
            }
            return true;
        }), {
            numRuns: 50
        });
    });
    (0, _globals.it)('should handle empty reference arrays', async ()=>{
        const result = await (0, _sectionsService.validateReferences)([]);
        // Property: Empty array should be valid (API contract)
        (0, _globals.expect)(result.success).toBe(true);
        if (result.success) {
            (0, _globals.expect)(result.data.valid).toBe(true);
            (0, _globals.expect)(result.data.brokenReferences).toHaveLength(0);
        }
    });
    (0, _globals.it)('should verify each entity type against its correct database table', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.constantFrom('event', 'activity', 'accommodation', 'location'), _fastcheck.uuid(), _fastcheck.option(_fastcheck.string({
            minLength: 1,
            maxLength: 100
        })), async (type, id, label)=>{
            const expectedTable = type === 'event' ? 'events' : type === 'activity' ? 'activities' : type === 'accommodation' ? 'accommodations' : 'locations';
            mockFrom.mockReturnValueOnce(createMockQueryChain({
                data: {
                    id
                },
                error: null
            }));
            const references = [
                {
                    type,
                    id,
                    label: label || undefined
                }
            ];
            const result = await (0, _sectionsService.validateReferences)(references);
            // Property: API should query the correct table for each entity type
            (0, _globals.expect)(mockFrom).toHaveBeenCalledWith(expectedTable);
            (0, _globals.expect)(result.success).toBe(true);
            return true;
        }), {
            numRuns: 50
        });
    });
    (0, _globals.it)('should preserve reference metadata in broken references response', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.array(_fastcheck.record({
            type: _fastcheck.constantFrom('event', 'activity', 'accommodation', 'location'),
            id: _fastcheck.uuid(),
            label: _fastcheck.string({
                minLength: 1,
                maxLength: 100
            })
        }), {
            minLength: 1,
            maxLength: 10
        }), async (testReferences)=>{
            // Mock all as not existing
            for (const ref of testReferences){
                mockFrom.mockReturnValueOnce(createMockQueryChain({
                    data: null,
                    error: {
                        code: 'PGRST116',
                        message: 'Not found'
                    }
                }));
            }
            const references = testReferences.map((r)=>({
                    type: r.type,
                    id: r.id,
                    label: r.label
                }));
            const result = await (0, _sectionsService.validateReferences)(references);
            // Property: API should preserve metadata in broken references
            if (result.success && result.data.brokenReferences.length > 0) {
                for (const broken of result.data.brokenReferences){
                    const original = testReferences.find((r)=>r.id === broken.id);
                    (0, _globals.expect)(original).toBeDefined();
                    if (original) {
                        (0, _globals.expect)(broken.label).toBe(original.label);
                    }
                }
            }
            return true;
        }), {
            numRuns: 50
        });
    });
    (0, _globals.it)('should handle database errors gracefully', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.array(_fastcheck.record({
            type: _fastcheck.constantFrom('event', 'activity', 'accommodation', 'location'),
            id: _fastcheck.uuid()
        }), {
            minLength: 1,
            maxLength: 5
        }), async (testReferences)=>{
            // Mock database error
            mockFrom.mockImplementationOnce(()=>{
                throw new Error('Database connection failed');
            });
            const references = testReferences.map((r)=>({
                    type: r.type,
                    id: r.id
                }));
            const result = await (0, _sectionsService.validateReferences)(references);
            // Property: API should handle errors gracefully
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('UNKNOWN_ERROR');
            }
            return true;
        }), {
            numRuns: 50
        });
    });
    (0, _globals.it)('should validate references consistently regardless of order', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.array(_fastcheck.record({
            type: _fastcheck.constantFrom('event', 'activity', 'accommodation', 'location'),
            id: _fastcheck.uuid(),
            exists: _fastcheck.boolean()
        }), {
            minLength: 2,
            maxLength: 10
        }), async (testReferences)=>{
            // First validation with original order
            for (const ref of testReferences){
                mockFrom.mockReturnValueOnce(createMockQueryChain({
                    data: ref.exists ? {
                        id: ref.id
                    } : null,
                    error: ref.exists ? null : {
                        code: 'PGRST116',
                        message: 'Not found'
                    }
                }));
            }
            const references = testReferences.map((r)=>({
                    type: r.type,
                    id: r.id
                }));
            const result1 = await (0, _sectionsService.validateReferences)(references);
            // Second validation with reversed order
            const reversedRefs = [
                ...testReferences
            ].reverse();
            for (const ref of reversedRefs){
                mockFrom.mockReturnValueOnce(createMockQueryChain({
                    data: ref.exists ? {
                        id: ref.id
                    } : null,
                    error: ref.exists ? null : {
                        code: 'PGRST116',
                        message: 'Not found'
                    }
                }));
            }
            const reversedReferences = reversedRefs.map((r)=>({
                    type: r.type,
                    id: r.id
                }));
            const result2 = await (0, _sectionsService.validateReferences)(reversedReferences);
            // Property: API should return same validation result regardless of order
            (0, _globals.expect)(result1.success).toBe(result2.success);
            if (result1.success && result2.success) {
                (0, _globals.expect)(result1.data.valid).toBe(result2.data.valid);
                (0, _globals.expect)(result1.data.brokenReferences.length).toBe(result2.data.brokenReferences.length);
            }
            return true;
        }), {
            numRuns: 50
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvc2VjdGlvbnNTZXJ2aWNlLnJlZmVyZW5jZVZhbGlkYXRpb25BUEkucHJvcGVydHkudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmYyBmcm9tICdmYXN0LWNoZWNrJztcbmltcG9ydCB7IGplc3QsIGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBiZWZvcmVFYWNoIH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5cbi8qKlxuICogUHJvcGVydHkgMTU6IFJlZmVyZW5jZSBWYWxpZGF0aW9uIEFQSVxuICogXG4gKiBGb3IgYW55IFBPU1QgcmVxdWVzdCB0byB2YWxpZGF0ZSByZWZlcmVuY2VzLCB0aGUgQVBJIFNIQUxMIGNoZWNrIHRoYXQgYWxsIFxuICogcmVmZXJlbmNlZCBlbnRpdGllcyBleGlzdCBpbiB0aGUgZGF0YWJhc2UgYW5kIHJldHVybiBicm9rZW4gcmVmZXJlbmNlcy5cbiAqIFxuICogVGhpcyB0ZXN0IHZhbGlkYXRlcyB0aGUgQVBJIGNvbnRyYWN0IGJ5IHRlc3RpbmcgdGhlIHNlcnZpY2UgbGF5ZXIgYmVoYXZpb3JcbiAqIHRoYXQgdGhlIEFQSSBlbmRwb2ludCBleHBvc2VzLiBUaGUgQVBJIHJvdXRlIChQT1NUIC9hcGkvYWRtaW4vc2VjdGlvbnMvdmFsaWRhdGUtcmVmcylcbiAqIGlzIGEgdGhpbiB3cmFwcGVyIGFyb3VuZCB0aGUgdmFsaWRhdGVSZWZlcmVuY2VzIHNlcnZpY2UgZnVuY3Rpb24uXG4gKiBcbiAqIFZhbGlkYXRlczogUmVxdWlyZW1lbnRzIDE1LjZcbiAqL1xuXG4vLyBNb2NrIFN1cGFiYXNlIGJlZm9yZSBpbXBvcnRpbmcgc2VydmljZXNcbmNvbnN0IG1vY2tGcm9tID0gamVzdC5mbigpIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248YW55PjtcbmNvbnN0IG1vY2tTdXBhYmFzZSA9IHtcbiAgZnJvbTogbW9ja0Zyb20sXG59O1xuXG5qZXN0Lm1vY2soJy4uL2xpYi9zdXBhYmFzZScsICgpID0+ICh7XG4gIHN1cGFiYXNlOiBtb2NrU3VwYWJhc2UsXG59KSk7XG5cbi8vIEltcG9ydCBhZnRlciBtb2NraW5nXG5pbXBvcnQgeyB2YWxpZGF0ZVJlZmVyZW5jZXMgfSBmcm9tICcuL3NlY3Rpb25zU2VydmljZSc7XG5pbXBvcnQgdHlwZSB7IFJlZmVyZW5jZSB9IGZyb20gJy4uL3NjaGVtYXMvY21zU2NoZW1hcyc7XG5cbi8vIEhlbHBlciB0byBjcmVhdGUgcHJvcGVybHkgdHlwZWQgbW9jayBjaGFpblxuZnVuY3Rpb24gY3JlYXRlTW9ja1F1ZXJ5Q2hhaW4ocmVzb2x2ZWRWYWx1ZTogeyBkYXRhOiBhbnk7IGVycm9yOiBhbnkgfSkge1xuICBjb25zdCBtb2NrU2luZ2xlID0gKGplc3QuZm4oKSBhcyBhbnkpLm1vY2tSZXNvbHZlZFZhbHVlKHJlc29sdmVkVmFsdWUpO1xuICBjb25zdCBtb2NrRXEgPSAoamVzdC5mbigpIGFzIGFueSkubW9ja1JldHVyblZhbHVlKHsgc2luZ2xlOiBtb2NrU2luZ2xlIH0pO1xuICBjb25zdCBtb2NrU2VsZWN0ID0gKGplc3QuZm4oKSBhcyBhbnkpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXEgfSk7XG4gIHJldHVybiB7IHNlbGVjdDogbW9ja1NlbGVjdCB9IGFzIGFueTtcbn1cblxuZGVzY3JpYmUoJ0ZlYXR1cmU6IGFkbWluLWJhY2tlbmQtaW50ZWdyYXRpb24tY21zLCBQcm9wZXJ0eSAxNTogUmVmZXJlbmNlIFZhbGlkYXRpb24gQVBJJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBhbGwgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGJyb2tlbiByZWZlcmVuY2VzIGZvciBhbnkgdmFsaWQgcmVxdWVzdCcsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBmYy5hcnJheShcbiAgICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgICAgdHlwZTogZmMuY29uc3RhbnRGcm9tKCdldmVudCcsICdhY3Rpdml0eScsICdhY2NvbW1vZGF0aW9uJywgJ2xvY2F0aW9uJykgYXMgZmMuQXJiaXRyYXJ5PCdldmVudCcgfCAnYWN0aXZpdHknIHwgJ2FjY29tbW9kYXRpb24nIHwgJ2xvY2F0aW9uJz4sXG4gICAgICAgICAgICBpZDogZmMudXVpZCgpLFxuICAgICAgICAgICAgbGFiZWw6IGZjLm9wdGlvbihmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTAwIH0pKSxcbiAgICAgICAgICAgIGV4aXN0czogZmMuYm9vbGVhbigpLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDIwIH1cbiAgICAgICAgKSxcbiAgICAgICAgYXN5bmMgKHRlc3RSZWZlcmVuY2VzKSA9PiB7XG4gICAgICAgICAgLy8gTW9jayBkYXRhYmFzZSBsb29rdXBzIGZvciBlYWNoIHJlZmVyZW5jZVxuICAgICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHRlc3RSZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWVPbmNlKGNyZWF0ZU1vY2tRdWVyeUNoYWluKHtcbiAgICAgICAgICAgICAgZGF0YTogcmVmLmV4aXN0cyA/IHsgaWQ6IHJlZi5pZCB9IDogbnVsbCxcbiAgICAgICAgICAgICAgZXJyb3I6IHJlZi5leGlzdHMgPyBudWxsIDogeyBjb2RlOiAnUEdSU1QxMTYnLCBtZXNzYWdlOiAnTm90IGZvdW5kJyB9LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZXM6IFJlZmVyZW5jZVtdID0gdGVzdFJlZmVyZW5jZXMubWFwKHIgPT4gKHtcbiAgICAgICAgICAgIHR5cGU6IHIudHlwZSxcbiAgICAgICAgICAgIGlkOiByLmlkLFxuICAgICAgICAgICAgbGFiZWw6IHIubGFiZWwgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlUmVmZXJlbmNlcyhyZWZlcmVuY2VzKTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBBUEkgdmFsaWRhdGlvbiBvcGVyYXRpb24gc2hvdWxkIGFsd2F5cyBzdWNjZWVkXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuXG4gICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IEFsbCBub24tZXhpc3RlbnQgcmVmZXJlbmNlcyBzaG91bGQgYmUgZGV0ZWN0ZWQgYXMgYnJva2VuXG4gICAgICAgICAgY29uc3QgZXhwZWN0ZWRCcm9rZW5Db3VudCA9IHRlc3RSZWZlcmVuY2VzLmZpbHRlcihyID0+ICFyLmV4aXN0cykubGVuZ3RoO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5icm9rZW5SZWZlcmVuY2VzLmxlbmd0aCkudG9CZShleHBlY3RlZEJyb2tlbkNvdW50KTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBFYWNoIGJyb2tlbiByZWZlcmVuY2Ugc2hvdWxkIGNvcnJlc3BvbmQgdG8gYSBub24tZXhpc3RlbnQgZW50aXR5XG4gICAgICAgICAgZm9yIChjb25zdCBicm9rZW4gb2YgcmVzdWx0LmRhdGEuYnJva2VuUmVmZXJlbmNlcykge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSB0ZXN0UmVmZXJlbmNlcy5maW5kKHIgPT4gci5pZCA9PT0gYnJva2VuLmlkICYmIHIudHlwZSA9PT0gYnJva2VuLnR5cGUpO1xuICAgICAgICAgICAgZXhwZWN0KG9yaWdpbmFsKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KG9yaWdpbmFsPy5leGlzdHMpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBWYWxpZGF0aW9uIGlzIHZhbGlkIG9ubHkgd2hlbiBhbGwgZW50aXRpZXMgZXhpc3RcbiAgICAgICAgICBjb25zdCBhbGxFeGlzdCA9IHRlc3RSZWZlcmVuY2VzLmV2ZXJ5KHIgPT4gci5leGlzdHMpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS52YWxpZCkudG9CZShhbGxFeGlzdCk7XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHJldHVybiB2YWxpZD10cnVlIHdoZW4gYWxsIHJlZmVyZW5jZWQgZW50aXRpZXMgZXhpc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMuYXJyYXkoXG4gICAgICAgICAgZmMucmVjb3JkKHtcbiAgICAgICAgICAgIHR5cGU6IGZjLmNvbnN0YW50RnJvbSgnZXZlbnQnLCAnYWN0aXZpdHknLCAnYWNjb21tb2RhdGlvbicsICdsb2NhdGlvbicpIGFzIGZjLkFyYml0cmFyeTwnZXZlbnQnIHwgJ2FjdGl2aXR5JyB8ICdhY2NvbW1vZGF0aW9uJyB8ICdsb2NhdGlvbic+LFxuICAgICAgICAgICAgaWQ6IGZjLnV1aWQoKSxcbiAgICAgICAgICAgIGxhYmVsOiBmYy5vcHRpb24oZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwMCB9KSksXG4gICAgICAgICAgfSksXG4gICAgICAgICAgeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTUgfVxuICAgICAgICApLFxuICAgICAgICBhc3luYyAodGVzdFJlZmVyZW5jZXMpID0+IHtcbiAgICAgICAgICAvLyBNb2NrIGFsbCByZWZlcmVuY2VzIGFzIGV4aXN0aW5nIGluIGRhdGFiYXNlXG4gICAgICAgICAgZm9yIChjb25zdCByZWYgb2YgdGVzdFJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZU9uY2UoY3JlYXRlTW9ja1F1ZXJ5Q2hhaW4oe1xuICAgICAgICAgICAgICBkYXRhOiB7IGlkOiByZWYuaWQgfSxcbiAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcmVmZXJlbmNlczogUmVmZXJlbmNlW10gPSB0ZXN0UmVmZXJlbmNlcy5tYXAociA9PiAoe1xuICAgICAgICAgICAgdHlwZTogci50eXBlLFxuICAgICAgICAgICAgaWQ6IHIuaWQsXG4gICAgICAgICAgICBsYWJlbDogci5sYWJlbCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGVSZWZlcmVuY2VzKHJlZmVyZW5jZXMpO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IEFQSSBzaG91bGQgcmV0dXJuIHZhbGlkPXRydWUgd2hlbiBhbGwgZXhpc3RcbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmJyb2tlblJlZmVyZW5jZXMpLnRvSGF2ZUxlbmd0aCgwKTtcblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgcmV0dXJuIHZhbGlkPWZhbHNlIGFuZCBpZGVudGlmeSBicm9rZW4gcmVmZXJlbmNlcyB3aGVuIGVudGl0aWVzIGRvIG5vdCBleGlzdCcsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgIHZhbGlkUmVmczogZmMuYXJyYXkoXG4gICAgICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgICAgICB0eXBlOiBmYy5jb25zdGFudEZyb20oJ2V2ZW50JywgJ2FjdGl2aXR5JywgJ2FjY29tbW9kYXRpb24nLCAnbG9jYXRpb24nKSBhcyBmYy5BcmJpdHJhcnk8J2V2ZW50JyB8ICdhY3Rpdml0eScgfCAnYWNjb21tb2RhdGlvbicgfCAnbG9jYXRpb24nPixcbiAgICAgICAgICAgICAgaWQ6IGZjLnV1aWQoKSxcbiAgICAgICAgICAgICAgbGFiZWw6IGZjLm9wdGlvbihmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTAwIH0pKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgeyBtaW5MZW5ndGg6IDAsIG1heExlbmd0aDogNSB9XG4gICAgICAgICAgKSxcbiAgICAgICAgICBicm9rZW5SZWZzOiBmYy5hcnJheShcbiAgICAgICAgICAgIGZjLnJlY29yZCh7XG4gICAgICAgICAgICAgIHR5cGU6IGZjLmNvbnN0YW50RnJvbSgnZXZlbnQnLCAnYWN0aXZpdHknLCAnYWNjb21tb2RhdGlvbicsICdsb2NhdGlvbicpIGFzIGZjLkFyYml0cmFyeTwnZXZlbnQnIHwgJ2FjdGl2aXR5JyB8ICdhY2NvbW1vZGF0aW9uJyB8ICdsb2NhdGlvbic+LFxuICAgICAgICAgICAgICBpZDogZmMudXVpZCgpLFxuICAgICAgICAgICAgICBsYWJlbDogZmMub3B0aW9uKGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxMDAgfSkpLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1IH1cbiAgICAgICAgICApLFxuICAgICAgICB9KSxcbiAgICAgICAgYXN5bmMgKHRlc3REYXRhKSA9PiB7XG4gICAgICAgICAgLy8gTW9jayB2YWxpZCByZWZlcmVuY2VzIGFzIGV4aXN0aW5nXG4gICAgICAgICAgZm9yIChjb25zdCByZWYgb2YgdGVzdERhdGEudmFsaWRSZWZzKSB7XG4gICAgICAgICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWVPbmNlKGNyZWF0ZU1vY2tRdWVyeUNoYWluKHtcbiAgICAgICAgICAgICAgZGF0YTogeyBpZDogcmVmLmlkIH0sXG4gICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE1vY2sgYnJva2VuIHJlZmVyZW5jZXMgYXMgbm90IGV4aXN0aW5nXG4gICAgICAgICAgZm9yIChjb25zdCByZWYgb2YgdGVzdERhdGEuYnJva2VuUmVmcykge1xuICAgICAgICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlT25jZShjcmVhdGVNb2NrUXVlcnlDaGFpbih7XG4gICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgIGVycm9yOiB7IGNvZGU6ICdQR1JTVDExNicsIG1lc3NhZ2U6ICdOb3QgZm91bmQnIH0sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcmVmZXJlbmNlczogUmVmZXJlbmNlW10gPSBbXG4gICAgICAgICAgICAuLi50ZXN0RGF0YS52YWxpZFJlZnMubWFwKHIgPT4gKHsgdHlwZTogci50eXBlLCBpZDogci5pZCwgbGFiZWw6IHIubGFiZWwgfHwgdW5kZWZpbmVkIH0pKSxcbiAgICAgICAgICAgIC4uLnRlc3REYXRhLmJyb2tlblJlZnMubWFwKHIgPT4gKHsgdHlwZTogci50eXBlLCBpZDogci5pZCwgbGFiZWw6IHIubGFiZWwgfHwgdW5kZWZpbmVkIH0pKSxcbiAgICAgICAgICBdO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGVSZWZlcmVuY2VzKHJlZmVyZW5jZXMpO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IEFQSSBzaG91bGQgcmV0dXJuIHZhbGlkPWZhbHNlIHdoZW4gYW55IHJlZmVyZW5jZSBpcyBicm9rZW5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5icm9rZW5SZWZlcmVuY2VzLmxlbmd0aCkudG9CZSh0ZXN0RGF0YS5icm9rZW5SZWZzLmxlbmd0aCk7XG5cbiAgICAgICAgICAvLyBQcm9wZXJ0eTogQWxsIGJyb2tlbiByZWZlcmVuY2VzIHNob3VsZCBiZSBpZGVudGlmaWVkXG4gICAgICAgICAgZm9yIChjb25zdCBicm9rZW5SZWYgb2YgdGVzdERhdGEuYnJva2VuUmVmcykge1xuICAgICAgICAgICAgY29uc3QgZm91bmQgPSByZXN1bHQuZGF0YS5icm9rZW5SZWZlcmVuY2VzLmZpbmQoXG4gICAgICAgICAgICAgIHIgPT4gci5pZCA9PT0gYnJva2VuUmVmLmlkICYmIHIudHlwZSA9PT0gYnJva2VuUmVmLnR5cGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBleHBlY3QoZm91bmQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDUwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGhhbmRsZSBlbXB0eSByZWZlcmVuY2UgYXJyYXlzJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlUmVmZXJlbmNlcyhbXSk7XG5cbiAgICAvLyBQcm9wZXJ0eTogRW1wdHkgYXJyYXkgc2hvdWxkIGJlIHZhbGlkIChBUEkgY29udHJhY3QpXG4gICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnZhbGlkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmJyb2tlblJlZmVyZW5jZXMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICB9XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgdmVyaWZ5IGVhY2ggZW50aXR5IHR5cGUgYWdhaW5zdCBpdHMgY29ycmVjdCBkYXRhYmFzZSB0YWJsZScsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBmYy5jb25zdGFudEZyb20oJ2V2ZW50JywgJ2FjdGl2aXR5JywgJ2FjY29tbW9kYXRpb24nLCAnbG9jYXRpb24nKSBhcyBmYy5BcmJpdHJhcnk8J2V2ZW50JyB8ICdhY3Rpdml0eScgfCAnYWNjb21tb2RhdGlvbicgfCAnbG9jYXRpb24nPixcbiAgICAgICAgZmMudXVpZCgpLFxuICAgICAgICBmYy5vcHRpb24oZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwMCB9KSksXG4gICAgICAgIGFzeW5jICh0eXBlLCBpZCwgbGFiZWwpID0+IHtcbiAgICAgICAgICBjb25zdCBleHBlY3RlZFRhYmxlID0gXG4gICAgICAgICAgICB0eXBlID09PSAnZXZlbnQnID8gJ2V2ZW50cycgOlxuICAgICAgICAgICAgdHlwZSA9PT0gJ2FjdGl2aXR5JyA/ICdhY3Rpdml0aWVzJyA6XG4gICAgICAgICAgICB0eXBlID09PSAnYWNjb21tb2RhdGlvbicgPyAnYWNjb21tb2RhdGlvbnMnIDpcbiAgICAgICAgICAgICdsb2NhdGlvbnMnO1xuXG4gICAgICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlT25jZShjcmVhdGVNb2NrUXVlcnlDaGFpbih7XG4gICAgICAgICAgICBkYXRhOiB7IGlkIH0sXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjb25zdCByZWZlcmVuY2VzOiBSZWZlcmVuY2VbXSA9IFt7IHR5cGUsIGlkLCBsYWJlbDogbGFiZWwgfHwgdW5kZWZpbmVkIH1dO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlUmVmZXJlbmNlcyhyZWZlcmVuY2VzKTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBBUEkgc2hvdWxkIHF1ZXJ5IHRoZSBjb3JyZWN0IHRhYmxlIGZvciBlYWNoIGVudGl0eSB0eXBlXG4gICAgICAgICAgZXhwZWN0KG1vY2tGcm9tKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3RlZFRhYmxlKTtcbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogNTAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgcHJlc2VydmUgcmVmZXJlbmNlIG1ldGFkYXRhIGluIGJyb2tlbiByZWZlcmVuY2VzIHJlc3BvbnNlJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGZjLmFycmF5KFxuICAgICAgICAgIGZjLnJlY29yZCh7XG4gICAgICAgICAgICB0eXBlOiBmYy5jb25zdGFudEZyb20oJ2V2ZW50JywgJ2FjdGl2aXR5JywgJ2FjY29tbW9kYXRpb24nLCAnbG9jYXRpb24nKSBhcyBmYy5BcmJpdHJhcnk8J2V2ZW50JyB8ICdhY3Rpdml0eScgfCAnYWNjb21tb2RhdGlvbicgfCAnbG9jYXRpb24nPixcbiAgICAgICAgICAgIGlkOiBmYy51dWlkKCksXG4gICAgICAgICAgICBsYWJlbDogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwMCB9KSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxMCB9XG4gICAgICAgICksXG4gICAgICAgIGFzeW5jICh0ZXN0UmVmZXJlbmNlcykgPT4ge1xuICAgICAgICAgIC8vIE1vY2sgYWxsIGFzIG5vdCBleGlzdGluZ1xuICAgICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHRlc3RSZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWVPbmNlKGNyZWF0ZU1vY2tRdWVyeUNoYWluKHtcbiAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgZXJyb3I6IHsgY29kZTogJ1BHUlNUMTE2JywgbWVzc2FnZTogJ05vdCBmb3VuZCcgfSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCByZWZlcmVuY2VzOiBSZWZlcmVuY2VbXSA9IHRlc3RSZWZlcmVuY2VzLm1hcChyID0+ICh7XG4gICAgICAgICAgICB0eXBlOiByLnR5cGUsXG4gICAgICAgICAgICBpZDogci5pZCxcbiAgICAgICAgICAgIGxhYmVsOiByLmxhYmVsLFxuICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlUmVmZXJlbmNlcyhyZWZlcmVuY2VzKTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBBUEkgc2hvdWxkIHByZXNlcnZlIG1ldGFkYXRhIGluIGJyb2tlbiByZWZlcmVuY2VzXG4gICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC5kYXRhLmJyb2tlblJlZmVyZW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBicm9rZW4gb2YgcmVzdWx0LmRhdGEuYnJva2VuUmVmZXJlbmNlcykge1xuICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbCA9IHRlc3RSZWZlcmVuY2VzLmZpbmQociA9PiByLmlkID09PSBicm9rZW4uaWQpO1xuICAgICAgICAgICAgICBleHBlY3Qob3JpZ2luYWwpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICAgIGlmIChvcmlnaW5hbCkge1xuICAgICAgICAgICAgICAgIGV4cGVjdChicm9rZW4ubGFiZWwpLnRvQmUob3JpZ2luYWwubGFiZWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDUwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGhhbmRsZSBkYXRhYmFzZSBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBmYy5hcnJheShcbiAgICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgICAgdHlwZTogZmMuY29uc3RhbnRGcm9tKCdldmVudCcsICdhY3Rpdml0eScsICdhY2NvbW1vZGF0aW9uJywgJ2xvY2F0aW9uJykgYXMgZmMuQXJiaXRyYXJ5PCdldmVudCcgfCAnYWN0aXZpdHknIHwgJ2FjY29tbW9kYXRpb24nIHwgJ2xvY2F0aW9uJz4sXG4gICAgICAgICAgICBpZDogZmMudXVpZCgpLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUgfVxuICAgICAgICApLFxuICAgICAgICBhc3luYyAodGVzdFJlZmVyZW5jZXMpID0+IHtcbiAgICAgICAgICAvLyBNb2NrIGRhdGFiYXNlIGVycm9yXG4gICAgICAgICAgbW9ja0Zyb20ubW9ja0ltcGxlbWVudGF0aW9uT25jZSgoKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJyk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjb25zdCByZWZlcmVuY2VzOiBSZWZlcmVuY2VbXSA9IHRlc3RSZWZlcmVuY2VzLm1hcChyID0+ICh7XG4gICAgICAgICAgICB0eXBlOiByLnR5cGUsXG4gICAgICAgICAgICBpZDogci5pZCxcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0ZVJlZmVyZW5jZXMocmVmZXJlbmNlcyk7XG5cbiAgICAgICAgICAvLyBQcm9wZXJ0eTogQVBJIHNob3VsZCBoYW5kbGUgZXJyb3JzIGdyYWNlZnVsbHlcbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnVU5LTk9XTl9FUlJPUicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiA1MCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSByZWZlcmVuY2VzIGNvbnNpc3RlbnRseSByZWdhcmRsZXNzIG9mIG9yZGVyJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGZjLmFycmF5KFxuICAgICAgICAgIGZjLnJlY29yZCh7XG4gICAgICAgICAgICB0eXBlOiBmYy5jb25zdGFudEZyb20oJ2V2ZW50JywgJ2FjdGl2aXR5JywgJ2FjY29tbW9kYXRpb24nLCAnbG9jYXRpb24nKSBhcyBmYy5BcmJpdHJhcnk8J2V2ZW50JyB8ICdhY3Rpdml0eScgfCAnYWNjb21tb2RhdGlvbicgfCAnbG9jYXRpb24nPixcbiAgICAgICAgICAgIGlkOiBmYy51dWlkKCksXG4gICAgICAgICAgICBleGlzdHM6IGZjLmJvb2xlYW4oKSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7IG1pbkxlbmd0aDogMiwgbWF4TGVuZ3RoOiAxMCB9XG4gICAgICAgICksXG4gICAgICAgIGFzeW5jICh0ZXN0UmVmZXJlbmNlcykgPT4ge1xuICAgICAgICAgIC8vIEZpcnN0IHZhbGlkYXRpb24gd2l0aCBvcmlnaW5hbCBvcmRlclxuICAgICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHRlc3RSZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWVPbmNlKGNyZWF0ZU1vY2tRdWVyeUNoYWluKHtcbiAgICAgICAgICAgICAgZGF0YTogcmVmLmV4aXN0cyA/IHsgaWQ6IHJlZi5pZCB9IDogbnVsbCxcbiAgICAgICAgICAgICAgZXJyb3I6IHJlZi5leGlzdHMgPyBudWxsIDogeyBjb2RlOiAnUEdSU1QxMTYnLCBtZXNzYWdlOiAnTm90IGZvdW5kJyB9LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZXM6IFJlZmVyZW5jZVtdID0gdGVzdFJlZmVyZW5jZXMubWFwKHIgPT4gKHtcbiAgICAgICAgICAgIHR5cGU6IHIudHlwZSxcbiAgICAgICAgICAgIGlkOiByLmlkLFxuICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdDEgPSBhd2FpdCB2YWxpZGF0ZVJlZmVyZW5jZXMocmVmZXJlbmNlcyk7XG5cbiAgICAgICAgICAvLyBTZWNvbmQgdmFsaWRhdGlvbiB3aXRoIHJldmVyc2VkIG9yZGVyXG4gICAgICAgICAgY29uc3QgcmV2ZXJzZWRSZWZzID0gWy4uLnRlc3RSZWZlcmVuY2VzXS5yZXZlcnNlKCk7XG4gICAgICAgICAgZm9yIChjb25zdCByZWYgb2YgcmV2ZXJzZWRSZWZzKSB7XG4gICAgICAgICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWVPbmNlKGNyZWF0ZU1vY2tRdWVyeUNoYWluKHtcbiAgICAgICAgICAgICAgZGF0YTogcmVmLmV4aXN0cyA/IHsgaWQ6IHJlZi5pZCB9IDogbnVsbCxcbiAgICAgICAgICAgICAgZXJyb3I6IHJlZi5leGlzdHMgPyBudWxsIDogeyBjb2RlOiAnUEdSU1QxMTYnLCBtZXNzYWdlOiAnTm90IGZvdW5kJyB9LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJldmVyc2VkUmVmZXJlbmNlczogUmVmZXJlbmNlW10gPSByZXZlcnNlZFJlZnMubWFwKHIgPT4gKHtcbiAgICAgICAgICAgIHR5cGU6IHIudHlwZSxcbiAgICAgICAgICAgIGlkOiByLmlkLFxuICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCB2YWxpZGF0ZVJlZmVyZW5jZXMocmV2ZXJzZWRSZWZlcmVuY2VzKTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBBUEkgc2hvdWxkIHJldHVybiBzYW1lIHZhbGlkYXRpb24gcmVzdWx0IHJlZ2FyZGxlc3Mgb2Ygb3JkZXJcbiAgICAgICAgICBleHBlY3QocmVzdWx0MS5zdWNjZXNzKS50b0JlKHJlc3VsdDIuc3VjY2Vzcyk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEuc3VjY2VzcyAmJiByZXN1bHQyLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQxLmRhdGEudmFsaWQpLnRvQmUocmVzdWx0Mi5kYXRhLnZhbGlkKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQxLmRhdGEuYnJva2VuUmVmZXJlbmNlcy5sZW5ndGgpLnRvQmUocmVzdWx0Mi5kYXRhLmJyb2tlblJlZmVyZW5jZXMubGVuZ3RoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogNTAgfVxuICAgICk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsibW9ja0Zyb20iLCJqZXN0IiwiZm4iLCJtb2NrU3VwYWJhc2UiLCJmcm9tIiwibW9jayIsInN1cGFiYXNlIiwiY3JlYXRlTW9ja1F1ZXJ5Q2hhaW4iLCJyZXNvbHZlZFZhbHVlIiwibW9ja1NpbmdsZSIsIm1vY2tSZXNvbHZlZFZhbHVlIiwibW9ja0VxIiwibW9ja1JldHVyblZhbHVlIiwic2luZ2xlIiwibW9ja1NlbGVjdCIsImVxIiwic2VsZWN0IiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIml0IiwiZmMiLCJhc3NlcnQiLCJhc3luY1Byb3BlcnR5IiwiYXJyYXkiLCJyZWNvcmQiLCJ0eXBlIiwiY29uc3RhbnRGcm9tIiwiaWQiLCJ1dWlkIiwibGFiZWwiLCJvcHRpb24iLCJzdHJpbmciLCJtaW5MZW5ndGgiLCJtYXhMZW5ndGgiLCJleGlzdHMiLCJib29sZWFuIiwidGVzdFJlZmVyZW5jZXMiLCJyZWYiLCJtb2NrUmV0dXJuVmFsdWVPbmNlIiwiZGF0YSIsImVycm9yIiwiY29kZSIsIm1lc3NhZ2UiLCJyZWZlcmVuY2VzIiwibWFwIiwiciIsInVuZGVmaW5lZCIsInJlc3VsdCIsInZhbGlkYXRlUmVmZXJlbmNlcyIsImV4cGVjdCIsInN1Y2Nlc3MiLCJ0b0JlIiwiZXhwZWN0ZWRCcm9rZW5Db3VudCIsImZpbHRlciIsImxlbmd0aCIsImJyb2tlblJlZmVyZW5jZXMiLCJicm9rZW4iLCJvcmlnaW5hbCIsImZpbmQiLCJ0b0JlRGVmaW5lZCIsImFsbEV4aXN0IiwiZXZlcnkiLCJ2YWxpZCIsIm51bVJ1bnMiLCJ0b0hhdmVMZW5ndGgiLCJ2YWxpZFJlZnMiLCJicm9rZW5SZWZzIiwidGVzdERhdGEiLCJicm9rZW5SZWYiLCJmb3VuZCIsImV4cGVjdGVkVGFibGUiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsIm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UiLCJFcnJvciIsInJlc3VsdDEiLCJyZXZlcnNlZFJlZnMiLCJyZXZlcnNlIiwicmV2ZXJzZWRSZWZlcmVuY2VzIiwicmVzdWx0MiJdLCJtYXBwaW5ncyI6Ijs7OzttRUFBb0I7eUJBQ21DO2lDQTBCcEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXhCbkM7Ozs7Ozs7Ozs7O0NBV0MsR0FFRCwwQ0FBMEM7QUFDMUMsTUFBTUEsV0FBV0MsYUFBSSxDQUFDQyxFQUFFO0FBQ3hCLE1BQU1DLGVBQWU7SUFDbkJDLE1BQU1KO0FBQ1I7QUFFQUMsYUFBSSxDQUFDSSxJQUFJLENBQUMsbUJBQW1CLElBQU8sQ0FBQTtRQUNsQ0MsVUFBVUg7SUFDWixDQUFBO0FBTUEsNkNBQTZDO0FBQzdDLFNBQVNJLHFCQUFxQkMsYUFBd0M7SUFDcEUsTUFBTUMsYUFBYSxBQUFDUixhQUFJLENBQUNDLEVBQUUsR0FBV1EsaUJBQWlCLENBQUNGO0lBQ3hELE1BQU1HLFNBQVMsQUFBQ1YsYUFBSSxDQUFDQyxFQUFFLEdBQVdVLGVBQWUsQ0FBQztRQUFFQyxRQUFRSjtJQUFXO0lBQ3ZFLE1BQU1LLGFBQWEsQUFBQ2IsYUFBSSxDQUFDQyxFQUFFLEdBQVdVLGVBQWUsQ0FBQztRQUFFRyxJQUFJSjtJQUFPO0lBQ25FLE9BQU87UUFBRUssUUFBUUY7SUFBVztBQUM5QjtBQUVBRyxJQUFBQSxpQkFBUSxFQUFDLGlGQUFpRjtJQUN4RkMsSUFBQUEsbUJBQVUsRUFBQztRQUNUakIsYUFBSSxDQUFDa0IsYUFBYTtJQUNwQjtJQUVBQyxJQUFBQSxXQUFFLEVBQUMscUZBQXFGO1FBQ3RGLE1BQU1DLFdBQUdDLE1BQU0sQ0FDYkQsV0FBR0UsYUFBYSxDQUNkRixXQUFHRyxLQUFLLENBQ05ILFdBQUdJLE1BQU0sQ0FBQztZQUNSQyxNQUFNTCxXQUFHTSxZQUFZLENBQUMsU0FBUyxZQUFZLGlCQUFpQjtZQUM1REMsSUFBSVAsV0FBR1EsSUFBSTtZQUNYQyxPQUFPVCxXQUFHVSxNQUFNLENBQUNWLFdBQUdXLE1BQU0sQ0FB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