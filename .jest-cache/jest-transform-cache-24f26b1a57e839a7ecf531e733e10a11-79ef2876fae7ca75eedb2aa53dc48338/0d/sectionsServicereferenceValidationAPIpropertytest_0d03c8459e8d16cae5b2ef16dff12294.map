{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/services/sectionsService.referenceValidationAPI.property.test.ts"],"sourcesContent":["import * as fc from 'fast-check';\nimport { jest, describe, it, expect, beforeEach } from '@jest/globals';\n\n/**\n * Property 15: Reference Validation API\n * \n * For any POST request to validate references, the API SHALL check that all \n * referenced entities exist in the database and return broken references.\n * \n * This test validates the API contract by testing the service layer behavior\n * that the API endpoint exposes. The API route (POST /api/admin/sections/validate-refs)\n * is a thin wrapper around the validateReferences service function.\n * \n * Validates: Requirements 15.6\n */\n\n// Mock Supabase before importing services\nconst mockFrom = jest.fn() as jest.MockedFunction<any>;\nconst mockSupabase = {\n  from: mockFrom,\n};\n\njest.mock('../lib/supabase', () => ({\n  supabase: mockSupabase,\n}));\n\n// Import after mocking\nimport { validateReferences } from './sectionsService';\nimport type { Reference } from '../schemas/cmsSchemas';\n\n// Helper to create properly typed mock chain\nfunction createMockQueryChain(resolvedValue: { data: any; error: any }) {\n  const mockSingle = (jest.fn() as any).mockResolvedValue(resolvedValue);\n  const mockEq = (jest.fn() as any).mockReturnValue({ single: mockSingle });\n  const mockSelect = (jest.fn() as any).mockReturnValue({ eq: mockEq });\n  return { select: mockSelect } as any;\n}\n\ndescribe('Feature: admin-backend-integration-cms, Property 15: Reference Validation API', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('should validate all references and return broken references for any valid request', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.array(\n          fc.record({\n            type: fc.constantFrom('event', 'activity', 'accommodation', 'location') as fc.Arbitrary<'event' | 'activity' | 'accommodation' | 'location'>,\n            id: fc.uuid(),\n            label: fc.option(fc.string({ minLength: 1, maxLength: 100 })),\n            exists: fc.boolean(),\n          }),\n          { minLength: 1, maxLength: 20 }\n        ),\n        async (testReferences) => {\n          // Mock database lookups for each reference\n          for (const ref of testReferences) {\n            mockFrom.mockReturnValueOnce(createMockQueryChain({\n              data: ref.exists ? { id: ref.id } : null,\n              error: ref.exists ? null : { code: 'PGRST116', message: 'Not found' },\n            }));\n          }\n\n          const references: Reference[] = testReferences.map(r => ({\n            type: r.type,\n            id: r.id,\n            label: r.label || undefined,\n          }));\n\n          const result = await validateReferences(references);\n\n          // Property: API validation operation should always succeed\n          expect(result.success).toBe(true);\n\n          if (!result.success) {\n            return true;\n          }\n\n          // Property: All non-existent references should be detected as broken\n          const expectedBrokenCount = testReferences.filter(r => !r.exists).length;\n          expect(result.data.brokenReferences.length).toBe(expectedBrokenCount);\n\n          // Property: Each broken reference should correspond to a non-existent entity\n          for (const broken of result.data.brokenReferences) {\n            const original = testReferences.find(r => r.id === broken.id && r.type === broken.type);\n            expect(original).toBeDefined();\n            expect(original?.exists).toBe(false);\n          }\n\n          // Property: Validation is valid only when all entities exist\n          const allExist = testReferences.every(r => r.exists);\n          expect(result.data.valid).toBe(allExist);\n\n          return true;\n        }\n      ),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should return valid=true when all referenced entities exist', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.array(\n          fc.record({\n            type: fc.constantFrom('event', 'activity', 'accommodation', 'location') as fc.Arbitrary<'event' | 'activity' | 'accommodation' | 'location'>,\n            id: fc.uuid(),\n            label: fc.option(fc.string({ minLength: 1, maxLength: 100 })),\n          }),\n          { minLength: 1, maxLength: 15 }\n        ),\n        async (testReferences) => {\n          // Mock all references as existing in database\n          for (const ref of testReferences) {\n            mockFrom.mockReturnValueOnce(createMockQueryChain({\n              data: { id: ref.id },\n              error: null,\n            }));\n          }\n\n          const references: Reference[] = testReferences.map(r => ({\n            type: r.type,\n            id: r.id,\n            label: r.label || undefined,\n          }));\n\n          const result = await validateReferences(references);\n\n          // Property: API should return valid=true when all exist\n          expect(result.success).toBe(true);\n\n          if (!result.success) {\n            return true;\n          }\n\n          expect(result.data.valid).toBe(true);\n          expect(result.data.brokenReferences).toHaveLength(0);\n\n          return true;\n        }\n      ),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should return valid=false and identify broken references when entities do not exist', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.record({\n          validRefs: fc.array(\n            fc.record({\n              type: fc.constantFrom('event', 'activity', 'accommodation', 'location') as fc.Arbitrary<'event' | 'activity' | 'accommodation' | 'location'>,\n              id: fc.uuid(),\n              label: fc.option(fc.string({ minLength: 1, maxLength: 100 })),\n            }),\n            { minLength: 0, maxLength: 5 }\n          ),\n          brokenRefs: fc.array(\n            fc.record({\n              type: fc.constantFrom('event', 'activity', 'accommodation', 'location') as fc.Arbitrary<'event' | 'activity' | 'accommodation' | 'location'>,\n              id: fc.uuid(),\n              label: fc.option(fc.string({ minLength: 1, maxLength: 100 })),\n            }),\n            { minLength: 1, maxLength: 5 }\n          ),\n        }),\n        async (testData) => {\n          // Mock valid references as existing\n          for (const ref of testData.validRefs) {\n            mockFrom.mockReturnValueOnce(createMockQueryChain({\n              data: { id: ref.id },\n              error: null,\n            }));\n          }\n\n          // Mock broken references as not existing\n          for (const ref of testData.brokenRefs) {\n            mockFrom.mockReturnValueOnce(createMockQueryChain({\n              data: null,\n              error: { code: 'PGRST116', message: 'Not found' },\n            }));\n          }\n\n          const references: Reference[] = [\n            ...testData.validRefs.map(r => ({ type: r.type, id: r.id, label: r.label || undefined })),\n            ...testData.brokenRefs.map(r => ({ type: r.type, id: r.id, label: r.label || undefined })),\n          ];\n\n          const result = await validateReferences(references);\n\n          // Property: API should return valid=false when any reference is broken\n          expect(result.success).toBe(true);\n\n          if (!result.success) {\n            return true;\n          }\n\n          expect(result.data.valid).toBe(false);\n          expect(result.data.brokenReferences.length).toBe(testData.brokenRefs.length);\n\n          // Property: All broken references should be identified\n          for (const brokenRef of testData.brokenRefs) {\n            const found = result.data.brokenReferences.find(\n              r => r.id === brokenRef.id && r.type === brokenRef.type\n            );\n            expect(found).toBeDefined();\n          }\n\n          return true;\n        }\n      ),\n      { numRuns: 50 }\n    );\n  });\n\n  it('should handle empty reference arrays', async () => {\n    const result = await validateReferences([]);\n\n    // Property: Empty array should be valid (API contract)\n    expect(result.success).toBe(true);\n    if (result.success) {\n      expect(result.data.valid).toBe(true);\n      expect(result.data.brokenReferences).toHaveLength(0);\n    }\n  });\n\n  it('should verify each entity type against its correct database table', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.constantFrom('event', 'activity', 'accommodation', 'location') as fc.Arbitrary<'event' | 'activity' | 'accommodation' | 'location'>,\n        fc.uuid(),\n        fc.option(fc.string({ minLength: 1, maxLength: 100 })),\n        async (type, id, label) => {\n          const expectedTable = \n            type === 'event' ? 'events' :\n            type === 'activity' ? 'activities' :\n            type === 'accommodation' ? 'accommodations' :\n            'locations';\n\n          mockFrom.mockReturnValueOnce(createMockQueryChain({\n            data: { id },\n            error: null,\n          }));\n\n          const references: Reference[] = [{ type, id, label: label || undefined }];\n          const result = await validateReferences(references);\n\n          // Property: API should query the correct table for each entity type\n          expect(mockFrom).toHaveBeenCalledWith(expectedTable);\n          expect(result.success).toBe(true);\n\n          return true;\n        }\n      ),\n      { numRuns: 50 }\n    );\n  });\n\n  it('should preserve reference metadata in broken references response', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.array(\n          fc.record({\n            type: fc.constantFrom('event', 'activity', 'accommodation', 'location') as fc.Arbitrary<'event' | 'activity' | 'accommodation' | 'location'>,\n            id: fc.uuid(),\n            label: fc.string({ minLength: 1, maxLength: 100 }),\n          }),\n          { minLength: 1, maxLength: 10 }\n        ),\n        async (testReferences) => {\n          // Mock all as not existing\n          for (const ref of testReferences) {\n            mockFrom.mockReturnValueOnce(createMockQueryChain({\n              data: null,\n              error: { code: 'PGRST116', message: 'Not found' },\n            }));\n          }\n\n          const references: Reference[] = testReferences.map(r => ({\n            type: r.type,\n            id: r.id,\n            label: r.label,\n          }));\n\n          const result = await validateReferences(references);\n\n          // Property: API should preserve metadata in broken references\n          if (result.success && result.data.brokenReferences.length > 0) {\n            for (const broken of result.data.brokenReferences) {\n              const original = testReferences.find(r => r.id === broken.id);\n              expect(original).toBeDefined();\n              if (original) {\n                expect(broken.label).toBe(original.label);\n              }\n            }\n          }\n\n          return true;\n        }\n      ),\n      { numRuns: 50 }\n    );\n  });\n\n  it('should handle database errors gracefully', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.array(\n          fc.record({\n            type: fc.constantFrom('event', 'activity', 'accommodation', 'location') as fc.Arbitrary<'event' | 'activity' | 'accommodation' | 'location'>,\n            id: fc.uuid(),\n          }),\n          { minLength: 1, maxLength: 5 }\n        ),\n        async (testReferences) => {\n          // Mock database error\n          mockFrom.mockImplementationOnce(() => {\n            throw new Error('Database connection failed');\n          });\n\n          const references: Reference[] = testReferences.map(r => ({\n            type: r.type,\n            id: r.id,\n          }));\n\n          const result = await validateReferences(references);\n\n          // Property: API should handle errors gracefully\n          expect(result.success).toBe(false);\n          if (!result.success) {\n            expect(result.error.code).toBe('UNKNOWN_ERROR');\n          }\n\n          return true;\n        }\n      ),\n      { numRuns: 50 }\n    );\n  });\n\n  it('should validate references consistently regardless of order', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.array(\n          fc.record({\n            type: fc.constantFrom('event', 'activity', 'accommodation', 'location') as fc.Arbitrary<'event' | 'activity' | 'accommodation' | 'location'>,\n            id: fc.uuid(),\n            exists: fc.boolean(),\n          }),\n          { minLength: 2, maxLength: 10 }\n        ),\n        async (testReferences) => {\n          // First validation with original order\n          for (const ref of testReferences) {\n            mockFrom.mockReturnValueOnce(createMockQueryChain({\n              data: ref.exists ? { id: ref.id } : null,\n              error: ref.exists ? null : { code: 'PGRST116', message: 'Not found' },\n            }));\n          }\n\n          const references: Reference[] = testReferences.map(r => ({\n            type: r.type,\n            id: r.id,\n          }));\n\n          const result1 = await validateReferences(references);\n\n          // Second validation with reversed order\n          const reversedRefs = [...testReferences].reverse();\n          for (const ref of reversedRefs) {\n            mockFrom.mockReturnValueOnce(createMockQueryChain({\n              data: ref.exists ? { id: ref.id } : null,\n              error: ref.exists ? null : { code: 'PGRST116', message: 'Not found' },\n            }));\n          }\n\n          const reversedReferences: Reference[] = reversedRefs.map(r => ({\n            type: r.type,\n            id: r.id,\n          }));\n\n          const result2 = await validateReferences(reversedReferences);\n\n          // Property: API should return same validation result regardless of order\n          expect(result1.success).toBe(result2.success);\n          if (result1.success && result2.success) {\n            expect(result1.data.valid).toBe(result2.data.valid);\n            expect(result1.data.brokenReferences.length).toBe(result2.data.brokenReferences.length);\n          }\n\n          return true;\n        }\n      ),\n      { numRuns: 50 }\n    );\n  });\n});\n"],"names":["mockFrom","jest","fn","mockSupabase","from","mock","supabase","createMockQueryChain","resolvedValue","mockSingle","mockResolvedValue","mockEq","mockReturnValue","single","mockSelect","eq","select","describe","beforeEach","clearAllMocks","it","fc","assert","asyncProperty","array","record","type","constantFrom","id","uuid","label","option","string","minLength","maxLength","exists","boolean","testReferences","ref","mockReturnValueOnce","data","error","code","message","references","map","r","undefined","result","validateReferences","expect","success","toBe","expectedBrokenCount","filter","length","brokenReferences","broken","original","find","toBeDefined","allExist","every","valid","numRuns","toHaveLength","validRefs","brokenRefs","testData","brokenRef","found","expectedTable","toHaveBeenCalledWith","mockImplementationOnce","Error","result1","reversedRefs","reverse","reversedReferences","result2"],"mappings":"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"}