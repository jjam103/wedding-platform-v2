b4e631ebebae5bae199bd3eebf9f80ec
"use strict";
// Mock dependencies
jest.mock('@/services/rsvpManagementService');
jest.mock('@/lib/apiHelpers', ()=>({
        ...jest.requireActual('@/lib/apiHelpers'),
        withAuth: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _route = require("./route");
const _rsvpManagementService = /*#__PURE__*/ _interop_require_wildcard(require("../../../../../services/rsvpManagementService"));
const _apiHelpers = /*#__PURE__*/ _interop_require_wildcard(require("../../../../../lib/apiHelpers"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('PATCH /api/admin/rsvps/bulk', ()=>{
    const mockUserId = 'user-123';
    const mockRsvpIds = [
        '11111111-1111-1111-1111-111111111111',
        '22222222-2222-2222-2222-222222222222',
        '33333333-3333-3333-3333-333333333333'
    ];
    beforeEach(()=>{
        jest.clearAllMocks();
        // Mock withAuth to call the handler with mockUserId
        _apiHelpers.withAuth.mockImplementation(async (handler)=>{
            return handler(mockUserId);
        });
    });
    describe('Success Cases', ()=>{
        it('should update RSVPs and return 200 when valid data provided', async ()=>{
            // Arrange
            const mockServiceResponse = {
                success: true,
                data: {
                    updatedCount: 3
                }
            };
            _rsvpManagementService.bulkUpdateRSVPs.mockResolvedValue(mockServiceResponse);
            const request = new Request('http://localhost:3000/api/admin/rsvps/bulk', {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    rsvpIds: mockRsvpIds,
                    status: 'attending'
                })
            });
            // Act
            const response = await (0, _route.PATCH)(request);
            const data = await response.json();
            // Assert
            expect(response.status).toBe(200);
            expect(data.success).toBe(true);
            expect(data.data.updatedCount).toBe(3);
            expect(_rsvpManagementService.bulkUpdateRSVPs).toHaveBeenCalledWith(mockRsvpIds, 'attending', undefined);
        });
        it('should update RSVPs with notes when notes provided', async ()=>{
            // Arrange
            const mockServiceResponse = {
                success: true,
                data: {
                    updatedCount: 2
                }
            };
            _rsvpManagementService.bulkUpdateRSVPs.mockResolvedValue(mockServiceResponse);
            const request = new Request('http://localhost:3000/api/admin/rsvps/bulk', {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    rsvpIds: mockRsvpIds.slice(0, 2),
                    status: 'declined',
                    notes: 'Bulk declined by admin'
                })
            });
            // Act
            const response = await (0, _route.PATCH)(request);
            const data = await response.json();
            // Assert
            expect(response.status).toBe(200);
            expect(data.success).toBe(true);
            expect(data.data.updatedCount).toBe(2);
            expect(_rsvpManagementService.bulkUpdateRSVPs).toHaveBeenCalledWith(mockRsvpIds.slice(0, 2), 'declined', 'Bulk declined by admin');
        });
        it('should handle partial success when some RSVPs not found', async ()=>{
            // Arrange
            const mockServiceResponse = {
                success: true,
                data: {
                    updatedCount: 2
                }
            };
            _rsvpManagementService.bulkUpdateRSVPs.mockResolvedValue(mockServiceResponse);
            const request = new Request('http://localhost:3000/api/admin/rsvps/bulk', {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    rsvpIds: mockRsvpIds,
                    status: 'maybe'
                })
            });
            // Act
            const response = await (0, _route.PATCH)(request);
            const data = await response.json();
            // Assert
            expect(response.status).toBe(200);
            expect(data.success).toBe(true);
            expect(data.data.updatedCount).toBe(2);
        });
        it('should update RSVPs to pending status', async ()=>{
            // Arrange
            const mockServiceResponse = {
                success: true,
                data: {
                    updatedCount: 1
                }
            };
            _rsvpManagementService.bulkUpdateRSVPs.mockResolvedValue(mockServiceResponse);
            const request = new Request('http://localhost:3000/api/admin/rsvps/bulk', {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    rsvpIds: [
                        mockRsvpIds[0]
                    ],
                    status: 'pending'
                })
            });
            // Act
            const response = await (0, _route.PATCH)(request);
            const data = await response.json();
            // Assert
            expect(response.status).toBe(200);
            expect(data.success).toBe(true);
            expect(data.data.updatedCount).toBe(1);
            expect(_rsvpManagementService.bulkUpdateRSVPs).toHaveBeenCalledWith([
                mockRsvpIds[0]
            ], 'pending', undefined);
        });
    });
    describe('Validation Errors', ()=>{
        it('should return 400 when rsvpIds is empty array', async ()=>{
            // Arrange
            const request = new Request('http://localhost:3000/api/admin/rsvps/bulk', {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    rsvpIds: [],
                    status: 'attending'
                })
            });
            // Act
            const response = await (0, _route.PATCH)(request);
            const data = await response.json();
            // Assert
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('VALIDATION_ERROR');
            expect(data.error.message).toBe('Invalid request data');
            expect(_rsvpManagementService.bulkUpdateRSVPs).not.toHaveBeenCalled();
        });
        it('should return 400 when rsvpIds exceeds 100 items', async ()=>{
            // Arrange
            const tooManyIds = Array.from({
                length: 101
            }, (_, i)=>`${String(i).padStart(8, '0')}-1111-1111-1111-111111111111`);
            const request = new Request('http://localhost:3000/api/admin/rsvps/bulk', {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    rsvpIds: tooManyIds,
                    status: 'attending'
                })
            });
            // Act
            const response = await (0, _route.PATCH)(request);
            const data = await response.json();
            // Assert
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('VALIDATION_ERROR');
            expect(_rsvpManagementService.bulkUpdateRSVPs).not.toHaveBeenCalled();
        });
        it('should return 400 when rsvpIds contains invalid UUID', async ()=>{
            // Arrange
            const request = new Request('http://localhost:3000/api/admin/rsvps/bulk', {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    rsvpIds: [
                        'invalid-uuid',
                        mockRsvpIds[0]
                    ],
                    status: 'attending'
                })
            });
            // Act
            const response = await (0, _route.PATCH)(request);
            const data = await response.json();
            // Assert
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('VALIDATION_ERROR');
            expect(_rsvpManagementService.bulkUpdateRSVPs).not.toHaveBeenCalled();
        });
        it('should return 400 when status is missing', async ()=>{
            // Arrange
            const request = new Request('http://localhost:3000/api/admin/rsvps/bulk', {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    rsvpIds: mockRsvpIds
                })
            });
            // Act
            const response = await (0, _route.PATCH)(request);
            const data = await response.json();
            // Assert
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('VALIDATION_ERROR');
            expect(_rsvpManagementService.bulkUpdateRSVPs).not.toHaveBeenCalled();
        });
        it('should return 400 when status is invalid', async ()=>{
            // Arrange
            const request = new Request('http://localhost:3000/api/admin/rsvps/bulk', {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    rsvpIds: mockRsvpIds,
                    status: 'invalid-status'
                })
            });
            // Act
            const response = await (0, _route.PATCH)(request);
            const data = await response.json();
            // Assert
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('VALIDATION_ERROR');
            expect(_rsvpManagementService.bulkUpdateRSVPs).not.toHaveBeenCalled();
        });
        it('should return 400 when notes exceeds 1000 characters', async ()=>{
            // Arrange
            const longNotes = 'a'.repeat(1001);
            const request = new Request('http://localhost:3000/api/admin/rsvps/bulk', {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    rsvpIds: mockRsvpIds,
                    status: 'attending',
                    notes: longNotes
                })
            });
            // Act
            const response = await (0, _route.PATCH)(request);
            const data = await response.json();
            // Assert
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('VALIDATION_ERROR');
            expect(_rsvpManagementService.bulkUpdateRSVPs).not.toHaveBeenCalled();
        });
        it('should return 400 when rsvpIds is missing', async ()=>{
            // Arrange
            const request = new Request('http://localhost:3000/api/admin/rsvps/bulk', {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    status: 'attending'
                })
            });
            // Act
            const response = await (0, _route.PATCH)(request);
            const data = await response.json();
            // Assert
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('VALIDATION_ERROR');
            expect(_rsvpManagementService.bulkUpdateRSVPs).not.toHaveBeenCalled();
        });
    });
    describe('Authentication Errors', ()=>{
        it('should return 401 when not authenticated', async ()=>{
            // Arrange
            _apiHelpers.withAuth.mockImplementation(async (handler)=>{
                return new Response(JSON.stringify({
                    success: false,
                    error: {
                        code: 'UNAUTHORIZED',
                        message: 'Authentication required'
                    }
                }), {
                    status: 401
                });
            });
            const request = new Request('http://localhost:3000/api/admin/rsvps/bulk', {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    rsvpIds: mockRsvpIds,
                    status: 'attending'
                })
            });
            // Act
            const response = await (0, _route.PATCH)(request);
            const data = await response.json();
            // Assert
            expect(response.status).toBe(401);
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('UNAUTHORIZED');
            expect(_rsvpManagementService.bulkUpdateRSVPs).not.toHaveBeenCalled();
        });
    });
    describe('Service Errors', ()=>{
        it('should return 500 when service returns DATABASE_ERROR', async ()=>{
            // Arrange
            const mockServiceResponse = {
                success: false,
                error: {
                    code: 'DATABASE_ERROR',
                    message: 'Database connection failed',
                    details: {
                        dbError: 'Connection timeout'
                    }
                }
            };
            _rsvpManagementService.bulkUpdateRSVPs.mockResolvedValue(mockServiceResponse);
            const request = new Request('http://localhost:3000/api/admin/rsvps/bulk', {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    rsvpIds: mockRsvpIds,
                    status: 'attending'
                })
            });
            // Act
            const response = await (0, _route.PATCH)(request);
            const data = await response.json();
            // Assert
            expect(response.status).toBe(500);
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('DATABASE_ERROR');
            expect(data.error.message).toBe('Database connection failed');
        });
        it('should return 500 when service returns UNKNOWN_ERROR', async ()=>{
            // Arrange
            const mockServiceResponse = {
                success: false,
                error: {
                    code: 'UNKNOWN_ERROR',
                    message: 'Unexpected error occurred'
                }
            };
            _rsvpManagementService.bulkUpdateRSVPs.mockResolvedValue(mockServiceResponse);
            const request = new Request('http://localhost:3000/api/admin/rsvps/bulk', {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    rsvpIds: mockRsvpIds,
                    status: 'declined'
                })
            });
            // Act
            const response = await (0, _route.PATCH)(request);
            const data = await response.json();
            // Assert
            expect(response.status).toBe(500);
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('UNKNOWN_ERROR');
        });
        it('should return 500 when service throws unexpected error', async ()=>{
            // Arrange
            _rsvpManagementService.bulkUpdateRSVPs.mockRejectedValue(new Error('Unexpected service error'));
            const request = new Request('http://localhost:3000/api/admin/rsvps/bulk', {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    rsvpIds: mockRsvpIds,
                    status: 'attending'
                })
            });
            // Act
            const response = await (0, _route.PATCH)(request);
            const data = await response.json();
            // Assert
            expect(response.status).toBe(500);
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('INTERNAL_ERROR');
            expect(data.error.message).toBe('Failed to update RSVPs');
        });
    });
    describe('Edge Cases', ()=>{
        it('should handle single RSVP update', async ()=>{
            // Arrange
            const mockServiceResponse = {
                success: true,
                data: {
                    updatedCount: 1
                }
            };
            _rsvpManagementService.bulkUpdateRSVPs.mockResolvedValue(mockServiceResponse);
            const request = new Request('http://localhost:3000/api/admin/rsvps/bulk', {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    rsvpIds: [
                        mockRsvpIds[0]
                    ],
                    status: 'attending'
                })
            });
            // Act
            const response = await (0, _route.PATCH)(request);
            const data = await response.json();
            // Assert
            expect(response.status).toBe(200);
            expect(data.success).toBe(true);
            expect(data.data.updatedCount).toBe(1);
        });
        it('should handle maximum allowed RSVPs (100)', async ()=>{
            // Arrange
            const maxRsvpIds = Array.from({
                length: 100
            }, (_, i)=>`${String(i).padStart(8, '0')}-1111-1111-1111-111111111111`);
            const mockServiceResponse = {
                success: true,
                data: {
                    updatedCount: 100
                }
            };
            _rsvpManagementService.bulkUpdateRSVPs.mockResolvedValue(mockServiceResponse);
            const request = new Request('http://localhost:3000/api/admin/rsvps/bulk', {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    rsvpIds: maxRsvpIds,
                    status: 'attending'
                })
            });
            // Act
            const response = await (0, _route.PATCH)(request);
            const data = await response.json();
            // Assert
            expect(response.status).toBe(200);
            expect(data.success).toBe(true);
            expect(data.data.updatedCount).toBe(100);
        });
        it('should handle empty notes string', async ()=>{
            // Arrange
            const mockServiceResponse = {
                success: true,
                data: {
                    updatedCount: 2
                }
            };
            _rsvpManagementService.bulkUpdateRSVPs.mockResolvedValue(mockServiceResponse);
            const request = new Request('http://localhost:3000/api/admin/rsvps/bulk', {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    rsvpIds: mockRsvpIds.slice(0, 2),
                    status: 'maybe',
                    notes: ''
                })
            });
            // Act
            const response = await (0, _route.PATCH)(request);
            const data = await response.json();
            // Assert
            expect(response.status).toBe(200);
            expect(data.success).toBe(true);
            expect(_rsvpManagementService.bulkUpdateRSVPs).toHaveBeenCalledWith(mockRsvpIds.slice(0, 2), 'maybe', '');
        });
        it('should handle notes at maximum length (1000 characters)', async ()=>{
            // Arrange
            const maxLengthNotes = 'a'.repeat(1000);
            const mockServiceResponse = {
                success: true,
                data: {
                    updatedCount: 1
                }
            };
            _rsvpManagementService.bulkUpdateRSVPs.mockResolvedValue(mockServiceResponse);
            const request = new Request('http://localhost:3000/api/admin/rsvps/bulk', {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    rsvpIds: [
                        mockRsvpIds[0]
                    ],
                    status: 'attending',
                    notes: maxLengthNotes
                })
            });
            // Act
            const response = await (0, _route.PATCH)(request);
            const data = await response.json();
            // Assert
            expect(response.status).toBe(200);
            expect(data.success).toBe(true);
            expect(_rsvpManagementService.bulkUpdateRSVPs).toHaveBeenCalledWith([
                mockRsvpIds[0]
            ], 'attending', maxLengthNotes);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvYXBwL2FwaS9hZG1pbi9yc3Zwcy9idWxrL3JvdXRlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUEFUQ0ggfSBmcm9tICcuL3JvdXRlJztcbmltcG9ydCAqIGFzIHJzdnBNYW5hZ2VtZW50U2VydmljZSBmcm9tICdAL3NlcnZpY2VzL3JzdnBNYW5hZ2VtZW50U2VydmljZSc7XG5pbXBvcnQgKiBhcyBhcGlIZWxwZXJzIGZyb20gJ0AvbGliL2FwaUhlbHBlcnMnO1xuXG4vLyBNb2NrIGRlcGVuZGVuY2llc1xuamVzdC5tb2NrKCdAL3NlcnZpY2VzL3JzdnBNYW5hZ2VtZW50U2VydmljZScpO1xuamVzdC5tb2NrKCdAL2xpYi9hcGlIZWxwZXJzJywgKCkgPT4gKHtcbiAgLi4uamVzdC5yZXF1aXJlQWN0dWFsKCdAL2xpYi9hcGlIZWxwZXJzJyksXG4gIHdpdGhBdXRoOiBqZXN0LmZuKCksXG59KSk7XG5cbmRlc2NyaWJlKCdQQVRDSCAvYXBpL2FkbWluL3JzdnBzL2J1bGsnLCAoKSA9PiB7XG4gIGNvbnN0IG1vY2tVc2VySWQgPSAndXNlci0xMjMnO1xuICBjb25zdCBtb2NrUnN2cElkcyA9IFtcbiAgICAnMTExMTExMTEtMTExMS0xMTExLTExMTEtMTExMTExMTExMTExJyxcbiAgICAnMjIyMjIyMjItMjIyMi0yMjIyLTIyMjItMjIyMjIyMjIyMjIyJyxcbiAgICAnMzMzMzMzMzMtMzMzMy0zMzMzLTMzMzMtMzMzMzMzMzMzMzMzJyxcbiAgXTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcblxuICAgIC8vIE1vY2sgd2l0aEF1dGggdG8gY2FsbCB0aGUgaGFuZGxlciB3aXRoIG1vY2tVc2VySWRcbiAgICAoYXBpSGVscGVycy53aXRoQXV0aCBhcyBqZXN0Lk1vY2spLm1vY2tJbXBsZW1lbnRhdGlvbihcbiAgICAgIGFzeW5jIChoYW5kbGVyOiAodXNlcklkOiBzdHJpbmcpID0+IFByb21pc2U8UmVzcG9uc2U+KSA9PiB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyKG1vY2tVc2VySWQpO1xuICAgICAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTdWNjZXNzIENhc2VzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdXBkYXRlIFJTVlBzIGFuZCByZXR1cm4gMjAwIHdoZW4gdmFsaWQgZGF0YSBwcm92aWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IG1vY2tTZXJ2aWNlUmVzcG9uc2UgPSB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHsgdXBkYXRlZENvdW50OiAzIH0sXG4gICAgICB9O1xuICAgICAgKHJzdnBNYW5hZ2VtZW50U2VydmljZS5idWxrVXBkYXRlUlNWUHMgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU2VydmljZVJlc3BvbnNlKTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL3JzdnBzL2J1bGsnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICByc3ZwSWRzOiBtb2NrUnN2cElkcyxcbiAgICAgICAgICBzdGF0dXM6ICdhdHRlbmRpbmcnLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUEFUQ0gocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoZGF0YS5kYXRhLnVwZGF0ZWRDb3VudCkudG9CZSgzKTtcbiAgICAgIGV4cGVjdChyc3ZwTWFuYWdlbWVudFNlcnZpY2UuYnVsa1VwZGF0ZVJTVlBzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgbW9ja1JzdnBJZHMsXG4gICAgICAgICdhdHRlbmRpbmcnLFxuICAgICAgICB1bmRlZmluZWRcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHVwZGF0ZSBSU1ZQcyB3aXRoIG5vdGVzIHdoZW4gbm90ZXMgcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBtb2NrU2VydmljZVJlc3BvbnNlID0ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7IHVwZGF0ZWRDb3VudDogMiB9LFxuICAgICAgfTtcbiAgICAgIChyc3ZwTWFuYWdlbWVudFNlcnZpY2UuYnVsa1VwZGF0ZVJTVlBzIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUobW9ja1NlcnZpY2VSZXNwb25zZSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9yc3Zwcy9idWxrJywge1xuICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcnN2cElkczogbW9ja1JzdnBJZHMuc2xpY2UoMCwgMiksXG4gICAgICAgICAgc3RhdHVzOiAnZGVjbGluZWQnLFxuICAgICAgICAgIG5vdGVzOiAnQnVsayBkZWNsaW5lZCBieSBhZG1pbicsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQQVRDSChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChkYXRhLmRhdGEudXBkYXRlZENvdW50KS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHJzdnBNYW5hZ2VtZW50U2VydmljZS5idWxrVXBkYXRlUlNWUHMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBtb2NrUnN2cElkcy5zbGljZSgwLCAyKSxcbiAgICAgICAgJ2RlY2xpbmVkJyxcbiAgICAgICAgJ0J1bGsgZGVjbGluZWQgYnkgYWRtaW4nXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcGFydGlhbCBzdWNjZXNzIHdoZW4gc29tZSBSU1ZQcyBub3QgZm91bmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBtb2NrU2VydmljZVJlc3BvbnNlID0ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7IHVwZGF0ZWRDb3VudDogMiB9LCAvLyBPbmx5IDIgb2YgMyB1cGRhdGVkXG4gICAgICB9O1xuICAgICAgKHJzdnBNYW5hZ2VtZW50U2VydmljZS5idWxrVXBkYXRlUlNWUHMgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU2VydmljZVJlc3BvbnNlKTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL3JzdnBzL2J1bGsnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICByc3ZwSWRzOiBtb2NrUnN2cElkcyxcbiAgICAgICAgICBzdGF0dXM6ICdtYXliZScsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQQVRDSChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChkYXRhLmRhdGEudXBkYXRlZENvdW50KS50b0JlKDIpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB1cGRhdGUgUlNWUHMgdG8gcGVuZGluZyBzdGF0dXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBtb2NrU2VydmljZVJlc3BvbnNlID0ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7IHVwZGF0ZWRDb3VudDogMSB9LFxuICAgICAgfTtcbiAgICAgIChyc3ZwTWFuYWdlbWVudFNlcnZpY2UuYnVsa1VwZGF0ZVJTVlBzIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUobW9ja1NlcnZpY2VSZXNwb25zZSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9yc3Zwcy9idWxrJywge1xuICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcnN2cElkczogW21vY2tSc3ZwSWRzWzBdXSxcbiAgICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBBVENIKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGRhdGEuZGF0YS51cGRhdGVkQ291bnQpLnRvQmUoMSk7XG4gICAgICBleHBlY3QocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmJ1bGtVcGRhdGVSU1ZQcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFttb2NrUnN2cElkc1swXV0sXG4gICAgICAgICdwZW5kaW5nJyxcbiAgICAgICAgdW5kZWZpbmVkXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnVmFsaWRhdGlvbiBFcnJvcnMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAwIHdoZW4gcnN2cElkcyBpcyBlbXB0eSBhcnJheScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9yc3Zwcy9idWxrJywge1xuICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcnN2cElkczogW10sXG4gICAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBBVENIKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yLmNvZGUpLnRvQmUoJ1ZBTElEQVRJT05fRVJST1InKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yLm1lc3NhZ2UpLnRvQmUoJ0ludmFsaWQgcmVxdWVzdCBkYXRhJyk7XG4gICAgICBleHBlY3QocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmJ1bGtVcGRhdGVSU1ZQcykubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMCB3aGVuIHJzdnBJZHMgZXhjZWVkcyAxMDAgaXRlbXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB0b29NYW55SWRzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAxIH0sIChfLCBpKSA9PiBcbiAgICAgICAgYCR7U3RyaW5nKGkpLnBhZFN0YXJ0KDgsICcwJyl9LTExMTEtMTExMS0xMTExLTExMTExMTExMTExMWBcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9yc3Zwcy9idWxrJywge1xuICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcnN2cElkczogdG9vTWFueUlkcyxcbiAgICAgICAgICBzdGF0dXM6ICdhdHRlbmRpbmcnLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUEFUQ0gocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IuY29kZSkudG9CZSgnVkFMSURBVElPTl9FUlJPUicpO1xuICAgICAgZXhwZWN0KHJzdnBNYW5hZ2VtZW50U2VydmljZS5idWxrVXBkYXRlUlNWUHMpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiA0MDAgd2hlbiByc3ZwSWRzIGNvbnRhaW5zIGludmFsaWQgVVVJRCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9yc3Zwcy9idWxrJywge1xuICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcnN2cElkczogWydpbnZhbGlkLXV1aWQnLCBtb2NrUnN2cElkc1swXV0sXG4gICAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBBVENIKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yLmNvZGUpLnRvQmUoJ1ZBTElEQVRJT05fRVJST1InKTtcbiAgICAgIGV4cGVjdChyc3ZwTWFuYWdlbWVudFNlcnZpY2UuYnVsa1VwZGF0ZVJTVlBzKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAwIHdoZW4gc3RhdHVzIGlzIG1pc3NpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vcnN2cHMvYnVsaycsIHtcbiAgICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHJzdnBJZHM6IG1vY2tSc3ZwSWRzLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUEFUQ0gocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IuY29kZSkudG9CZSgnVkFMSURBVElPTl9FUlJPUicpO1xuICAgICAgZXhwZWN0KHJzdnBNYW5hZ2VtZW50U2VydmljZS5idWxrVXBkYXRlUlNWUHMpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiA0MDAgd2hlbiBzdGF0dXMgaXMgaW52YWxpZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9yc3Zwcy9idWxrJywge1xuICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcnN2cElkczogbW9ja1JzdnBJZHMsXG4gICAgICAgICAgc3RhdHVzOiAnaW52YWxpZC1zdGF0dXMnLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUEFUQ0gocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IuY29kZSkudG9CZSgnVkFMSURBVElPTl9FUlJPUicpO1xuICAgICAgZXhwZWN0KHJzdnBNYW5hZ2VtZW50U2VydmljZS5idWxrVXBkYXRlUlNWUHMpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiA0MDAgd2hlbiBub3RlcyBleGNlZWRzIDEwMDAgY2hhcmFjdGVycycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGxvbmdOb3RlcyA9ICdhJy5yZXBlYXQoMTAwMSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9yc3Zwcy9idWxrJywge1xuICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcnN2cElkczogbW9ja1JzdnBJZHMsXG4gICAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyxcbiAgICAgICAgICBub3RlczogbG9uZ05vdGVzLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUEFUQ0gocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IuY29kZSkudG9CZSgnVkFMSURBVElPTl9FUlJPUicpO1xuICAgICAgZXhwZWN0KHJzdnBNYW5hZ2VtZW50U2VydmljZS5idWxrVXBkYXRlUlNWUHMpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiA0MDAgd2hlbiByc3ZwSWRzIGlzIG1pc3NpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vcnN2cHMvYnVsaycsIHtcbiAgICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHN0YXR1czogJ2F0dGVuZGluZycsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQQVRDSChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5jb2RlKS50b0JlKCdWQUxJREFUSU9OX0VSUk9SJyk7XG4gICAgICBleHBlY3QocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmJ1bGtVcGRhdGVSU1ZQcykubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0F1dGhlbnRpY2F0aW9uIEVycm9ycycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiA0MDEgd2hlbiBub3QgYXV0aGVudGljYXRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIChhcGlIZWxwZXJzLndpdGhBdXRoIGFzIGplc3QuTW9jaykubW9ja0ltcGxlbWVudGF0aW9uKFxuICAgICAgICBhc3luYyAoaGFuZGxlcjogKHVzZXJJZDogc3RyaW5nKSA9PiBQcm9taXNlPFJlc3BvbnNlPikgPT4ge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBlcnJvcjogeyBjb2RlOiAnVU5BVVRIT1JJWkVEJywgbWVzc2FnZTogJ0F1dGhlbnRpY2F0aW9uIHJlcXVpcmVkJyB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB7IHN0YXR1czogNDAxIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vcnN2cHMvYnVsaycsIHtcbiAgICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHJzdnBJZHM6IG1vY2tSc3ZwSWRzLFxuICAgICAgICAgIHN0YXR1czogJ2F0dGVuZGluZycsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQQVRDSChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDEpO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5jb2RlKS50b0JlKCdVTkFVVEhPUklaRUQnKTtcbiAgICAgIGV4cGVjdChyc3ZwTWFuYWdlbWVudFNlcnZpY2UuYnVsa1VwZGF0ZVJTVlBzKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2VydmljZSBFcnJvcnMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gNTAwIHdoZW4gc2VydmljZSByZXR1cm5zIERBVEFCQVNFX0VSUk9SJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgbW9ja1NlcnZpY2VSZXNwb25zZSA9IHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgY29kZTogJ0RBVEFCQVNFX0VSUk9SJyxcbiAgICAgICAgICBtZXNzYWdlOiAnRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnLFxuICAgICAgICAgIGRldGFpbHM6IHsgZGJFcnJvcjogJ0Nvbm5lY3Rpb24gdGltZW91dCcgfSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICAocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmJ1bGtVcGRhdGVSU1ZQcyBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTZXJ2aWNlUmVzcG9uc2UpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vcnN2cHMvYnVsaycsIHtcbiAgICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHJzdnBJZHM6IG1vY2tSc3ZwSWRzLFxuICAgICAgICAgIHN0YXR1czogJ2F0dGVuZGluZycsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQQVRDSChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg1MDApO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5jb2RlKS50b0JlKCdEQVRBQkFTRV9FUlJPUicpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IubWVzc2FnZSkudG9CZSgnRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIDUwMCB3aGVuIHNlcnZpY2UgcmV0dXJucyBVTktOT1dOX0VSUk9SJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgbW9ja1NlcnZpY2VSZXNwb25zZSA9IHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgY29kZTogJ1VOS05PV05fRVJST1InLFxuICAgICAgICAgIG1lc3NhZ2U6ICdVbmV4cGVjdGVkIGVycm9yIG9jY3VycmVkJyxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICAocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmJ1bGtVcGRhdGVSU1ZQcyBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTZXJ2aWNlUmVzcG9uc2UpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vcnN2cHMvYnVsaycsIHtcbiAgICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHJzdnBJZHM6IG1vY2tSc3ZwSWRzLFxuICAgICAgICAgIHN0YXR1czogJ2RlY2xpbmVkJyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBBVENIKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDUwMCk7XG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yLmNvZGUpLnRvQmUoJ1VOS05PV05fRVJST1InKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIDUwMCB3aGVuIHNlcnZpY2UgdGhyb3dzIHVuZXhwZWN0ZWQgZXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICAocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmJ1bGtVcGRhdGVSU1ZQcyBhcyBqZXN0Lk1vY2spLm1vY2tSZWplY3RlZFZhbHVlKFxuICAgICAgICBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc2VydmljZSBlcnJvcicpXG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vcnN2cHMvYnVsaycsIHtcbiAgICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHJzdnBJZHM6IG1vY2tSc3ZwSWRzLFxuICAgICAgICAgIHN0YXR1czogJ2F0dGVuZGluZycsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQQVRDSChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg1MDApO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5jb2RlKS50b0JlKCdJTlRFUk5BTF9FUlJPUicpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IubWVzc2FnZSkudG9CZSgnRmFpbGVkIHRvIHVwZGF0ZSBSU1ZQcycpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRWRnZSBDYXNlcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBzaW5nbGUgUlNWUCB1cGRhdGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBtb2NrU2VydmljZVJlc3BvbnNlID0ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7IHVwZGF0ZWRDb3VudDogMSB9LFxuICAgICAgfTtcbiAgICAgIChyc3ZwTWFuYWdlbWVudFNlcnZpY2UuYnVsa1VwZGF0ZVJTVlBzIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUobW9ja1NlcnZpY2VSZXNwb25zZSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9yc3Zwcy9idWxrJywge1xuICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcnN2cElkczogW21vY2tSc3ZwSWRzWzBdXSxcbiAgICAgICAgICBzdGF0dXM6ICdhdHRlbmRpbmcnLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUEFUQ0gocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoZGF0YS5kYXRhLnVwZGF0ZWRDb3VudCkudG9CZSgxKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG1heGltdW0gYWxsb3dlZCBSU1ZQcyAoMTAwKScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IG1heFJzdnBJZHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAgfSwgKF8sIGkpID0+IFxuICAgICAgICBgJHtTdHJpbmcoaSkucGFkU3RhcnQoOCwgJzAnKX0tMTExMS0xMTExLTExMTEtMTExMTExMTExMTExYFxuICAgICAgKTtcbiAgICAgIGNvbnN0IG1vY2tTZXJ2aWNlUmVzcG9uc2UgPSB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHsgdXBkYXRlZENvdW50OiAxMDAgfSxcbiAgICAgIH07XG4gICAgICAocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmJ1bGtVcGRhdGVSU1ZQcyBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTZXJ2aWNlUmVzcG9uc2UpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vcnN2cHMvYnVsaycsIHtcbiAgICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHJzdnBJZHM6IG1heFJzdnBJZHMsXG4gICAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBBVENIKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGRhdGEuZGF0YS51cGRhdGVkQ291bnQpLnRvQmUoMTAwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVtcHR5IG5vdGVzIHN0cmluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IG1vY2tTZXJ2aWNlUmVzcG9uc2UgPSB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHsgdXBkYXRlZENvdW50OiAyIH0sXG4gICAgICB9O1xuICAgICAgKHJzdnBNYW5hZ2VtZW50U2VydmljZS5idWxrVXBkYXRlUlNWUHMgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU2VydmljZVJlc3BvbnNlKTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL3JzdnBzL2J1bGsnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICByc3ZwSWRzOiBtb2NrUnN2cElkcy5zbGljZSgwLCAyKSxcbiAgICAgICAgICBzdGF0dXM6ICdtYXliZScsXG4gICAgICAgICAgbm90ZXM6ICcnLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUEFUQ0gocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmJ1bGtVcGRhdGVSU1ZQcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIG1vY2tSc3ZwSWRzLnNsaWNlKDAsIDIpLFxuICAgICAgICAnbWF5YmUnLFxuICAgICAgICAnJ1xuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG5vdGVzIGF0IG1heGltdW0gbGVuZ3RoICgxMDAwIGNoYXJhY3RlcnMpJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgbWF4TGVuZ3RoTm90ZXMgPSAnYScucmVwZWF0KDEwMDApO1xuICAgICAgY29uc3QgbW9ja1NlcnZpY2VSZXNwb25zZSA9IHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YTogeyB1cGRhdGVkQ291bnQ6IDEgfSxcbiAgICAgIH07XG4gICAgICAocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmJ1bGtVcGRhdGVSU1ZQcyBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTZXJ2aWNlUmVzcG9uc2UpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vcnN2cHMvYnVsaycsIHtcbiAgICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHJzdnBJZHM6IFttb2NrUnN2cElkc1swXV0sXG4gICAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyxcbiAgICAgICAgICBub3RlczogbWF4TGVuZ3RoTm90ZXMsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQQVRDSChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyc3ZwTWFuYWdlbWVudFNlcnZpY2UuYnVsa1VwZGF0ZVJTVlBzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgW21vY2tSc3ZwSWRzWzBdXSxcbiAgICAgICAgJ2F0dGVuZGluZycsXG4gICAgICAgIG1heExlbmd0aE5vdGVzXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwicmVxdWlyZUFjdHVhbCIsIndpdGhBdXRoIiwiZm4iLCJkZXNjcmliZSIsIm1vY2tVc2VySWQiLCJtb2NrUnN2cElkcyIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiYXBpSGVscGVycyIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsImhhbmRsZXIiLCJpdCIsIm1vY2tTZXJ2aWNlUmVzcG9uc2UiLCJzdWNjZXNzIiwiZGF0YSIsInVwZGF0ZWRDb3VudCIsInJzdnBNYW5hZ2VtZW50U2VydmljZSIsImJ1bGtVcGRhdGVSU1ZQcyIsIm1vY2tSZXNvbHZlZFZhbHVlIiwicmVxdWVzdCIsIlJlcXVlc3QiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJyc3ZwSWRzIiwic3RhdHVzIiwicmVzcG9uc2UiLCJQQVRDSCIsImpzb24iLCJleHBlY3QiLCJ0b0JlIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJ1bmRlZmluZWQiLCJzbGljZSIsIm5vdGVzIiwiZXJyb3IiLCJjb2RlIiwibWVzc2FnZSIsIm5vdCIsInRvSGF2ZUJlZW5DYWxsZWQiLCJ0b29NYW55SWRzIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJTdHJpbmciLCJwYWRTdGFydCIsImxvbmdOb3RlcyIsInJlcGVhdCIsIlJlc3BvbnNlIiwiZGV0YWlscyIsImRiRXJyb3IiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIkVycm9yIiwibWF4UnN2cElkcyIsIm1heExlbmd0aE5vdGVzIl0sIm1hcHBpbmdzIjoiO0FBSUEsb0JBQW9CO0FBQ3BCQSxLQUFLQyxJQUFJLENBQUM7QUFDVkQsS0FBS0MsSUFBSSxDQUFDLG9CQUFvQixJQUFPLENBQUE7UUFDbkMsR0FBR0QsS0FBS0UsYUFBYSxDQUFDLG1CQUFtQjtRQUN6Q0MsVUFBVUgsS0FBS0ksRUFBRTtJQUNuQixDQUFBOzs7O3VCQVRzQjsrRUFDaUI7b0VBQ1g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVM1QkMsU0FBUywrQkFBK0I7SUFDdEMsTUFBTUMsYUFBYTtJQUNuQixNQUFNQyxjQUFjO1FBQ2xCO1FBQ0E7UUFDQTtLQUNEO0lBRURDLFdBQVc7UUFDVFIsS0FBS1MsYUFBYTtRQUVsQixvREFBb0Q7UUFDbkRDLFlBQVdQLFFBQVEsQ0FBZVEsa0JBQWtCLENBQ25ELE9BQU9DO1lBQ0wsT0FBT0EsUUFBUU47UUFDakI7SUFFSjtJQUVBRCxTQUFTLGlCQUFpQjtRQUN4QlEsR0FBRywrREFBK0Q7WUFDaEUsVUFBVTtZQUNWLE1BQU1DLHNCQUFzQjtnQkFDMUJDLFNBQVM7Z0JBQ1RDLE1BQU07b0JBQUVDLGNBQWM7Z0JBQUU7WUFDMUI7WUFDQ0MsdUJBQXNCQyxlQUFlLENBQWVDLGlCQUFpQixDQUFDTjtZQUV2RSxNQUFNTyxVQUFVLElBQUlDLFFBQVEsOENBQThDO2dCQUN4RUMsUUFBUTtnQkFDUkMsU0FBUztvQkFBRSxnQkFBZ0I7Z0JBQW1CO2dCQUM5Q0MsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO29CQUNuQkMsU0FBU3JCO29C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