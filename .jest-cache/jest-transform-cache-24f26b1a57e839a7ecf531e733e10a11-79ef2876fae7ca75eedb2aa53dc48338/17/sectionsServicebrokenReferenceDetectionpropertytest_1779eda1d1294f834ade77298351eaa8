c1f470c4c6cff828f308cae6f431da78
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _globals = require("@jest/globals");
const _sectionsService = require("./sectionsService");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Mock Supabase before importing services
const mockFrom = _globals.jest.fn();
const mockSupabase = {
    from: mockFrom
};
_globals.jest.mock('../lib/supabase', ()=>({
        supabase: mockSupabase
    }));
// Helper to create properly typed mock chain
function createMockQueryChain(resolvedValue) {
    const mockSingle = _globals.jest.fn().mockResolvedValue(resolvedValue);
    const mockEq = _globals.jest.fn().mockReturnValue({
        single: mockSingle
    });
    const mockSelect = _globals.jest.fn().mockReturnValue({
        eq: mockEq
    });
    return {
        select: mockSelect
    };
}
/**
 * Property 6: Broken Reference Detection
 * 
 * For any reference link that points to a deleted entity, the system SHALL mark it 
 * as broken and display a warning to the admin.
 * 
 * This property verifies that:
 * 1. References to non-existent entities are detected as broken
 * 2. The system correctly identifies which specific references are broken
 * 3. Validation fails when any reference is broken
 * 4. All broken references are included in the response
 * 
 * Validates: Requirements 2.10
 */ (0, _globals.describe)('Feature: admin-backend-integration-cms, Property 6: Broken Reference Detection', ()=>{
    (0, _globals.beforeEach)(()=>{
        _globals.jest.clearAllMocks();
    });
    (0, _globals.it)('should mark references to deleted entities as broken', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.array(_fastcheck.record({
            type: _fastcheck.constantFrom('event', 'activity', 'accommodation', 'location'),
            id: _fastcheck.uuid(),
            label: _fastcheck.option(_fastcheck.string({
                minLength: 1,
                maxLength: 100
            })),
            isDeleted: _fastcheck.boolean()
        }), {
            minLength: 1,
            maxLength: 20
        }), async (testReferences)=>{
            // Mock database lookups - deleted entities return null
            for (const ref of testReferences){
                mockFrom.mockReturnValueOnce(createMockQueryChain({
                    data: ref.isDeleted ? null : {
                        id: ref.id
                    },
                    error: ref.isDeleted ? {
                        code: 'PGRST116',
                        message: 'Not found'
                    } : null
                }));
            }
            const references = testReferences.map((r)=>({
                    type: r.type,
                    id: r.id,
                    label: r.label || undefined
                }));
            const result = await (0, _sectionsService.validateReferences)(references);
            // Property: Validation operation should always succeed
            (0, _globals.expect)(result.success).toBe(true);
            if (!result.success) {
                return true;
            }
            // Property: All deleted entities should be marked as broken
            const deletedRefs = testReferences.filter((r)=>r.isDeleted);
            (0, _globals.expect)(result.data.brokenReferences.length).toBe(deletedRefs.length);
            // Property: Each broken reference should correspond to a deleted entity
            for (const broken of result.data.brokenReferences){
                const original = testReferences.find((r)=>r.id === broken.id && r.type === broken.type);
                (0, _globals.expect)(original).toBeDefined();
                (0, _globals.expect)(original?.isDeleted).toBe(true);
            }
            // Property: Validation is valid only when no entities are deleted
            const hasDeletedEntities = testReferences.some((r)=>r.isDeleted);
            (0, _globals.expect)(result.data.valid).toBe(!hasDeletedEntities);
            return true;
        }), {
            numRuns: 100
        });
    });
    (0, _globals.it)('should detect broken references when entities are deleted after reference creation', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
            existingRefs: _fastcheck.array(_fastcheck.record({
                type: _fastcheck.constantFrom('event', 'activity', 'accommodation', 'location'),
                id: _fastcheck.uuid(),
                label: _fastcheck.option(_fastcheck.string({
                    minLength: 1,
                    maxLength: 100
                }))
            }), {
                minLength: 0,
                maxLength: 5
            }),
            deletedRefs: _fastcheck.array(_fastcheck.record({
                type: _fastcheck.constantFrom('event', 'activity', 'accommodation', 'location'),
                id: _fastcheck.uuid(),
                label: _fastcheck.option(_fastcheck.string({
                    minLength: 1,
                    maxLength: 100
                }))
            }), {
                minLength: 1,
                maxLength: 5
            })
        }), async (testData)=>{
            // Mock existing references as still in database
            for (const ref of testData.existingRefs){
                mockFrom.mockReturnValueOnce(createMockQueryChain({
                    data: {
                        id: ref.id
                    },
                    error: null
                }));
            }
            // Mock deleted references as no longer in database
            for (const ref of testData.deletedRefs){
                mockFrom.mockReturnValueOnce(createMockQueryChain({
                    data: null,
                    error: {
                        code: 'PGRST116',
                        message: 'Not found'
                    }
                }));
            }
            const references = [
                ...testData.existingRefs.map((r)=>({
                        type: r.type,
                        id: r.id,
                        label: r.label || undefined
                    })),
                ...testData.deletedRefs.map((r)=>({
                        type: r.type,
                        id: r.id,
                        label: r.label || undefined
                    }))
            ];
            const result = await (0, _sectionsService.validateReferences)(references);
            // Property: Validation should succeed
            (0, _globals.expect)(result.success).toBe(true);
            if (!result.success) {
                return true;
            }
            // Property: Should be invalid when any reference points to deleted entity
            (0, _globals.expect)(result.data.valid).toBe(false);
            (0, _globals.expect)(result.data.brokenReferences.length).toBe(testData.deletedRefs.length);
            // Property: All deleted references should be identified as broken
            for (const deletedRef of testData.deletedRefs){
                const found = result.data.brokenReferences.find((r)=>r.id === deletedRef.id && r.type === deletedRef.type);
                (0, _globals.expect)(found).toBeDefined();
                (0, _globals.expect)(found?.type).toBe(deletedRef.type);
                (0, _globals.expect)(found?.id).toBe(deletedRef.id);
            }
            // Property: No existing references should be marked as broken
            for (const existingRef of testData.existingRefs){
                const found = result.data.brokenReferences.find((r)=>r.id === existingRef.id && r.type === existingRef.type);
                (0, _globals.expect)(found).toBeUndefined();
            }
            return true;
        }), {
            numRuns: 50
        });
    });
    (0, _globals.it)('should correctly identify broken references across different entity types', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.constantFrom('event', 'activity', 'accommodation', 'location'), _fastcheck.uuid(), _fastcheck.option(_fastcheck.string({
            minLength: 1,
            maxLength: 100
        })), _fastcheck.boolean(), async (type, id, label, isDeleted)=>{
            // Mock database lookup
            mockFrom.mockReturnValueOnce(createMockQueryChain({
                data: isDeleted ? null : {
                    id
                },
                error: isDeleted ? {
                    code: 'PGRST116',
                    message: 'Not found'
                } : null
            }));
            const references = [
                {
                    type,
                    id,
                    label: label || undefined
                }
            ];
            const result = await (0, _sectionsService.validateReferences)(references);
            // Property: Validation should succeed
            (0, _globals.expect)(result.success).toBe(true);
            if (!result.success) {
                return true;
            }
            // Property: Deleted entity should be marked as broken
            if (isDeleted) {
                (0, _globals.expect)(result.data.valid).toBe(false);
                (0, _globals.expect)(result.data.brokenReferences).toHaveLength(1);
                (0, _globals.expect)(result.data.brokenReferences[0].type).toBe(type);
                (0, _globals.expect)(result.data.brokenReferences[0].id).toBe(id);
            } else {
                (0, _globals.expect)(result.data.valid).toBe(true);
                (0, _globals.expect)(result.data.brokenReferences).toHaveLength(0);
            }
            return true;
        }), {
            numRuns: 100
        });
    });
    (0, _globals.it)('should return empty broken references when all entities exist', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.array(_fastcheck.record({
            type: _fastcheck.constantFrom('event', 'activity', 'accommodation', 'location'),
            id: _fastcheck.uuid(),
            label: _fastcheck.option(_fastcheck.string({
                minLength: 1,
                maxLength: 100
            }))
        }), {
            minLength: 1,
            maxLength: 15
        }), async (testReferences)=>{
            // Mock all references as existing in database
            for (const ref of testReferences){
                mockFrom.mockReturnValueOnce(createMockQueryChain({
                    data: {
                        id: ref.id
                    },
                    error: null
                }));
            }
            const references = testReferences.map((r)=>({
                    type: r.type,
                    id: r.id,
                    label: r.label || undefined
                }));
            const result = await (0, _sectionsService.validateReferences)(references);
            // Property: Validation should succeed
            (0, _globals.expect)(result.success).toBe(true);
            if (!result.success) {
                return true;
            }
            // Property: No entities deleted, so no broken references
            (0, _globals.expect)(result.data.valid).toBe(true);
            (0, _globals.expect)(result.data.brokenReferences).toHaveLength(0);
            return true;
        }), {
            numRuns: 100
        });
    });
    (0, _globals.it)('should handle empty reference arrays without broken references', async ()=>{
        const result = await (0, _sectionsService.validateReferences)([]);
        // Property: Empty array should be valid with no broken references
        (0, _globals.expect)(result.success).toBe(true);
        if (result.success) {
            (0, _globals.expect)(result.data.valid).toBe(true);
            (0, _globals.expect)(result.data.brokenReferences).toHaveLength(0);
        }
    });
    (0, _globals.it)('should preserve reference metadata when marking as broken', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
            type: _fastcheck.constantFrom('event', 'activity', 'accommodation', 'location'),
            id: _fastcheck.uuid(),
            label: _fastcheck.string({
                minLength: 1,
                maxLength: 100
            })
        }), async (testRef)=>{
            // Mock as deleted entity
            mockFrom.mockReturnValueOnce(createMockQueryChain({
                data: null,
                error: {
                    code: 'PGRST116',
                    message: 'Not found'
                }
            }));
            const references = [
                {
                    type: testRef.type,
                    id: testRef.id,
                    label: testRef.label
                }
            ];
            const result = await (0, _sectionsService.validateReferences)(references);
            // Property: Validation should succeed
            (0, _globals.expect)(result.success).toBe(true);
            if (!result.success) {
                return true;
            }
            // Property: Broken reference should preserve all original metadata
            (0, _globals.expect)(result.data.brokenReferences).toHaveLength(1);
            const broken = result.data.brokenReferences[0];
            (0, _globals.expect)(broken.type).toBe(testRef.type);
            (0, _globals.expect)(broken.id).toBe(testRef.id);
            (0, _globals.expect)(broken.label).toBe(testRef.label);
            return true;
        }), {
            numRuns: 50
        });
    });
    (0, _globals.it)('should detect all broken references in a mixed set', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.integer({
            min: 0,
            max: 10
        }), _fastcheck.integer({
            min: 1,
            max: 10
        }), async (validCount, brokenCount)=>{
            const validRefs = Array.from({
                length: validCount
            }, (_, i)=>({
                    type: [
                        'event',
                        'activity',
                        'accommodation',
                        'location'
                    ][i % 4],
                    id: `valid-${i}`,
                    label: `Valid ${i}`
                }));
            const brokenRefs = Array.from({
                length: brokenCount
            }, (_, i)=>({
                    type: [
                        'event',
                        'activity',
                        'accommodation',
                        'location'
                    ][i % 4],
                    id: `broken-${i}`,
                    label: `Broken ${i}`
                }));
            // Mock valid references
            for (const ref of validRefs){
                mockFrom.mockReturnValueOnce(createMockQueryChain({
                    data: {
                        id: ref.id
                    },
                    error: null
                }));
            }
            // Mock broken references
            for (const ref of brokenRefs){
                mockFrom.mockReturnValueOnce(createMockQueryChain({
                    data: null,
                    error: {
                        code: 'PGRST116',
                        message: 'Not found'
                    }
                }));
            }
            const references = [
                ...validRefs,
                ...brokenRefs
            ];
            const result = await (0, _sectionsService.validateReferences)(references);
            // Property: Should detect exactly the broken references
            (0, _globals.expect)(result.success).toBe(true);
            if (!result.success) {
                return true;
            }
            (0, _globals.expect)(result.data.brokenReferences.length).toBe(brokenCount);
            (0, _globals.expect)(result.data.valid).toBe(brokenCount === 0);
            // Property: All broken IDs should be in the broken references list
            const brokenIds = new Set(brokenRefs.map((r)=>r.id));
            for (const broken of result.data.brokenReferences){
                (0, _globals.expect)(brokenIds.has(broken.id)).toBe(true);
            }
            return true;
        }), {
            numRuns: 50
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvc2VjdGlvbnNTZXJ2aWNlLmJyb2tlblJlZmVyZW5jZURldGVjdGlvbi5wcm9wZXJ0eS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGZjIGZyb20gJ2Zhc3QtY2hlY2snO1xuaW1wb3J0IHsgamVzdCwgZGVzY3JpYmUsIGl0LCBleHBlY3QsIGJlZm9yZUVhY2ggfSBmcm9tICdAamVzdC9nbG9iYWxzJztcblxuLy8gTW9jayBTdXBhYmFzZSBiZWZvcmUgaW1wb3J0aW5nIHNlcnZpY2VzXG5jb25zdCBtb2NrRnJvbSA9IGplc3QuZm4oKSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT47XG5jb25zdCBtb2NrU3VwYWJhc2UgPSB7XG4gIGZyb206IG1vY2tGcm9tLFxufTtcblxuamVzdC5tb2NrKCcuLi9saWIvc3VwYWJhc2UnLCAoKSA9PiAoe1xuICBzdXBhYmFzZTogbW9ja1N1cGFiYXNlLFxufSkpO1xuXG4vLyBJbXBvcnQgYWZ0ZXIgbW9ja2luZ1xuaW1wb3J0IHsgdmFsaWRhdGVSZWZlcmVuY2VzIH0gZnJvbSAnLi9zZWN0aW9uc1NlcnZpY2UnO1xuaW1wb3J0IHR5cGUgeyBSZWZlcmVuY2UgfSBmcm9tICcuLi9zY2hlbWFzL2Ntc1NjaGVtYXMnO1xuXG4vLyBIZWxwZXIgdG8gY3JlYXRlIHByb3Blcmx5IHR5cGVkIG1vY2sgY2hhaW5cbmZ1bmN0aW9uIGNyZWF0ZU1vY2tRdWVyeUNoYWluKHJlc29sdmVkVmFsdWU6IHsgZGF0YTogYW55OyBlcnJvcjogYW55IH0pIHtcbiAgY29uc3QgbW9ja1NpbmdsZSA9IChqZXN0LmZuKCkgYXMgYW55KS5tb2NrUmVzb2x2ZWRWYWx1ZShyZXNvbHZlZFZhbHVlKTtcbiAgY29uc3QgbW9ja0VxID0gKGplc3QuZm4oKSBhcyBhbnkpLm1vY2tSZXR1cm5WYWx1ZSh7IHNpbmdsZTogbW9ja1NpbmdsZSB9KTtcbiAgY29uc3QgbW9ja1NlbGVjdCA9IChqZXN0LmZuKCkgYXMgYW55KS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxIH0pO1xuICByZXR1cm4geyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSBhcyBhbnk7XG59XG5cbi8qKlxuICogUHJvcGVydHkgNjogQnJva2VuIFJlZmVyZW5jZSBEZXRlY3Rpb25cbiAqIFxuICogRm9yIGFueSByZWZlcmVuY2UgbGluayB0aGF0IHBvaW50cyB0byBhIGRlbGV0ZWQgZW50aXR5LCB0aGUgc3lzdGVtIFNIQUxMIG1hcmsgaXQgXG4gKiBhcyBicm9rZW4gYW5kIGRpc3BsYXkgYSB3YXJuaW5nIHRvIHRoZSBhZG1pbi5cbiAqIFxuICogVGhpcyBwcm9wZXJ0eSB2ZXJpZmllcyB0aGF0OlxuICogMS4gUmVmZXJlbmNlcyB0byBub24tZXhpc3RlbnQgZW50aXRpZXMgYXJlIGRldGVjdGVkIGFzIGJyb2tlblxuICogMi4gVGhlIHN5c3RlbSBjb3JyZWN0bHkgaWRlbnRpZmllcyB3aGljaCBzcGVjaWZpYyByZWZlcmVuY2VzIGFyZSBicm9rZW5cbiAqIDMuIFZhbGlkYXRpb24gZmFpbHMgd2hlbiBhbnkgcmVmZXJlbmNlIGlzIGJyb2tlblxuICogNC4gQWxsIGJyb2tlbiByZWZlcmVuY2VzIGFyZSBpbmNsdWRlZCBpbiB0aGUgcmVzcG9uc2VcbiAqIFxuICogVmFsaWRhdGVzOiBSZXF1aXJlbWVudHMgMi4xMFxuICovXG5kZXNjcmliZSgnRmVhdHVyZTogYWRtaW4tYmFja2VuZC1pbnRlZ3JhdGlvbi1jbXMsIFByb3BlcnR5IDY6IEJyb2tlbiBSZWZlcmVuY2UgRGV0ZWN0aW9uJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBtYXJrIHJlZmVyZW5jZXMgdG8gZGVsZXRlZCBlbnRpdGllcyBhcyBicm9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMuYXJyYXkoXG4gICAgICAgICAgZmMucmVjb3JkKHtcbiAgICAgICAgICAgIHR5cGU6IGZjLmNvbnN0YW50RnJvbSgnZXZlbnQnLCAnYWN0aXZpdHknLCAnYWNjb21tb2RhdGlvbicsICdsb2NhdGlvbicpIGFzIGZjLkFyYml0cmFyeTwnZXZlbnQnIHwgJ2FjdGl2aXR5JyB8ICdhY2NvbW1vZGF0aW9uJyB8ICdsb2NhdGlvbic+LFxuICAgICAgICAgICAgaWQ6IGZjLnV1aWQoKSxcbiAgICAgICAgICAgIGxhYmVsOiBmYy5vcHRpb24oZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwMCB9KSksXG4gICAgICAgICAgICBpc0RlbGV0ZWQ6IGZjLmJvb2xlYW4oKSwgLy8gU2ltdWxhdGVzIHdoZXRoZXIgZW50aXR5IHdhcyBkZWxldGVkXG4gICAgICAgICAgfSksXG4gICAgICAgICAgeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMjAgfVxuICAgICAgICApLFxuICAgICAgICBhc3luYyAodGVzdFJlZmVyZW5jZXMpID0+IHtcbiAgICAgICAgICAvLyBNb2NrIGRhdGFiYXNlIGxvb2t1cHMgLSBkZWxldGVkIGVudGl0aWVzIHJldHVybiBudWxsXG4gICAgICAgICAgZm9yIChjb25zdCByZWYgb2YgdGVzdFJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZU9uY2UoY3JlYXRlTW9ja1F1ZXJ5Q2hhaW4oe1xuICAgICAgICAgICAgICBkYXRhOiByZWYuaXNEZWxldGVkID8gbnVsbCA6IHsgaWQ6IHJlZi5pZCB9LFxuICAgICAgICAgICAgICBlcnJvcjogcmVmLmlzRGVsZXRlZCA/IHsgY29kZTogJ1BHUlNUMTE2JywgbWVzc2FnZTogJ05vdCBmb3VuZCcgfSA6IG51bGwsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcmVmZXJlbmNlczogUmVmZXJlbmNlW10gPSB0ZXN0UmVmZXJlbmNlcy5tYXAociA9PiAoe1xuICAgICAgICAgICAgdHlwZTogci50eXBlLFxuICAgICAgICAgICAgaWQ6IHIuaWQsXG4gICAgICAgICAgICBsYWJlbDogci5sYWJlbCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGVSZWZlcmVuY2VzKHJlZmVyZW5jZXMpO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IFZhbGlkYXRpb24gb3BlcmF0aW9uIHNob3VsZCBhbHdheXMgc3VjY2VlZFxuICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcblxuICAgICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBBbGwgZGVsZXRlZCBlbnRpdGllcyBzaG91bGQgYmUgbWFya2VkIGFzIGJyb2tlblxuICAgICAgICAgIGNvbnN0IGRlbGV0ZWRSZWZzID0gdGVzdFJlZmVyZW5jZXMuZmlsdGVyKHIgPT4gci5pc0RlbGV0ZWQpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5icm9rZW5SZWZlcmVuY2VzLmxlbmd0aCkudG9CZShkZWxldGVkUmVmcy5sZW5ndGgpO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IEVhY2ggYnJva2VuIHJlZmVyZW5jZSBzaG91bGQgY29ycmVzcG9uZCB0byBhIGRlbGV0ZWQgZW50aXR5XG4gICAgICAgICAgZm9yIChjb25zdCBicm9rZW4gb2YgcmVzdWx0LmRhdGEuYnJva2VuUmVmZXJlbmNlcykge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSB0ZXN0UmVmZXJlbmNlcy5maW5kKHIgPT4gci5pZCA9PT0gYnJva2VuLmlkICYmIHIudHlwZSA9PT0gYnJva2VuLnR5cGUpO1xuICAgICAgICAgICAgZXhwZWN0KG9yaWdpbmFsKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KG9yaWdpbmFsPy5pc0RlbGV0ZWQpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IFZhbGlkYXRpb24gaXMgdmFsaWQgb25seSB3aGVuIG5vIGVudGl0aWVzIGFyZSBkZWxldGVkXG4gICAgICAgICAgY29uc3QgaGFzRGVsZXRlZEVudGl0aWVzID0gdGVzdFJlZmVyZW5jZXMuc29tZShyID0+IHIuaXNEZWxldGVkKTtcbiAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudmFsaWQpLnRvQmUoIWhhc0RlbGV0ZWRFbnRpdGllcyk7XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGRldGVjdCBicm9rZW4gcmVmZXJlbmNlcyB3aGVuIGVudGl0aWVzIGFyZSBkZWxldGVkIGFmdGVyIHJlZmVyZW5jZSBjcmVhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgIGV4aXN0aW5nUmVmczogZmMuYXJyYXkoXG4gICAgICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgICAgICB0eXBlOiBmYy5jb25zdGFudEZyb20oJ2V2ZW50JywgJ2FjdGl2aXR5JywgJ2FjY29tbW9kYXRpb24nLCAnbG9jYXRpb24nKSBhcyBmYy5BcmJpdHJhcnk8J2V2ZW50JyB8ICdhY3Rpdml0eScgfCAnYWNjb21tb2RhdGlvbicgfCAnbG9jYXRpb24nPixcbiAgICAgICAgICAgICAgaWQ6IGZjLnV1aWQoKSxcbiAgICAgICAgICAgICAgbGFiZWw6IGZjLm9wdGlvbihmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTAwIH0pKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgeyBtaW5MZW5ndGg6IDAsIG1heExlbmd0aDogNSB9XG4gICAgICAgICAgKSxcbiAgICAgICAgICBkZWxldGVkUmVmczogZmMuYXJyYXkoXG4gICAgICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgICAgICB0eXBlOiBmYy5jb25zdGFudEZyb20oJ2V2ZW50JywgJ2FjdGl2aXR5JywgJ2FjY29tbW9kYXRpb24nLCAnbG9jYXRpb24nKSBhcyBmYy5BcmJpdHJhcnk8J2V2ZW50JyB8ICdhY3Rpdml0eScgfCAnYWNjb21tb2RhdGlvbicgfCAnbG9jYXRpb24nPixcbiAgICAgICAgICAgICAgaWQ6IGZjLnV1aWQoKSxcbiAgICAgICAgICAgICAgbGFiZWw6IGZjLm9wdGlvbihmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTAwIH0pKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogNSB9XG4gICAgICAgICAgKSxcbiAgICAgICAgfSksXG4gICAgICAgIGFzeW5jICh0ZXN0RGF0YSkgPT4ge1xuICAgICAgICAgIC8vIE1vY2sgZXhpc3RpbmcgcmVmZXJlbmNlcyBhcyBzdGlsbCBpbiBkYXRhYmFzZVxuICAgICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHRlc3REYXRhLmV4aXN0aW5nUmVmcykge1xuICAgICAgICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlT25jZShjcmVhdGVNb2NrUXVlcnlDaGFpbih7XG4gICAgICAgICAgICAgIGRhdGE6IHsgaWQ6IHJlZi5pZCB9LFxuICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBNb2NrIGRlbGV0ZWQgcmVmZXJlbmNlcyBhcyBubyBsb25nZXIgaW4gZGF0YWJhc2VcbiAgICAgICAgICBmb3IgKGNvbnN0IHJlZiBvZiB0ZXN0RGF0YS5kZWxldGVkUmVmcykge1xuICAgICAgICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlT25jZShjcmVhdGVNb2NrUXVlcnlDaGFpbih7XG4gICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgIGVycm9yOiB7IGNvZGU6ICdQR1JTVDExNicsIG1lc3NhZ2U6ICdOb3QgZm91bmQnIH0sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcmVmZXJlbmNlczogUmVmZXJlbmNlW10gPSBbXG4gICAgICAgICAgICAuLi50ZXN0RGF0YS5leGlzdGluZ1JlZnMubWFwKHIgPT4gKHsgdHlwZTogci50eXBlLCBpZDogci5pZCwgbGFiZWw6IHIubGFiZWwgfHwgdW5kZWZpbmVkIH0pKSxcbiAgICAgICAgICAgIC4uLnRlc3REYXRhLmRlbGV0ZWRSZWZzLm1hcChyID0+ICh7IHR5cGU6IHIudHlwZSwgaWQ6IHIuaWQsIGxhYmVsOiByLmxhYmVsIHx8IHVuZGVmaW5lZCB9KSksXG4gICAgICAgICAgXTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlUmVmZXJlbmNlcyhyZWZlcmVuY2VzKTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBWYWxpZGF0aW9uIHNob3VsZCBzdWNjZWVkXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuXG4gICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IFNob3VsZCBiZSBpbnZhbGlkIHdoZW4gYW55IHJlZmVyZW5jZSBwb2ludHMgdG8gZGVsZXRlZCBlbnRpdHlcbiAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5icm9rZW5SZWZlcmVuY2VzLmxlbmd0aCkudG9CZSh0ZXN0RGF0YS5kZWxldGVkUmVmcy5sZW5ndGgpO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IEFsbCBkZWxldGVkIHJlZmVyZW5jZXMgc2hvdWxkIGJlIGlkZW50aWZpZWQgYXMgYnJva2VuXG4gICAgICAgICAgZm9yIChjb25zdCBkZWxldGVkUmVmIG9mIHRlc3REYXRhLmRlbGV0ZWRSZWZzKSB7XG4gICAgICAgICAgICBjb25zdCBmb3VuZCA9IHJlc3VsdC5kYXRhLmJyb2tlblJlZmVyZW5jZXMuZmluZChcbiAgICAgICAgICAgICAgciA9PiByLmlkID09PSBkZWxldGVkUmVmLmlkICYmIHIudHlwZSA9PT0gZGVsZXRlZFJlZi50eXBlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXhwZWN0KGZvdW5kKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KGZvdW5kPy50eXBlKS50b0JlKGRlbGV0ZWRSZWYudHlwZSk7XG4gICAgICAgICAgICBleHBlY3QoZm91bmQ/LmlkKS50b0JlKGRlbGV0ZWRSZWYuaWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBObyBleGlzdGluZyByZWZlcmVuY2VzIHNob3VsZCBiZSBtYXJrZWQgYXMgYnJva2VuXG4gICAgICAgICAgZm9yIChjb25zdCBleGlzdGluZ1JlZiBvZiB0ZXN0RGF0YS5leGlzdGluZ1JlZnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gcmVzdWx0LmRhdGEuYnJva2VuUmVmZXJlbmNlcy5maW5kKFxuICAgICAgICAgICAgICByID0+IHIuaWQgPT09IGV4aXN0aW5nUmVmLmlkICYmIHIudHlwZSA9PT0gZXhpc3RpbmdSZWYudHlwZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGV4cGVjdChmb3VuZCkudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiA1MCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBjb3JyZWN0bHkgaWRlbnRpZnkgYnJva2VuIHJlZmVyZW5jZXMgYWNyb3NzIGRpZmZlcmVudCBlbnRpdHkgdHlwZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMuY29uc3RhbnRGcm9tKCdldmVudCcsICdhY3Rpdml0eScsICdhY2NvbW1vZGF0aW9uJywgJ2xvY2F0aW9uJykgYXMgZmMuQXJiaXRyYXJ5PCdldmVudCcgfCAnYWN0aXZpdHknIHwgJ2FjY29tbW9kYXRpb24nIHwgJ2xvY2F0aW9uJz4sXG4gICAgICAgIGZjLnV1aWQoKSxcbiAgICAgICAgZmMub3B0aW9uKGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxMDAgfSkpLFxuICAgICAgICBmYy5ib29sZWFuKCksXG4gICAgICAgIGFzeW5jICh0eXBlLCBpZCwgbGFiZWwsIGlzRGVsZXRlZCkgPT4ge1xuICAgICAgICAgIC8vIE1vY2sgZGF0YWJhc2UgbG9va3VwXG4gICAgICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlT25jZShjcmVhdGVNb2NrUXVlcnlDaGFpbih7XG4gICAgICAgICAgICBkYXRhOiBpc0RlbGV0ZWQgPyBudWxsIDogeyBpZCB9LFxuICAgICAgICAgICAgZXJyb3I6IGlzRGVsZXRlZCA/IHsgY29kZTogJ1BHUlNUMTE2JywgbWVzc2FnZTogJ05vdCBmb3VuZCcgfSA6IG51bGwsXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY29uc3QgcmVmZXJlbmNlczogUmVmZXJlbmNlW10gPSBbeyB0eXBlLCBpZCwgbGFiZWw6IGxhYmVsIHx8IHVuZGVmaW5lZCB9XTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0ZVJlZmVyZW5jZXMocmVmZXJlbmNlcyk7XG5cbiAgICAgICAgICAvLyBQcm9wZXJ0eTogVmFsaWRhdGlvbiBzaG91bGQgc3VjY2VlZFxuICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcblxuICAgICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBEZWxldGVkIGVudGl0eSBzaG91bGQgYmUgbWFya2VkIGFzIGJyb2tlblxuICAgICAgICAgIGlmIChpc0RlbGV0ZWQpIHtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS52YWxpZCkudG9CZShmYWxzZSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuYnJva2VuUmVmZXJlbmNlcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmJyb2tlblJlZmVyZW5jZXNbMF0udHlwZSkudG9CZSh0eXBlKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5icm9rZW5SZWZlcmVuY2VzWzBdLmlkKS50b0JlKGlkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnZhbGlkKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmJyb2tlblJlZmVyZW5jZXMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHJldHVybiBlbXB0eSBicm9rZW4gcmVmZXJlbmNlcyB3aGVuIGFsbCBlbnRpdGllcyBleGlzdCcsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBmYy5hcnJheShcbiAgICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgICAgdHlwZTogZmMuY29uc3RhbnRGcm9tKCdldmVudCcsICdhY3Rpdml0eScsICdhY2NvbW1vZGF0aW9uJywgJ2xvY2F0aW9uJykgYXMgZmMuQXJiaXRyYXJ5PCdldmVudCcgfCAnYWN0aXZpdHknIHwgJ2FjY29tbW9kYXRpb24nIHwgJ2xvY2F0aW9uJz4sXG4gICAgICAgICAgICBpZDogZmMudXVpZCgpLFxuICAgICAgICAgICAgbGFiZWw6IGZjLm9wdGlvbihmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTAwIH0pKSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxNSB9XG4gICAgICAgICksXG4gICAgICAgIGFzeW5jICh0ZXN0UmVmZXJlbmNlcykgPT4ge1xuICAgICAgICAgIC8vIE1vY2sgYWxsIHJlZmVyZW5jZXMgYXMgZXhpc3RpbmcgaW4gZGF0YWJhc2VcbiAgICAgICAgICBmb3IgKGNvbnN0IHJlZiBvZiB0ZXN0UmVmZXJlbmNlcykge1xuICAgICAgICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlT25jZShjcmVhdGVNb2NrUXVlcnlDaGFpbih7XG4gICAgICAgICAgICAgIGRhdGE6IHsgaWQ6IHJlZi5pZCB9LFxuICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCByZWZlcmVuY2VzOiBSZWZlcmVuY2VbXSA9IHRlc3RSZWZlcmVuY2VzLm1hcChyID0+ICh7XG4gICAgICAgICAgICB0eXBlOiByLnR5cGUsXG4gICAgICAgICAgICBpZDogci5pZCxcbiAgICAgICAgICAgIGxhYmVsOiByLmxhYmVsIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0ZVJlZmVyZW5jZXMocmVmZXJlbmNlcyk7XG5cbiAgICAgICAgICAvLyBQcm9wZXJ0eTogVmFsaWRhdGlvbiBzaG91bGQgc3VjY2VlZFxuICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcblxuICAgICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBObyBlbnRpdGllcyBkZWxldGVkLCBzbyBubyBicm9rZW4gcmVmZXJlbmNlc1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS52YWxpZCkudG9CZSh0cnVlKTtcbiAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuYnJva2VuUmVmZXJlbmNlcykudG9IYXZlTGVuZ3RoKDApO1xuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgcmVmZXJlbmNlIGFycmF5cyB3aXRob3V0IGJyb2tlbiByZWZlcmVuY2VzJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlUmVmZXJlbmNlcyhbXSk7XG5cbiAgICAvLyBQcm9wZXJ0eTogRW1wdHkgYXJyYXkgc2hvdWxkIGJlIHZhbGlkIHdpdGggbm8gYnJva2VuIHJlZmVyZW5jZXNcbiAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICBleHBlY3QocmVzdWx0LmRhdGEudmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmRhdGEuYnJva2VuUmVmZXJlbmNlcykudG9IYXZlTGVuZ3RoKDApO1xuICAgIH1cbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBwcmVzZXJ2ZSByZWZlcmVuY2UgbWV0YWRhdGEgd2hlbiBtYXJraW5nIGFzIGJyb2tlbicsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgIHR5cGU6IGZjLmNvbnN0YW50RnJvbSgnZXZlbnQnLCAnYWN0aXZpdHknLCAnYWNjb21tb2RhdGlvbicsICdsb2NhdGlvbicpIGFzIGZjLkFyYml0cmFyeTwnZXZlbnQnIHwgJ2FjdGl2aXR5JyB8ICdhY2NvbW1vZGF0aW9uJyB8ICdsb2NhdGlvbic+LFxuICAgICAgICAgIGlkOiBmYy51dWlkKCksXG4gICAgICAgICAgbGFiZWw6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxMDAgfSksXG4gICAgICAgIH0pLFxuICAgICAgICBhc3luYyAodGVzdFJlZikgPT4ge1xuICAgICAgICAgIC8vIE1vY2sgYXMgZGVsZXRlZCBlbnRpdHlcbiAgICAgICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWVPbmNlKGNyZWF0ZU1vY2tRdWVyeUNoYWluKHtcbiAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICBlcnJvcjogeyBjb2RlOiAnUEdSU1QxMTYnLCBtZXNzYWdlOiAnTm90IGZvdW5kJyB9LFxuICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZXM6IFJlZmVyZW5jZVtdID0gW3sgXG4gICAgICAgICAgICB0eXBlOiB0ZXN0UmVmLnR5cGUsIFxuICAgICAgICAgICAgaWQ6IHRlc3RSZWYuaWQsIFxuICAgICAgICAgICAgbGFiZWw6IHRlc3RSZWYubGFiZWwgXG4gICAgICAgICAgfV07XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0ZVJlZmVyZW5jZXMocmVmZXJlbmNlcyk7XG5cbiAgICAgICAgICAvLyBQcm9wZXJ0eTogVmFsaWRhdGlvbiBzaG91bGQgc3VjY2VlZFxuICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcblxuICAgICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBCcm9rZW4gcmVmZXJlbmNlIHNob3VsZCBwcmVzZXJ2ZSBhbGwgb3JpZ2luYWwgbWV0YWRhdGFcbiAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuYnJva2VuUmVmZXJlbmNlcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgICAgIGNvbnN0IGJyb2tlbiA9IHJlc3VsdC5kYXRhLmJyb2tlblJlZmVyZW5jZXNbMF07XG4gICAgICAgICAgZXhwZWN0KGJyb2tlbi50eXBlKS50b0JlKHRlc3RSZWYudHlwZSk7XG4gICAgICAgICAgZXhwZWN0KGJyb2tlbi5pZCkudG9CZSh0ZXN0UmVmLmlkKTtcbiAgICAgICAgICBleHBlY3QoYnJva2VuLmxhYmVsKS50b0JlKHRlc3RSZWYubGFiZWwpO1xuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDUwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGRldGVjdCBhbGwgYnJva2VuIHJlZmVyZW5jZXMgaW4gYSBtaXhlZCBzZXQnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMCwgbWF4OiAxMCB9KSxcbiAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMSwgbWF4OiAxMCB9KSxcbiAgICAgICAgYXN5bmMgKHZhbGlkQ291bnQsIGJyb2tlbkNvdW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsaWRSZWZzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdmFsaWRDb3VudCB9LCAoXywgaSkgPT4gKHtcbiAgICAgICAgICAgIHR5cGU6IChbJ2V2ZW50JywgJ2FjdGl2aXR5JywgJ2FjY29tbW9kYXRpb24nLCAnbG9jYXRpb24nXSBhcyBjb25zdClbaSAlIDRdLFxuICAgICAgICAgICAgaWQ6IGB2YWxpZC0ke2l9YCxcbiAgICAgICAgICAgIGxhYmVsOiBgVmFsaWQgJHtpfWAsXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY29uc3QgYnJva2VuUmVmcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGJyb2tlbkNvdW50IH0sIChfLCBpKSA9PiAoe1xuICAgICAgICAgICAgdHlwZTogKFsnZXZlbnQnLCAnYWN0aXZpdHknLCAnYWNjb21tb2RhdGlvbicsICdsb2NhdGlvbiddIGFzIGNvbnN0KVtpICUgNF0sXG4gICAgICAgICAgICBpZDogYGJyb2tlbi0ke2l9YCxcbiAgICAgICAgICAgIGxhYmVsOiBgQnJva2VuICR7aX1gLFxuICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIC8vIE1vY2sgdmFsaWQgcmVmZXJlbmNlc1xuICAgICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHZhbGlkUmVmcykge1xuICAgICAgICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlT25jZShjcmVhdGVNb2NrUXVlcnlDaGFpbih7XG4gICAgICAgICAgICAgIGRhdGE6IHsgaWQ6IHJlZi5pZCB9LFxuICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBNb2NrIGJyb2tlbiByZWZlcmVuY2VzXG4gICAgICAgICAgZm9yIChjb25zdCByZWYgb2YgYnJva2VuUmVmcykge1xuICAgICAgICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlT25jZShjcmVhdGVNb2NrUXVlcnlDaGFpbih7XG4gICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgIGVycm9yOiB7IGNvZGU6ICdQR1JTVDExNicsIG1lc3NhZ2U6ICdOb3QgZm91bmQnIH0sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcmVmZXJlbmNlczogUmVmZXJlbmNlW10gPSBbLi4udmFsaWRSZWZzLCAuLi5icm9rZW5SZWZzXTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0ZVJlZmVyZW5jZXMocmVmZXJlbmNlcyk7XG5cbiAgICAgICAgICAvLyBQcm9wZXJ0eTogU2hvdWxkIGRldGVjdCBleGFjdGx5IHRoZSBicm9rZW4gcmVmZXJlbmNlc1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuYnJva2VuUmVmZXJlbmNlcy5sZW5ndGgpLnRvQmUoYnJva2VuQ291bnQpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS52YWxpZCkudG9CZShicm9rZW5Db3VudCA9PT0gMCk7XG5cbiAgICAgICAgICAvLyBQcm9wZXJ0eTogQWxsIGJyb2tlbiBJRHMgc2hvdWxkIGJlIGluIHRoZSBicm9rZW4gcmVmZXJlbmNlcyBsaXN0XG4gICAgICAgICAgY29uc3QgYnJva2VuSWRzID0gbmV3IFNldChicm9rZW5SZWZzLm1hcChyID0+IHIuaWQpKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGJyb2tlbiBvZiByZXN1bHQuZGF0YS5icm9rZW5SZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBleHBlY3QoYnJva2VuSWRzLmhhcyhicm9rZW4uaWQpKS50b0JlKHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiA1MCB9XG4gICAgKTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJtb2NrRnJvbSIsImplc3QiLCJmbiIsIm1vY2tTdXBhYmFzZSIsImZyb20iLCJtb2NrIiwic3VwYWJhc2UiLCJjcmVhdGVNb2NrUXVlcnlDaGFpbiIsInJlc29sdmVkVmFsdWUiLCJtb2NrU2luZ2xlIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJtb2NrRXEiLCJtb2NrUmV0dXJuVmFsdWUiLCJzaW5nbGUiLCJtb2NrU2VsZWN0IiwiZXEiLCJzZWxlY3QiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiaXQiLCJmYyIsImFzc2VydCIsImFzeW5jUHJvcGVydHkiLCJhcnJheSIsInJlY29yZCIsInR5cGUiLCJjb25zdGFudEZyb20iLCJpZCIsInV1aWQiLCJsYWJlbCIsIm9wdGlvbiIsInN0cmluZyIsIm1pbkxlbmd0aCIsIm1heExlbmd0aCIsImlzRGVsZXRlZCIsImJvb2xlYW4iLCJ0ZXN0UmVmZXJlbmNlcyIsInJlZiIsIm1vY2tSZXR1cm5WYWx1ZU9uY2UiLCJkYXRhIiwiZXJyb3IiLCJjb2RlIiwibWVzc2FnZSIsInJlZmVyZW5jZXMiLCJtYXAiLCJyIiwidW5kZWZpbmVkIiwicmVzdWx0IiwidmFsaWRhdGVSZWZlcmVuY2VzIiwiZXhwZWN0Iiwic3VjY2VzcyIsInRvQmUiLCJkZWxldGVkUmVmcyIsImZpbHRlciIsImJyb2tlblJlZmVyZW5jZXMiLCJsZW5ndGgiLCJicm9rZW4iLCJvcmlnaW5hbCIsImZpbmQiLCJ0b0JlRGVmaW5lZCIsImhhc0RlbGV0ZWRFbnRpdGllcyIsInNvbWUiLCJ2YWxpZCIsIm51bVJ1bnMiLCJleGlzdGluZ1JlZnMiLCJ0ZXN0RGF0YSIsImRlbGV0ZWRSZWYiLCJmb3VuZCIsImV4aXN0aW5nUmVmIiwidG9CZVVuZGVmaW5lZCIsInRvSGF2ZUxlbmd0aCIsInRlc3RSZWYiLCJpbnRlZ2VyIiwibWluIiwibWF4IiwidmFsaWRDb3VudCIsImJyb2tlbkNvdW50IiwidmFsaWRSZWZzIiwiQXJyYXkiLCJfIiwiaSIsImJyb2tlblJlZnMiLCJicm9rZW5JZHMiLCJTZXQiLCJoYXMiXSwibWFwcGluZ3MiOiI7Ozs7bUVBQW9CO3lCQUNtQztpQ0FhcEI7Ozs7Ozs7Ozs7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