{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/services/sectionsService.brokenReferenceDetection.property.test.ts"],"sourcesContent":["import * as fc from 'fast-check';\nimport { jest, describe, it, expect, beforeEach } from '@jest/globals';\n\n// Mock Supabase before importing services\nconst mockFrom = jest.fn() as jest.MockedFunction<any>;\nconst mockSupabase = {\n  from: mockFrom,\n};\n\njest.mock('../lib/supabase', () => ({\n  supabase: mockSupabase,\n}));\n\n// Import after mocking\nimport { validateReferences } from './sectionsService';\nimport type { Reference } from '../schemas/cmsSchemas';\n\n// Helper to create properly typed mock chain\nfunction createMockQueryChain(resolvedValue: { data: any; error: any }) {\n  const mockSingle = (jest.fn() as any).mockResolvedValue(resolvedValue);\n  const mockEq = (jest.fn() as any).mockReturnValue({ single: mockSingle });\n  const mockSelect = (jest.fn() as any).mockReturnValue({ eq: mockEq });\n  return { select: mockSelect } as any;\n}\n\n/**\n * Property 6: Broken Reference Detection\n * \n * For any reference link that points to a deleted entity, the system SHALL mark it \n * as broken and display a warning to the admin.\n * \n * This property verifies that:\n * 1. References to non-existent entities are detected as broken\n * 2. The system correctly identifies which specific references are broken\n * 3. Validation fails when any reference is broken\n * 4. All broken references are included in the response\n * \n * Validates: Requirements 2.10\n */\ndescribe('Feature: admin-backend-integration-cms, Property 6: Broken Reference Detection', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('should mark references to deleted entities as broken', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.array(\n          fc.record({\n            type: fc.constantFrom('event', 'activity', 'accommodation', 'location') as fc.Arbitrary<'event' | 'activity' | 'accommodation' | 'location'>,\n            id: fc.uuid(),\n            label: fc.option(fc.string({ minLength: 1, maxLength: 100 })),\n            isDeleted: fc.boolean(), // Simulates whether entity was deleted\n          }),\n          { minLength: 1, maxLength: 20 }\n        ),\n        async (testReferences) => {\n          // Mock database lookups - deleted entities return null\n          for (const ref of testReferences) {\n            mockFrom.mockReturnValueOnce(createMockQueryChain({\n              data: ref.isDeleted ? null : { id: ref.id },\n              error: ref.isDeleted ? { code: 'PGRST116', message: 'Not found' } : null,\n            }));\n          }\n\n          const references: Reference[] = testReferences.map(r => ({\n            type: r.type,\n            id: r.id,\n            label: r.label || undefined,\n          }));\n\n          const result = await validateReferences(references);\n\n          // Property: Validation operation should always succeed\n          expect(result.success).toBe(true);\n\n          if (!result.success) {\n            return true;\n          }\n\n          // Property: All deleted entities should be marked as broken\n          const deletedRefs = testReferences.filter(r => r.isDeleted);\n          expect(result.data.brokenReferences.length).toBe(deletedRefs.length);\n\n          // Property: Each broken reference should correspond to a deleted entity\n          for (const broken of result.data.brokenReferences) {\n            const original = testReferences.find(r => r.id === broken.id && r.type === broken.type);\n            expect(original).toBeDefined();\n            expect(original?.isDeleted).toBe(true);\n          }\n\n          // Property: Validation is valid only when no entities are deleted\n          const hasDeletedEntities = testReferences.some(r => r.isDeleted);\n          expect(result.data.valid).toBe(!hasDeletedEntities);\n\n          return true;\n        }\n      ),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should detect broken references when entities are deleted after reference creation', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.record({\n          existingRefs: fc.array(\n            fc.record({\n              type: fc.constantFrom('event', 'activity', 'accommodation', 'location') as fc.Arbitrary<'event' | 'activity' | 'accommodation' | 'location'>,\n              id: fc.uuid(),\n              label: fc.option(fc.string({ minLength: 1, maxLength: 100 })),\n            }),\n            { minLength: 0, maxLength: 5 }\n          ),\n          deletedRefs: fc.array(\n            fc.record({\n              type: fc.constantFrom('event', 'activity', 'accommodation', 'location') as fc.Arbitrary<'event' | 'activity' | 'accommodation' | 'location'>,\n              id: fc.uuid(),\n              label: fc.option(fc.string({ minLength: 1, maxLength: 100 })),\n            }),\n            { minLength: 1, maxLength: 5 }\n          ),\n        }),\n        async (testData) => {\n          // Mock existing references as still in database\n          for (const ref of testData.existingRefs) {\n            mockFrom.mockReturnValueOnce(createMockQueryChain({\n              data: { id: ref.id },\n              error: null,\n            }));\n          }\n\n          // Mock deleted references as no longer in database\n          for (const ref of testData.deletedRefs) {\n            mockFrom.mockReturnValueOnce(createMockQueryChain({\n              data: null,\n              error: { code: 'PGRST116', message: 'Not found' },\n            }));\n          }\n\n          const references: Reference[] = [\n            ...testData.existingRefs.map(r => ({ type: r.type, id: r.id, label: r.label || undefined })),\n            ...testData.deletedRefs.map(r => ({ type: r.type, id: r.id, label: r.label || undefined })),\n          ];\n\n          const result = await validateReferences(references);\n\n          // Property: Validation should succeed\n          expect(result.success).toBe(true);\n\n          if (!result.success) {\n            return true;\n          }\n\n          // Property: Should be invalid when any reference points to deleted entity\n          expect(result.data.valid).toBe(false);\n          expect(result.data.brokenReferences.length).toBe(testData.deletedRefs.length);\n\n          // Property: All deleted references should be identified as broken\n          for (const deletedRef of testData.deletedRefs) {\n            const found = result.data.brokenReferences.find(\n              r => r.id === deletedRef.id && r.type === deletedRef.type\n            );\n            expect(found).toBeDefined();\n            expect(found?.type).toBe(deletedRef.type);\n            expect(found?.id).toBe(deletedRef.id);\n          }\n\n          // Property: No existing references should be marked as broken\n          for (const existingRef of testData.existingRefs) {\n            const found = result.data.brokenReferences.find(\n              r => r.id === existingRef.id && r.type === existingRef.type\n            );\n            expect(found).toBeUndefined();\n          }\n\n          return true;\n        }\n      ),\n      { numRuns: 50 }\n    );\n  });\n\n  it('should correctly identify broken references across different entity types', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.constantFrom('event', 'activity', 'accommodation', 'location') as fc.Arbitrary<'event' | 'activity' | 'accommodation' | 'location'>,\n        fc.uuid(),\n        fc.option(fc.string({ minLength: 1, maxLength: 100 })),\n        fc.boolean(),\n        async (type, id, label, isDeleted) => {\n          // Mock database lookup\n          mockFrom.mockReturnValueOnce(createMockQueryChain({\n            data: isDeleted ? null : { id },\n            error: isDeleted ? { code: 'PGRST116', message: 'Not found' } : null,\n          }));\n\n          const references: Reference[] = [{ type, id, label: label || undefined }];\n          const result = await validateReferences(references);\n\n          // Property: Validation should succeed\n          expect(result.success).toBe(true);\n\n          if (!result.success) {\n            return true;\n          }\n\n          // Property: Deleted entity should be marked as broken\n          if (isDeleted) {\n            expect(result.data.valid).toBe(false);\n            expect(result.data.brokenReferences).toHaveLength(1);\n            expect(result.data.brokenReferences[0].type).toBe(type);\n            expect(result.data.brokenReferences[0].id).toBe(id);\n          } else {\n            expect(result.data.valid).toBe(true);\n            expect(result.data.brokenReferences).toHaveLength(0);\n          }\n\n          return true;\n        }\n      ),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should return empty broken references when all entities exist', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.array(\n          fc.record({\n            type: fc.constantFrom('event', 'activity', 'accommodation', 'location') as fc.Arbitrary<'event' | 'activity' | 'accommodation' | 'location'>,\n            id: fc.uuid(),\n            label: fc.option(fc.string({ minLength: 1, maxLength: 100 })),\n          }),\n          { minLength: 1, maxLength: 15 }\n        ),\n        async (testReferences) => {\n          // Mock all references as existing in database\n          for (const ref of testReferences) {\n            mockFrom.mockReturnValueOnce(createMockQueryChain({\n              data: { id: ref.id },\n              error: null,\n            }));\n          }\n\n          const references: Reference[] = testReferences.map(r => ({\n            type: r.type,\n            id: r.id,\n            label: r.label || undefined,\n          }));\n\n          const result = await validateReferences(references);\n\n          // Property: Validation should succeed\n          expect(result.success).toBe(true);\n\n          if (!result.success) {\n            return true;\n          }\n\n          // Property: No entities deleted, so no broken references\n          expect(result.data.valid).toBe(true);\n          expect(result.data.brokenReferences).toHaveLength(0);\n\n          return true;\n        }\n      ),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should handle empty reference arrays without broken references', async () => {\n    const result = await validateReferences([]);\n\n    // Property: Empty array should be valid with no broken references\n    expect(result.success).toBe(true);\n    if (result.success) {\n      expect(result.data.valid).toBe(true);\n      expect(result.data.brokenReferences).toHaveLength(0);\n    }\n  });\n\n  it('should preserve reference metadata when marking as broken', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.record({\n          type: fc.constantFrom('event', 'activity', 'accommodation', 'location') as fc.Arbitrary<'event' | 'activity' | 'accommodation' | 'location'>,\n          id: fc.uuid(),\n          label: fc.string({ minLength: 1, maxLength: 100 }),\n        }),\n        async (testRef) => {\n          // Mock as deleted entity\n          mockFrom.mockReturnValueOnce(createMockQueryChain({\n            data: null,\n            error: { code: 'PGRST116', message: 'Not found' },\n          }));\n\n          const references: Reference[] = [{ \n            type: testRef.type, \n            id: testRef.id, \n            label: testRef.label \n          }];\n\n          const result = await validateReferences(references);\n\n          // Property: Validation should succeed\n          expect(result.success).toBe(true);\n\n          if (!result.success) {\n            return true;\n          }\n\n          // Property: Broken reference should preserve all original metadata\n          expect(result.data.brokenReferences).toHaveLength(1);\n          const broken = result.data.brokenReferences[0];\n          expect(broken.type).toBe(testRef.type);\n          expect(broken.id).toBe(testRef.id);\n          expect(broken.label).toBe(testRef.label);\n\n          return true;\n        }\n      ),\n      { numRuns: 50 }\n    );\n  });\n\n  it('should detect all broken references in a mixed set', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.integer({ min: 0, max: 10 }),\n        fc.integer({ min: 1, max: 10 }),\n        async (validCount, brokenCount) => {\n          const validRefs = Array.from({ length: validCount }, (_, i) => ({\n            type: (['event', 'activity', 'accommodation', 'location'] as const)[i % 4],\n            id: `valid-${i}`,\n            label: `Valid ${i}`,\n          }));\n\n          const brokenRefs = Array.from({ length: brokenCount }, (_, i) => ({\n            type: (['event', 'activity', 'accommodation', 'location'] as const)[i % 4],\n            id: `broken-${i}`,\n            label: `Broken ${i}`,\n          }));\n\n          // Mock valid references\n          for (const ref of validRefs) {\n            mockFrom.mockReturnValueOnce(createMockQueryChain({\n              data: { id: ref.id },\n              error: null,\n            }));\n          }\n\n          // Mock broken references\n          for (const ref of brokenRefs) {\n            mockFrom.mockReturnValueOnce(createMockQueryChain({\n              data: null,\n              error: { code: 'PGRST116', message: 'Not found' },\n            }));\n          }\n\n          const references: Reference[] = [...validRefs, ...brokenRefs];\n          const result = await validateReferences(references);\n\n          // Property: Should detect exactly the broken references\n          expect(result.success).toBe(true);\n          if (!result.success) {\n            return true;\n          }\n\n          expect(result.data.brokenReferences.length).toBe(brokenCount);\n          expect(result.data.valid).toBe(brokenCount === 0);\n\n          // Property: All broken IDs should be in the broken references list\n          const brokenIds = new Set(brokenRefs.map(r => r.id));\n          for (const broken of result.data.brokenReferences) {\n            expect(brokenIds.has(broken.id)).toBe(true);\n          }\n\n          return true;\n        }\n      ),\n      { numRuns: 50 }\n    );\n  });\n});\n"],"names":["mockFrom","jest","fn","mockSupabase","from","mock","supabase","createMockQueryChain","resolvedValue","mockSingle","mockResolvedValue","mockEq","mockReturnValue","single","mockSelect","eq","select","describe","beforeEach","clearAllMocks","it","fc","assert","asyncProperty","array","record","type","constantFrom","id","uuid","label","option","string","minLength","maxLength","isDeleted","boolean","testReferences","ref","mockReturnValueOnce","data","error","code","message","references","map","r","undefined","result","validateReferences","expect","success","toBe","deletedRefs","filter","brokenReferences","length","broken","original","find","toBeDefined","hasDeletedEntities","some","valid","numRuns","existingRefs","testData","deletedRef","found","existingRef","toBeUndefined","toHaveLength","testRef","integer","min","max","validCount","brokenCount","validRefs","Array","_","i","brokenRefs","brokenIds","Set","has"],"mappings":"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"}