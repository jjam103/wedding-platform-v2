0140a7dc76b0c85180c72247edb70e40
/**
 * Property-Based Tests for Event Service Slug Generation from Title
 * 
 * **Property 26: Slug Generation from Title**
 * **Validates: Requirements 24.1**
 * 
 * Tests that slugs are correctly generated from event names following all transformation rules.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _eventService = require("./eventService");
const _slugs = require("../utils/slugs");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('Feature: guest-portal-and-admin-enhancements, Property 26: Slug Generation from Title', ()=>{
    // Clean up test events after each test
    const createdEventIds = [];
    afterEach(async ()=>{
        // Clean up all created events
        for (const id of createdEventIds){
            await (0, _eventService.deleteEvent)(id);
        }
        createdEventIds.length = 0;
    });
    /**
   * Property: Generated slug matches the expected transformation of the event name
   * 
   * The slug should be:
   * - Lowercase
   * - Spaces replaced with hyphens
   * - Special characters removed
   * - Multiple hyphens collapsed to single hyphen
   * - Leading/trailing hyphens removed
   */ it('should generate slug that matches expected transformation of event name', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.string({
            minLength: 3,
            maxLength: 50
        }).filter((s)=>/[a-zA-Z0-9]/.test(s)), _fastcheck.date(), async (name, startDate)=>{
            const result = await (0, _eventService.create)({
                name,
                eventType: 'ceremony',
                startDate: startDate.toISOString()
            });
            if (!result.success) {
                return true;
            }
            createdEventIds.push(result.data.id);
            // Generate expected slug using the same utility function
            const expectedBaseSlug = (0, _slugs.generateSlug)(name);
            // The actual slug should either match the expected slug or have a numeric suffix
            const actualSlug = result.data.slug;
            const hasNumericSuffix = /-\d+$/.test(actualSlug);
            if (hasNumericSuffix) {
                // Remove suffix and check base matches
                const baseSlug = actualSlug.replace(/-\d+$/, '');
                expect(baseSlug).toBe(expectedBaseSlug);
            } else {
                // Should match exactly
                expect(actualSlug).toBe(expectedBaseSlug);
            }
            return true;
        }), {
            numRuns: 100
        });
    });
    /**
   * Property: Slug generation is deterministic for the same input
   */ it('should generate the same base slug for identical event names', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.string({
            minLength: 3,
            maxLength: 30
        }).filter((s)=>/[a-zA-Z0-9]/.test(s)), _fastcheck.date(), async (name, startDate)=>{
            // Create first event
            const result1 = await (0, _eventService.create)({
                name,
                eventType: 'reception',
                startDate: startDate.toISOString()
            });
            if (!result1.success) {
                return true;
            }
            createdEventIds.push(result1.data.id);
            const slug1 = result1.data.slug;
            // Create second event with same name
            const result2 = await (0, _eventService.create)({
                name,
                eventType: 'reception',
                startDate: new Date(startDate.getTime() + 3600000).toISOString()
            });
            if (!result2.success) {
                return true;
            }
            createdEventIds.push(result2.data.id);
            const slug2 = result2.data.slug;
            // Second slug should be first slug with -2 suffix
            expect(slug2).toBe(`${slug1}-2`);
            return true;
        }), {
            numRuns: 30
        });
    });
    /**
   * Property: Slug generation handles mixed case correctly
   */ it('should convert mixed case event names to lowercase slugs', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.array(_fastcheck.string({
            minLength: 1,
            maxLength: 10
        }), {
            minLength: 2,
            maxLength: 4
        }), _fastcheck.date(), async (words, startDate)=>{
            // Create name with mixed case
            const name = words.map((word, i)=>i % 2 === 0 ? word.toUpperCase() : word.toLowerCase()).join(' ');
            if (!/[a-zA-Z0-9]/.test(name)) {
                return true;
            }
            const result = await (0, _eventService.create)({
                name,
                eventType: 'meal',
                startDate: startDate.toISOString()
            });
            if (!result.success) {
                return true;
            }
            createdEventIds.push(result.data.id);
            // Slug should be all lowercase
            expect(result.data.slug).toBe(result.data.slug.toLowerCase());
            expect(result.data.slug).not.toMatch(/[A-Z]/);
            return true;
        }), {
            numRuns: 50
        });
    });
    /**
   * Property: Slug generation removes leading and trailing whitespace
   */ it('should trim whitespace from event names when generating slugs', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.string({
            minLength: 3,
            maxLength: 20
        }).filter((s)=>/[a-zA-Z0-9]/.test(s)), _fastcheck.nat({
            max: 5
        }), _fastcheck.nat({
            max: 5
        }), _fastcheck.date(), async (baseName, leadingSpaces, trailingSpaces, startDate)=>{
            const name = ' '.repeat(leadingSpaces) + baseName + ' '.repeat(trailingSpaces);
            const result = await (0, _eventService.create)({
                name,
                eventType: 'activity',
                startDate: startDate.toISOString()
            });
            if (!result.success) {
                return true;
            }
            createdEventIds.push(result.data.id);
            // Slug should not have leading or trailing hyphens
            expect(result.data.slug).not.toMatch(/^-/);
            expect(result.data.slug).not.toMatch(/-$/);
            return true;
        }), {
            numRuns: 40
        });
    });
    /**
   * Property: Slug generation collapses multiple spaces to single hyphen
   */ it('should collapse multiple spaces to single hyphen in slugs', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.array(_fastcheck.string({
            minLength: 1,
            maxLength: 10
        }).filter((s)=>/[a-zA-Z0-9]/.test(s)), {
            minLength: 2,
            maxLength: 4
        }), _fastcheck.nat({
            min: 2,
            max: 5
        }), _fastcheck.date(), async (words, spaceCount, startDate)=>{
            const name = words.join(' '.repeat(spaceCount));
            const result = await (0, _eventService.create)({
                name,
                eventType: 'transport',
                startDate: startDate.toISOString()
            });
            if (!result.success) {
                return true;
            }
            createdEventIds.push(result.data.id);
            // Slug should not have consecutive hyphens
            expect(result.data.slug).not.toMatch(/--/);
            return true;
        }), {
            numRuns: 40
        });
    });
    /**
   * Property: Slug generation is consistent with utility function
   */ it('should generate slugs consistent with generateSlug utility', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.constantFrom('Wedding Ceremony', 'Reception Party', 'Beach Volleyball', 'Sunset Dinner', 'Welcome Drinks', 'Farewell Brunch'), _fastcheck.date(), async (name, startDate)=>{
            const result = await (0, _eventService.create)({
                name,
                eventType: 'ceremony',
                startDate: startDate.toISOString()
            });
            if (!result.success) {
                return true;
            }
            createdEventIds.push(result.data.id);
            // Generate expected slug
            const expectedSlug = (0, _slugs.generateSlug)(name);
            // Actual slug should match or have numeric suffix
            const actualSlug = result.data.slug;
            expect(actualSlug === expectedSlug || actualSlug.startsWith(`${expectedSlug}-`)).toBe(true);
            return true;
        }), {
            numRuns: 20
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvZXZlbnRTZXJ2aWNlLnNsdWdHZW5lcmF0aW9uLnByb3BlcnR5LnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQcm9wZXJ0eS1CYXNlZCBUZXN0cyBmb3IgRXZlbnQgU2VydmljZSBTbHVnIEdlbmVyYXRpb24gZnJvbSBUaXRsZVxuICogXG4gKiAqKlByb3BlcnR5IDI2OiBTbHVnIEdlbmVyYXRpb24gZnJvbSBUaXRsZSoqXG4gKiAqKlZhbGlkYXRlczogUmVxdWlyZW1lbnRzIDI0LjEqKlxuICogXG4gKiBUZXN0cyB0aGF0IHNsdWdzIGFyZSBjb3JyZWN0bHkgZ2VuZXJhdGVkIGZyb20gZXZlbnQgbmFtZXMgZm9sbG93aW5nIGFsbCB0cmFuc2Zvcm1hdGlvbiBydWxlcy5cbiAqL1xuXG5pbXBvcnQgKiBhcyBmYyBmcm9tICdmYXN0LWNoZWNrJztcbmltcG9ydCB7IGNyZWF0ZSwgZGVsZXRlRXZlbnQgfSBmcm9tICcuL2V2ZW50U2VydmljZSc7XG5pbXBvcnQgeyBnZW5lcmF0ZVNsdWcgfSBmcm9tICcuLi91dGlscy9zbHVncyc7XG5cbmRlc2NyaWJlKCdGZWF0dXJlOiBndWVzdC1wb3J0YWwtYW5kLWFkbWluLWVuaGFuY2VtZW50cywgUHJvcGVydHkgMjY6IFNsdWcgR2VuZXJhdGlvbiBmcm9tIFRpdGxlJywgKCkgPT4ge1xuICAvLyBDbGVhbiB1cCB0ZXN0IGV2ZW50cyBhZnRlciBlYWNoIHRlc3RcbiAgY29uc3QgY3JlYXRlZEV2ZW50SWRzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XG4gICAgLy8gQ2xlYW4gdXAgYWxsIGNyZWF0ZWQgZXZlbnRzXG4gICAgZm9yIChjb25zdCBpZCBvZiBjcmVhdGVkRXZlbnRJZHMpIHtcbiAgICAgIGF3YWl0IGRlbGV0ZUV2ZW50KGlkKTtcbiAgICB9XG4gICAgY3JlYXRlZEV2ZW50SWRzLmxlbmd0aCA9IDA7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQcm9wZXJ0eTogR2VuZXJhdGVkIHNsdWcgbWF0Y2hlcyB0aGUgZXhwZWN0ZWQgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGV2ZW50IG5hbWVcbiAgICogXG4gICAqIFRoZSBzbHVnIHNob3VsZCBiZTpcbiAgICogLSBMb3dlcmNhc2VcbiAgICogLSBTcGFjZXMgcmVwbGFjZWQgd2l0aCBoeXBoZW5zXG4gICAqIC0gU3BlY2lhbCBjaGFyYWN0ZXJzIHJlbW92ZWRcbiAgICogLSBNdWx0aXBsZSBoeXBoZW5zIGNvbGxhcHNlZCB0byBzaW5nbGUgaHlwaGVuXG4gICAqIC0gTGVhZGluZy90cmFpbGluZyBoeXBoZW5zIHJlbW92ZWRcbiAgICovXG4gIGl0KCdzaG91bGQgZ2VuZXJhdGUgc2x1ZyB0aGF0IG1hdGNoZXMgZXhwZWN0ZWQgdHJhbnNmb3JtYXRpb24gb2YgZXZlbnQgbmFtZScsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDMsIG1heExlbmd0aDogNTAgfSkuZmlsdGVyKHMgPT4gL1thLXpBLVowLTldLy50ZXN0KHMpKSxcbiAgICAgICAgZmMuZGF0ZSgpLFxuICAgICAgICBhc3luYyAobmFtZSwgc3RhcnREYXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3JlYXRlKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBldmVudFR5cGU6ICdjZXJlbW9ueScsXG4gICAgICAgICAgICBzdGFydERhdGU6IHN0YXJ0RGF0ZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3JlYXRlZEV2ZW50SWRzLnB1c2gocmVzdWx0LmRhdGEuaWQpO1xuXG4gICAgICAgICAgLy8gR2VuZXJhdGUgZXhwZWN0ZWQgc2x1ZyB1c2luZyB0aGUgc2FtZSB1dGlsaXR5IGZ1bmN0aW9uXG4gICAgICAgICAgY29uc3QgZXhwZWN0ZWRCYXNlU2x1ZyA9IGdlbmVyYXRlU2x1ZyhuYW1lKTtcblxuICAgICAgICAgIC8vIFRoZSBhY3R1YWwgc2x1ZyBzaG91bGQgZWl0aGVyIG1hdGNoIHRoZSBleHBlY3RlZCBzbHVnIG9yIGhhdmUgYSBudW1lcmljIHN1ZmZpeFxuICAgICAgICAgIGNvbnN0IGFjdHVhbFNsdWcgPSByZXN1bHQuZGF0YS5zbHVnO1xuICAgICAgICAgIGNvbnN0IGhhc051bWVyaWNTdWZmaXggPSAvLVxcZCskLy50ZXN0KGFjdHVhbFNsdWcpO1xuXG4gICAgICAgICAgaWYgKGhhc051bWVyaWNTdWZmaXgpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBzdWZmaXggYW5kIGNoZWNrIGJhc2UgbWF0Y2hlc1xuICAgICAgICAgICAgY29uc3QgYmFzZVNsdWcgPSBhY3R1YWxTbHVnLnJlcGxhY2UoLy1cXGQrJC8sICcnKTtcbiAgICAgICAgICAgIGV4cGVjdChiYXNlU2x1ZykudG9CZShleHBlY3RlZEJhc2VTbHVnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2hvdWxkIG1hdGNoIGV4YWN0bHlcbiAgICAgICAgICAgIGV4cGVjdChhY3R1YWxTbHVnKS50b0JlKGV4cGVjdGVkQmFzZVNsdWcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQcm9wZXJ0eTogU2x1ZyBnZW5lcmF0aW9uIGlzIGRldGVybWluaXN0aWMgZm9yIHRoZSBzYW1lIGlucHV0XG4gICAqL1xuICBpdCgnc2hvdWxkIGdlbmVyYXRlIHRoZSBzYW1lIGJhc2Ugc2x1ZyBmb3IgaWRlbnRpY2FsIGV2ZW50IG5hbWVzJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMywgbWF4TGVuZ3RoOiAzMCB9KS5maWx0ZXIocyA9PiAvW2EtekEtWjAtOV0vLnRlc3QocykpLFxuICAgICAgICBmYy5kYXRlKCksXG4gICAgICAgIGFzeW5jIChuYW1lLCBzdGFydERhdGUpID0+IHtcbiAgICAgICAgICAvLyBDcmVhdGUgZmlyc3QgZXZlbnRcbiAgICAgICAgICBjb25zdCByZXN1bHQxID0gYXdhaXQgY3JlYXRlKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBldmVudFR5cGU6ICdyZWNlcHRpb24nLFxuICAgICAgICAgICAgc3RhcnREYXRlOiBzdGFydERhdGUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghcmVzdWx0MS5zdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjcmVhdGVkRXZlbnRJZHMucHVzaChyZXN1bHQxLmRhdGEuaWQpO1xuICAgICAgICAgIGNvbnN0IHNsdWcxID0gcmVzdWx0MS5kYXRhLnNsdWc7XG5cbiAgICAgICAgICAvLyBDcmVhdGUgc2Vjb25kIGV2ZW50IHdpdGggc2FtZSBuYW1lXG4gICAgICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IGNyZWF0ZSh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZXZlbnRUeXBlOiAncmVjZXB0aW9uJyxcbiAgICAgICAgICAgIHN0YXJ0RGF0ZTogbmV3IERhdGUoc3RhcnREYXRlLmdldFRpbWUoKSArIDM2MDAwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIXJlc3VsdDIuc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3JlYXRlZEV2ZW50SWRzLnB1c2gocmVzdWx0Mi5kYXRhLmlkKTtcbiAgICAgICAgICBjb25zdCBzbHVnMiA9IHJlc3VsdDIuZGF0YS5zbHVnO1xuXG4gICAgICAgICAgLy8gU2Vjb25kIHNsdWcgc2hvdWxkIGJlIGZpcnN0IHNsdWcgd2l0aCAtMiBzdWZmaXhcbiAgICAgICAgICBleHBlY3Qoc2x1ZzIpLnRvQmUoYCR7c2x1ZzF9LTJgKTtcblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAzMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFByb3BlcnR5OiBTbHVnIGdlbmVyYXRpb24gaGFuZGxlcyBtaXhlZCBjYXNlIGNvcnJlY3RseVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBjb252ZXJ0IG1peGVkIGNhc2UgZXZlbnQgbmFtZXMgdG8gbG93ZXJjYXNlIHNsdWdzJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGZjLmFycmF5KGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxMCB9KSwgeyBtaW5MZW5ndGg6IDIsIG1heExlbmd0aDogNCB9KSxcbiAgICAgICAgZmMuZGF0ZSgpLFxuICAgICAgICBhc3luYyAod29yZHMsIHN0YXJ0RGF0ZSkgPT4ge1xuICAgICAgICAgIC8vIENyZWF0ZSBuYW1lIHdpdGggbWl4ZWQgY2FzZVxuICAgICAgICAgIGNvbnN0IG5hbWUgPSB3b3Jkcy5tYXAoKHdvcmQsIGkpID0+IFxuICAgICAgICAgICAgaSAlIDIgPT09IDAgPyB3b3JkLnRvVXBwZXJDYXNlKCkgOiB3b3JkLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICApLmpvaW4oJyAnKTtcblxuICAgICAgICAgIGlmICghL1thLXpBLVowLTldLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcmVhdGUoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGV2ZW50VHlwZTogJ21lYWwnLFxuICAgICAgICAgICAgc3RhcnREYXRlOiBzdGFydERhdGUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNyZWF0ZWRFdmVudElkcy5wdXNoKHJlc3VsdC5kYXRhLmlkKTtcblxuICAgICAgICAgIC8vIFNsdWcgc2hvdWxkIGJlIGFsbCBsb3dlcmNhc2VcbiAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuc2x1ZykudG9CZShyZXN1bHQuZGF0YS5zbHVnLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5zbHVnKS5ub3QudG9NYXRjaCgvW0EtWl0vKTtcblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiA1MCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFByb3BlcnR5OiBTbHVnIGdlbmVyYXRpb24gcmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAqL1xuICBpdCgnc2hvdWxkIHRyaW0gd2hpdGVzcGFjZSBmcm9tIGV2ZW50IG5hbWVzIHdoZW4gZ2VuZXJhdGluZyBzbHVncycsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDMsIG1heExlbmd0aDogMjAgfSkuZmlsdGVyKHMgPT4gL1thLXpBLVowLTldLy50ZXN0KHMpKSxcbiAgICAgICAgZmMubmF0KHsgbWF4OiA1IH0pLFxuICAgICAgICBmYy5uYXQoeyBtYXg6IDUgfSksXG4gICAgICAgIGZjLmRhdGUoKSxcbiAgICAgICAgYXN5bmMgKGJhc2VOYW1lLCBsZWFkaW5nU3BhY2VzLCB0cmFpbGluZ1NwYWNlcywgc3RhcnREYXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9ICcgJy5yZXBlYXQobGVhZGluZ1NwYWNlcykgKyBiYXNlTmFtZSArICcgJy5yZXBlYXQodHJhaWxpbmdTcGFjZXMpO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3JlYXRlKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBldmVudFR5cGU6ICdhY3Rpdml0eScsXG4gICAgICAgICAgICBzdGFydERhdGU6IHN0YXJ0RGF0ZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3JlYXRlZEV2ZW50SWRzLnB1c2gocmVzdWx0LmRhdGEuaWQpO1xuXG4gICAgICAgICAgLy8gU2x1ZyBzaG91bGQgbm90IGhhdmUgbGVhZGluZyBvciB0cmFpbGluZyBoeXBoZW5zXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnNsdWcpLm5vdC50b01hdGNoKC9eLS8pO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5zbHVnKS5ub3QudG9NYXRjaCgvLSQvKTtcblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiA0MCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFByb3BlcnR5OiBTbHVnIGdlbmVyYXRpb24gY29sbGFwc2VzIG11bHRpcGxlIHNwYWNlcyB0byBzaW5nbGUgaHlwaGVuXG4gICAqL1xuICBpdCgnc2hvdWxkIGNvbGxhcHNlIG11bHRpcGxlIHNwYWNlcyB0byBzaW5nbGUgaHlwaGVuIGluIHNsdWdzJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGZjLmFycmF5KGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxMCB9KS5maWx0ZXIocyA9PiAvW2EtekEtWjAtOV0vLnRlc3QocykpLCB7IG1pbkxlbmd0aDogMiwgbWF4TGVuZ3RoOiA0IH0pLFxuICAgICAgICBmYy5uYXQoeyBtaW46IDIsIG1heDogNSB9KSxcbiAgICAgICAgZmMuZGF0ZSgpLFxuICAgICAgICBhc3luYyAod29yZHMsIHNwYWNlQ291bnQsIHN0YXJ0RGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSB3b3Jkcy5qb2luKCcgJy5yZXBlYXQoc3BhY2VDb3VudCkpO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3JlYXRlKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBldmVudFR5cGU6ICd0cmFuc3BvcnQnLFxuICAgICAgICAgICAgc3RhcnREYXRlOiBzdGFydERhdGUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNyZWF0ZWRFdmVudElkcy5wdXNoKHJlc3VsdC5kYXRhLmlkKTtcblxuICAgICAgICAgIC8vIFNsdWcgc2hvdWxkIG5vdCBoYXZlIGNvbnNlY3V0aXZlIGh5cGhlbnNcbiAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuc2x1Zykubm90LnRvTWF0Y2goLy0tLyk7XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogNDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQcm9wZXJ0eTogU2x1ZyBnZW5lcmF0aW9uIGlzIGNvbnNpc3RlbnQgd2l0aCB1dGlsaXR5IGZ1bmN0aW9uXG4gICAqL1xuICBpdCgnc2hvdWxkIGdlbmVyYXRlIHNsdWdzIGNvbnNpc3RlbnQgd2l0aCBnZW5lcmF0ZVNsdWcgdXRpbGl0eScsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBmYy5jb25zdGFudEZyb20oXG4gICAgICAgICAgJ1dlZGRpbmcgQ2VyZW1vbnknLFxuICAgICAgICAgICdSZWNlcHRpb24gUGFydHknLFxuICAgICAgICAgICdCZWFjaCBWb2xsZXliYWxsJyxcbiAgICAgICAgICAnU3Vuc2V0IERpbm5lcicsXG4gICAgICAgICAgJ1dlbGNvbWUgRHJpbmtzJyxcbiAgICAgICAgICAnRmFyZXdlbGwgQnJ1bmNoJ1xuICAgICAgICApLFxuICAgICAgICBmYy5kYXRlKCksXG4gICAgICAgIGFzeW5jIChuYW1lLCBzdGFydERhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcmVhdGUoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGV2ZW50VHlwZTogJ2NlcmVtb255JyxcbiAgICAgICAgICAgIHN0YXJ0RGF0ZTogc3RhcnREYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjcmVhdGVkRXZlbnRJZHMucHVzaChyZXN1bHQuZGF0YS5pZCk7XG5cbiAgICAgICAgICAvLyBHZW5lcmF0ZSBleHBlY3RlZCBzbHVnXG4gICAgICAgICAgY29uc3QgZXhwZWN0ZWRTbHVnID0gZ2VuZXJhdGVTbHVnKG5hbWUpO1xuXG4gICAgICAgICAgLy8gQWN0dWFsIHNsdWcgc2hvdWxkIG1hdGNoIG9yIGhhdmUgbnVtZXJpYyBzdWZmaXhcbiAgICAgICAgICBjb25zdCBhY3R1YWxTbHVnID0gcmVzdWx0LmRhdGEuc2x1ZztcbiAgICAgICAgICBleHBlY3QoYWN0dWFsU2x1ZyA9PT0gZXhwZWN0ZWRTbHVnIHx8IGFjdHVhbFNsdWcuc3RhcnRzV2l0aChgJHtleHBlY3RlZFNsdWd9LWApKS50b0JlKHRydWUpO1xuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDIwIH1cbiAgICApO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImRlc2NyaWJlIiwiY3JlYXRlZEV2ZW50SWRzIiwiYWZ0ZXJFYWNoIiwiaWQiLCJkZWxldGVFdmVudCIsImxlbmd0aCIsIml0IiwiZmMiLCJhc3NlcnQiLCJhc3luY1Byb3BlcnR5Iiwic3RyaW5nIiwibWluTGVuZ3RoIiwibWF4TGVuZ3RoIiwiZmlsdGVyIiwicyIsInRlc3QiLCJkYXRlIiwibmFtZSIsInN0YXJ0RGF0ZSIsInJlc3VsdCIsImNyZWF0ZSIsImV2ZW50VHlwZSIsInRvSVNPU3RyaW5nIiwic3VjY2VzcyIsInB1c2giLCJkYXRhIiwiZXhwZWN0ZWRCYXNlU2x1ZyIsImdlbmVyYXRlU2x1ZyIsImFjdHVhbFNsdWciLCJzbHVnIiwiaGFzTnVtZXJpY1N1ZmZpeCIsImJhc2VTbHVnIiwicmVwbGFjZSIsImV4cGVjdCIsInRvQmUiLCJudW1SdW5zIiwicmVzdWx0MSIsInNsdWcxIiwicmVzdWx0MiIsIkRhdGUiLCJnZXRUaW1lIiwic2x1ZzIiLCJhcnJheSIsIndvcmRzIiwibWFwIiwid29yZCIsImkiLCJ0b1VwcGVyQ2FzZSIsInRvTG93ZXJDYXNlIiwiam9pbiIsIm5vdCIsInRvTWF0Y2giLCJuYXQiLCJtYXgiLCJiYXNlTmFtZSIsImxlYWRpbmdTcGFjZXMiLCJ0cmFpbGluZ1NwYWNlcyIsInJlcGVhdCIsIm1pbiIsInNwYWNlQ291bnQiLCJjb25zdGFudEZyb20iLCJleHBlY3RlZFNsdWciLCJzdGFydHNXaXRoIl0s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