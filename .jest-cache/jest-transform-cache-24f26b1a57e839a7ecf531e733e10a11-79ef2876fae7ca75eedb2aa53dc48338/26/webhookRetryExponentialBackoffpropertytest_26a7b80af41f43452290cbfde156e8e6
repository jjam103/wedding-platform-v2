e50b4d3044e32083309984d76ab1bb90
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _webhookService = require("./webhookService");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
/**
 * Feature: destination-wedding-platform, Property 32: Webhook Retry Exponential Backoff
 * 
 * For any failed webhook delivery, the retry delays should follow exponential backoff
 * (e.g., 1s, 2s, 4s, 8s), with each retry delay being approximately double the previous delay.
 * 
 * Validates: Requirements 19.6
 */ describe('Feature: destination-wedding-platform, Property 32: Webhook Retry Exponential Backoff', ()=>{
    describe('Exponential backoff calculation', ()=>{
        it('should follow exponential backoff pattern for retry delays', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.integer({
                min: 0,
                max: 10
            }), _fastcheck.integer({
                min: 100,
                max: 5000
            }), (attempt, baseDelay)=>{
                const delay = (0, _webhookService.calculateRetryDelay)(attempt, baseDelay);
                // Expected delay is baseDelay * 2^attempt (with jitter)
                const expectedDelay = baseDelay * Math.pow(2, attempt);
                // Allow for 10% jitter
                const minDelay = expectedDelay * 0.9;
                const maxDelay = expectedDelay * 1.1;
                expect(delay).toBeGreaterThanOrEqual(minDelay);
                expect(delay).toBeLessThanOrEqual(maxDelay);
            }), {
                numRuns: 100
            });
        });
        it('should double the delay with each retry attempt', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.integer({
                min: 0,
                max: 9
            }), _fastcheck.integer({
                min: 100,
                max: 2000
            }), (attempt, baseDelay)=>{
                const delay1 = (0, _webhookService.calculateRetryDelay)(attempt, baseDelay);
                const delay2 = (0, _webhookService.calculateRetryDelay)(attempt + 1, baseDelay);
                // Second delay should be approximately double the first
                // Account for jitter by checking a range
                const ratio = delay2 / delay1;
                // Ratio should be close to 2 (between 1.8 and 2.2 accounting for jitter)
                expect(ratio).toBeGreaterThan(1.8);
                expect(ratio).toBeLessThan(2.2);
            }), {
                numRuns: 100
            });
        });
        it('should increase monotonically with attempt number', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.integer({
                min: 0,
                max: 9
            }), _fastcheck.integer({
                min: 100,
                max: 2000
            }), (attempt, baseDelay)=>{
                const delays = [];
                for(let i = attempt; i <= attempt + 3; i++){
                    delays.push((0, _webhookService.calculateRetryDelay)(i, baseDelay));
                }
                // Each delay should be greater than the previous (accounting for jitter)
                for(let i = 1; i < delays.length; i++){
                    // Allow small variance due to jitter, but overall trend should be increasing
                    expect(delays[i]).toBeGreaterThan(delays[i - 1] * 0.9);
                }
            }), {
                numRuns: 100
            });
        });
    });
    describe('Base delay parameter', ()=>{
        it('should scale proportionally with base delay', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.integer({
                min: 0,
                max: 5
            }), _fastcheck.integer({
                min: 100,
                max: 1000
            }), (attempt, baseDelay)=>{
                const delay1 = (0, _webhookService.calculateRetryDelay)(attempt, baseDelay);
                const delay2 = (0, _webhookService.calculateRetryDelay)(attempt, baseDelay * 2);
                // Doubling base delay should approximately double the result
                const ratio = delay2 / delay1;
                // Account for jitter - ratio should be close to 2
                expect(ratio).toBeGreaterThan(1.8);
                expect(ratio).toBeLessThan(2.2);
            }), {
                numRuns: 100
            });
        });
        it('should use default base delay of 1000ms when not specified', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.integer({
                min: 0,
                max: 5
            }), (attempt)=>{
                const delayWithDefault = (0, _webhookService.calculateRetryDelay)(attempt);
                const delayWithExplicit = (0, _webhookService.calculateRetryDelay)(attempt, 1000);
                // Both should produce similar results (within jitter range)
                const ratio = delayWithDefault / delayWithExplicit;
                expect(ratio).toBeGreaterThan(0.9);
                expect(ratio).toBeLessThan(1.1);
            }), {
                numRuns: 100
            });
        });
    });
    describe('Edge cases', ()=>{
        it('should handle attempt 0 correctly', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.integer({
                min: 100,
                max: 5000
            }), (baseDelay)=>{
                const delay = (0, _webhookService.calculateRetryDelay)(0, baseDelay);
                // For attempt 0, delay should be baseDelay * 2^0 = baseDelay (with jitter)
                expect(delay).toBeGreaterThanOrEqual(baseDelay * 0.9);
                expect(delay).toBeLessThanOrEqual(baseDelay * 1.1);
            }), {
                numRuns: 100
            });
        });
        it('should handle large attempt numbers without overflow', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.integer({
                min: 10,
                max: 20
            }), _fastcheck.integer({
                min: 100,
                max: 1000
            }), (attempt, baseDelay)=>{
                const delay = (0, _webhookService.calculateRetryDelay)(attempt, baseDelay);
                // Should return a finite number
                expect(Number.isFinite(delay)).toBe(true);
                expect(delay).toBeGreaterThan(0);
                // Should still follow exponential pattern
                const expectedDelay = baseDelay * Math.pow(2, attempt);
                expect(delay).toBeGreaterThan(expectedDelay * 0.9);
                expect(delay).toBeLessThan(expectedDelay * 1.1);
            }), {
                numRuns: 50
            });
        });
        it('should return integer milliseconds', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.integer({
                min: 0,
                max: 10
            }), _fastcheck.integer({
                min: 100,
                max: 5000
            }), (attempt, baseDelay)=>{
                const delay = (0, _webhookService.calculateRetryDelay)(attempt, baseDelay);
                // Should be an integer (no fractional milliseconds)
                expect(Number.isInteger(delay)).toBe(true);
            }), {
                numRuns: 100
            });
        });
    });
    describe('Jitter properties', ()=>{
        it('should add randomness to prevent thundering herd', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.integer({
                min: 0,
                max: 5
            }), _fastcheck.integer({
                min: 1000,
                max: 2000
            }), (attempt, baseDelay)=>{
                // Generate multiple delays for the same attempt
                const delays = Array.from({
                    length: 10
                }, ()=>(0, _webhookService.calculateRetryDelay)(attempt, baseDelay));
                // Not all delays should be identical (jitter adds randomness)
                const uniqueDelays = new Set(delays);
                // With 10 samples, we should see some variation
                // (might occasionally fail due to randomness, but very unlikely)
                expect(uniqueDelays.size).toBeGreaterThan(1);
            }), {
                numRuns: 50
            });
        });
        it('should keep jitter within 10% of base exponential delay', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.integer({
                min: 0,
                max: 10
            }), _fastcheck.integer({
                min: 100,
                max: 5000
            }), (attempt, baseDelay)=>{
                const delay = (0, _webhookService.calculateRetryDelay)(attempt, baseDelay);
                const expectedDelay = baseDelay * Math.pow(2, attempt);
                // Jitter should be within 10% of expected delay
                const minDelay = expectedDelay * 0.9;
                const maxDelay = expectedDelay * 1.1;
                expect(delay).toBeGreaterThanOrEqual(minDelay);
                expect(delay).toBeLessThanOrEqual(maxDelay);
            }), {
                numRuns: 100
            });
        });
    });
    describe('Practical retry scenarios', ()=>{
        it('should produce reasonable delays for typical retry sequences', ()=>{
            const baseDelay = 1000; // 1 second
            const delays = [];
            for(let attempt = 0; attempt < 5; attempt++){
                delays.push((0, _webhookService.calculateRetryDelay)(attempt, baseDelay));
            }
            // Verify the sequence follows exponential pattern
            // Attempt 0: ~1s, Attempt 1: ~2s, Attempt 2: ~4s, Attempt 3: ~8s, Attempt 4: ~16s
            expect(delays[0]).toBeGreaterThan(900);
            expect(delays[0]).toBeLessThan(1100);
            expect(delays[1]).toBeGreaterThan(1800);
            expect(delays[1]).toBeLessThan(2200);
            expect(delays[2]).toBeGreaterThan(3600);
            expect(delays[2]).toBeLessThan(4400);
            expect(delays[3]).toBeGreaterThan(7200);
            expect(delays[3]).toBeLessThan(8800);
            expect(delays[4]).toBeGreaterThan(14400);
            expect(delays[4]).toBeLessThan(17600);
        });
        it('should handle different base delays appropriately', ()=>{
            const attempt = 3;
            const delay100 = (0, _webhookService.calculateRetryDelay)(attempt, 100);
            const delay1000 = (0, _webhookService.calculateRetryDelay)(attempt, 1000);
            const delay5000 = (0, _webhookService.calculateRetryDelay)(attempt, 5000);
            // Delays should scale with base delay
            expect(delay1000).toBeGreaterThan(delay100 * 9);
            expect(delay1000).toBeLessThan(delay100 * 11);
            expect(delay5000).toBeGreaterThan(delay1000 * 4.5);
            expect(delay5000).toBeLessThan(delay1000 * 5.5);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvd2ViaG9va1JldHJ5RXhwb25lbnRpYWxCYWNrb2ZmLnByb3BlcnR5LnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZmMgZnJvbSAnZmFzdC1jaGVjayc7XG5pbXBvcnQgeyBjYWxjdWxhdGVSZXRyeURlbGF5IH0gZnJvbSAnLi93ZWJob29rU2VydmljZSc7XG5cbi8qKlxuICogRmVhdHVyZTogZGVzdGluYXRpb24td2VkZGluZy1wbGF0Zm9ybSwgUHJvcGVydHkgMzI6IFdlYmhvb2sgUmV0cnkgRXhwb25lbnRpYWwgQmFja29mZlxuICogXG4gKiBGb3IgYW55IGZhaWxlZCB3ZWJob29rIGRlbGl2ZXJ5LCB0aGUgcmV0cnkgZGVsYXlzIHNob3VsZCBmb2xsb3cgZXhwb25lbnRpYWwgYmFja29mZlxuICogKGUuZy4sIDFzLCAycywgNHMsIDhzKSwgd2l0aCBlYWNoIHJldHJ5IGRlbGF5IGJlaW5nIGFwcHJveGltYXRlbHkgZG91YmxlIHRoZSBwcmV2aW91cyBkZWxheS5cbiAqIFxuICogVmFsaWRhdGVzOiBSZXF1aXJlbWVudHMgMTkuNlxuICovXG5cbmRlc2NyaWJlKCdGZWF0dXJlOiBkZXN0aW5hdGlvbi13ZWRkaW5nLXBsYXRmb3JtLCBQcm9wZXJ0eSAzMjogV2ViaG9vayBSZXRyeSBFeHBvbmVudGlhbCBCYWNrb2ZmJywgKCkgPT4ge1xuICBkZXNjcmliZSgnRXhwb25lbnRpYWwgYmFja29mZiBjYWxjdWxhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGZvbGxvdyBleHBvbmVudGlhbCBiYWNrb2ZmIHBhdHRlcm4gZm9yIHJldHJ5IGRlbGF5cycsICgpID0+IHtcbiAgICAgIGZjLmFzc2VydChcbiAgICAgICAgZmMucHJvcGVydHkoXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMCwgbWF4OiAxMCB9KSwgLy8gYXR0ZW1wdCBudW1iZXJcbiAgICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAxMDAsIG1heDogNTAwMCB9KSwgLy8gYmFzZSBkZWxheVxuICAgICAgICAgIChhdHRlbXB0LCBiYXNlRGVsYXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gY2FsY3VsYXRlUmV0cnlEZWxheShhdHRlbXB0LCBiYXNlRGVsYXkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBFeHBlY3RlZCBkZWxheSBpcyBiYXNlRGVsYXkgKiAyXmF0dGVtcHQgKHdpdGggaml0dGVyKVxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWREZWxheSA9IGJhc2VEZWxheSAqIE1hdGgucG93KDIsIGF0dGVtcHQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBbGxvdyBmb3IgMTAlIGppdHRlclxuICAgICAgICAgICAgY29uc3QgbWluRGVsYXkgPSBleHBlY3RlZERlbGF5ICogMC45O1xuICAgICAgICAgICAgY29uc3QgbWF4RGVsYXkgPSBleHBlY3RlZERlbGF5ICogMS4xO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHBlY3QoZGVsYXkpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwobWluRGVsYXkpO1xuICAgICAgICAgICAgZXhwZWN0KGRlbGF5KS50b0JlTGVzc1RoYW5PckVxdWFsKG1heERlbGF5KTtcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRvdWJsZSB0aGUgZGVsYXkgd2l0aCBlYWNoIHJldHJ5IGF0dGVtcHQnLCAoKSA9PiB7XG4gICAgICBmYy5hc3NlcnQoXG4gICAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDAsIG1heDogOSB9KSwgLy8gYXR0ZW1wdCBudW1iZXIgKGxlYXZlIHJvb20gZm9yIGF0dGVtcHQgKyAxKVxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDEwMCwgbWF4OiAyMDAwIH0pLCAvLyBiYXNlIGRlbGF5XG4gICAgICAgICAgKGF0dGVtcHQsIGJhc2VEZWxheSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVsYXkxID0gY2FsY3VsYXRlUmV0cnlEZWxheShhdHRlbXB0LCBiYXNlRGVsYXkpO1xuICAgICAgICAgICAgY29uc3QgZGVsYXkyID0gY2FsY3VsYXRlUmV0cnlEZWxheShhdHRlbXB0ICsgMSwgYmFzZURlbGF5KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU2Vjb25kIGRlbGF5IHNob3VsZCBiZSBhcHByb3hpbWF0ZWx5IGRvdWJsZSB0aGUgZmlyc3RcbiAgICAgICAgICAgIC8vIEFjY291bnQgZm9yIGppdHRlciBieSBjaGVja2luZyBhIHJhbmdlXG4gICAgICAgICAgICBjb25zdCByYXRpbyA9IGRlbGF5MiAvIGRlbGF5MTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUmF0aW8gc2hvdWxkIGJlIGNsb3NlIHRvIDIgKGJldHdlZW4gMS44IGFuZCAyLjIgYWNjb3VudGluZyBmb3Igaml0dGVyKVxuICAgICAgICAgICAgZXhwZWN0KHJhdGlvKS50b0JlR3JlYXRlclRoYW4oMS44KTtcbiAgICAgICAgICAgIGV4cGVjdChyYXRpbykudG9CZUxlc3NUaGFuKDIuMik7XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBpbmNyZWFzZSBtb25vdG9uaWNhbGx5IHdpdGggYXR0ZW1wdCBudW1iZXInLCAoKSA9PiB7XG4gICAgICBmYy5hc3NlcnQoXG4gICAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDAsIG1heDogOSB9KSxcbiAgICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAxMDAsIG1heDogMjAwMCB9KSxcbiAgICAgICAgICAoYXR0ZW1wdCwgYmFzZURlbGF5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWxheXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBhdHRlbXB0OyBpIDw9IGF0dGVtcHQgKyAzOyBpKyspIHtcbiAgICAgICAgICAgICAgZGVsYXlzLnB1c2goY2FsY3VsYXRlUmV0cnlEZWxheShpLCBiYXNlRGVsYXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRWFjaCBkZWxheSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIHRoZSBwcmV2aW91cyAoYWNjb3VudGluZyBmb3Igaml0dGVyKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkZWxheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgLy8gQWxsb3cgc21hbGwgdmFyaWFuY2UgZHVlIHRvIGppdHRlciwgYnV0IG92ZXJhbGwgdHJlbmQgc2hvdWxkIGJlIGluY3JlYXNpbmdcbiAgICAgICAgICAgICAgZXhwZWN0KGRlbGF5c1tpXSkudG9CZUdyZWF0ZXJUaGFuKGRlbGF5c1tpIC0gMV0gKiAwLjkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Jhc2UgZGVsYXkgcGFyYW1ldGVyJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgc2NhbGUgcHJvcG9ydGlvbmFsbHkgd2l0aCBiYXNlIGRlbGF5JywgKCkgPT4ge1xuICAgICAgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5wcm9wZXJ0eShcbiAgICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAwLCBtYXg6IDUgfSksXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMTAwLCBtYXg6IDEwMDAgfSksXG4gICAgICAgICAgKGF0dGVtcHQsIGJhc2VEZWxheSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVsYXkxID0gY2FsY3VsYXRlUmV0cnlEZWxheShhdHRlbXB0LCBiYXNlRGVsYXkpO1xuICAgICAgICAgICAgY29uc3QgZGVsYXkyID0gY2FsY3VsYXRlUmV0cnlEZWxheShhdHRlbXB0LCBiYXNlRGVsYXkgKiAyKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRG91YmxpbmcgYmFzZSBkZWxheSBzaG91bGQgYXBwcm94aW1hdGVseSBkb3VibGUgdGhlIHJlc3VsdFxuICAgICAgICAgICAgY29uc3QgcmF0aW8gPSBkZWxheTIgLyBkZWxheTE7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFjY291bnQgZm9yIGppdHRlciAtIHJhdGlvIHNob3VsZCBiZSBjbG9zZSB0byAyXG4gICAgICAgICAgICBleHBlY3QocmF0aW8pLnRvQmVHcmVhdGVyVGhhbigxLjgpO1xuICAgICAgICAgICAgZXhwZWN0KHJhdGlvKS50b0JlTGVzc1RoYW4oMi4yKTtcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHVzZSBkZWZhdWx0IGJhc2UgZGVsYXkgb2YgMTAwMG1zIHdoZW4gbm90IHNwZWNpZmllZCcsICgpID0+IHtcbiAgICAgIGZjLmFzc2VydChcbiAgICAgICAgZmMucHJvcGVydHkoXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMCwgbWF4OiA1IH0pLFxuICAgICAgICAgIChhdHRlbXB0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWxheVdpdGhEZWZhdWx0ID0gY2FsY3VsYXRlUmV0cnlEZWxheShhdHRlbXB0KTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5V2l0aEV4cGxpY2l0ID0gY2FsY3VsYXRlUmV0cnlEZWxheShhdHRlbXB0LCAxMDAwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQm90aCBzaG91bGQgcHJvZHVjZSBzaW1pbGFyIHJlc3VsdHMgKHdpdGhpbiBqaXR0ZXIgcmFuZ2UpXG4gICAgICAgICAgICBjb25zdCByYXRpbyA9IGRlbGF5V2l0aERlZmF1bHQgLyBkZWxheVdpdGhFeHBsaWNpdDtcbiAgICAgICAgICAgIGV4cGVjdChyYXRpbykudG9CZUdyZWF0ZXJUaGFuKDAuOSk7XG4gICAgICAgICAgICBleHBlY3QocmF0aW8pLnRvQmVMZXNzVGhhbigxLjEpO1xuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0VkZ2UgY2FzZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYXR0ZW1wdCAwIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGZjLmFzc2VydChcbiAgICAgICAgZmMucHJvcGVydHkoXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMTAwLCBtYXg6IDUwMDAgfSksXG4gICAgICAgICAgKGJhc2VEZWxheSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVsYXkgPSBjYWxjdWxhdGVSZXRyeURlbGF5KDAsIGJhc2VEZWxheSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEZvciBhdHRlbXB0IDAsIGRlbGF5IHNob3VsZCBiZSBiYXNlRGVsYXkgKiAyXjAgPSBiYXNlRGVsYXkgKHdpdGggaml0dGVyKVxuICAgICAgICAgICAgZXhwZWN0KGRlbGF5KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKGJhc2VEZWxheSAqIDAuOSk7XG4gICAgICAgICAgICBleHBlY3QoZGVsYXkpLnRvQmVMZXNzVGhhbk9yRXF1YWwoYmFzZURlbGF5ICogMS4xKTtcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBsYXJnZSBhdHRlbXB0IG51bWJlcnMgd2l0aG91dCBvdmVyZmxvdycsICgpID0+IHtcbiAgICAgIGZjLmFzc2VydChcbiAgICAgICAgZmMucHJvcGVydHkoXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMTAsIG1heDogMjAgfSksXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMTAwLCBtYXg6IDEwMDAgfSksXG4gICAgICAgICAgKGF0dGVtcHQsIGJhc2VEZWxheSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVsYXkgPSBjYWxjdWxhdGVSZXRyeURlbGF5KGF0dGVtcHQsIGJhc2VEZWxheSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNob3VsZCByZXR1cm4gYSBmaW5pdGUgbnVtYmVyXG4gICAgICAgICAgICBleHBlY3QoTnVtYmVyLmlzRmluaXRlKGRlbGF5KSkudG9CZSh0cnVlKTtcbiAgICAgICAgICAgIGV4cGVjdChkZWxheSkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTaG91bGQgc3RpbGwgZm9sbG93IGV4cG9uZW50aWFsIHBhdHRlcm5cbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkRGVsYXkgPSBiYXNlRGVsYXkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KTtcbiAgICAgICAgICAgIGV4cGVjdChkZWxheSkudG9CZUdyZWF0ZXJUaGFuKGV4cGVjdGVkRGVsYXkgKiAwLjkpO1xuICAgICAgICAgICAgZXhwZWN0KGRlbGF5KS50b0JlTGVzc1RoYW4oZXhwZWN0ZWREZWxheSAqIDEuMSk7XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDUwIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBpbnRlZ2VyIG1pbGxpc2Vjb25kcycsICgpID0+IHtcbiAgICAgIGZjLmFzc2VydChcbiAgICAgICAgZmMucHJvcGVydHkoXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMCwgbWF4OiAxMCB9KSxcbiAgICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAxMDAsIG1heDogNTAwMCB9KSxcbiAgICAgICAgICAoYXR0ZW1wdCwgYmFzZURlbGF5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWxheSA9IGNhbGN1bGF0ZVJldHJ5RGVsYXkoYXR0ZW1wdCwgYmFzZURlbGF5KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU2hvdWxkIGJlIGFuIGludGVnZXIgKG5vIGZyYWN0aW9uYWwgbWlsbGlzZWNvbmRzKVxuICAgICAgICAgICAgZXhwZWN0KE51bWJlci5pc0ludGVnZXIoZGVsYXkpKS50b0JlKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ppdHRlciBwcm9wZXJ0aWVzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgYWRkIHJhbmRvbW5lc3MgdG8gcHJldmVudCB0aHVuZGVyaW5nIGhlcmQnLCAoKSA9PiB7XG4gICAgICBmYy5hc3NlcnQoXG4gICAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDAsIG1heDogNSB9KSxcbiAgICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAxMDAwLCBtYXg6IDIwMDAgfSksXG4gICAgICAgICAgKGF0dGVtcHQsIGJhc2VEZWxheSkgPT4ge1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgbXVsdGlwbGUgZGVsYXlzIGZvciB0aGUgc2FtZSBhdHRlbXB0XG4gICAgICAgICAgICBjb25zdCBkZWxheXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMCB9LCAoKSA9PlxuICAgICAgICAgICAgICBjYWxjdWxhdGVSZXRyeURlbGF5KGF0dGVtcHQsIGJhc2VEZWxheSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE5vdCBhbGwgZGVsYXlzIHNob3VsZCBiZSBpZGVudGljYWwgKGppdHRlciBhZGRzIHJhbmRvbW5lc3MpXG4gICAgICAgICAgICBjb25zdCB1bmlxdWVEZWxheXMgPSBuZXcgU2V0KGRlbGF5cyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFdpdGggMTAgc2FtcGxlcywgd2Ugc2hvdWxkIHNlZSBzb21lIHZhcmlhdGlvblxuICAgICAgICAgICAgLy8gKG1pZ2h0IG9jY2FzaW9uYWxseSBmYWlsIGR1ZSB0byByYW5kb21uZXNzLCBidXQgdmVyeSB1bmxpa2VseSlcbiAgICAgICAgICAgIGV4cGVjdCh1bmlxdWVEZWxheXMuc2l6ZSkudG9CZUdyZWF0ZXJUaGFuKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgeyBudW1SdW5zOiA1MCB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBrZWVwIGppdHRlciB3aXRoaW4gMTAlIG9mIGJhc2UgZXhwb25lbnRpYWwgZGVsYXknLCAoKSA9PiB7XG4gICAgICBmYy5hc3NlcnQoXG4gICAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDAsIG1heDogMTAgfSksXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMTAwLCBtYXg6IDUwMDAgfSksXG4gICAgICAgICAgKGF0dGVtcHQsIGJhc2VEZWxheSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVsYXkgPSBjYWxjdWxhdGVSZXRyeURlbGF5KGF0dGVtcHQsIGJhc2VEZWxheSk7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZERlbGF5ID0gYmFzZURlbGF5ICogTWF0aC5wb3coMiwgYXR0ZW1wdCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEppdHRlciBzaG91bGQgYmUgd2l0aGluIDEwJSBvZiBleHBlY3RlZCBkZWxheVxuICAgICAgICAgICAgY29uc3QgbWluRGVsYXkgPSBleHBlY3RlZERlbGF5ICogMC45O1xuICAgICAgICAgICAgY29uc3QgbWF4RGVsYXkgPSBleHBlY3RlZERlbGF5ICogMS4xO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHBlY3QoZGVsYXkpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwobWluRGVsYXkpO1xuICAgICAgICAgICAgZXhwZWN0KGRlbGF5KS50b0JlTGVzc1RoYW5PckVxdWFsKG1heERlbGF5KTtcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQcmFjdGljYWwgcmV0cnkgc2NlbmFyaW9zJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcHJvZHVjZSByZWFzb25hYmxlIGRlbGF5cyBmb3IgdHlwaWNhbCByZXRyeSBzZXF1ZW5jZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBiYXNlRGVsYXkgPSAxMDAwOyAvLyAxIHNlY29uZFxuICAgICAgY29uc3QgZGVsYXlzID0gW107XG4gICAgICBcbiAgICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgNTsgYXR0ZW1wdCsrKSB7XG4gICAgICAgIGRlbGF5cy5wdXNoKGNhbGN1bGF0ZVJldHJ5RGVsYXkoYXR0ZW1wdCwgYmFzZURlbGF5KSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSB0aGUgc2VxdWVuY2UgZm9sbG93cyBleHBvbmVudGlhbCBwYXR0ZXJuXG4gICAgICAvLyBBdHRlbXB0IDA6IH4xcywgQXR0ZW1wdCAxOiB+MnMsIEF0dGVtcHQgMjogfjRzLCBBdHRlbXB0IDM6IH44cywgQXR0ZW1wdCA0OiB+MTZzXG4gICAgICBleHBlY3QoZGVsYXlzWzBdKS50b0JlR3JlYXRlclRoYW4oOTAwKTtcbiAgICAgIGV4cGVjdChkZWxheXNbMF0pLnRvQmVMZXNzVGhhbigxMTAwKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGRlbGF5c1sxXSkudG9CZUdyZWF0ZXJUaGFuKDE4MDApO1xuICAgICAgZXhwZWN0KGRlbGF5c1sxXSkudG9CZUxlc3NUaGFuKDIyMDApO1xuICAgICAgXG4gICAgICBleHBlY3QoZGVsYXlzWzJdKS50b0JlR3JlYXRlclRoYW4oMzYwMCk7XG4gICAgICBleHBlY3QoZGVsYXlzWzJdKS50b0JlTGVzc1RoYW4oNDQwMCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChkZWxheXNbM10pLnRvQmVHcmVhdGVyVGhhbig3MjAwKTtcbiAgICAgIGV4cGVjdChkZWxheXNbM10pLnRvQmVMZXNzVGhhbig4ODAwKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGRlbGF5c1s0XSkudG9CZUdyZWF0ZXJUaGFuKDE0NDAwKTtcbiAgICAgIGV4cGVjdChkZWxheXNbNF0pLnRvQmVMZXNzVGhhbigxNzYwMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBkaWZmZXJlbnQgYmFzZSBkZWxheXMgYXBwcm9wcmlhdGVseScsICgpID0+IHtcbiAgICAgIGNvbnN0IGF0dGVtcHQgPSAzO1xuICAgICAgXG4gICAgICBjb25zdCBkZWxheTEwMCA9IGNhbGN1bGF0ZVJldHJ5RGVsYXkoYXR0ZW1wdCwgMTAwKTtcbiAgICAgIGNvbnN0IGRlbGF5MTAwMCA9IGNhbGN1bGF0ZVJldHJ5RGVsYXkoYXR0ZW1wdCwgMTAwMCk7XG4gICAgICBjb25zdCBkZWxheTUwMDAgPSBjYWxjdWxhdGVSZXRyeURlbGF5KGF0dGVtcHQsIDUwMDApO1xuICAgICAgXG4gICAgICAvLyBEZWxheXMgc2hvdWxkIHNjYWxlIHdpdGggYmFzZSBkZWxheVxuICAgICAgZXhwZWN0KGRlbGF5MTAwMCkudG9CZUdyZWF0ZXJUaGFuKGRlbGF5MTAwICogOSk7XG4gICAgICBleHBlY3QoZGVsYXkxMDAwKS50b0JlTGVzc1RoYW4oZGVsYXkxMDAgKiAxMSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChkZWxheTUwMDApLnRvQmVHcmVhdGVyVGhhbihkZWxheTEwMDAgKiA0LjUpO1xuICAgICAgZXhwZWN0KGRlbGF5NTAwMCkudG9CZUxlc3NUaGFuKGRlbGF5MTAwMCAqIDUuNSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJpdCIsImZjIiwiYXNzZXJ0IiwicHJvcGVydHkiLCJpbnRlZ2VyIiwibWluIiwibWF4IiwiYXR0ZW1wdCIsImJhc2VEZWxheSIsImRlbGF5IiwiY2FsY3VsYXRlUmV0cnlEZWxheSIsImV4cGVjdGVkRGVsYXkiLCJNYXRoIiwicG93IiwibWluRGVsYXkiLCJtYXhEZWxheSIsImV4cGVjdCIsInRvQmVHcmVhdGVyVGhhbk9yRXF1YWwiLCJ0b0JlTGVzc1RoYW5PckVxdWFsIiwibnVtUnVucyIsImRlbGF5MSIsImRlbGF5MiIsInJhdGlvIiwidG9CZUdyZWF0ZXJUaGFuIiwidG9CZUxlc3NUaGFuIiwiZGVsYXlzIiwiaSIsInB1c2giLCJsZW5ndGgiLCJkZWxheVdpdGhEZWZhdWx0IiwiZGVsYXlXaXRoRXhwbGljaXQiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInRvQmUiLCJpc0ludGVnZXIiLCJBcnJheSIsImZyb20iLCJ1bmlxdWVEZWxheXMiLCJTZXQiLCJzaXplIiwiZGVsYXkxMDAiLCJkZWxheTEwMDAiLCJkZWxheTUwMDAiXSwibWFwcGluZ3MiOiI7Ozs7bUVBQW9CO2dDQUNnQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRXBDOzs7Ozs7O0NBT0MsR0FFREEsU0FBUyx5RkFBeUY7SUFDaEdBLFNBQVMsbUNBQW1DO1FBQzFDQyxHQUFHLDhEQUE4RDtZQUMvREMsV0FBR0MsTUFBTSxDQUNQRCxXQUFHRSxRQUFRLENBQ1RGLFdBQUdHLE9BQU8sQ0FBQztnQkFBRUMsS0FBSztnQkFBR0MsS0FBSztZQUFHLElBQzdCTCxXQUFHRyxPQUFPLENBQUM7Z0JBQUVDLEtBQUs7Z0JBQUtDLEtBQUs7WUFBSyxJQUNqQyxDQUFDQyxTQUFTQztnQkFDUixNQUFNQyxRQUFRQyxJQUFBQSxtQ0FBbUIsRUFBQ0gsU0FBU0M7Z0JBRTNDLHdEQUF3RDtnQkFDeEQsTUFBTUcsZ0JBQWdCSCxZQUFZSSxLQUFLQyxHQUFHLENBQUMsR0FBR047Z0JBRTlD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