{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/services/webhookRetryExponentialBackoff.property.test.ts"],"sourcesContent":["import * as fc from 'fast-check';\nimport { calculateRetryDelay } from './webhookService';\n\n/**\n * Feature: destination-wedding-platform, Property 32: Webhook Retry Exponential Backoff\n * \n * For any failed webhook delivery, the retry delays should follow exponential backoff\n * (e.g., 1s, 2s, 4s, 8s), with each retry delay being approximately double the previous delay.\n * \n * Validates: Requirements 19.6\n */\n\ndescribe('Feature: destination-wedding-platform, Property 32: Webhook Retry Exponential Backoff', () => {\n  describe('Exponential backoff calculation', () => {\n    it('should follow exponential backoff pattern for retry delays', () => {\n      fc.assert(\n        fc.property(\n          fc.integer({ min: 0, max: 10 }), // attempt number\n          fc.integer({ min: 100, max: 5000 }), // base delay\n          (attempt, baseDelay) => {\n            const delay = calculateRetryDelay(attempt, baseDelay);\n            \n            // Expected delay is baseDelay * 2^attempt (with jitter)\n            const expectedDelay = baseDelay * Math.pow(2, attempt);\n            \n            // Allow for 10% jitter\n            const minDelay = expectedDelay * 0.9;\n            const maxDelay = expectedDelay * 1.1;\n            \n            expect(delay).toBeGreaterThanOrEqual(minDelay);\n            expect(delay).toBeLessThanOrEqual(maxDelay);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should double the delay with each retry attempt', () => {\n      fc.assert(\n        fc.property(\n          fc.integer({ min: 0, max: 9 }), // attempt number (leave room for attempt + 1)\n          fc.integer({ min: 100, max: 2000 }), // base delay\n          (attempt, baseDelay) => {\n            const delay1 = calculateRetryDelay(attempt, baseDelay);\n            const delay2 = calculateRetryDelay(attempt + 1, baseDelay);\n            \n            // Second delay should be approximately double the first\n            // Account for jitter by checking a range\n            const ratio = delay2 / delay1;\n            \n            // Ratio should be close to 2 (between 1.8 and 2.2 accounting for jitter)\n            expect(ratio).toBeGreaterThan(1.8);\n            expect(ratio).toBeLessThan(2.2);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should increase monotonically with attempt number', () => {\n      fc.assert(\n        fc.property(\n          fc.integer({ min: 0, max: 9 }),\n          fc.integer({ min: 100, max: 2000 }),\n          (attempt, baseDelay) => {\n            const delays = [];\n            for (let i = attempt; i <= attempt + 3; i++) {\n              delays.push(calculateRetryDelay(i, baseDelay));\n            }\n            \n            // Each delay should be greater than the previous (accounting for jitter)\n            for (let i = 1; i < delays.length; i++) {\n              // Allow small variance due to jitter, but overall trend should be increasing\n              expect(delays[i]).toBeGreaterThan(delays[i - 1] * 0.9);\n            }\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n  });\n\n  describe('Base delay parameter', () => {\n    it('should scale proportionally with base delay', () => {\n      fc.assert(\n        fc.property(\n          fc.integer({ min: 0, max: 5 }),\n          fc.integer({ min: 100, max: 1000 }),\n          (attempt, baseDelay) => {\n            const delay1 = calculateRetryDelay(attempt, baseDelay);\n            const delay2 = calculateRetryDelay(attempt, baseDelay * 2);\n            \n            // Doubling base delay should approximately double the result\n            const ratio = delay2 / delay1;\n            \n            // Account for jitter - ratio should be close to 2\n            expect(ratio).toBeGreaterThan(1.8);\n            expect(ratio).toBeLessThan(2.2);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should use default base delay of 1000ms when not specified', () => {\n      fc.assert(\n        fc.property(\n          fc.integer({ min: 0, max: 5 }),\n          (attempt) => {\n            const delayWithDefault = calculateRetryDelay(attempt);\n            const delayWithExplicit = calculateRetryDelay(attempt, 1000);\n            \n            // Both should produce similar results (within jitter range)\n            const ratio = delayWithDefault / delayWithExplicit;\n            expect(ratio).toBeGreaterThan(0.9);\n            expect(ratio).toBeLessThan(1.1);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n  });\n\n  describe('Edge cases', () => {\n    it('should handle attempt 0 correctly', () => {\n      fc.assert(\n        fc.property(\n          fc.integer({ min: 100, max: 5000 }),\n          (baseDelay) => {\n            const delay = calculateRetryDelay(0, baseDelay);\n            \n            // For attempt 0, delay should be baseDelay * 2^0 = baseDelay (with jitter)\n            expect(delay).toBeGreaterThanOrEqual(baseDelay * 0.9);\n            expect(delay).toBeLessThanOrEqual(baseDelay * 1.1);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should handle large attempt numbers without overflow', () => {\n      fc.assert(\n        fc.property(\n          fc.integer({ min: 10, max: 20 }),\n          fc.integer({ min: 100, max: 1000 }),\n          (attempt, baseDelay) => {\n            const delay = calculateRetryDelay(attempt, baseDelay);\n            \n            // Should return a finite number\n            expect(Number.isFinite(delay)).toBe(true);\n            expect(delay).toBeGreaterThan(0);\n            \n            // Should still follow exponential pattern\n            const expectedDelay = baseDelay * Math.pow(2, attempt);\n            expect(delay).toBeGreaterThan(expectedDelay * 0.9);\n            expect(delay).toBeLessThan(expectedDelay * 1.1);\n          }\n        ),\n        { numRuns: 50 }\n      );\n    });\n\n    it('should return integer milliseconds', () => {\n      fc.assert(\n        fc.property(\n          fc.integer({ min: 0, max: 10 }),\n          fc.integer({ min: 100, max: 5000 }),\n          (attempt, baseDelay) => {\n            const delay = calculateRetryDelay(attempt, baseDelay);\n            \n            // Should be an integer (no fractional milliseconds)\n            expect(Number.isInteger(delay)).toBe(true);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n  });\n\n  describe('Jitter properties', () => {\n    it('should add randomness to prevent thundering herd', () => {\n      fc.assert(\n        fc.property(\n          fc.integer({ min: 0, max: 5 }),\n          fc.integer({ min: 1000, max: 2000 }),\n          (attempt, baseDelay) => {\n            // Generate multiple delays for the same attempt\n            const delays = Array.from({ length: 10 }, () =>\n              calculateRetryDelay(attempt, baseDelay)\n            );\n            \n            // Not all delays should be identical (jitter adds randomness)\n            const uniqueDelays = new Set(delays);\n            \n            // With 10 samples, we should see some variation\n            // (might occasionally fail due to randomness, but very unlikely)\n            expect(uniqueDelays.size).toBeGreaterThan(1);\n          }\n        ),\n        { numRuns: 50 }\n      );\n    });\n\n    it('should keep jitter within 10% of base exponential delay', () => {\n      fc.assert(\n        fc.property(\n          fc.integer({ min: 0, max: 10 }),\n          fc.integer({ min: 100, max: 5000 }),\n          (attempt, baseDelay) => {\n            const delay = calculateRetryDelay(attempt, baseDelay);\n            const expectedDelay = baseDelay * Math.pow(2, attempt);\n            \n            // Jitter should be within 10% of expected delay\n            const minDelay = expectedDelay * 0.9;\n            const maxDelay = expectedDelay * 1.1;\n            \n            expect(delay).toBeGreaterThanOrEqual(minDelay);\n            expect(delay).toBeLessThanOrEqual(maxDelay);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n  });\n\n  describe('Practical retry scenarios', () => {\n    it('should produce reasonable delays for typical retry sequences', () => {\n      const baseDelay = 1000; // 1 second\n      const delays = [];\n      \n      for (let attempt = 0; attempt < 5; attempt++) {\n        delays.push(calculateRetryDelay(attempt, baseDelay));\n      }\n      \n      // Verify the sequence follows exponential pattern\n      // Attempt 0: ~1s, Attempt 1: ~2s, Attempt 2: ~4s, Attempt 3: ~8s, Attempt 4: ~16s\n      expect(delays[0]).toBeGreaterThan(900);\n      expect(delays[0]).toBeLessThan(1100);\n      \n      expect(delays[1]).toBeGreaterThan(1800);\n      expect(delays[1]).toBeLessThan(2200);\n      \n      expect(delays[2]).toBeGreaterThan(3600);\n      expect(delays[2]).toBeLessThan(4400);\n      \n      expect(delays[3]).toBeGreaterThan(7200);\n      expect(delays[3]).toBeLessThan(8800);\n      \n      expect(delays[4]).toBeGreaterThan(14400);\n      expect(delays[4]).toBeLessThan(17600);\n    });\n\n    it('should handle different base delays appropriately', () => {\n      const attempt = 3;\n      \n      const delay100 = calculateRetryDelay(attempt, 100);\n      const delay1000 = calculateRetryDelay(attempt, 1000);\n      const delay5000 = calculateRetryDelay(attempt, 5000);\n      \n      // Delays should scale with base delay\n      expect(delay1000).toBeGreaterThan(delay100 * 9);\n      expect(delay1000).toBeLessThan(delay100 * 11);\n      \n      expect(delay5000).toBeGreaterThan(delay1000 * 4.5);\n      expect(delay5000).toBeLessThan(delay1000 * 5.5);\n    });\n  });\n});\n"],"names":["describe","it","fc","assert","property","integer","min","max","attempt","baseDelay","delay","calculateRetryDelay","expectedDelay","Math","pow","minDelay","maxDelay","expect","toBeGreaterThanOrEqual","toBeLessThanOrEqual","numRuns","delay1","delay2","ratio","toBeGreaterThan","toBeLessThan","delays","i","push","length","delayWithDefault","delayWithExplicit","Number","isFinite","toBe","isInteger","Array","from","uniqueDelays","Set","size","delay100","delay1000","delay5000"],"mappings":"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"}