5b1e479cbea3ee4f26fe2a9d2a5f73c4
/**
 * Performance tests for admin pages
 * 
 * Tests:
 * - List page load times (< 500ms for datasets under 1000 items)
 * - Search response times (< 1000ms)
 * - Save operation times (< 2000ms)
 * 
 * Requirements: 20.1-20.3
 */ "use strict";
// Mock Supabase
jest.mock('@/lib/supabase', ()=>({
        createClient: jest.fn()
    }));
jest.mock('@supabase/auth-helpers-nextjs', ()=>({
        createRouteHandlerClient: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _mockSupabase = require("../helpers/mockSupabase");
describe('Admin Pages Performance Tests', ()=>{
    let mockSupabase;
    beforeEach(()=>{
        mockSupabase = (0, _mockSupabase.createMockSupabaseClient)();
        jest.clearAllMocks();
    });
    describe('List Page Load Times', ()=>{
        it('should load guests list page within 500ms for 100 guests', async ()=>{
            // Arrange: Create 100 mock guests
            const mockGuests = Array.from({
                length: 100
            }, (_, i)=>({
                    id: `guest-${i}`,
                    first_name: `First${i}`,
                    last_name: `Last${i}`,
                    email: `guest${i}@example.com`,
                    age_type: 'adult',
                    guest_type: 'wedding_guest',
                    group_id: 'group-1',
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString()
                }));
            mockSupabase.from.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    order: jest.fn().mockReturnValue({
                        range: jest.fn().mockResolvedValue({
                            data: mockGuests,
                            error: null,
                            count: 100
                        })
                    })
                })
            });
            // Act: Measure load time
            const startTime = performance.now();
            // Simulate fetching guests
            const { data, error } = await mockSupabase.from('guests').select('*', {
                count: 'exact'
            }).order('last_name').range(0, 49);
            const endTime = performance.now();
            const loadTime = endTime - startTime;
            // Assert: Load time should be under 500ms
            expect(error).toBeNull();
            expect(data).toHaveLength(100);
            expect(loadTime).toBeLessThan(500);
        });
        it('should load events list page within 500ms for 50 events', async ()=>{
            // Arrange: Create 50 mock events
            const mockEvents = Array.from({
                length: 50
            }, (_, i)=>({
                    id: `event-${i}`,
                    slug: `event-${i}`,
                    title: `Event ${i}`,
                    event_type: 'activity',
                    event_date: new Date().toISOString(),
                    is_active: true,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString()
                }));
            mockSupabase.from.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    order: jest.fn().mockReturnValue({
                        range: jest.fn().mockResolvedValue({
                            data: mockEvents,
                            error: null,
                            count: 50
                        })
                    })
                })
            });
            // Act: Measure load time
            const startTime = performance.now();
            const { data, error } = await mockSupabase.from('events').select('*', {
                count: 'exact'
            }).order('event_date').range(0, 49);
            const endTime = performance.now();
            const loadTime = endTime - startTime;
            // Assert
            expect(error).toBeNull();
            expect(data).toHaveLength(50);
            expect(loadTime).toBeLessThan(500);
        });
        it('should load activities list page within 500ms for 100 activities', async ()=>{
            // Arrange
            const mockActivities = Array.from({
                length: 100
            }, (_, i)=>({
                    id: `activity-${i}`,
                    slug: `activity-${i}`,
                    title: `Activity ${i}`,
                    activity_type: 'activity',
                    activity_date: new Date().toISOString(),
                    capacity: 50,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString()
                }));
            mockSupabase.from.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    order: jest.fn().mockReturnValue({
                        range: jest.fn().mockResolvedValue({
                            data: mockActivities,
                            error: null,
                            count: 100
                        })
                    })
                })
            });
            // Act
            const startTime = performance.now();
            const { data, error } = await mockSupabase.from('activities').select('*', {
                count: 'exact'
            }).order('activity_date').range(0, 49);
            const endTime = performance.now();
            const loadTime = endTime - startTime;
            // Assert
            expect(error).toBeNull();
            expect(data).toHaveLength(100);
            expect(loadTime).toBeLessThan(500);
        });
    });
    describe('Search Response Times', ()=>{
        it('should return search results within 1000ms for guest search', async ()=>{
            // Arrange
            const mockResults = Array.from({
                length: 20
            }, (_, i)=>({
                    id: `guest-${i}`,
                    first_name: `John${i}`,
                    last_name: `Doe${i}`,
                    email: `john${i}@example.com`
                }));
            mockSupabase.from.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    or: jest.fn().mockReturnValue({
                        limit: jest.fn().mockResolvedValue({
                            data: mockResults,
                            error: null
                        })
                    })
                })
            });
            // Act
            const startTime = performance.now();
            const { data, error } = await mockSupabase.from('guests').select('id, first_name, last_name, email').or('first_name.ilike.%john%,last_name.ilike.%john%,email.ilike.%john%').limit(20);
            const endTime = performance.now();
            const searchTime = endTime - startTime;
            // Assert
            expect(error).toBeNull();
            expect(data).toHaveLength(20);
            expect(searchTime).toBeLessThan(1000);
        });
        it('should return reference search results within 1000ms', async ()=>{
            // Arrange
            const mockResults = [
                {
                    id: 'event-1',
                    name: 'Ceremony',
                    type: 'event',
                    slug: 'ceremony'
                },
                {
                    id: 'activity-1',
                    name: 'Beach Day',
                    type: 'activity',
                    slug: 'beach-day'
                },
                {
                    id: 'page-1',
                    name: 'Our Story',
                    type: 'content_page',
                    slug: 'our-story'
                }
            ];
            // Mock multiple table queries
            mockSupabase.from.mockImplementation((table)=>({
                    select: jest.fn().mockReturnValue({
                        ilike: jest.fn().mockReturnValue({
                            limit: jest.fn().mockResolvedValue({
                                data: mockResults.filter((r)=>r.type === table.slice(0, -1)),
                                error: null
                            })
                        })
                    })
                }));
            // Act
            const startTime = performance.now();
            // Simulate searching across multiple entity types
            const searches = await Promise.all([
                mockSupabase.from('events').select('*').ilike('title', '%ceremony%').limit(5),
                mockSupabase.from('activities').select('*').ilike('title', '%beach%').limit(5),
                mockSupabase.from('content_pages').select('*').ilike('title', '%story%').limit(5)
            ]);
            const endTime = performance.now();
            const searchTime = endTime - startTime;
            // Assert
            expect(searches.every((s)=>s.error === null)).toBe(true);
            expect(searchTime).toBeLessThan(1000);
        });
        it('should filter activities by type within 1000ms', async ()=>{
            // Arrange
            const mockActivities = Array.from({
                length: 30
            }, (_, i)=>({
                    id: `activity-${i}`,
                    title: `Activity ${i}`,
                    activity_type: 'activity'
                }));
            mockSupabase.from.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        order: jest.fn().mockResolvedValue({
                            data: mockActivities,
                            error: null
                        })
                    })
                })
            });
            // Act
            const startTime = performance.now();
            const { data, error } = await mockSupabase.from('activities').select('*').eq('activity_type', 'activity').order('activity_date');
            const endTime = performance.now();
            const filterTime = endTime - startTime;
            // Assert
            expect(error).toBeNull();
            expect(data).toHaveLength(30);
            expect(filterTime).toBeLessThan(1000);
        });
    });
    describe('Save Operation Times', ()=>{
        it('should save guest within 2000ms', async ()=>{
            // Arrange
            const guestData = {
                first_name: 'John',
                last_name: 'Doe',
                email: 'john@example.com',
                age_type: 'adult',
                guest_type: 'wedding_guest',
                group_id: 'group-1'
            };
            const savedGuest = {
                id: 'guest-1',
                ...guestData,
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
            };
            mockSupabase.from.mockReturnValue({
                insert: jest.fn().mockReturnValue({
                    select: jest.fn().mockReturnValue({
                        single: jest.fn().mockResolvedValue({
                            data: savedGuest,
                            error: null
                        })
                    })
                })
            });
            // Act
            const startTime = performance.now();
            const { data, error } = await mockSupabase.from('guests').insert(guestData).select().single();
            const endTime = performance.now();
            const saveTime = endTime - startTime;
            // Assert
            expect(error).toBeNull();
            expect(data).toEqual(savedGuest);
            expect(saveTime).toBeLessThan(2000);
        });
        it('should update event within 2000ms', async ()=>{
            // Arrange
            const updateData = {
                title: 'Updated Event',
                description: 'Updated description'
            };
            const updatedEvent = {
                id: 'event-1',
                slug: 'updated-event',
                ...updateData,
                updated_at: new Date().toISOString()
            };
            mockSupabase.from.mockReturnValue({
                update: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        select: jest.fn().mockReturnValue({
                            single: jest.fn().mockResolvedValue({
                                data: updatedEvent,
                                error: null
                            })
                        })
                    })
                })
            });
            // Act
            const startTime = performance.now();
            const { data, error } = await mockSupabase.from('events').update(updateData).eq('id', 'event-1').select().single();
            const endTime = performance.now();
            const updateTime = endTime - startTime;
            // Assert
            expect(error).toBeNull();
            expect(data).toEqual(updatedEvent);
            expect(updateTime).toBeLessThan(2000);
        });
        it('should save section with columns within 2000ms', async ()=>{
            // Arrange
            const sectionData = {
                page_type: 'custom',
                page_id: 'page-1',
                display_order: 1,
                layout: 'two-column'
            };
            const savedSection = {
                id: 'section-1',
                ...sectionData,
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
            };
            const columnData = [
                {
                    section_id: 'section-1',
                    column_number: 1,
                    content_type: 'rich_text',
                    content_data: {
                        html: '<p>Column 1 content</p>'
                    }
                },
                {
                    section_id: 'section-1',
                    column_number: 2,
                    content_type: 'rich_text',
                    content_data: {
                        html: '<p>Column 2 content</p>'
                    }
                }
            ];
            mockSupabase.from.mockImplementation((table)=>{
                if (table === 'sections') {
                    return {
                        insert: jest.fn().mockReturnValue({
                            select: jest.fn().mockReturnValue({
                                single: jest.fn().mockResolvedValue({
                                    data: savedSection,
                                    error: null
                                })
                            })
                        })
                    };
                } else if (table === 'section_columns') {
                    return {
                        insert: jest.fn().mockResolvedValue({
                            data: columnData,
                            error: null
                        })
                    };
                }
                return {};
            });
            // Act
            const startTime = performance.now();
            // Save section
            const sectionResult = await mockSupabase.from('sections').insert(sectionData).select().single();
            // Save columns
            const columnsResult = await mockSupabase.from('section_columns').insert(columnData);
            const endTime = performance.now();
            const saveTime = endTime - startTime;
            // Assert
            expect(sectionResult.error).toBeNull();
            expect(columnsResult.error).toBeNull();
            expect(saveTime).toBeLessThan(2000);
        });
        it('should bulk create guests within 2000ms for 50 guests', async ()=>{
            // Arrange
            const guestsData = Array.from({
                length: 50
            }, (_, i)=>({
                    first_name: `First${i}`,
                    last_name: `Last${i}`,
                    email: `guest${i}@example.com`,
                    age_type: 'adult',
                    guest_type: 'wedding_guest',
                    group_id: 'group-1'
                }));
            const savedGuests = guestsData.map((g, i)=>({
                    id: `guest-${i}`,
                    ...g,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString()
                }));
            mockSupabase.from.mockReturnValue({
                insert: jest.fn().mockReturnValue({
                    select: jest.fn().mockResolvedValue({
                        data: savedGuests,
                        error: null
                    })
                })
            });
            // Act
            const startTime = performance.now();
            const { data, error } = await mockSupabase.from('guests').insert(guestsData).select();
            const endTime = performance.now();
            const bulkSaveTime = endTime - startTime;
            // Assert
            expect(error).toBeNull();
            expect(data).toHaveLength(50);
            expect(bulkSaveTime).toBeLessThan(2000);
        });
    });
    describe('Performance Degradation Tests', ()=>{
        it('should maintain performance with 1000 guests', async ()=>{
            // Arrange
            const mockGuests = Array.from({
                length: 1000
            }, (_, i)=>({
                    id: `guest-${i}`,
                    first_name: `First${i}`,
                    last_name: `Last${i}`,
                    email: `guest${i}@example.com`
                }));
            mockSupabase.from.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    order: jest.fn().mockReturnValue({
                        range: jest.fn().mockResolvedValue({
                            data: mockGuests.slice(0, 50),
                            error: null,
                            count: 1000
                        })
                    })
                })
            });
            // Act
            const startTime = performance.now();
            const { data, error } = await mockSupabase.from('guests').select('*', {
                count: 'exact'
            }).order('last_name').range(0, 49);
            const endTime = performance.now();
            const loadTime = endTime - startTime;
            // Assert
            expect(error).toBeNull();
            expect(data).toHaveLength(50);
            expect(loadTime).toBeLessThan(500);
        });
        it('should handle pagination efficiently', async ()=>{
            // Arrange
            const totalGuests = 500;
            const pageSize = 50;
            const pages = Math.ceil(totalGuests / pageSize);
            mockSupabase.from.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    order: jest.fn().mockReturnValue({
                        range: jest.fn().mockImplementation((from, to)=>{
                            const mockData = Array.from({
                                length: to - from + 1
                            }, (_, i)=>({
                                    id: `guest-${from + i}`,
                                    first_name: `First${from + i}`,
                                    last_name: `Last${from + i}`
                                }));
                            return Promise.resolve({
                                data: mockData,
                                error: null,
                                count: totalGuests
                            });
                        })
                    })
                })
            });
            // Act: Load all pages
            const startTime = performance.now();
            const pageLoads = [];
            for(let page = 0; page < pages; page++){
                const from = page * pageSize;
                const to = from + pageSize - 1;
                const pageStart = performance.now();
                await mockSupabase.from('guests').select('*', {
                    count: 'exact'
                }).order('last_name').range(from, to);
                const pageEnd = performance.now();
                pageLoads.push(pageEnd - pageStart);
            }
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            const avgPageLoad = pageLoads.reduce((a, b)=>a + b, 0) / pageLoads.length;
            // Assert
            expect(avgPageLoad).toBeLessThan(500);
            expect(totalTime).toBeLessThan(5000); // All pages should load in under 5 seconds
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvX190ZXN0c19fL3BlcmZvcm1hbmNlL2FkbWluUGFnZXMucGVyZm9ybWFuY2UudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBlcmZvcm1hbmNlIHRlc3RzIGZvciBhZG1pbiBwYWdlc1xuICogXG4gKiBUZXN0czpcbiAqIC0gTGlzdCBwYWdlIGxvYWQgdGltZXMgKDwgNTAwbXMgZm9yIGRhdGFzZXRzIHVuZGVyIDEwMDAgaXRlbXMpXG4gKiAtIFNlYXJjaCByZXNwb25zZSB0aW1lcyAoPCAxMDAwbXMpXG4gKiAtIFNhdmUgb3BlcmF0aW9uIHRpbWVzICg8IDIwMDBtcylcbiAqIFxuICogUmVxdWlyZW1lbnRzOiAyMC4xLTIwLjNcbiAqL1xuXG5pbXBvcnQgeyBjcmVhdGVNb2NrU3VwYWJhc2VDbGllbnQgfSBmcm9tICcuLi9oZWxwZXJzL21vY2tTdXBhYmFzZSc7XG5cbi8vIE1vY2sgU3VwYWJhc2Vcbmplc3QubW9jaygnQC9saWIvc3VwYWJhc2UnLCAoKSA9PiAoe1xuICBjcmVhdGVDbGllbnQ6IGplc3QuZm4oKSxcbn0pKTtcblxuamVzdC5tb2NrKCdAc3VwYWJhc2UvYXV0aC1oZWxwZXJzLW5leHRqcycsICgpID0+ICh7XG4gIGNyZWF0ZVJvdXRlSGFuZGxlckNsaWVudDogamVzdC5mbigpLFxufSkpO1xuXG5kZXNjcmliZSgnQWRtaW4gUGFnZXMgUGVyZm9ybWFuY2UgVGVzdHMnLCAoKSA9PiB7XG4gIGxldCBtb2NrU3VwYWJhc2U6IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZU1vY2tTdXBhYmFzZUNsaWVudD47XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgbW9ja1N1cGFiYXNlID0gY3JlYXRlTW9ja1N1cGFiYXNlQ2xpZW50KCk7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdMaXN0IFBhZ2UgTG9hZCBUaW1lcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGxvYWQgZ3Vlc3RzIGxpc3QgcGFnZSB3aXRoaW4gNTAwbXMgZm9yIDEwMCBndWVzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlOiBDcmVhdGUgMTAwIG1vY2sgZ3Vlc3RzXG4gICAgICBjb25zdCBtb2NrR3Vlc3RzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sIChfLCBpKSA9PiAoe1xuICAgICAgICBpZDogYGd1ZXN0LSR7aX1gLFxuICAgICAgICBmaXJzdF9uYW1lOiBgRmlyc3Qke2l9YCxcbiAgICAgICAgbGFzdF9uYW1lOiBgTGFzdCR7aX1gLFxuICAgICAgICBlbWFpbDogYGd1ZXN0JHtpfUBleGFtcGxlLmNvbWAsXG4gICAgICAgIGFnZV90eXBlOiAnYWR1bHQnLFxuICAgICAgICBndWVzdF90eXBlOiAnd2VkZGluZ19ndWVzdCcsXG4gICAgICAgIGdyb3VwX2lkOiAnZ3JvdXAtMScsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfSkpO1xuXG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIG9yZGVyOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgIHJhbmdlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICBkYXRhOiBtb2NrR3Vlc3RzLFxuICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgY291bnQ6IDEwMCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3Q6IE1lYXN1cmUgbG9hZCB0aW1lXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgZmV0Y2hpbmcgZ3Vlc3RzXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBtb2NrU3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2d1ZXN0cycpXG4gICAgICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnIH0pXG4gICAgICAgIC5vcmRlcignbGFzdF9uYW1lJylcbiAgICAgICAgLnJhbmdlKDAsIDQ5KTtcblxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgbG9hZFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuXG4gICAgICAvLyBBc3NlcnQ6IExvYWQgdGltZSBzaG91bGQgYmUgdW5kZXIgNTAwbXNcbiAgICAgIGV4cGVjdChlcnJvcikudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChkYXRhKS50b0hhdmVMZW5ndGgoMTAwKTtcbiAgICAgIGV4cGVjdChsb2FkVGltZSkudG9CZUxlc3NUaGFuKDUwMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGxvYWQgZXZlbnRzIGxpc3QgcGFnZSB3aXRoaW4gNTAwbXMgZm9yIDUwIGV2ZW50cycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2U6IENyZWF0ZSA1MCBtb2NrIGV2ZW50c1xuICAgICAgY29uc3QgbW9ja0V2ZW50cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDUwIH0sIChfLCBpKSA9PiAoe1xuICAgICAgICBpZDogYGV2ZW50LSR7aX1gLFxuICAgICAgICBzbHVnOiBgZXZlbnQtJHtpfWAsXG4gICAgICAgIHRpdGxlOiBgRXZlbnQgJHtpfWAsXG4gICAgICAgIGV2ZW50X3R5cGU6ICdhY3Rpdml0eScsXG4gICAgICAgIGV2ZW50X2RhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH0pKTtcblxuICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBvcmRlcjogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICByYW5nZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgZGF0YTogbW9ja0V2ZW50cyxcbiAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgIGNvdW50OiA1MCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3Q6IE1lYXN1cmUgbG9hZCB0aW1lXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgbW9ja1N1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdldmVudHMnKVxuICAgICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JyB9KVxuICAgICAgICAub3JkZXIoJ2V2ZW50X2RhdGUnKVxuICAgICAgICAucmFuZ2UoMCwgNDkpO1xuXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBsb2FkVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGRhdGEpLnRvSGF2ZUxlbmd0aCg1MCk7XG4gICAgICBleHBlY3QobG9hZFRpbWUpLnRvQmVMZXNzVGhhbig1MDApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBsb2FkIGFjdGl2aXRpZXMgbGlzdCBwYWdlIHdpdGhpbiA1MDBtcyBmb3IgMTAwIGFjdGl2aXRpZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBtb2NrQWN0aXZpdGllcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMCB9LCAoXywgaSkgPT4gKHtcbiAgICAgICAgaWQ6IGBhY3Rpdml0eS0ke2l9YCxcbiAgICAgICAgc2x1ZzogYGFjdGl2aXR5LSR7aX1gLFxuICAgICAgICB0aXRsZTogYEFjdGl2aXR5ICR7aX1gLFxuICAgICAgICBhY3Rpdml0eV90eXBlOiAnYWN0aXZpdHknLFxuICAgICAgICBhY3Rpdml0eV9kYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGNhcGFjaXR5OiA1MCxcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9KSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgb3JkZXI6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgcmFuZ2U6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgIGRhdGE6IG1vY2tBY3Rpdml0aWVzLFxuICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgY291bnQ6IDEwMCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBtb2NrU3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2FjdGl2aXRpZXMnKVxuICAgICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JyB9KVxuICAgICAgICAub3JkZXIoJ2FjdGl2aXR5X2RhdGUnKVxuICAgICAgICAucmFuZ2UoMCwgNDkpO1xuXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBsb2FkVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGRhdGEpLnRvSGF2ZUxlbmd0aCgxMDApO1xuICAgICAgZXhwZWN0KGxvYWRUaW1lKS50b0JlTGVzc1RoYW4oNTAwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1NlYXJjaCBSZXNwb25zZSBUaW1lcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBzZWFyY2ggcmVzdWx0cyB3aXRoaW4gMTAwMG1zIGZvciBndWVzdCBzZWFyY2gnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBtb2NrUmVzdWx0cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDIwIH0sIChfLCBpKSA9PiAoe1xuICAgICAgICBpZDogYGd1ZXN0LSR7aX1gLFxuICAgICAgICBmaXJzdF9uYW1lOiBgSm9obiR7aX1gLFxuICAgICAgICBsYXN0X25hbWU6IGBEb2Uke2l9YCxcbiAgICAgICAgZW1haWw6IGBqb2huJHtpfUBleGFtcGxlLmNvbWAsXG4gICAgICB9KSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgb3I6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgbGltaXQ6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgIGRhdGE6IG1vY2tSZXN1bHRzLFxuICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBtb2NrU3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2d1ZXN0cycpXG4gICAgICAgIC5zZWxlY3QoJ2lkLCBmaXJzdF9uYW1lLCBsYXN0X25hbWUsIGVtYWlsJylcbiAgICAgICAgLm9yKCdmaXJzdF9uYW1lLmlsaWtlLiVqb2huJSxsYXN0X25hbWUuaWxpa2UuJWpvaG4lLGVtYWlsLmlsaWtlLiVqb2huJScpXG4gICAgICAgIC5saW1pdCgyMCk7XG5cbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHNlYXJjaFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChlcnJvcikudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChkYXRhKS50b0hhdmVMZW5ndGgoMjApO1xuICAgICAgZXhwZWN0KHNlYXJjaFRpbWUpLnRvQmVMZXNzVGhhbigxMDAwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHJlZmVyZW5jZSBzZWFyY2ggcmVzdWx0cyB3aXRoaW4gMTAwMG1zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgbW9ja1Jlc3VsdHMgPSBbXG4gICAgICAgIHsgaWQ6ICdldmVudC0xJywgbmFtZTogJ0NlcmVtb255JywgdHlwZTogJ2V2ZW50Jywgc2x1ZzogJ2NlcmVtb255JyB9LFxuICAgICAgICB7IGlkOiAnYWN0aXZpdHktMScsIG5hbWU6ICdCZWFjaCBEYXknLCB0eXBlOiAnYWN0aXZpdHknLCBzbHVnOiAnYmVhY2gtZGF5JyB9LFxuICAgICAgICB7IGlkOiAncGFnZS0xJywgbmFtZTogJ091ciBTdG9yeScsIHR5cGU6ICdjb250ZW50X3BhZ2UnLCBzbHVnOiAnb3VyLXN0b3J5JyB9LFxuICAgICAgXTtcblxuICAgICAgLy8gTW9jayBtdWx0aXBsZSB0YWJsZSBxdWVyaWVzXG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrSW1wbGVtZW50YXRpb24oKHRhYmxlOiBzdHJpbmcpID0+ICh7XG4gICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgaWxpa2U6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgbGltaXQ6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgIGRhdGE6IG1vY2tSZXN1bHRzLmZpbHRlcihyID0+IHIudHlwZSA9PT0gdGFibGUuc2xpY2UoMCwgLTEpKSxcbiAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICB9KSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIHNlYXJjaGluZyBhY3Jvc3MgbXVsdGlwbGUgZW50aXR5IHR5cGVzXG4gICAgICBjb25zdCBzZWFyY2hlcyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgbW9ja1N1cGFiYXNlLmZyb20oJ2V2ZW50cycpLnNlbGVjdCgnKicpLmlsaWtlKCd0aXRsZScsICclY2VyZW1vbnklJykubGltaXQoNSksXG4gICAgICAgIG1vY2tTdXBhYmFzZS5mcm9tKCdhY3Rpdml0aWVzJykuc2VsZWN0KCcqJykuaWxpa2UoJ3RpdGxlJywgJyViZWFjaCUnKS5saW1pdCg1KSxcbiAgICAgICAgbW9ja1N1cGFiYXNlLmZyb20oJ2NvbnRlbnRfcGFnZXMnKS5zZWxlY3QoJyonKS5pbGlrZSgndGl0bGUnLCAnJXN0b3J5JScpLmxpbWl0KDUpLFxuICAgICAgXSk7XG5cbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHNlYXJjaFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChzZWFyY2hlcy5ldmVyeShzID0+IHMuZXJyb3IgPT09IG51bGwpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHNlYXJjaFRpbWUpLnRvQmVMZXNzVGhhbigxMDAwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZmlsdGVyIGFjdGl2aXRpZXMgYnkgdHlwZSB3aXRoaW4gMTAwMG1zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgbW9ja0FjdGl2aXRpZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAzMCB9LCAoXywgaSkgPT4gKHtcbiAgICAgICAgaWQ6IGBhY3Rpdml0eS0ke2l9YCxcbiAgICAgICAgdGl0bGU6IGBBY3Rpdml0eSAke2l9YCxcbiAgICAgICAgYWN0aXZpdHlfdHlwZTogJ2FjdGl2aXR5JyxcbiAgICAgIH0pKTtcblxuICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBvcmRlcjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgZGF0YTogbW9ja0FjdGl2aXRpZXMsXG4gICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IG1vY2tTdXBhYmFzZVxuICAgICAgICAuZnJvbSgnYWN0aXZpdGllcycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZXEoJ2FjdGl2aXR5X3R5cGUnLCAnYWN0aXZpdHknKVxuICAgICAgICAub3JkZXIoJ2FjdGl2aXR5X2RhdGUnKTtcblxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgZmlsdGVyVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGRhdGEpLnRvSGF2ZUxlbmd0aCgzMCk7XG4gICAgICBleHBlY3QoZmlsdGVyVGltZSkudG9CZUxlc3NUaGFuKDEwMDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2F2ZSBPcGVyYXRpb24gVGltZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzYXZlIGd1ZXN0IHdpdGhpbiAyMDAwbXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBndWVzdERhdGEgPSB7XG4gICAgICAgIGZpcnN0X25hbWU6ICdKb2huJyxcbiAgICAgICAgbGFzdF9uYW1lOiAnRG9lJyxcbiAgICAgICAgZW1haWw6ICdqb2huQGV4YW1wbGUuY29tJyxcbiAgICAgICAgYWdlX3R5cGU6ICdhZHVsdCcsXG4gICAgICAgIGd1ZXN0X3R5cGU6ICd3ZWRkaW5nX2d1ZXN0JyxcbiAgICAgICAgZ3JvdXBfaWQ6ICdncm91cC0xJyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHNhdmVkR3Vlc3QgPSB7XG4gICAgICAgIGlkOiAnZ3Vlc3QtMScsXG4gICAgICAgIC4uLmd1ZXN0RGF0YSxcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9O1xuXG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBpbnNlcnQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgIGRhdGE6IHNhdmVkR3Vlc3QsXG4gICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IG1vY2tTdXBhYmFzZVxuICAgICAgICAuZnJvbSgnZ3Vlc3RzJylcbiAgICAgICAgLmluc2VydChndWVzdERhdGEpXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHNhdmVUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoZXJyb3IpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoZGF0YSkudG9FcXVhbChzYXZlZEd1ZXN0KTtcbiAgICAgIGV4cGVjdChzYXZlVGltZSkudG9CZUxlc3NUaGFuKDIwMDApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB1cGRhdGUgZXZlbnQgd2l0aGluIDIwMDBtcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHVwZGF0ZURhdGEgPSB7XG4gICAgICAgIHRpdGxlOiAnVXBkYXRlZCBFdmVudCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnVXBkYXRlZCBkZXNjcmlwdGlvbicsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB1cGRhdGVkRXZlbnQgPSB7XG4gICAgICAgIGlkOiAnZXZlbnQtMScsXG4gICAgICAgIHNsdWc6ICd1cGRhdGVkLWV2ZW50JyxcbiAgICAgICAgLi4udXBkYXRlRGF0YSxcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfTtcblxuICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgdXBkYXRlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogdXBkYXRlZEV2ZW50LFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBtb2NrU3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2V2ZW50cycpXG4gICAgICAgIC51cGRhdGUodXBkYXRlRGF0YSlcbiAgICAgICAgLmVxKCdpZCcsICdldmVudC0xJylcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgdXBkYXRlVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG5cbiAgICAgIC8vIEFzc2VydFxuICAgICAgZXhwZWN0KGVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGRhdGEpLnRvRXF1YWwodXBkYXRlZEV2ZW50KTtcbiAgICAgIGV4cGVjdCh1cGRhdGVUaW1lKS50b0JlTGVzc1RoYW4oMjAwMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNhdmUgc2VjdGlvbiB3aXRoIGNvbHVtbnMgd2l0aGluIDIwMDBtcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHNlY3Rpb25EYXRhID0ge1xuICAgICAgICBwYWdlX3R5cGU6ICdjdXN0b20nLFxuICAgICAgICBwYWdlX2lkOiAncGFnZS0xJyxcbiAgICAgICAgZGlzcGxheV9vcmRlcjogMSxcbiAgICAgICAgbGF5b3V0OiAndHdvLWNvbHVtbicsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzYXZlZFNlY3Rpb24gPSB7XG4gICAgICAgIGlkOiAnc2VjdGlvbi0xJyxcbiAgICAgICAgLi4uc2VjdGlvbkRhdGEsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgY29sdW1uRGF0YSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHNlY3Rpb25faWQ6ICdzZWN0aW9uLTEnLFxuICAgICAgICAgIGNvbHVtbl9udW1iZXI6IDEsXG4gICAgICAgICAgY29udGVudF90eXBlOiAncmljaF90ZXh0JyxcbiAgICAgICAgICBjb250ZW50X2RhdGE6IHsgaHRtbDogJzxwPkNvbHVtbiAxIGNvbnRlbnQ8L3A+JyB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgc2VjdGlvbl9pZDogJ3NlY3Rpb24tMScsXG4gICAgICAgICAgY29sdW1uX251bWJlcjogMixcbiAgICAgICAgICBjb250ZW50X3R5cGU6ICdyaWNoX3RleHQnLFxuICAgICAgICAgIGNvbnRlbnRfZGF0YTogeyBodG1sOiAnPHA+Q29sdW1uIDIgY29udGVudDwvcD4nIH0sXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrSW1wbGVtZW50YXRpb24oKHRhYmxlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKHRhYmxlID09PSAnc2VjdGlvbnMnKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluc2VydDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgZGF0YTogc2F2ZWRTZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWJsZSA9PT0gJ3NlY3Rpb25fY29sdW1ucycpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5zZXJ0OiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICBkYXRhOiBjb2x1bW5EYXRhLFxuICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFNhdmUgc2VjdGlvblxuICAgICAgY29uc3Qgc2VjdGlvblJlc3VsdCA9IGF3YWl0IG1vY2tTdXBhYmFzZVxuICAgICAgICAuZnJvbSgnc2VjdGlvbnMnKVxuICAgICAgICAuaW5zZXJ0KHNlY3Rpb25EYXRhKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICAvLyBTYXZlIGNvbHVtbnNcbiAgICAgIGNvbnN0IGNvbHVtbnNSZXN1bHQgPSBhd2FpdCBtb2NrU3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3NlY3Rpb25fY29sdW1ucycpXG4gICAgICAgIC5pbnNlcnQoY29sdW1uRGF0YSk7XG5cbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHNhdmVUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3Qoc2VjdGlvblJlc3VsdC5lcnJvcikudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChjb2x1bW5zUmVzdWx0LmVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KHNhdmVUaW1lKS50b0JlTGVzc1RoYW4oMjAwMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGJ1bGsgY3JlYXRlIGd1ZXN0cyB3aXRoaW4gMjAwMG1zIGZvciA1MCBndWVzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBndWVzdHNEYXRhID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogNTAgfSwgKF8sIGkpID0+ICh7XG4gICAgICAgIGZpcnN0X25hbWU6IGBGaXJzdCR7aX1gLFxuICAgICAgICBsYXN0X25hbWU6IGBMYXN0JHtpfWAsXG4gICAgICAgIGVtYWlsOiBgZ3Vlc3Qke2l9QGV4YW1wbGUuY29tYCxcbiAgICAgICAgYWdlX3R5cGU6ICdhZHVsdCcsXG4gICAgICAgIGd1ZXN0X3R5cGU6ICd3ZWRkaW5nX2d1ZXN0JyxcbiAgICAgICAgZ3JvdXBfaWQ6ICdncm91cC0xJyxcbiAgICAgIH0pKTtcblxuICAgICAgY29uc3Qgc2F2ZWRHdWVzdHMgPSBndWVzdHNEYXRhLm1hcCgoZywgaSkgPT4gKHtcbiAgICAgICAgaWQ6IGBndWVzdC0ke2l9YCxcbiAgICAgICAgLi4uZyxcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9KSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIGluc2VydDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgZGF0YTogc2F2ZWRHdWVzdHMsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgbW9ja1N1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdndWVzdHMnKVxuICAgICAgICAuaW5zZXJ0KGd1ZXN0c0RhdGEpXG4gICAgICAgIC5zZWxlY3QoKTtcblxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgYnVsa1NhdmVUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoZXJyb3IpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoZGF0YSkudG9IYXZlTGVuZ3RoKDUwKTtcbiAgICAgIGV4cGVjdChidWxrU2F2ZVRpbWUpLnRvQmVMZXNzVGhhbigyMDAwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIERlZ3JhZGF0aW9uIFRlc3RzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgbWFpbnRhaW4gcGVyZm9ybWFuY2Ugd2l0aCAxMDAwIGd1ZXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IG1vY2tHdWVzdHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAwIH0sIChfLCBpKSA9PiAoe1xuICAgICAgICBpZDogYGd1ZXN0LSR7aX1gLFxuICAgICAgICBmaXJzdF9uYW1lOiBgRmlyc3Qke2l9YCxcbiAgICAgICAgbGFzdF9uYW1lOiBgTGFzdCR7aX1gLFxuICAgICAgICBlbWFpbDogYGd1ZXN0JHtpfUBleGFtcGxlLmNvbWAsXG4gICAgICB9KSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgb3JkZXI6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgcmFuZ2U6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgIGRhdGE6IG1vY2tHdWVzdHMuc2xpY2UoMCwgNTApLFxuICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgY291bnQ6IDEwMDAsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgbW9ja1N1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdndWVzdHMnKVxuICAgICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JyB9KVxuICAgICAgICAub3JkZXIoJ2xhc3RfbmFtZScpXG4gICAgICAgIC5yYW5nZSgwLCA0OSk7XG5cbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IGxvYWRUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcblxuICAgICAgLy8gQXNzZXJ0XG4gICAgICBleHBlY3QoZXJyb3IpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoZGF0YSkudG9IYXZlTGVuZ3RoKDUwKTtcbiAgICAgIGV4cGVjdChsb2FkVGltZSkudG9CZUxlc3NUaGFuKDUwMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBwYWdpbmF0aW9uIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgdG90YWxHdWVzdHMgPSA1MDA7XG4gICAgICBjb25zdCBwYWdlU2l6ZSA9IDUwO1xuICAgICAgY29uc3QgcGFnZXMgPSBNYXRoLmNlaWwodG90YWxHdWVzdHMgLyBwYWdlU2l6ZSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgb3JkZXI6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgcmFuZ2U6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKGZyb206IG51bWJlciwgdG86IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBtb2NrRGF0YSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHRvIC0gZnJvbSArIDEgfSwgKF8sIGkpID0+ICh7XG4gICAgICAgICAgICAgICAgaWQ6IGBndWVzdC0ke2Zyb20gKyBpfWAsXG4gICAgICAgICAgICAgICAgZmlyc3RfbmFtZTogYEZpcnN0JHtmcm9tICsgaX1gLFxuICAgICAgICAgICAgICAgIGxhc3RfbmFtZTogYExhc3Qke2Zyb20gKyBpfWAsXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogbW9ja0RhdGEsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgY291bnQ6IHRvdGFsR3Vlc3RzLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3Q6IExvYWQgYWxsIHBhZ2VzXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgY29uc3QgcGFnZUxvYWRzID0gW107XG4gICAgICBmb3IgKGxldCBwYWdlID0gMDsgcGFnZSA8IHBhZ2VzOyBwYWdlKyspIHtcbiAgICAgICAgY29uc3QgZnJvbSA9IHBhZ2UgKiBwYWdlU2l6ZTtcbiAgICAgICAgY29uc3QgdG8gPSBmcm9tICsgcGFnZVNpemUgLSAxO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcGFnZVN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGF3YWl0IG1vY2tTdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdndWVzdHMnKVxuICAgICAgICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnIH0pXG4gICAgICAgICAgLm9yZGVyKCdsYXN0X25hbWUnKVxuICAgICAgICAgIC5yYW5nZShmcm9tLCB0byk7XG4gICAgICAgIGNvbnN0IHBhZ2VFbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgXG4gICAgICAgIHBhZ2VMb2Fkcy5wdXNoKHBhZ2VFbmQgLSBwYWdlU3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc3QgYXZnUGFnZUxvYWQgPSBwYWdlTG9hZHMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBwYWdlTG9hZHMubGVuZ3RoO1xuXG4gICAgICAvLyBBc3NlcnRcbiAgICAgIGV4cGVjdChhdmdQYWdlTG9hZCkudG9CZUxlc3NUaGFuKDUwMCk7XG4gICAgICBleHBlY3QodG90YWxUaW1lKS50b0JlTGVzc1RoYW4oNTAwMCk7IC8vIEFsbCBwYWdlcyBzaG91bGQgbG9hZCBpbiB1bmRlciA1IHNlY29uZHNcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImNyZWF0ZUNsaWVudCIsImZuIiwiY3JlYXRlUm91dGVIYW5kbGVyQ2xpZW50IiwiZGVzY3JpYmUiLCJtb2NrU3VwYWJhc2UiLCJiZWZvcmVFYWNoIiwiY3JlYXRlTW9ja1N1cGFiYXNlQ2xpZW50IiwiY2xlYXJBbGxNb2NrcyIsIml0IiwibW9ja0d1ZXN0cyIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsIl8iLCJpIiwiaWQiLCJmaXJzdF9uYW1lIiwibGFzdF9uYW1lIiwiZW1haWwiLCJhZ2VfdHlwZSIsImd1ZXN0X3R5cGUiLCJncm91cF9pZCIsImNyZWF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ1cGRhdGVkX2F0IiwibW9ja1JldHVyblZhbHVlIiwic2VsZWN0Iiwib3JkZXIiLCJyYW5nZSIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiZGF0YSIsImVycm9yIiwiY291bnQiLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImVuZFRpbWUiLCJsb2FkVGltZSIsImV4cGVjdCIsInRvQmVOdWxsIiwidG9IYXZlTGVuZ3RoIiwidG9CZUxlc3NUaGFuIiwibW9ja0V2ZW50cyIsInNsdWciLCJ0aXRsZSIsImV2ZW50X3R5cGUiLCJldmVudF9kYXRlIiwiaXNfYWN0aXZlIiwibW9ja0FjdGl2aXRpZXMiLCJhY3Rpdml0eV90eXBlIiwiYWN0aXZpdHlfZGF0ZSIsImNhcGFjaXR5IiwibW9ja1Jlc3VsdHMiLCJvciIsImxpbWl0Iiwic2VhcmNoVGltZSIsIm5hbWUiLCJ0eXBlIiwibW9ja0ltcGxlbWVudGF0aW9uIiwidGFibGUiLCJpbGlrZSIsImZpbHRlciIsInIiLCJzbGljZSIsInNlYXJjaGVzIiwiUHJvbWlzZSIsImFsbCIsImV2ZXJ5IiwicyIsInRvQmUiLCJlcSIsImZpbHRlclRpbWUiLCJndWVzdERhdGEiLCJzYXZlZEd1ZXN0IiwiaW5zZXJ0Iiwic2luZ2xlIiwic2F2ZVRpbWUiLCJ0b0VxdWFsIiwidXBkYXRlRGF0YSIsImRlc2NyaXB0aW9uIiwidXBkYXRlZEV2ZW50IiwidXBkYXRlIiwidXBkYXRlVGltZSIsInNlY3Rpb25EYXRhIiwicGFnZV90eXBlIiwicGFnZV9pZCIsImRpc3BsYXlfb3JkZXIiLCJsYXlvdXQiLCJzYXZlZFNlY3Rpb24iLCJjb2x1bW5EYXRhIiwic2VjdGlvbl9pZCIsImNvbHVtbl9udW1iZXIiLCJjb250ZW50X3R5cGUiLCJjb250ZW50X2RhdGEiLCJodG1sIiwic2VjdGlvblJlc3VsdCIsImNvbHVtbnNSZXN1bHQiLCJndWVzdHNEYXRhIiwic2F2ZWRHdWVzdHMiLCJtYXAiLCJnIiwiYnVsa1NhdmVUaW1lIiwidG90YWxHdWVzdHMiLCJwYWdlU2l6ZSIsInBhZ2VzIiwiTWF0aCIsImNlaWwiLCJ0byIsIm1vY2tEYXRhIiwicmVzb2x2ZSIsInBhZ2VMb2FkcyIsInBhZ2UiLCJwYWdlU3RhcnQiLCJwYWdlRW5kIiwicHVzaCIsInRvdGFsVGltZSIsImF2Z1BhZ2VMb2FkIiwicmVkdWNlIiwiYSIs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