d39948e8dfef1f463e296fe7e4872e98
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
/**
 * Property-Based Test for Email Template Round-Trip
 * Feature: destination-wedding-platform, Property 25: Email Template Round-Trip
 * 
 * Property: For any valid email template object, the sequence of operations 
 * (format to string → parse from string → format to string again) should produce 
 * an equivalent template with all fields and variables preserved.
 * 
 * Validates: Requirements 20.7
 */ /**
 * Email template formatter - converts template object to string format.
 */ function formatEmailTemplate(template) {
    return JSON.stringify({
        name: template.name,
        subject: template.subject,
        body_html: template.body_html,
        body_text: template.body_text,
        variables: template.variables
    });
}
/**
 * Email template parser - parses string format back to template object.
 */ function parseEmailTemplate(templateString) {
    const parsed = JSON.parse(templateString);
    return {
        name: parsed.name,
        subject: parsed.subject,
        body_html: parsed.body_html,
        body_text: parsed.body_text,
        variables: parsed.variables || []
    };
}
describe('Feature: destination-wedding-platform, Property 25: Email Template Round-Trip', ()=>{
    // Arbitrary for valid email template
    const emailTemplateArbitrary = _fastcheck.record({
        name: _fastcheck.string({
            minLength: 1,
            maxLength: 100
        }),
        subject: _fastcheck.string({
            minLength: 1,
            maxLength: 200
        }),
        body_html: _fastcheck.string({
            minLength: 1,
            maxLength: 1000
        }),
        body_text: _fastcheck.string({
            minLength: 1,
            maxLength: 1000
        }),
        variables: _fastcheck.array(_fastcheck.string({
            minLength: 1,
            maxLength: 50
        }).filter((s)=>!s.includes('"') && !s.includes('\\')), {
            maxLength: 20
        })
    });
    it('should preserve all template fields through format → parse → format cycle', ()=>{
        _fastcheck.assert(_fastcheck.property(emailTemplateArbitrary, (template)=>{
            // Format to string
            const formatted1 = formatEmailTemplate(template);
            // Parse back to object
            const parsed = parseEmailTemplate(formatted1);
            // Format again
            const formatted2 = formatEmailTemplate(parsed);
            // The two formatted strings should be identical
            expect(formatted1).toBe(formatted2);
            // The parsed object should match the original
            expect(parsed.name).toBe(template.name);
            expect(parsed.subject).toBe(template.subject);
            expect(parsed.body_html).toBe(template.body_html);
            expect(parsed.body_text).toBe(template.body_text);
            expect(parsed.variables).toEqual(template.variables);
        }), {
            numRuns: 100
        });
    });
    it('should preserve template with no variables', ()=>{
        _fastcheck.assert(_fastcheck.property(_fastcheck.record({
            name: _fastcheck.string({
                minLength: 1,
                maxLength: 100
            }),
            subject: _fastcheck.string({
                minLength: 1,
                maxLength: 200
            }),
            body_html: _fastcheck.string({
                minLength: 1,
                maxLength: 1000
            }),
            body_text: _fastcheck.string({
                minLength: 1,
                maxLength: 1000
            }),
            variables: _fastcheck.constant([])
        }), (template)=>{
            const formatted = formatEmailTemplate(template);
            const parsed = parseEmailTemplate(formatted);
            expect(parsed.variables).toEqual([]);
            expect(parsed.name).toBe(template.name);
        }), {
            numRuns: 100
        });
    });
    it('should preserve template with special characters in content', ()=>{
        _fastcheck.assert(_fastcheck.property(_fastcheck.record({
            name: _fastcheck.string({
                minLength: 1,
                maxLength: 100
            }),
            subject: _fastcheck.string({
                minLength: 1,
                maxLength: 200
            }),
            body_html: _fastcheck.constantFrom('<p>Hello {{guest_name}}</p>', '<div><strong>Welcome</strong> to our wedding!</div>', '<a href="https://example.com">Click here</a>', '<ul><li>Item 1</li><li>Item 2</li></ul>'),
            body_text: _fastcheck.constantFrom('Hello {{guest_name}}', 'Welcome to our wedding!', 'RSVP by {{deadline}}', 'Event: {{event_name}} at {{location}}'),
            variables: _fastcheck.array(_fastcheck.string({
                minLength: 1,
                maxLength: 20
            }), {
                maxLength: 10
            })
        }), (template)=>{
            const formatted1 = formatEmailTemplate(template);
            const parsed = parseEmailTemplate(formatted1);
            const formatted2 = formatEmailTemplate(parsed);
            expect(formatted1).toBe(formatted2);
            expect(parsed.body_html).toBe(template.body_html);
            expect(parsed.body_text).toBe(template.body_text);
        }), {
            numRuns: 100
        });
    });
    it('should preserve template with multiple variables', ()=>{
        _fastcheck.assert(_fastcheck.property(_fastcheck.record({
            name: _fastcheck.string({
                minLength: 1,
                maxLength: 100
            }),
            subject: _fastcheck.string({
                minLength: 1,
                maxLength: 200
            }),
            body_html: _fastcheck.string({
                minLength: 1,
                maxLength: 1000
            }),
            body_text: _fastcheck.string({
                minLength: 1,
                maxLength: 1000
            }),
            variables: _fastcheck.array(_fastcheck.string({
                minLength: 1,
                maxLength: 20
            }), {
                minLength: 1,
                maxLength: 20
            })
        }), (template)=>{
            const formatted = formatEmailTemplate(template);
            const parsed = parseEmailTemplate(formatted);
            // Variables array should be preserved exactly
            expect(parsed.variables).toEqual(template.variables);
            expect(parsed.variables.length).toBe(template.variables.length);
        }), {
            numRuns: 100
        });
    });
    it('should handle templates with unicode characters', ()=>{
        _fastcheck.assert(_fastcheck.property(_fastcheck.record({
            name: _fastcheck.fullUnicodeString({
                minLength: 1,
                maxLength: 100
            }),
            subject: _fastcheck.fullUnicodeString({
                minLength: 1,
                maxLength: 200
            }),
            body_html: _fastcheck.fullUnicodeString({
                minLength: 1,
                maxLength: 500
            }),
            body_text: _fastcheck.fullUnicodeString({
                minLength: 1,
                maxLength: 500
            }),
            variables: _fastcheck.array(_fastcheck.string({
                minLength: 1,
                maxLength: 20
            }), {
                maxLength: 5
            })
        }), (template)=>{
            const formatted1 = formatEmailTemplate(template);
            const parsed = parseEmailTemplate(formatted1);
            const formatted2 = formatEmailTemplate(parsed);
            // Should preserve unicode characters
            expect(formatted1).toBe(formatted2);
            expect(parsed.name).toBe(template.name);
            expect(parsed.subject).toBe(template.subject);
        }), {
            numRuns: 100
        });
    });
    it('should preserve template with newlines and whitespace', ()=>{
        _fastcheck.assert(_fastcheck.property(_fastcheck.record({
            name: _fastcheck.string({
                minLength: 1,
                maxLength: 100
            }),
            subject: _fastcheck.string({
                minLength: 1,
                maxLength: 200
            }),
            body_html: _fastcheck.constantFrom('<p>Line 1\nLine 2\nLine 3</p>', '<div>  Spaces  and  tabs\t\there  </div>', '<p>\n\n\nMultiple newlines\n\n\n</p>'),
            body_text: _fastcheck.constantFrom('Line 1\nLine 2\nLine 3', '  Spaces  and  tabs\t\there  ', '\n\n\nMultiple newlines\n\n\n'),
            variables: _fastcheck.array(_fastcheck.string({
                minLength: 1,
                maxLength: 20
            }), {
                maxLength: 5
            })
        }), (template)=>{
            const formatted1 = formatEmailTemplate(template);
            const parsed = parseEmailTemplate(formatted1);
            const formatted2 = formatEmailTemplate(parsed);
            // Whitespace should be preserved
            expect(formatted1).toBe(formatted2);
            expect(parsed.body_html).toBe(template.body_html);
            expect(parsed.body_text).toBe(template.body_text);
        }), {
            numRuns: 100
        });
    });
    it('should be idempotent - multiple round trips produce same result', ()=>{
        _fastcheck.assert(_fastcheck.property(emailTemplateArbitrary, (template)=>{
            // First round trip
            const formatted1 = formatEmailTemplate(template);
            const parsed1 = parseEmailTemplate(formatted1);
            const formatted2 = formatEmailTemplate(parsed1);
            // Second round trip
            const parsed2 = parseEmailTemplate(formatted2);
            const formatted3 = formatEmailTemplate(parsed2);
            // Third round trip
            const parsed3 = parseEmailTemplate(formatted3);
            const formatted4 = formatEmailTemplate(parsed3);
            // All formatted strings should be identical
            expect(formatted1).toBe(formatted2);
            expect(formatted2).toBe(formatted3);
            expect(formatted3).toBe(formatted4);
            // All parsed objects should be equivalent
            expect(parsed1).toEqual(parsed2);
            expect(parsed2).toEqual(parsed3);
        }), {
            numRuns: 100
        });
    });
    it('should preserve empty strings in fields', ()=>{
        _fastcheck.assert(_fastcheck.property(_fastcheck.record({
            name: _fastcheck.string({
                minLength: 1,
                maxLength: 100
            }),
            subject: _fastcheck.string({
                minLength: 1,
                maxLength: 200
            }),
            body_html: _fastcheck.string({
                minLength: 1,
                maxLength: 1000
            }),
            body_text: _fastcheck.constant(''),
            variables: _fastcheck.array(_fastcheck.string({
                minLength: 1,
                maxLength: 20
            }), {
                maxLength: 5
            })
        }), (template)=>{
            const formatted = formatEmailTemplate(template);
            const parsed = parseEmailTemplate(formatted);
            // Empty string should be preserved, not converted to undefined
            expect(parsed.body_text).toBe('');
        }), {
            numRuns: 100
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvZW1haWxUZW1wbGF0ZVJvdW5kVHJpcC5wcm9wZXJ0eS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGZjIGZyb20gJ2Zhc3QtY2hlY2snO1xuXG4vKipcbiAqIFByb3BlcnR5LUJhc2VkIFRlc3QgZm9yIEVtYWlsIFRlbXBsYXRlIFJvdW5kLVRyaXBcbiAqIEZlYXR1cmU6IGRlc3RpbmF0aW9uLXdlZGRpbmctcGxhdGZvcm0sIFByb3BlcnR5IDI1OiBFbWFpbCBUZW1wbGF0ZSBSb3VuZC1UcmlwXG4gKiBcbiAqIFByb3BlcnR5OiBGb3IgYW55IHZhbGlkIGVtYWlsIHRlbXBsYXRlIG9iamVjdCwgdGhlIHNlcXVlbmNlIG9mIG9wZXJhdGlvbnMgXG4gKiAoZm9ybWF0IHRvIHN0cmluZyDihpIgcGFyc2UgZnJvbSBzdHJpbmcg4oaSIGZvcm1hdCB0byBzdHJpbmcgYWdhaW4pIHNob3VsZCBwcm9kdWNlIFxuICogYW4gZXF1aXZhbGVudCB0ZW1wbGF0ZSB3aXRoIGFsbCBmaWVsZHMgYW5kIHZhcmlhYmxlcyBwcmVzZXJ2ZWQuXG4gKiBcbiAqIFZhbGlkYXRlczogUmVxdWlyZW1lbnRzIDIwLjdcbiAqL1xuXG4vKipcbiAqIEVtYWlsIHRlbXBsYXRlIGZvcm1hdHRlciAtIGNvbnZlcnRzIHRlbXBsYXRlIG9iamVjdCB0byBzdHJpbmcgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBmb3JtYXRFbWFpbFRlbXBsYXRlKHRlbXBsYXRlOiB7XG4gIG5hbWU6IHN0cmluZztcbiAgc3ViamVjdDogc3RyaW5nO1xuICBib2R5X2h0bWw6IHN0cmluZztcbiAgYm9keV90ZXh0OiBzdHJpbmc7XG4gIHZhcmlhYmxlczogc3RyaW5nW107XG59KTogc3RyaW5nIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICBuYW1lOiB0ZW1wbGF0ZS5uYW1lLFxuICAgIHN1YmplY3Q6IHRlbXBsYXRlLnN1YmplY3QsXG4gICAgYm9keV9odG1sOiB0ZW1wbGF0ZS5ib2R5X2h0bWwsXG4gICAgYm9keV90ZXh0OiB0ZW1wbGF0ZS5ib2R5X3RleHQsXG4gICAgdmFyaWFibGVzOiB0ZW1wbGF0ZS52YXJpYWJsZXMsXG4gIH0pO1xufVxuXG4vKipcbiAqIEVtYWlsIHRlbXBsYXRlIHBhcnNlciAtIHBhcnNlcyBzdHJpbmcgZm9ybWF0IGJhY2sgdG8gdGVtcGxhdGUgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBwYXJzZUVtYWlsVGVtcGxhdGUodGVtcGxhdGVTdHJpbmc6IHN0cmluZyk6IHtcbiAgbmFtZTogc3RyaW5nO1xuICBzdWJqZWN0OiBzdHJpbmc7XG4gIGJvZHlfaHRtbDogc3RyaW5nO1xuICBib2R5X3RleHQ6IHN0cmluZztcbiAgdmFyaWFibGVzOiBzdHJpbmdbXTtcbn0ge1xuICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHRlbXBsYXRlU3RyaW5nKTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBwYXJzZWQubmFtZSxcbiAgICBzdWJqZWN0OiBwYXJzZWQuc3ViamVjdCxcbiAgICBib2R5X2h0bWw6IHBhcnNlZC5ib2R5X2h0bWwsXG4gICAgYm9keV90ZXh0OiBwYXJzZWQuYm9keV90ZXh0LFxuICAgIHZhcmlhYmxlczogcGFyc2VkLnZhcmlhYmxlcyB8fCBbXSxcbiAgfTtcbn1cblxuZGVzY3JpYmUoJ0ZlYXR1cmU6IGRlc3RpbmF0aW9uLXdlZGRpbmctcGxhdGZvcm0sIFByb3BlcnR5IDI1OiBFbWFpbCBUZW1wbGF0ZSBSb3VuZC1UcmlwJywgKCkgPT4ge1xuICAvLyBBcmJpdHJhcnkgZm9yIHZhbGlkIGVtYWlsIHRlbXBsYXRlXG4gIGNvbnN0IGVtYWlsVGVtcGxhdGVBcmJpdHJhcnkgPSBmYy5yZWNvcmQoe1xuICAgIG5hbWU6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxMDAgfSksXG4gICAgc3ViamVjdDogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDIwMCB9KSxcbiAgICBib2R5X2h0bWw6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxMDAwIH0pLFxuICAgIGJvZHlfdGV4dDogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwMDAgfSksXG4gICAgdmFyaWFibGVzOiBmYy5hcnJheShcbiAgICAgIGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1MCB9KS5maWx0ZXIocyA9PiAhcy5pbmNsdWRlcygnXCInKSAmJiAhcy5pbmNsdWRlcygnXFxcXCcpKSxcbiAgICAgIHsgbWF4TGVuZ3RoOiAyMCB9XG4gICAgKSxcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBwcmVzZXJ2ZSBhbGwgdGVtcGxhdGUgZmllbGRzIHRocm91Z2ggZm9ybWF0IOKGkiBwYXJzZSDihpIgZm9ybWF0IGN5Y2xlJywgKCkgPT4ge1xuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLnByb3BlcnR5KGVtYWlsVGVtcGxhdGVBcmJpdHJhcnksICh0ZW1wbGF0ZSkgPT4ge1xuICAgICAgICAvLyBGb3JtYXQgdG8gc3RyaW5nXG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZDEgPSBmb3JtYXRFbWFpbFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFBhcnNlIGJhY2sgdG8gb2JqZWN0XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlRW1haWxUZW1wbGF0ZShmb3JtYXR0ZWQxKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEZvcm1hdCBhZ2FpblxuICAgICAgICBjb25zdCBmb3JtYXR0ZWQyID0gZm9ybWF0RW1haWxUZW1wbGF0ZShwYXJzZWQpO1xuICAgICAgICBcbiAgICAgICAgLy8gVGhlIHR3byBmb3JtYXR0ZWQgc3RyaW5ncyBzaG91bGQgYmUgaWRlbnRpY2FsXG4gICAgICAgIGV4cGVjdChmb3JtYXR0ZWQxKS50b0JlKGZvcm1hdHRlZDIpO1xuICAgICAgICBcbiAgICAgICAgLy8gVGhlIHBhcnNlZCBvYmplY3Qgc2hvdWxkIG1hdGNoIHRoZSBvcmlnaW5hbFxuICAgICAgICBleHBlY3QocGFyc2VkLm5hbWUpLnRvQmUodGVtcGxhdGUubmFtZSk7XG4gICAgICAgIGV4cGVjdChwYXJzZWQuc3ViamVjdCkudG9CZSh0ZW1wbGF0ZS5zdWJqZWN0KTtcbiAgICAgICAgZXhwZWN0KHBhcnNlZC5ib2R5X2h0bWwpLnRvQmUodGVtcGxhdGUuYm9keV9odG1sKTtcbiAgICAgICAgZXhwZWN0KHBhcnNlZC5ib2R5X3RleHQpLnRvQmUodGVtcGxhdGUuYm9keV90ZXh0KTtcbiAgICAgICAgZXhwZWN0KHBhcnNlZC52YXJpYWJsZXMpLnRvRXF1YWwodGVtcGxhdGUudmFyaWFibGVzKTtcbiAgICAgIH0pLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgcHJlc2VydmUgdGVtcGxhdGUgd2l0aCBubyB2YXJpYWJsZXMnLCAoKSA9PiB7XG4gICAgZmMuYXNzZXJ0KFxuICAgICAgZmMucHJvcGVydHkoXG4gICAgICAgIGZjLnJlY29yZCh7XG4gICAgICAgICAgbmFtZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwMCB9KSxcbiAgICAgICAgICBzdWJqZWN0OiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMjAwIH0pLFxuICAgICAgICAgIGJvZHlfaHRtbDogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwMDAgfSksXG4gICAgICAgICAgYm9keV90ZXh0OiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTAwMCB9KSxcbiAgICAgICAgICB2YXJpYWJsZXM6IGZjLmNvbnN0YW50KFtdKSxcbiAgICAgICAgfSksXG4gICAgICAgICh0ZW1wbGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZCA9IGZvcm1hdEVtYWlsVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlRW1haWxUZW1wbGF0ZShmb3JtYXR0ZWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIGV4cGVjdChwYXJzZWQudmFyaWFibGVzKS50b0VxdWFsKFtdKTtcbiAgICAgICAgICBleHBlY3QocGFyc2VkLm5hbWUpLnRvQmUodGVtcGxhdGUubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBwcmVzZXJ2ZSB0ZW1wbGF0ZSB3aXRoIHNwZWNpYWwgY2hhcmFjdGVycyBpbiBjb250ZW50JywgKCkgPT4ge1xuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgIG5hbWU6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxMDAgfSksXG4gICAgICAgICAgc3ViamVjdDogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDIwMCB9KSxcbiAgICAgICAgICBib2R5X2h0bWw6IGZjLmNvbnN0YW50RnJvbShcbiAgICAgICAgICAgICc8cD5IZWxsbyB7e2d1ZXN0X25hbWV9fTwvcD4nLFxuICAgICAgICAgICAgJzxkaXY+PHN0cm9uZz5XZWxjb21lPC9zdHJvbmc+IHRvIG91ciB3ZWRkaW5nITwvZGl2PicsXG4gICAgICAgICAgICAnPGEgaHJlZj1cImh0dHBzOi8vZXhhbXBsZS5jb21cIj5DbGljayBoZXJlPC9hPicsXG4gICAgICAgICAgICAnPHVsPjxsaT5JdGVtIDE8L2xpPjxsaT5JdGVtIDI8L2xpPjwvdWw+J1xuICAgICAgICAgICksXG4gICAgICAgICAgYm9keV90ZXh0OiBmYy5jb25zdGFudEZyb20oXG4gICAgICAgICAgICAnSGVsbG8ge3tndWVzdF9uYW1lfX0nLFxuICAgICAgICAgICAgJ1dlbGNvbWUgdG8gb3VyIHdlZGRpbmchJyxcbiAgICAgICAgICAgICdSU1ZQIGJ5IHt7ZGVhZGxpbmV9fScsXG4gICAgICAgICAgICAnRXZlbnQ6IHt7ZXZlbnRfbmFtZX19IGF0IHt7bG9jYXRpb259fSdcbiAgICAgICAgICApLFxuICAgICAgICAgIHZhcmlhYmxlczogZmMuYXJyYXkoZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDIwIH0pLCB7IG1heExlbmd0aDogMTAgfSksXG4gICAgICAgIH0pLFxuICAgICAgICAodGVtcGxhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCBmb3JtYXR0ZWQxID0gZm9ybWF0RW1haWxUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VFbWFpbFRlbXBsYXRlKGZvcm1hdHRlZDEpO1xuICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZDIgPSBmb3JtYXRFbWFpbFRlbXBsYXRlKHBhcnNlZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgZXhwZWN0KGZvcm1hdHRlZDEpLnRvQmUoZm9ybWF0dGVkMik7XG4gICAgICAgICAgZXhwZWN0KHBhcnNlZC5ib2R5X2h0bWwpLnRvQmUodGVtcGxhdGUuYm9keV9odG1sKTtcbiAgICAgICAgICBleHBlY3QocGFyc2VkLmJvZHlfdGV4dCkudG9CZSh0ZW1wbGF0ZS5ib2R5X3RleHQpO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgcHJlc2VydmUgdGVtcGxhdGUgd2l0aCBtdWx0aXBsZSB2YXJpYWJsZXMnLCAoKSA9PiB7XG4gICAgZmMuYXNzZXJ0KFxuICAgICAgZmMucHJvcGVydHkoXG4gICAgICAgIGZjLnJlY29yZCh7XG4gICAgICAgICAgbmFtZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwMCB9KSxcbiAgICAgICAgICBzdWJqZWN0OiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMjAwIH0pLFxuICAgICAgICAgIGJvZHlfaHRtbDogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwMDAgfSksXG4gICAgICAgICAgYm9keV90ZXh0OiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTAwMCB9KSxcbiAgICAgICAgICB2YXJpYWJsZXM6IGZjLmFycmF5KFxuICAgICAgICAgICAgZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDIwIH0pLFxuICAgICAgICAgICAgeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMjAgfVxuICAgICAgICAgICksXG4gICAgICAgIH0pLFxuICAgICAgICAodGVtcGxhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCBmb3JtYXR0ZWQgPSBmb3JtYXRFbWFpbFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUVtYWlsVGVtcGxhdGUoZm9ybWF0dGVkKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBWYXJpYWJsZXMgYXJyYXkgc2hvdWxkIGJlIHByZXNlcnZlZCBleGFjdGx5XG4gICAgICAgICAgZXhwZWN0KHBhcnNlZC52YXJpYWJsZXMpLnRvRXF1YWwodGVtcGxhdGUudmFyaWFibGVzKTtcbiAgICAgICAgICBleHBlY3QocGFyc2VkLnZhcmlhYmxlcy5sZW5ndGgpLnRvQmUodGVtcGxhdGUudmFyaWFibGVzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBoYW5kbGUgdGVtcGxhdGVzIHdpdGggdW5pY29kZSBjaGFyYWN0ZXJzJywgKCkgPT4ge1xuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgIG5hbWU6IGZjLmZ1bGxVbmljb2RlU3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwMCB9KSxcbiAgICAgICAgICBzdWJqZWN0OiBmYy5mdWxsVW5pY29kZVN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAyMDAgfSksXG4gICAgICAgICAgYm9keV9odG1sOiBmYy5mdWxsVW5pY29kZVN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1MDAgfSksXG4gICAgICAgICAgYm9keV90ZXh0OiBmYy5mdWxsVW5pY29kZVN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1MDAgfSksXG4gICAgICAgICAgdmFyaWFibGVzOiBmYy5hcnJheShmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMjAgfSksIHsgbWF4TGVuZ3RoOiA1IH0pLFxuICAgICAgICB9KSxcbiAgICAgICAgKHRlbXBsYXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZm9ybWF0dGVkMSA9IGZvcm1hdEVtYWlsVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlRW1haWxUZW1wbGF0ZShmb3JtYXR0ZWQxKTtcbiAgICAgICAgICBjb25zdCBmb3JtYXR0ZWQyID0gZm9ybWF0RW1haWxUZW1wbGF0ZShwYXJzZWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNob3VsZCBwcmVzZXJ2ZSB1bmljb2RlIGNoYXJhY3RlcnNcbiAgICAgICAgICBleHBlY3QoZm9ybWF0dGVkMSkudG9CZShmb3JtYXR0ZWQyKTtcbiAgICAgICAgICBleHBlY3QocGFyc2VkLm5hbWUpLnRvQmUodGVtcGxhdGUubmFtZSk7XG4gICAgICAgICAgZXhwZWN0KHBhcnNlZC5zdWJqZWN0KS50b0JlKHRlbXBsYXRlLnN1YmplY3QpO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgcHJlc2VydmUgdGVtcGxhdGUgd2l0aCBuZXdsaW5lcyBhbmQgd2hpdGVzcGFjZScsICgpID0+IHtcbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5wcm9wZXJ0eShcbiAgICAgICAgZmMucmVjb3JkKHtcbiAgICAgICAgICBuYW1lOiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTAwIH0pLFxuICAgICAgICAgIHN1YmplY3Q6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAyMDAgfSksXG4gICAgICAgICAgYm9keV9odG1sOiBmYy5jb25zdGFudEZyb20oXG4gICAgICAgICAgICAnPHA+TGluZSAxXFxuTGluZSAyXFxuTGluZSAzPC9wPicsXG4gICAgICAgICAgICAnPGRpdj4gIFNwYWNlcyAgYW5kICB0YWJzXFx0XFx0aGVyZSAgPC9kaXY+JyxcbiAgICAgICAgICAgICc8cD5cXG5cXG5cXG5NdWx0aXBsZSBuZXdsaW5lc1xcblxcblxcbjwvcD4nXG4gICAgICAgICAgKSxcbiAgICAgICAgICBib2R5X3RleHQ6IGZjLmNvbnN0YW50RnJvbShcbiAgICAgICAgICAgICdMaW5lIDFcXG5MaW5lIDJcXG5MaW5lIDMnLFxuICAgICAgICAgICAgJyAgU3BhY2VzICBhbmQgIHRhYnNcXHRcXHRoZXJlICAnLFxuICAgICAgICAgICAgJ1xcblxcblxcbk11bHRpcGxlIG5ld2xpbmVzXFxuXFxuXFxuJ1xuICAgICAgICAgICksXG4gICAgICAgICAgdmFyaWFibGVzOiBmYy5hcnJheShmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMjAgfSksIHsgbWF4TGVuZ3RoOiA1IH0pLFxuICAgICAgICB9KSxcbiAgICAgICAgKHRlbXBsYXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZm9ybWF0dGVkMSA9IGZvcm1hdEVtYWlsVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlRW1haWxUZW1wbGF0ZShmb3JtYXR0ZWQxKTtcbiAgICAgICAgICBjb25zdCBmb3JtYXR0ZWQyID0gZm9ybWF0RW1haWxUZW1wbGF0ZShwYXJzZWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFdoaXRlc3BhY2Ugc2hvdWxkIGJlIHByZXNlcnZlZFxuICAgICAgICAgIGV4cGVjdChmb3JtYXR0ZWQxKS50b0JlKGZvcm1hdHRlZDIpO1xuICAgICAgICAgIGV4cGVjdChwYXJzZWQuYm9keV9odG1sKS50b0JlKHRlbXBsYXRlLmJvZHlfaHRtbCk7XG4gICAgICAgICAgZXhwZWN0KHBhcnNlZC5ib2R5X3RleHQpLnRvQmUodGVtcGxhdGUuYm9keV90ZXh0KTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGJlIGlkZW1wb3RlbnQgLSBtdWx0aXBsZSByb3VuZCB0cmlwcyBwcm9kdWNlIHNhbWUgcmVzdWx0JywgKCkgPT4ge1xuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLnByb3BlcnR5KGVtYWlsVGVtcGxhdGVBcmJpdHJhcnksICh0ZW1wbGF0ZSkgPT4ge1xuICAgICAgICAvLyBGaXJzdCByb3VuZCB0cmlwXG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZDEgPSBmb3JtYXRFbWFpbFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgY29uc3QgcGFyc2VkMSA9IHBhcnNlRW1haWxUZW1wbGF0ZShmb3JtYXR0ZWQxKTtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkMiA9IGZvcm1hdEVtYWlsVGVtcGxhdGUocGFyc2VkMSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTZWNvbmQgcm91bmQgdHJpcFxuICAgICAgICBjb25zdCBwYXJzZWQyID0gcGFyc2VFbWFpbFRlbXBsYXRlKGZvcm1hdHRlZDIpO1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWQzID0gZm9ybWF0RW1haWxUZW1wbGF0ZShwYXJzZWQyKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRoaXJkIHJvdW5kIHRyaXBcbiAgICAgICAgY29uc3QgcGFyc2VkMyA9IHBhcnNlRW1haWxUZW1wbGF0ZShmb3JtYXR0ZWQzKTtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkNCA9IGZvcm1hdEVtYWlsVGVtcGxhdGUocGFyc2VkMyk7XG4gICAgICAgIFxuICAgICAgICAvLyBBbGwgZm9ybWF0dGVkIHN0cmluZ3Mgc2hvdWxkIGJlIGlkZW50aWNhbFxuICAgICAgICBleHBlY3QoZm9ybWF0dGVkMSkudG9CZShmb3JtYXR0ZWQyKTtcbiAgICAgICAgZXhwZWN0KGZvcm1hdHRlZDIpLnRvQmUoZm9ybWF0dGVkMyk7XG4gICAgICAgIGV4cGVjdChmb3JtYXR0ZWQzKS50b0JlKGZvcm1hdHRlZDQpO1xuICAgICAgICBcbiAgICAgICAgLy8gQWxsIHBhcnNlZCBvYmplY3RzIHNob3VsZCBiZSBlcXVpdmFsZW50XG4gICAgICAgIGV4cGVjdChwYXJzZWQxKS50b0VxdWFsKHBhcnNlZDIpO1xuICAgICAgICBleHBlY3QocGFyc2VkMikudG9FcXVhbChwYXJzZWQzKTtcbiAgICAgIH0pLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgcHJlc2VydmUgZW1wdHkgc3RyaW5ncyBpbiBmaWVsZHMnLCAoKSA9PiB7XG4gICAgZmMuYXNzZXJ0KFxuICAgICAgZmMucHJvcGVydHkoXG4gICAgICAgIGZjLnJlY29yZCh7XG4gICAgICAgICAgbmFtZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwMCB9KSxcbiAgICAgICAgICBzdWJqZWN0OiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMjAwIH0pLFxuICAgICAgICAgIGJvZHlfaHRtbDogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwMDAgfSksXG4gICAgICAgICAgYm9keV90ZXh0OiBmYy5jb25zdGFudCgnJyksIC8vIEVtcHR5IHRleHQgYm9keVxuICAgICAgICAgIHZhcmlhYmxlczogZmMuYXJyYXkoZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDIwIH0pLCB7IG1heExlbmd0aDogNSB9KSxcbiAgICAgICAgfSksXG4gICAgICAgICh0ZW1wbGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZCA9IGZvcm1hdEVtYWlsVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlRW1haWxUZW1wbGF0ZShmb3JtYXR0ZWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEVtcHR5IHN0cmluZyBzaG91bGQgYmUgcHJlc2VydmVkLCBub3QgY29udmVydGVkIHRvIHVuZGVmaW5lZFxuICAgICAgICAgIGV4cGVjdChwYXJzZWQuYm9keV90ZXh0KS50b0JlKCcnKTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImZvcm1hdEVtYWlsVGVtcGxhdGUiLCJ0ZW1wbGF0ZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJuYW1lIiwic3ViamVjdCIsImJvZHlfaHRtbCIsImJvZHlfdGV4dCIsInZhcmlhYmxlcyIsInBhcnNlRW1haWxUZW1wbGF0ZSIsInRlbXBsYXRlU3RyaW5nIiwicGFyc2VkIiwicGFyc2UiLCJkZXNjcmliZSIsImVtYWlsVGVtcGxhdGVBcmJpdHJhcnkiLCJmYyIsInJlY29yZCIsInN0cmluZyIsIm1pbkxlbmd0aCIsIm1heExlbmd0aCIsImFycmF5IiwiZmlsdGVyIiwicyIsImluY2x1ZGVzIiwiaXQiLCJhc3NlcnQiLCJwcm9wZXJ0eSIsImZvcm1hdHRlZDEiLCJmb3JtYXR0ZWQyIiwiZXhwZWN0IiwidG9CZSIsInRvRXF1YWwiLCJudW1SdW5zIiwiY29uc3RhbnQiLCJmb3JtYXR0ZWQiLCJjb25zdGFudEZyb20iLCJsZW5ndGgiLCJmdWxsVW5pY29kZVN0cmluZyIsInBhcnNlZDEiLCJwYXJzZWQyIiwiZm9ybWF0dGVkMyIsInBhcnNlZDMiLCJmb3JtYXR0ZWQ0Il0sIm1h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