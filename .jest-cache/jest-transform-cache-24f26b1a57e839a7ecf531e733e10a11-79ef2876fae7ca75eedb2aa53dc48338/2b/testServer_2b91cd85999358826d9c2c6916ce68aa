f814f907a0cd0bd03acee819e1231115
/**
 * Test Server Utilities
 * 
 * Utilities for starting and managing a real Next.js dev server for integration tests.
 * This allows testing against actual API routes instead of mocked implementations.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get authenticatedRequest () {
        return authenticatedRequest;
    },
    get getTestServerUrl () {
        return getTestServerUrl;
    },
    get isTestServerRunning () {
        return isTestServerRunning;
    },
    get startTestServer () {
        return startTestServer;
    },
    get stopTestServer () {
        return stopTestServer;
    }
});
const _child_process = require("child_process");
let serverProcess = null;
const SERVER_PORT = 3001; // Use different port than dev server
const SERVER_URL = `http://localhost:${SERVER_PORT}`;
/**
 * Wait for server to be ready by polling the health endpoint
 */ async function waitForServer(maxAttempts = 30, delayMs = 1000) {
    for(let i = 0; i < maxAttempts; i++){
        try {
            const response = await fetch(`${SERVER_URL}/api/health`);
            if (response.ok) {
                console.log('âœ… Test server is ready');
                return;
            }
        } catch (error) {
        // Server not ready yet, continue waiting
        }
        await new Promise((resolve)=>setTimeout(resolve, delayMs));
    }
    throw new Error(`Server did not start after ${maxAttempts} attempts`);
}
async function startTestServer() {
    if (serverProcess) {
        console.log('âš ï¸  Test server already running');
        return SERVER_URL;
    }
    console.log('ðŸš€ Starting test server...');
    serverProcess = (0, _child_process.spawn)('npm', [
        'run',
        'dev',
        '--',
        '-p',
        SERVER_PORT.toString()
    ], {
        stdio: 'pipe',
        env: {
            ...process.env,
            NODE_ENV: 'test',
            PORT: SERVER_PORT.toString()
        }
    });
    // Log server output for debugging
    serverProcess.stdout?.on('data', (data)=>{
        const output = data.toString();
        if (output.includes('Ready') || output.includes('started')) {
            console.log('ðŸ“¡ Server output:', output.trim());
        }
    });
    serverProcess.stderr?.on('data', (data)=>{
        console.error('âŒ Server error:', data.toString());
    });
    serverProcess.on('error', (error)=>{
        console.error('âŒ Failed to start server:', error);
    });
    // Wait for server to be ready
    await waitForServer();
    return SERVER_URL;
}
async function stopTestServer() {
    if (!serverProcess) {
        return;
    }
    console.log('ðŸ›‘ Stopping test server...');
    return new Promise((resolve)=>{
        if (!serverProcess) {
            resolve();
            return;
        }
        serverProcess.on('exit', ()=>{
            serverProcess = null;
            console.log('âœ… Test server stopped');
            resolve();
        });
        // Try graceful shutdown first
        serverProcess.kill('SIGTERM');
        // Force kill after 5 seconds if still running
        setTimeout(()=>{
            if (serverProcess) {
                serverProcess.kill('SIGKILL');
            }
        }, 5000);
    });
}
async function authenticatedRequest(path, options = {}) {
    // TODO: Implement authentication
    // For now, just make the request
    const url = `${SERVER_URL}${path}`;
    return fetch(url, options);
}
function getTestServerUrl() {
    return SERVER_URL;
}
function isTestServerRunning() {
    return serverProcess !== null;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvX190ZXN0c19fL2hlbHBlcnMvdGVzdFNlcnZlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRlc3QgU2VydmVyIFV0aWxpdGllc1xuICogXG4gKiBVdGlsaXRpZXMgZm9yIHN0YXJ0aW5nIGFuZCBtYW5hZ2luZyBhIHJlYWwgTmV4dC5qcyBkZXYgc2VydmVyIGZvciBpbnRlZ3JhdGlvbiB0ZXN0cy5cbiAqIFRoaXMgYWxsb3dzIHRlc3RpbmcgYWdhaW5zdCBhY3R1YWwgQVBJIHJvdXRlcyBpbnN0ZWFkIG9mIG1vY2tlZCBpbXBsZW1lbnRhdGlvbnMuXG4gKi9cblxuaW1wb3J0IHsgc3Bhd24sIENoaWxkUHJvY2VzcyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuXG5sZXQgc2VydmVyUHJvY2VzczogQ2hpbGRQcm9jZXNzIHwgbnVsbCA9IG51bGw7XG5jb25zdCBTRVJWRVJfUE9SVCA9IDMwMDE7IC8vIFVzZSBkaWZmZXJlbnQgcG9ydCB0aGFuIGRldiBzZXJ2ZXJcbmNvbnN0IFNFUlZFUl9VUkwgPSBgaHR0cDovL2xvY2FsaG9zdDoke1NFUlZFUl9QT1JUfWA7XG5cbi8qKlxuICogV2FpdCBmb3Igc2VydmVyIHRvIGJlIHJlYWR5IGJ5IHBvbGxpbmcgdGhlIGhlYWx0aCBlbmRwb2ludFxuICovXG5hc3luYyBmdW5jdGlvbiB3YWl0Rm9yU2VydmVyKG1heEF0dGVtcHRzID0gMzAsIGRlbGF5TXMgPSAxMDAwKTogUHJvbWlzZTx2b2lkPiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4QXR0ZW1wdHM7IGkrKykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke1NFUlZFUl9VUkx9L2FwaS9oZWFsdGhgKTtcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zb2xlLmxvZygn4pyFIFRlc3Qgc2VydmVyIGlzIHJlYWR5Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gU2VydmVyIG5vdCByZWFkeSB5ZXQsIGNvbnRpbnVlIHdhaXRpbmdcbiAgICB9XG4gICAgXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5TXMpKTtcbiAgfVxuICBcbiAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgZGlkIG5vdCBzdGFydCBhZnRlciAke21heEF0dGVtcHRzfSBhdHRlbXB0c2ApO1xufVxuXG4vKipcbiAqIFN0YXJ0IE5leHQuanMgZGV2IHNlcnZlciBmb3IgdGVzdGluZ1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RhcnRUZXN0U2VydmVyKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGlmIChzZXJ2ZXJQcm9jZXNzKSB7XG4gICAgY29uc29sZS5sb2coJ+KaoO+4jyAgVGVzdCBzZXJ2ZXIgYWxyZWFkeSBydW5uaW5nJyk7XG4gICAgcmV0dXJuIFNFUlZFUl9VUkw7XG4gIH1cbiAgXG4gIGNvbnNvbGUubG9nKCfwn5qAIFN0YXJ0aW5nIHRlc3Qgc2VydmVyLi4uJyk7XG4gIFxuICBzZXJ2ZXJQcm9jZXNzID0gc3Bhd24oJ25wbScsIFsncnVuJywgJ2RldicsICctLScsICctcCcsIFNFUlZFUl9QT1JULnRvU3RyaW5nKCldLCB7XG4gICAgc3RkaW86ICdwaXBlJyxcbiAgICBlbnY6IHtcbiAgICAgIC4uLnByb2Nlc3MuZW52LFxuICAgICAgTk9ERV9FTlY6ICd0ZXN0JyxcbiAgICAgIFBPUlQ6IFNFUlZFUl9QT1JULnRvU3RyaW5nKCksXG4gICAgfSxcbiAgfSk7XG4gIFxuICAvLyBMb2cgc2VydmVyIG91dHB1dCBmb3IgZGVidWdnaW5nXG4gIHNlcnZlclByb2Nlc3Muc3Rkb3V0Py5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0gZGF0YS50b1N0cmluZygpO1xuICAgIGlmIChvdXRwdXQuaW5jbHVkZXMoJ1JlYWR5JykgfHwgb3V0cHV0LmluY2x1ZGVzKCdzdGFydGVkJykpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OhIFNlcnZlciBvdXRwdXQ6Jywgb3V0cHV0LnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgXG4gIHNlcnZlclByb2Nlc3Muc3RkZXJyPy5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIFNlcnZlciBlcnJvcjonLCBkYXRhLnRvU3RyaW5nKCkpO1xuICB9KTtcbiAgXG4gIHNlcnZlclByb2Nlc3Mub24oJ2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBzdGFydCBzZXJ2ZXI6JywgZXJyb3IpO1xuICB9KTtcbiAgXG4gIC8vIFdhaXQgZm9yIHNlcnZlciB0byBiZSByZWFkeVxuICBhd2FpdCB3YWl0Rm9yU2VydmVyKCk7XG4gIFxuICByZXR1cm4gU0VSVkVSX1VSTDtcbn1cblxuLyoqXG4gKiBTdG9wIHRoZSB0ZXN0IHNlcnZlclxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RvcFRlc3RTZXJ2ZXIoKTogUHJvbWlzZTx2b2lkPiB7XG4gIGlmICghc2VydmVyUHJvY2Vzcykge1xuICAgIHJldHVybjtcbiAgfVxuICBcbiAgY29uc29sZS5sb2coJ/Cfm5EgU3RvcHBpbmcgdGVzdCBzZXJ2ZXIuLi4nKTtcbiAgXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGlmICghc2VydmVyUHJvY2Vzcykge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBzZXJ2ZXJQcm9jZXNzLm9uKCdleGl0JywgKCkgPT4ge1xuICAgICAgc2VydmVyUHJvY2VzcyA9IG51bGw7XG4gICAgICBjb25zb2xlLmxvZygn4pyFIFRlc3Qgc2VydmVyIHN0b3BwZWQnKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBUcnkgZ3JhY2VmdWwgc2h1dGRvd24gZmlyc3RcbiAgICBzZXJ2ZXJQcm9jZXNzLmtpbGwoJ1NJR1RFUk0nKTtcbiAgICBcbiAgICAvLyBGb3JjZSBraWxsIGFmdGVyIDUgc2Vjb25kcyBpZiBzdGlsbCBydW5uaW5nXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoc2VydmVyUHJvY2Vzcykge1xuICAgICAgICBzZXJ2ZXJQcm9jZXNzLmtpbGwoJ1NJR0tJTEwnKTtcbiAgICAgIH1cbiAgICB9LCA1MDAwKTtcbiAgfSk7XG59XG5cbi8qKlxuICogTWFrZSBhdXRoZW50aWNhdGVkIHJlcXVlc3QgdG8gdGVzdCBzZXJ2ZXJcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0KFxuICBwYXRoOiBzdHJpbmcsXG4gIG9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge31cbik6IFByb21pc2U8UmVzcG9uc2U+IHtcbiAgLy8gVE9ETzogSW1wbGVtZW50IGF1dGhlbnRpY2F0aW9uXG4gIC8vIEZvciBub3csIGp1c3QgbWFrZSB0aGUgcmVxdWVzdFxuICBjb25zdCB1cmwgPSBgJHtTRVJWRVJfVVJMfSR7cGF0aH1gO1xuICByZXR1cm4gZmV0Y2godXJsLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBHZXQgdGVzdCBzZXJ2ZXIgVVJMXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXN0U2VydmVyVXJsKCk6IHN0cmluZyB7XG4gIHJldHVybiBTRVJWRVJfVVJMO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRlc3Qgc2VydmVyIGlzIHJ1bm5pbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVGVzdFNlcnZlclJ1bm5pbmcoKTogYm9vbGVhbiB7XG4gIHJldHVybiBzZXJ2ZXJQcm9jZXNzICE9PSBudWxsO1xufVxuIl0sIm5hbWVzIjpbImF1dGhlbnRpY2F0ZWRSZXF1ZXN0IiwiZ2V0VGVzdFNlcnZlclVybCIsImlzVGVzdFNlcnZlclJ1bm5pbmciLCJzdGFydFRlc3RTZXJ2ZXIiLCJzdG9wVGVzdFNlcnZlciIsInNlcnZlclByb2Nlc3MiLCJTRVJWRVJfUE9SVCIsIlNFUlZFUl9VUkwiLCJ3YWl0Rm9yU2VydmVyIiwibWF4QXR0ZW1wdHMiLCJkZWxheU1zIiwiaSIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIkVycm9yIiwic3Bhd24iLCJ0b1N0cmluZyIsInN0ZGlvIiwiZW52IiwicHJvY2VzcyIsIk5PREVfRU5WIiwiUE9SVCIsInN0ZG91dCIsIm9uIiwiZGF0YSIsIm91dHB1dCIsImluY2x1ZGVzIiwidHJpbSIsInN0ZGVyciIsImtpbGwiLCJwYXRoIiwib3B0aW9ucyIsInVybCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0M7Ozs7Ozs7Ozs7O1FBNEdxQkE7ZUFBQUE7O1FBYU5DO2VBQUFBOztRQU9BQztlQUFBQTs7UUFoR01DO2VBQUFBOztRQTBDQUM7ZUFBQUE7OzsrQkF4RWM7QUFFcEMsSUFBSUMsZ0JBQXFDO0FBQ3pDLE1BQU1DLGNBQWMsTUFBTSxxQ0FBcUM7QUFDL0QsTUFBTUMsYUFBYSxDQUFDLGlCQUFpQixFQUFFRCxhQUFhO0FBRXBEOztDQUVDLEdBQ0QsZUFBZUUsY0FBY0MsY0FBYyxFQUFFLEVBQUVDLFVBQVUsSUFBSTtJQUMzRCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsYUFBYUUsSUFBSztRQUNwQyxJQUFJO1lBQ0YsTUFBTUMsV0FBVyxNQUFNQyxNQUFNLEdBQUdOLFdBQVcsV0FBVyxDQUFDO1lBQ3ZELElBQUlLLFNBQVNFLEVBQUUsRUFBRTtnQkFDZkMsUUFBUUMsR0FBRyxDQUFDO2dCQUNaO1lBQ0Y7UUFDRixFQUFFLE9BQU9DLE9BQU87UUFDZCx5Q0FBeUM7UUFDM0M7UUFFQSxNQUFNLElBQUlDLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVNUO0lBQ25EO0lBRUEsTUFBTSxJQUFJVyxNQUFNLENBQUMsMkJBQTJCLEVBQUVaLFlBQVksU0FBUyxDQUFDO0FBQ3RFO0FBS08sZUFBZU47SUFDcEIsSUFBSUUsZUFBZTtRQUNqQlUsUUFBUUMsR0FBRyxDQUFDO1FBQ1osT0FBT1Q7SUFDVDtJQUVBUSxRQUFRQyxHQUFHLENBQUM7SUFFWlgsZ0JBQWdCaUIsSUFBQUEsb0JBQUssRUFBQyxPQUFPO1FBQUM7UUFBTztRQUFPO1FBQU07UUFBTWhCLFlBQVlpQixRQUFRO0tBQUcsRUFBRTtRQUMvRUMsT0FBTztRQUNQQyxLQUFLO1lBQ0gsR0FBR0MsUUFBUUQsR0FBRztZQUNkRSxVQUFVO1lBQ1ZDLE1BQU10QixZQUFZaUIsUUFBUTtRQUM1QjtJQUNGO0lBRUEsa0NBQWtDO0lBQ2xDbEIsY0FBY3dCLE1BQU0sRUFBRUMsR0FBRyxRQUFRLENBQUNDO1FBQ2hDLE1BQU1DLFNBQVNELEtBQUtSLFFBQVE7UUFDNUIsSUFBSVMsT0FBT0MsUUFBUSxDQUFDLFlBQVlELE9BQU9DLFFBQVEsQ0FBQyxZQUFZO1lBQzFEbEIsUUFBUUMsR0FBRyxDQUFDLHFCQUFxQmdCLE9BQU9FLElBQUk7UUFDOUM7SUFDRjtJQUVBN0IsY0FBYzhCLE1BQU0sRUFBRUwsR0FBRyxRQUFRLENBQUNDO1FBQ2hDaEIsUUFBUUUsS0FBSyxDQUFDLG1CQUFtQmMsS0FBS1IsUUFBUTtJQUNoRDtJQUVBbEIsY0FBY3lCLEVBQUUsQ0FBQyxTQUFTLENBQUNiO1FBQ3pCRixRQUFRRSxLQUFLLENBQUMsNkJBQTZCQTtJQUM3QztJQUVBLDhCQUE4QjtJQUM5QixNQUFNVDtJQUVOLE9BQU9EO0FBQ1Q7QUFLTyxlQUFlSDtJQUNwQixJQUFJLENBQUNDLGVBQWU7UUFDbEI7SUFDRjtJQUVBVSxRQUFRQyxHQUFHLENBQUM7SUFFWixPQUFPLElBQUlFLFFBQVEsQ0FBQ0M7UUFDbEIsSUFBSSxDQUFDZCxlQUFlO1lBQ2xCYztZQUNBO1FBQ0Y7UUFFQWQsY0FBY3lCLEVBQUUsQ0FBQyxRQUFRO1lBQ3ZCekIsZ0JBQWdCO1lBQ2hCVSxRQUFRQyxHQUFHLENBQUM7WUFDWkc7UUFDRjtRQUVBLDhCQUE4QjtRQUM5QmQsY0FBYytCLElBQUksQ0FBQztRQUVuQiw4Q0FBOEM7UUFDOUNoQixXQUFXO1lBQ1QsSUFBSWYsZUFBZTtnQkFDakJBLGNBQWMrQixJQUFJLENBQUM7WUFDckI7UUFDRixHQUFHO0lBQ0w7QUFDRjtBQUtPLGVBQWVwQyxxQkFDcEJxQyxJQUFZLEVBQ1pDLFVBQXVCLENBQUMsQ0FBQztJQUV6QixpQ0FBaUM7SUFDakMsaUNBQWlDO0lBQ2pDLE1BQU1DLE1BQU0sR0FBR2hDLGFBQWE4QixNQUFNO0lBQ2xDLE9BQU94QixNQUFNMEIsS0FBS0Q7QUFDcEI7QUFLTyxTQUFTckM7SUFDZCxPQUFPTTtBQUNUO0FBS08sU0FBU0w7SUFDZCxPQUFPRyxrQkFBa0I7QUFDM0IifQ==