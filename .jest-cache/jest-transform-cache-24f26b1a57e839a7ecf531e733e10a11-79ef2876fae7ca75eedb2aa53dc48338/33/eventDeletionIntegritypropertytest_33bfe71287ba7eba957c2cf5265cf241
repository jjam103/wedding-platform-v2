f64bc7d0ecab16ed1e718bc0ab2340ff
"use strict";
// Mock Supabase
jest.mock('@supabase/supabase-js');
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _eventService = /*#__PURE__*/ _interop_require_wildcard(require("./eventService"));
const _activityService = /*#__PURE__*/ _interop_require_wildcard(require("./activityService"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
/**
 * Property-based tests for event deletion integrity.
 * Feature: destination-wedding-platform, Property 10: Event Deletion Integrity
 * 
 * Validates: Requirements 6.13
 * 
 * This test validates that when an event is deleted, associated independent activities
 * (activities with event_id set to the deleted event) are not cascade deleted but instead
 * have their event_id set to NULL, preserving data integrity.
 */ describe.skip('Feature: destination-wedding-platform, Property 10: Event Deletion Integrity', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://test.supabase.co';
        process.env.SUPABASE_SERVICE_ROLE_KEY = 'test-service-role-key';
    });
    it('should not cascade delete activities when event is deleted', ()=>{
        const eventIdArbitrary = _fastcheck.uuid();
        const activityArbitrary = _fastcheck.record({
            id: _fastcheck.uuid(),
            name: _fastcheck.string({
                minLength: 1,
                maxLength: 100
            }),
            activityType: _fastcheck.constantFrom('ceremony', 'reception', 'meal', 'transport', 'activity'),
            startTime: _fastcheck.date({
                min: new Date('2025-01-01'),
                max: new Date('2025-12-31')
            }).map((d)=>d.toISOString())
        });
        _fastcheck.assert(_fastcheck.asyncProperty(eventIdArbitrary, _fastcheck.array(activityArbitrary, {
            minLength: 1,
            maxLength: 10
        }), async (eventId, activities)=>{
            // Mock activities associated with the event
            const activitiesWithEvent = activities.map((a)=>({
                    ...a,
                    eventId
                }));
            // Mock the event deletion
            const mockDeleteEvent = jest.spyOn(_eventService, 'deleteEvent');
            mockDeleteEvent.mockResolvedValue({
                success: true,
                data: undefined
            });
            // Mock activity retrieval after deletion (activities should still exist with eventId = null)
            const mockListActivities = jest.spyOn(_activityService, 'list');
            const activitiesAfterDeletion = activities.map((a)=>({
                    ...a,
                    eventId: null,
                    locationId: null,
                    description: null,
                    endTime: null,
                    capacity: null,
                    costPerPerson: null,
                    hostSubsidy: null,
                    adultsOnly: false,
                    plusOneAllowed: true,
                    visibility: [],
                    status: 'draft',
                    displayOrder: 0,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                }));
            mockListActivities.mockResolvedValue({
                success: true,
                data: {
                    activities: activitiesAfterDeletion,
                    total: activitiesAfterDeletion.length,
                    page: 1,
                    pageSize: 50,
                    totalPages: 1
                }
            });
            // Delete the event
            const deleteResult = await _eventService.deleteEvent(eventId);
            // Property 1: Event deletion should succeed
            expect(deleteResult.success).toBe(true);
            // Query for activities that were associated with the event
            const activityIds = activities.map((a)=>a.id);
            const listResult = await _activityService.list({});
            // Property 2: Activities should still exist
            expect(listResult.success).toBe(true);
            if (listResult.success) {
                const retrievedActivityIds = listResult.data.activities.map((a)=>a.id);
                // Property 3: All original activities should still be present
                for (const activityId of activityIds){
                    expect(retrievedActivityIds).toContain(activityId);
                }
                // Property 4: Activities should have eventId set to null (not deleted)
                for (const activity of listResult.data.activities){
                    if (activityIds.includes(activity.id)) {
                        expect(activity.eventId).toBeNull();
                    }
                }
            }
            mockDeleteEvent.mockRestore();
            mockListActivities.mockRestore();
        }), {
            numRuns: 10,
            timeout: 30000
        });
    });
    it('should preserve activity data when event is deleted', ()=>{
        const eventIdArbitrary = _fastcheck.uuid();
        const activityArbitrary = _fastcheck.record({
            id: _fastcheck.uuid(),
            name: _fastcheck.string({
                minLength: 1,
                maxLength: 100
            }),
            activityType: _fastcheck.constantFrom('ceremony', 'reception', 'meal', 'transport', 'activity'),
            startTime: _fastcheck.date({
                min: new Date('2025-01-01'),
                max: new Date('2025-12-31')
            }).map((d)=>d.toISOString()),
            description: _fastcheck.option(_fastcheck.string({
                maxLength: 200
            }), {
                nil: null
            }),
            capacity: _fastcheck.option(_fastcheck.integer({
                min: 1,
                max: 100
            }), {
                nil: null
            }),
            costPerPerson: _fastcheck.option(_fastcheck.float({
                min: 0,
                max: 1000
            }), {
                nil: null
            })
        });
        _fastcheck.assert(_fastcheck.asyncProperty(eventIdArbitrary, activityArbitrary, async (eventId, activityData)=>{
            // Mock the event deletion
            const mockDeleteEvent = jest.spyOn(_eventService, 'deleteEvent');
            mockDeleteEvent.mockResolvedValue({
                success: true,
                data: undefined
            });
            // Mock activity retrieval - activity should exist with same data except eventId
            const mockGetActivity = jest.spyOn(_activityService, 'get');
            mockGetActivity.mockResolvedValue({
                success: true,
                data: {
                    ...activityData,
                    eventId: null,
                    locationId: null,
                    endTime: null,
                    hostSubsidy: null,
                    adultsOnly: false,
                    plusOneAllowed: true,
                    visibility: [],
                    status: 'draft',
                    displayOrder: 0,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                }
            });
            // Delete the event
            const deleteResult = await _eventService.deleteEvent(eventId);
            expect(deleteResult.success).toBe(true);
            // Retrieve the activity
            const activityResult = await _activityService.get(activityData.id);
            // Property 1: Activity should still exist
            expect(activityResult.success).toBe(true);
            if (activityResult.success) {
                // Property 2: Activity data should be preserved (except eventId)
                expect(activityResult.data.name).toBe(activityData.name);
                expect(activityResult.data.activityType).toBe(activityData.activityType);
                expect(activityResult.data.startTime).toBe(activityData.startTime);
                expect(activityResult.data.description).toBe(activityData.description);
                expect(activityResult.data.capacity).toBe(activityData.capacity);
                expect(activityResult.data.costPerPerson).toBe(activityData.costPerPerson);
                // Property 3: eventId should be null (not the deleted event ID)
                expect(activityResult.data.eventId).toBeNull();
                expect(activityResult.data.eventId).not.toBe(eventId);
            }
            mockDeleteEvent.mockRestore();
            mockGetActivity.mockRestore();
        }), {
            numRuns: 10,
            timeout: 30000
        });
    });
    it('should allow activities to be reassigned to different events after original event deletion', ()=>{
        const originalEventIdArbitrary = _fastcheck.uuid();
        const newEventIdArbitrary = _fastcheck.uuid();
        const activityIdArbitrary = _fastcheck.uuid();
        _fastcheck.assert(_fastcheck.asyncProperty(originalEventIdArbitrary, newEventIdArbitrary, activityIdArbitrary, async (originalEventId, newEventId, activityId)=>{
            // Ensure event IDs are different
            _fastcheck.pre(originalEventId !== newEventId);
            // Mock event deletion
            const mockDeleteEvent = jest.spyOn(_eventService, 'deleteEvent');
            mockDeleteEvent.mockResolvedValue({
                success: true,
                data: undefined
            });
            // Mock activity update to new event
            const mockUpdateActivity = jest.spyOn(_activityService, 'update');
            mockUpdateActivity.mockResolvedValue({
                success: true,
                data: {
                    id: activityId,
                    eventId: newEventId,
                    name: 'Test Activity',
                    activityType: 'activity',
                    startTime: new Date().toISOString(),
                    description: null,
                    locationId: null,
                    endTime: null,
                    capacity: null,
                    costPerPerson: null,
                    hostSubsidy: null,
                    adultsOnly: false,
                    plusOneAllowed: true,
                    visibility: [],
                    status: 'draft',
                    displayOrder: 0,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                }
            });
            // Delete original event
            const deleteResult = await _eventService.deleteEvent(originalEventId);
            expect(deleteResult.success).toBe(true);
            // Reassign activity to new event
            const updateResult = await _activityService.update(activityId, {
                eventId: newEventId
            });
            // Property 1: Update should succeed
            expect(updateResult.success).toBe(true);
            if (updateResult.success) {
                // Property 2: Activity should be assigned to new event
                expect(updateResult.data.eventId).toBe(newEventId);
                expect(updateResult.data.eventId).not.toBe(originalEventId);
            }
            mockDeleteEvent.mockRestore();
            mockUpdateActivity.mockRestore();
        }), {
            numRuns: 10,
            timeout: 30000
        });
    });
    it('should handle deletion of events with no associated activities', ()=>{
        const eventIdArbitrary = _fastcheck.uuid();
        _fastcheck.assert(_fastcheck.asyncProperty(eventIdArbitrary, async (eventId)=>{
            // Mock event deletion (event with no activities)
            const mockDeleteEvent = jest.spyOn(_eventService, 'deleteEvent');
            mockDeleteEvent.mockResolvedValue({
                success: true,
                data: undefined
            });
            // Delete the event
            const deleteResult = await _eventService.deleteEvent(eventId);
            // Property 1: Deletion should succeed even with no activities
            expect(deleteResult.success).toBe(true);
            mockDeleteEvent.mockRestore();
        }), {
            numRuns: 10,
            timeout: 30000
        });
    });
    it('should handle deletion of events with mix of dependent and independent activities', ()=>{
        const eventIdArbitrary = _fastcheck.uuid();
        const activityArbitrary = _fastcheck.record({
            id: _fastcheck.uuid(),
            name: _fastcheck.string({
                minLength: 1,
                maxLength: 100
            }),
            activityType: _fastcheck.constantFrom('ceremony', 'reception', 'meal', 'transport', 'activity'),
            startTime: _fastcheck.date({
                min: new Date('2025-01-01'),
                max: new Date('2025-12-31')
            }).map((d)=>d.toISOString())
        });
        _fastcheck.assert(_fastcheck.asyncProperty(eventIdArbitrary, _fastcheck.array(activityArbitrary, {
            minLength: 2,
            maxLength: 10
        }), async (eventId, activities)=>{
            // Split activities into dependent (with eventId) and independent (without eventId)
            const midpoint = Math.floor(activities.length / 2);
            const dependentActivities = activities.slice(0, midpoint).map((a)=>({
                    ...a,
                    eventId
                }));
            const independentActivities = activities.slice(midpoint).map((a)=>({
                    ...a,
                    eventId: null
                }));
            // Mock event deletion
            const mockDeleteEvent = jest.spyOn(_eventService, 'deleteEvent');
            mockDeleteEvent.mockResolvedValue({
                success: true,
                data: undefined
            });
            // Mock activity list - all activities should exist after deletion
            const mockListActivities = jest.spyOn(_activityService, 'list');
            const allActivitiesAfterDeletion = [
                ...dependentActivities.map((a)=>({
                        ...a,
                        eventId: null
                    })),
                ...independentActivities
            ].map((a)=>({
                    ...a,
                    locationId: null,
                    description: null,
                    endTime: null,
                    capacity: null,
                    costPerPerson: null,
                    hostSubsidy: null,
                    adultsOnly: false,
                    plusOneAllowed: true,
                    visibility: [],
                    status: 'draft',
                    displayOrder: 0,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                }));
            mockListActivities.mockResolvedValue({
                success: true,
                data: {
                    activities: allActivitiesAfterDeletion,
                    total: allActivitiesAfterDeletion.length,
                    page: 1,
                    pageSize: 50,
                    totalPages: 1
                }
            });
            // Delete the event
            const deleteResult = await _eventService.deleteEvent(eventId);
            expect(deleteResult.success).toBe(true);
            // Query all activities
            const listResult = await _activityService.list({});
            // Property 1: All activities should still exist
            expect(listResult.success).toBe(true);
            if (listResult.success) {
                const allActivityIds = activities.map((a)=>a.id);
                const retrievedActivityIds = listResult.data.activities.map((a)=>a.id);
                // Property 2: Count should match original count
                expect(retrievedActivityIds.length).toBe(allActivityIds.length);
                // Property 3: All activities should be present
                for (const activityId of allActivityIds){
                    expect(retrievedActivityIds).toContain(activityId);
                }
                // Property 4: All activities should have eventId = null
                for (const activity of listResult.data.activities){
                    expect(activity.eventId).toBeNull();
                }
            }
            mockDeleteEvent.mockRestore();
            mockListActivities.mockRestore();
        }), {
            numRuns: 10,
            timeout: 30000
        });
    });
    it('should maintain referential integrity after event deletion', ()=>{
        const eventIdArbitrary = _fastcheck.uuid();
        const activityIdArbitrary = _fastcheck.uuid();
        _fastcheck.assert(_fastcheck.asyncProperty(eventIdArbitrary, activityIdArbitrary, async (eventId, activityId)=>{
            // Mock event deletion
            const mockDeleteEvent = jest.spyOn(_eventService, 'deleteEvent');
            mockDeleteEvent.mockResolvedValue({
                success: true,
                data: undefined
            });
            // Mock activity get - should return activity with null eventId
            const mockGetActivity = jest.spyOn(_activityService, 'get');
            mockGetActivity.mockResolvedValue({
                success: true,
                data: {
                    id: activityId,
                    eventId: null,
                    name: 'Test Activity',
                    activityType: 'activity',
                    startTime: new Date().toISOString(),
                    description: null,
                    locationId: null,
                    endTime: null,
                    capacity: null,
                    costPerPerson: null,
                    hostSubsidy: null,
                    adultsOnly: false,
                    plusOneAllowed: true,
                    visibility: [],
                    status: 'draft',
                    displayOrder: 0,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                }
            });
            // Delete event
            const deleteResult = await _eventService.deleteEvent(eventId);
            expect(deleteResult.success).toBe(true);
            // Get activity
            const activityResult = await _activityService.get(activityId);
            // Property 1: Activity should exist
            expect(activityResult.success).toBe(true);
            if (activityResult.success) {
                // Property 2: eventId should be null (not pointing to deleted event)
                expect(activityResult.data.eventId).toBeNull();
                // Property 3: Activity should not reference the deleted event
                expect(activityResult.data.eventId).not.toBe(eventId);
            }
            mockDeleteEvent.mockRestore();
            mockGetActivity.mockRestore();
        }), {
            numRuns: 10,
            timeout: 30000
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvZXZlbnREZWxldGlvbkludGVncml0eS5wcm9wZXJ0eS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGZjIGZyb20gJ2Zhc3QtY2hlY2snO1xuaW1wb3J0ICogYXMgZXZlbnRTZXJ2aWNlIGZyb20gJy4vZXZlbnRTZXJ2aWNlJztcbmltcG9ydCAqIGFzIGFjdGl2aXR5U2VydmljZSBmcm9tICcuL2FjdGl2aXR5U2VydmljZSc7XG5cbi8vIE1vY2sgU3VwYWJhc2Vcbmplc3QubW9jaygnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJyk7XG5cbi8qKlxuICogUHJvcGVydHktYmFzZWQgdGVzdHMgZm9yIGV2ZW50IGRlbGV0aW9uIGludGVncml0eS5cbiAqIEZlYXR1cmU6IGRlc3RpbmF0aW9uLXdlZGRpbmctcGxhdGZvcm0sIFByb3BlcnR5IDEwOiBFdmVudCBEZWxldGlvbiBJbnRlZ3JpdHlcbiAqIFxuICogVmFsaWRhdGVzOiBSZXF1aXJlbWVudHMgNi4xM1xuICogXG4gKiBUaGlzIHRlc3QgdmFsaWRhdGVzIHRoYXQgd2hlbiBhbiBldmVudCBpcyBkZWxldGVkLCBhc3NvY2lhdGVkIGluZGVwZW5kZW50IGFjdGl2aXRpZXNcbiAqIChhY3Rpdml0aWVzIHdpdGggZXZlbnRfaWQgc2V0IHRvIHRoZSBkZWxldGVkIGV2ZW50KSBhcmUgbm90IGNhc2NhZGUgZGVsZXRlZCBidXQgaW5zdGVhZFxuICogaGF2ZSB0aGVpciBldmVudF9pZCBzZXQgdG8gTlVMTCwgcHJlc2VydmluZyBkYXRhIGludGVncml0eS5cbiAqL1xuXG5kZXNjcmliZS5za2lwKCdGZWF0dXJlOiBkZXN0aW5hdGlvbi13ZWRkaW5nLXBsYXRmb3JtLCBQcm9wZXJ0eSAxMDogRXZlbnQgRGVsZXRpb24gSW50ZWdyaXR5JywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwgPSAnaHR0cHM6Ly90ZXN0LnN1cGFiYXNlLmNvJztcbiAgICBwcm9jZXNzLmVudi5TVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZID0gJ3Rlc3Qtc2VydmljZS1yb2xlLWtleSc7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgbm90IGNhc2NhZGUgZGVsZXRlIGFjdGl2aXRpZXMgd2hlbiBldmVudCBpcyBkZWxldGVkJywgKCkgPT4ge1xuICAgIGNvbnN0IGV2ZW50SWRBcmJpdHJhcnkgPSBmYy51dWlkKCk7XG4gICAgY29uc3QgYWN0aXZpdHlBcmJpdHJhcnkgPSBmYy5yZWNvcmQoe1xuICAgICAgaWQ6IGZjLnV1aWQoKSxcbiAgICAgIG5hbWU6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxMDAgfSksXG4gICAgICBhY3Rpdml0eVR5cGU6IGZjLmNvbnN0YW50RnJvbSgnY2VyZW1vbnknLCAncmVjZXB0aW9uJywgJ21lYWwnLCAndHJhbnNwb3J0JywgJ2FjdGl2aXR5JyksXG4gICAgICBzdGFydFRpbWU6IGZjLmRhdGUoe1xuICAgICAgICBtaW46IG5ldyBEYXRlKCcyMDI1LTAxLTAxJyksXG4gICAgICAgIG1heDogbmV3IERhdGUoJzIwMjUtMTItMzEnKSxcbiAgICAgIH0pLm1hcChkID0+IGQudG9JU09TdHJpbmcoKSksXG4gICAgfSk7XG5cbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBldmVudElkQXJiaXRyYXJ5LFxuICAgICAgICBmYy5hcnJheShhY3Rpdml0eUFyYml0cmFyeSwgeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTAgfSksXG4gICAgICAgIGFzeW5jIChldmVudElkLCBhY3Rpdml0aWVzKSA9PiB7XG4gICAgICAgICAgLy8gTW9jayBhY3Rpdml0aWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnRcbiAgICAgICAgICBjb25zdCBhY3Rpdml0aWVzV2l0aEV2ZW50ID0gYWN0aXZpdGllcy5tYXAoYSA9PiAoe1xuICAgICAgICAgICAgLi4uYSxcbiAgICAgICAgICAgIGV2ZW50SWQsXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgLy8gTW9jayB0aGUgZXZlbnQgZGVsZXRpb25cbiAgICAgICAgICBjb25zdCBtb2NrRGVsZXRlRXZlbnQgPSBqZXN0LnNweU9uKGV2ZW50U2VydmljZSwgJ2RlbGV0ZUV2ZW50Jyk7XG4gICAgICAgICAgbW9ja0RlbGV0ZUV2ZW50Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICAgICAgLy8gTW9jayBhY3Rpdml0eSByZXRyaWV2YWwgYWZ0ZXIgZGVsZXRpb24gKGFjdGl2aXRpZXMgc2hvdWxkIHN0aWxsIGV4aXN0IHdpdGggZXZlbnRJZCA9IG51bGwpXG4gICAgICAgICAgY29uc3QgbW9ja0xpc3RBY3Rpdml0aWVzID0gamVzdC5zcHlPbihhY3Rpdml0eVNlcnZpY2UsICdsaXN0Jyk7XG4gICAgICAgICAgY29uc3QgYWN0aXZpdGllc0FmdGVyRGVsZXRpb24gPSBhY3Rpdml0aWVzLm1hcChhID0+ICh7XG4gICAgICAgICAgICAuLi5hLFxuICAgICAgICAgICAgZXZlbnRJZDogbnVsbCwgLy8gRXZlbnQgSUQgc2hvdWxkIGJlIHNldCB0byBOVUxMLCBub3QgZGVsZXRlZFxuICAgICAgICAgICAgbG9jYXRpb25JZDogbnVsbCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBudWxsLFxuICAgICAgICAgICAgZW5kVGltZTogbnVsbCxcbiAgICAgICAgICAgIGNhcGFjaXR5OiBudWxsLFxuICAgICAgICAgICAgY29zdFBlclBlcnNvbjogbnVsbCxcbiAgICAgICAgICAgIGhvc3RTdWJzaWR5OiBudWxsLFxuICAgICAgICAgICAgYWR1bHRzT25seTogZmFsc2UsXG4gICAgICAgICAgICBwbHVzT25lQWxsb3dlZDogdHJ1ZSxcbiAgICAgICAgICAgIHZpc2liaWxpdHk6IFtdLFxuICAgICAgICAgICAgc3RhdHVzOiAnZHJhZnQnIGFzIGNvbnN0LFxuICAgICAgICAgICAgZGlzcGxheU9yZGVyOiAwLFxuICAgICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBtb2NrTGlzdEFjdGl2aXRpZXMubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgYWN0aXZpdGllczogYWN0aXZpdGllc0FmdGVyRGVsZXRpb24sXG4gICAgICAgICAgICAgIHRvdGFsOiBhY3Rpdml0aWVzQWZ0ZXJEZWxldGlvbi5sZW5ndGgsXG4gICAgICAgICAgICAgIHBhZ2U6IDEsXG4gICAgICAgICAgICAgIHBhZ2VTaXplOiA1MCxcbiAgICAgICAgICAgICAgdG90YWxQYWdlczogMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICAgICAgLy8gRGVsZXRlIHRoZSBldmVudFxuICAgICAgICAgIGNvbnN0IGRlbGV0ZVJlc3VsdCA9IGF3YWl0IGV2ZW50U2VydmljZS5kZWxldGVFdmVudChldmVudElkKTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5IDE6IEV2ZW50IGRlbGV0aW9uIHNob3VsZCBzdWNjZWVkXG4gICAgICAgICAgZXhwZWN0KGRlbGV0ZVJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuXG4gICAgICAgICAgLy8gUXVlcnkgZm9yIGFjdGl2aXRpZXMgdGhhdCB3ZXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnRcbiAgICAgICAgICBjb25zdCBhY3Rpdml0eUlkcyA9IGFjdGl2aXRpZXMubWFwKGEgPT4gYS5pZCk7XG4gICAgICAgICAgY29uc3QgbGlzdFJlc3VsdCA9IGF3YWl0IGFjdGl2aXR5U2VydmljZS5saXN0KHt9KTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5IDI6IEFjdGl2aXRpZXMgc2hvdWxkIHN0aWxsIGV4aXN0XG4gICAgICAgICAgZXhwZWN0KGxpc3RSZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgICAgICBpZiAobGlzdFJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBjb25zdCByZXRyaWV2ZWRBY3Rpdml0eUlkcyA9IGxpc3RSZXN1bHQuZGF0YS5hY3Rpdml0aWVzLm1hcChhID0+IGEuaWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eSAzOiBBbGwgb3JpZ2luYWwgYWN0aXZpdGllcyBzaG91bGQgc3RpbGwgYmUgcHJlc2VudFxuICAgICAgICAgICAgZm9yIChjb25zdCBhY3Rpdml0eUlkIG9mIGFjdGl2aXR5SWRzKSB7XG4gICAgICAgICAgICAgIGV4cGVjdChyZXRyaWV2ZWRBY3Rpdml0eUlkcykudG9Db250YWluKGFjdGl2aXR5SWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eSA0OiBBY3Rpdml0aWVzIHNob3VsZCBoYXZlIGV2ZW50SWQgc2V0IHRvIG51bGwgKG5vdCBkZWxldGVkKVxuICAgICAgICAgICAgZm9yIChjb25zdCBhY3Rpdml0eSBvZiBsaXN0UmVzdWx0LmRhdGEuYWN0aXZpdGllcykge1xuICAgICAgICAgICAgICBpZiAoYWN0aXZpdHlJZHMuaW5jbHVkZXMoYWN0aXZpdHkuaWQpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KGFjdGl2aXR5LmV2ZW50SWQpLnRvQmVOdWxsKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb2NrRGVsZXRlRXZlbnQubW9ja1Jlc3RvcmUoKTtcbiAgICAgICAgICBtb2NrTGlzdEFjdGl2aXRpZXMubW9ja1Jlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAsIHRpbWVvdXQ6IDMwMDAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHByZXNlcnZlIGFjdGl2aXR5IGRhdGEgd2hlbiBldmVudCBpcyBkZWxldGVkJywgKCkgPT4ge1xuICAgIGNvbnN0IGV2ZW50SWRBcmJpdHJhcnkgPSBmYy51dWlkKCk7XG4gICAgY29uc3QgYWN0aXZpdHlBcmJpdHJhcnkgPSBmYy5yZWNvcmQoe1xuICAgICAgaWQ6IGZjLnV1aWQoKSxcbiAgICAgIG5hbWU6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxMDAgfSksXG4gICAgICBhY3Rpdml0eVR5cGU6IGZjLmNvbnN0YW50RnJvbSgnY2VyZW1vbnknLCAncmVjZXB0aW9uJywgJ21lYWwnLCAndHJhbnNwb3J0JywgJ2FjdGl2aXR5JyksXG4gICAgICBzdGFydFRpbWU6IGZjLmRhdGUoe1xuICAgICAgICBtaW46IG5ldyBEYXRlKCcyMDI1LTAxLTAxJyksXG4gICAgICAgIG1heDogbmV3IERhdGUoJzIwMjUtMTItMzEnKSxcbiAgICAgIH0pLm1hcChkID0+IGQudG9JU09TdHJpbmcoKSksXG4gICAgICBkZXNjcmlwdGlvbjogZmMub3B0aW9uKGZjLnN0cmluZyh7IG1heExlbmd0aDogMjAwIH0pLCB7IG5pbDogbnVsbCB9KSxcbiAgICAgIGNhcGFjaXR5OiBmYy5vcHRpb24oZmMuaW50ZWdlcih7IG1pbjogMSwgbWF4OiAxMDAgfSksIHsgbmlsOiBudWxsIH0pLFxuICAgICAgY29zdFBlclBlcnNvbjogZmMub3B0aW9uKGZjLmZsb2F0KHsgbWluOiAwLCBtYXg6IDEwMDAgfSksIHsgbmlsOiBudWxsIH0pLFxuICAgIH0pO1xuXG4gICAgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZXZlbnRJZEFyYml0cmFyeSxcbiAgICAgICAgYWN0aXZpdHlBcmJpdHJhcnksXG4gICAgICAgIGFzeW5jIChldmVudElkLCBhY3Rpdml0eURhdGEpID0+IHtcbiAgICAgICAgICAvLyBNb2NrIHRoZSBldmVudCBkZWxldGlvblxuICAgICAgICAgIGNvbnN0IG1vY2tEZWxldGVFdmVudCA9IGplc3Quc3B5T24oZXZlbnRTZXJ2aWNlLCAnZGVsZXRlRXZlbnQnKTtcbiAgICAgICAgICBtb2NrRGVsZXRlRXZlbnQubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9IGFzIGFueSk7XG5cbiAgICAgICAgICAvLyBNb2NrIGFjdGl2aXR5IHJldHJpZXZhbCAtIGFjdGl2aXR5IHNob3VsZCBleGlzdCB3aXRoIHNhbWUgZGF0YSBleGNlcHQgZXZlbnRJZFxuICAgICAgICAgIGNvbnN0IG1vY2tHZXRBY3Rpdml0eSA9IGplc3Quc3B5T24oYWN0aXZpdHlTZXJ2aWNlLCAnZ2V0Jyk7XG4gICAgICAgICAgbW9ja0dldEFjdGl2aXR5Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIC4uLmFjdGl2aXR5RGF0YSxcbiAgICAgICAgICAgICAgZXZlbnRJZDogbnVsbCwgLy8gQ2hhbmdlZCBmcm9tIGV2ZW50SWQgdG8gbnVsbFxuICAgICAgICAgICAgICBsb2NhdGlvbklkOiBudWxsLFxuICAgICAgICAgICAgICBlbmRUaW1lOiBudWxsLFxuICAgICAgICAgICAgICBob3N0U3Vic2lkeTogbnVsbCxcbiAgICAgICAgICAgICAgYWR1bHRzT25seTogZmFsc2UsXG4gICAgICAgICAgICAgIHBsdXNPbmVBbGxvd2VkOiB0cnVlLFxuICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBbXSxcbiAgICAgICAgICAgICAgc3RhdHVzOiAnZHJhZnQnLFxuICAgICAgICAgICAgICBkaXNwbGF5T3JkZXI6IDAsXG4gICAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICAgICAgLy8gRGVsZXRlIHRoZSBldmVudFxuICAgICAgICAgIGNvbnN0IGRlbGV0ZVJlc3VsdCA9IGF3YWl0IGV2ZW50U2VydmljZS5kZWxldGVFdmVudChldmVudElkKTtcbiAgICAgICAgICBleHBlY3QoZGVsZXRlUmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG5cbiAgICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgYWN0aXZpdHlcbiAgICAgICAgICBjb25zdCBhY3Rpdml0eVJlc3VsdCA9IGF3YWl0IGFjdGl2aXR5U2VydmljZS5nZXQoYWN0aXZpdHlEYXRhLmlkKTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5IDE6IEFjdGl2aXR5IHNob3VsZCBzdGlsbCBleGlzdFxuICAgICAgICAgIGV4cGVjdChhY3Rpdml0eVJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuXG4gICAgICAgICAgaWYgKGFjdGl2aXR5UmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIC8vIFByb3BlcnR5IDI6IEFjdGl2aXR5IGRhdGEgc2hvdWxkIGJlIHByZXNlcnZlZCAoZXhjZXB0IGV2ZW50SWQpXG4gICAgICAgICAgICBleHBlY3QoYWN0aXZpdHlSZXN1bHQuZGF0YS5uYW1lKS50b0JlKGFjdGl2aXR5RGF0YS5uYW1lKTtcbiAgICAgICAgICAgIGV4cGVjdChhY3Rpdml0eVJlc3VsdC5kYXRhLmFjdGl2aXR5VHlwZSkudG9CZShhY3Rpdml0eURhdGEuYWN0aXZpdHlUeXBlKTtcbiAgICAgICAgICAgIGV4cGVjdChhY3Rpdml0eVJlc3VsdC5kYXRhLnN0YXJ0VGltZSkudG9CZShhY3Rpdml0eURhdGEuc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIGV4cGVjdChhY3Rpdml0eVJlc3VsdC5kYXRhLmRlc2NyaXB0aW9uKS50b0JlKGFjdGl2aXR5RGF0YS5kZXNjcmlwdGlvbik7XG4gICAgICAgICAgICBleHBlY3QoYWN0aXZpdHlSZXN1bHQuZGF0YS5jYXBhY2l0eSkudG9CZShhY3Rpdml0eURhdGEuY2FwYWNpdHkpO1xuICAgICAgICAgICAgZXhwZWN0KGFjdGl2aXR5UmVzdWx0LmRhdGEuY29zdFBlclBlcnNvbikudG9CZShhY3Rpdml0eURhdGEuY29zdFBlclBlcnNvbik7XG5cbiAgICAgICAgICAgIC8vIFByb3BlcnR5IDM6IGV2ZW50SWQgc2hvdWxkIGJlIG51bGwgKG5vdCB0aGUgZGVsZXRlZCBldmVudCBJRClcbiAgICAgICAgICAgIGV4cGVjdChhY3Rpdml0eVJlc3VsdC5kYXRhLmV2ZW50SWQpLnRvQmVOdWxsKCk7XG4gICAgICAgICAgICBleHBlY3QoYWN0aXZpdHlSZXN1bHQuZGF0YS5ldmVudElkKS5ub3QudG9CZShldmVudElkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb2NrRGVsZXRlRXZlbnQubW9ja1Jlc3RvcmUoKTtcbiAgICAgICAgICBtb2NrR2V0QWN0aXZpdHkubW9ja1Jlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAsIHRpbWVvdXQ6IDMwMDAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGFsbG93IGFjdGl2aXRpZXMgdG8gYmUgcmVhc3NpZ25lZCB0byBkaWZmZXJlbnQgZXZlbnRzIGFmdGVyIG9yaWdpbmFsIGV2ZW50IGRlbGV0aW9uJywgKCkgPT4ge1xuICAgIGNvbnN0IG9yaWdpbmFsRXZlbnRJZEFyYml0cmFyeSA9IGZjLnV1aWQoKTtcbiAgICBjb25zdCBuZXdFdmVudElkQXJiaXRyYXJ5ID0gZmMudXVpZCgpO1xuICAgIGNvbnN0IGFjdGl2aXR5SWRBcmJpdHJhcnkgPSBmYy51dWlkKCk7XG5cbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBvcmlnaW5hbEV2ZW50SWRBcmJpdHJhcnksXG4gICAgICAgIG5ld0V2ZW50SWRBcmJpdHJhcnksXG4gICAgICAgIGFjdGl2aXR5SWRBcmJpdHJhcnksXG4gICAgICAgIGFzeW5jIChvcmlnaW5hbEV2ZW50SWQsIG5ld0V2ZW50SWQsIGFjdGl2aXR5SWQpID0+IHtcbiAgICAgICAgICAvLyBFbnN1cmUgZXZlbnQgSURzIGFyZSBkaWZmZXJlbnRcbiAgICAgICAgICBmYy5wcmUob3JpZ2luYWxFdmVudElkICE9PSBuZXdFdmVudElkKTtcblxuICAgICAgICAgIC8vIE1vY2sgZXZlbnQgZGVsZXRpb25cbiAgICAgICAgICBjb25zdCBtb2NrRGVsZXRlRXZlbnQgPSBqZXN0LnNweU9uKGV2ZW50U2VydmljZSwgJ2RlbGV0ZUV2ZW50Jyk7XG4gICAgICAgICAgbW9ja0RlbGV0ZUV2ZW50Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICAgICAgLy8gTW9jayBhY3Rpdml0eSB1cGRhdGUgdG8gbmV3IGV2ZW50XG4gICAgICAgICAgY29uc3QgbW9ja1VwZGF0ZUFjdGl2aXR5ID0gamVzdC5zcHlPbihhY3Rpdml0eVNlcnZpY2UsICd1cGRhdGUnKTtcbiAgICAgICAgICBtb2NrVXBkYXRlQWN0aXZpdHkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgaWQ6IGFjdGl2aXR5SWQsXG4gICAgICAgICAgICAgIGV2ZW50SWQ6IG5ld0V2ZW50SWQsIC8vIFN1Y2Nlc3NmdWxseSByZWFzc2lnbmVkXG4gICAgICAgICAgICAgIG5hbWU6ICdUZXN0IEFjdGl2aXR5JyxcbiAgICAgICAgICAgICAgYWN0aXZpdHlUeXBlOiAnYWN0aXZpdHknLFxuICAgICAgICAgICAgICBzdGFydFRpbWU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG51bGwsXG4gICAgICAgICAgICAgIGxvY2F0aW9uSWQ6IG51bGwsXG4gICAgICAgICAgICAgIGVuZFRpbWU6IG51bGwsXG4gICAgICAgICAgICAgIGNhcGFjaXR5OiBudWxsLFxuICAgICAgICAgICAgICBjb3N0UGVyUGVyc29uOiBudWxsLFxuICAgICAgICAgICAgICBob3N0U3Vic2lkeTogbnVsbCxcbiAgICAgICAgICAgICAgYWR1bHRzT25seTogZmFsc2UsXG4gICAgICAgICAgICAgIHBsdXNPbmVBbGxvd2VkOiB0cnVlLFxuICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBbXSxcbiAgICAgICAgICAgICAgc3RhdHVzOiAnZHJhZnQnLFxuICAgICAgICAgICAgICBkaXNwbGF5T3JkZXI6IDAsXG4gICAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICAgICAgLy8gRGVsZXRlIG9yaWdpbmFsIGV2ZW50XG4gICAgICAgICAgY29uc3QgZGVsZXRlUmVzdWx0ID0gYXdhaXQgZXZlbnRTZXJ2aWNlLmRlbGV0ZUV2ZW50KG9yaWdpbmFsRXZlbnRJZCk7XG4gICAgICAgICAgZXhwZWN0KGRlbGV0ZVJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuXG4gICAgICAgICAgLy8gUmVhc3NpZ24gYWN0aXZpdHkgdG8gbmV3IGV2ZW50XG4gICAgICAgICAgY29uc3QgdXBkYXRlUmVzdWx0ID0gYXdhaXQgYWN0aXZpdHlTZXJ2aWNlLnVwZGF0ZShhY3Rpdml0eUlkLCB7XG4gICAgICAgICAgICBldmVudElkOiBuZXdFdmVudElkLFxuICAgICAgICAgIH0gYXMgYW55KTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5IDE6IFVwZGF0ZSBzaG91bGQgc3VjY2VlZFxuICAgICAgICAgIGV4cGVjdCh1cGRhdGVSZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcblxuICAgICAgICAgIGlmICh1cGRhdGVSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgLy8gUHJvcGVydHkgMjogQWN0aXZpdHkgc2hvdWxkIGJlIGFzc2lnbmVkIHRvIG5ldyBldmVudFxuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZVJlc3VsdC5kYXRhLmV2ZW50SWQpLnRvQmUobmV3RXZlbnRJZCk7XG4gICAgICAgICAgICBleHBlY3QodXBkYXRlUmVzdWx0LmRhdGEuZXZlbnRJZCkubm90LnRvQmUob3JpZ2luYWxFdmVudElkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb2NrRGVsZXRlRXZlbnQubW9ja1Jlc3RvcmUoKTtcbiAgICAgICAgICBtb2NrVXBkYXRlQWN0aXZpdHkubW9ja1Jlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAsIHRpbWVvdXQ6IDMwMDAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGhhbmRsZSBkZWxldGlvbiBvZiBldmVudHMgd2l0aCBubyBhc3NvY2lhdGVkIGFjdGl2aXRpZXMnLCAoKSA9PiB7XG4gICAgY29uc3QgZXZlbnRJZEFyYml0cmFyeSA9IGZjLnV1aWQoKTtcblxuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGV2ZW50SWRBcmJpdHJhcnksXG4gICAgICAgIGFzeW5jIChldmVudElkKSA9PiB7XG4gICAgICAgICAgLy8gTW9jayBldmVudCBkZWxldGlvbiAoZXZlbnQgd2l0aCBubyBhY3Rpdml0aWVzKVxuICAgICAgICAgIGNvbnN0IG1vY2tEZWxldGVFdmVudCA9IGplc3Quc3B5T24oZXZlbnRTZXJ2aWNlLCAnZGVsZXRlRXZlbnQnKTtcbiAgICAgICAgICBtb2NrRGVsZXRlRXZlbnQubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9IGFzIGFueSk7XG5cbiAgICAgICAgICAvLyBEZWxldGUgdGhlIGV2ZW50XG4gICAgICAgICAgY29uc3QgZGVsZXRlUmVzdWx0ID0gYXdhaXQgZXZlbnRTZXJ2aWNlLmRlbGV0ZUV2ZW50KGV2ZW50SWQpO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHkgMTogRGVsZXRpb24gc2hvdWxkIHN1Y2NlZWQgZXZlbiB3aXRoIG5vIGFjdGl2aXRpZXNcbiAgICAgICAgICBleHBlY3QoZGVsZXRlUmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG5cbiAgICAgICAgICBtb2NrRGVsZXRlRXZlbnQubW9ja1Jlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAsIHRpbWVvdXQ6IDMwMDAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGhhbmRsZSBkZWxldGlvbiBvZiBldmVudHMgd2l0aCBtaXggb2YgZGVwZW5kZW50IGFuZCBpbmRlcGVuZGVudCBhY3Rpdml0aWVzJywgKCkgPT4ge1xuICAgIGNvbnN0IGV2ZW50SWRBcmJpdHJhcnkgPSBmYy51dWlkKCk7XG4gICAgY29uc3QgYWN0aXZpdHlBcmJpdHJhcnkgPSBmYy5yZWNvcmQoe1xuICAgICAgaWQ6IGZjLnV1aWQoKSxcbiAgICAgIG5hbWU6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxMDAgfSksXG4gICAgICBhY3Rpdml0eVR5cGU6IGZjLmNvbnN0YW50RnJvbSgnY2VyZW1vbnknLCAncmVjZXB0aW9uJywgJ21lYWwnLCAndHJhbnNwb3J0JywgJ2FjdGl2aXR5JyksXG4gICAgICBzdGFydFRpbWU6IGZjLmRhdGUoe1xuICAgICAgICBtaW46IG5ldyBEYXRlKCcyMDI1LTAxLTAxJyksXG4gICAgICAgIG1heDogbmV3IERhdGUoJzIwMjUtMTItMzEnKSxcbiAgICAgIH0pLm1hcChkID0+IGQudG9JU09TdHJpbmcoKSksXG4gICAgfSk7XG5cbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBldmVudElkQXJiaXRyYXJ5LFxuICAgICAgICBmYy5hcnJheShhY3Rpdml0eUFyYml0cmFyeSwgeyBtaW5MZW5ndGg6IDIsIG1heExlbmd0aDogMTAgfSksXG4gICAgICAgIGFzeW5jIChldmVudElkLCBhY3Rpdml0aWVzKSA9PiB7XG4gICAgICAgICAgLy8gU3BsaXQgYWN0aXZpdGllcyBpbnRvIGRlcGVuZGVudCAod2l0aCBldmVudElkKSBhbmQgaW5kZXBlbmRlbnQgKHdpdGhvdXQgZXZlbnRJZClcbiAgICAgICAgICBjb25zdCBtaWRwb2ludCA9IE1hdGguZmxvb3IoYWN0aXZpdGllcy5sZW5ndGggLyAyKTtcbiAgICAgICAgICBjb25zdCBkZXBlbmRlbnRBY3Rpdml0aWVzID0gYWN0aXZpdGllcy5zbGljZSgwLCBtaWRwb2ludCkubWFwKGEgPT4gKHtcbiAgICAgICAgICAgIC4uLmEsXG4gICAgICAgICAgICBldmVudElkLFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBjb25zdCBpbmRlcGVuZGVudEFjdGl2aXRpZXMgPSBhY3Rpdml0aWVzLnNsaWNlKG1pZHBvaW50KS5tYXAoYSA9PiAoe1xuICAgICAgICAgICAgLi4uYSxcbiAgICAgICAgICAgIGV2ZW50SWQ6IG51bGwsXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgLy8gTW9jayBldmVudCBkZWxldGlvblxuICAgICAgICAgIGNvbnN0IG1vY2tEZWxldGVFdmVudCA9IGplc3Quc3B5T24oZXZlbnRTZXJ2aWNlLCAnZGVsZXRlRXZlbnQnKTtcbiAgICAgICAgICBtb2NrRGVsZXRlRXZlbnQubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9IGFzIGFueSk7XG5cbiAgICAgICAgICAvLyBNb2NrIGFjdGl2aXR5IGxpc3QgLSBhbGwgYWN0aXZpdGllcyBzaG91bGQgZXhpc3QgYWZ0ZXIgZGVsZXRpb25cbiAgICAgICAgICBjb25zdCBtb2NrTGlzdEFjdGl2aXRpZXMgPSBqZXN0LnNweU9uKGFjdGl2aXR5U2VydmljZSwgJ2xpc3QnKTtcbiAgICAgICAgICBjb25zdCBhbGxBY3Rpdml0aWVzQWZ0ZXJEZWxldGlvbiA9IFtcbiAgICAgICAgICAgIC4uLmRlcGVuZGVudEFjdGl2aXRpZXMubWFwKGEgPT4gKHsgLi4uYSwgZXZlbnRJZDogbnVsbCB9KSksIC8vIERlcGVuZGVudCBhY3Rpdml0aWVzIG5vdyBoYXZlIG51bGwgZXZlbnRJZFxuICAgICAgICAgICAgLi4uaW5kZXBlbmRlbnRBY3Rpdml0aWVzLCAvLyBJbmRlcGVuZGVudCBhY3Rpdml0aWVzIHVuY2hhbmdlZFxuICAgICAgICAgIF0ubWFwKGEgPT4gKHtcbiAgICAgICAgICAgIC4uLmEsXG4gICAgICAgICAgICBsb2NhdGlvbklkOiBudWxsLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IG51bGwsXG4gICAgICAgICAgICBlbmRUaW1lOiBudWxsLFxuICAgICAgICAgICAgY2FwYWNpdHk6IG51bGwsXG4gICAgICAgICAgICBjb3N0UGVyUGVyc29uOiBudWxsLFxuICAgICAgICAgICAgaG9zdFN1YnNpZHk6IG51bGwsXG4gICAgICAgICAgICBhZHVsdHNPbmx5OiBmYWxzZSxcbiAgICAgICAgICAgIHBsdXNPbmVBbGxvd2VkOiB0cnVlLFxuICAgICAgICAgICAgdmlzaWJpbGl0eTogW10sXG4gICAgICAgICAgICBzdGF0dXM6ICdkcmFmdCcgYXMgY29uc3QsXG4gICAgICAgICAgICBkaXNwbGF5T3JkZXI6IDAsXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIG1vY2tMaXN0QWN0aXZpdGllcy5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBhY3Rpdml0aWVzOiBhbGxBY3Rpdml0aWVzQWZ0ZXJEZWxldGlvbixcbiAgICAgICAgICAgICAgdG90YWw6IGFsbEFjdGl2aXRpZXNBZnRlckRlbGV0aW9uLmxlbmd0aCxcbiAgICAgICAgICAgICAgcGFnZTogMSxcbiAgICAgICAgICAgICAgcGFnZVNpemU6IDUwLFxuICAgICAgICAgICAgICB0b3RhbFBhZ2VzOiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9IGFzIGFueSk7XG5cbiAgICAgICAgICAvLyBEZWxldGUgdGhlIGV2ZW50XG4gICAgICAgICAgY29uc3QgZGVsZXRlUmVzdWx0ID0gYXdhaXQgZXZlbnRTZXJ2aWNlLmRlbGV0ZUV2ZW50KGV2ZW50SWQpO1xuICAgICAgICAgIGV4cGVjdChkZWxldGVSZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcblxuICAgICAgICAgIC8vIFF1ZXJ5IGFsbCBhY3Rpdml0aWVzXG4gICAgICAgICAgY29uc3QgbGlzdFJlc3VsdCA9IGF3YWl0IGFjdGl2aXR5U2VydmljZS5saXN0KHt9KTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5IDE6IEFsbCBhY3Rpdml0aWVzIHNob3VsZCBzdGlsbCBleGlzdFxuICAgICAgICAgIGV4cGVjdChsaXN0UmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgaWYgKGxpc3RSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgY29uc3QgYWxsQWN0aXZpdHlJZHMgPSBhY3Rpdml0aWVzLm1hcChhID0+IGEuaWQpO1xuICAgICAgICAgICAgY29uc3QgcmV0cmlldmVkQWN0aXZpdHlJZHMgPSBsaXN0UmVzdWx0LmRhdGEuYWN0aXZpdGllcy5tYXAoYSA9PiBhLmlkKTtcblxuICAgICAgICAgICAgLy8gUHJvcGVydHkgMjogQ291bnQgc2hvdWxkIG1hdGNoIG9yaWdpbmFsIGNvdW50XG4gICAgICAgICAgICBleHBlY3QocmV0cmlldmVkQWN0aXZpdHlJZHMubGVuZ3RoKS50b0JlKGFsbEFjdGl2aXR5SWRzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIC8vIFByb3BlcnR5IDM6IEFsbCBhY3Rpdml0aWVzIHNob3VsZCBiZSBwcmVzZW50XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFjdGl2aXR5SWQgb2YgYWxsQWN0aXZpdHlJZHMpIHtcbiAgICAgICAgICAgICAgZXhwZWN0KHJldHJpZXZlZEFjdGl2aXR5SWRzKS50b0NvbnRhaW4oYWN0aXZpdHlJZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByb3BlcnR5IDQ6IEFsbCBhY3Rpdml0aWVzIHNob3VsZCBoYXZlIGV2ZW50SWQgPSBudWxsXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFjdGl2aXR5IG9mIGxpc3RSZXN1bHQuZGF0YS5hY3Rpdml0aWVzKSB7XG4gICAgICAgICAgICAgIGV4cGVjdChhY3Rpdml0eS5ldmVudElkKS50b0JlTnVsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vY2tEZWxldGVFdmVudC5tb2NrUmVzdG9yZSgpO1xuICAgICAgICAgIG1vY2tMaXN0QWN0aXZpdGllcy5tb2NrUmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMCwgdGltZW91dDogMzAwMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgbWFpbnRhaW4gcmVmZXJlbnRpYWwgaW50ZWdyaXR5IGFmdGVyIGV2ZW50IGRlbGV0aW9uJywgKCkgPT4ge1xuICAgIGNvbnN0IGV2ZW50SWRBcmJpdHJhcnkgPSBmYy51dWlkKCk7XG4gICAgY29uc3QgYWN0aXZpdHlJZEFyYml0cmFyeSA9IGZjLnV1aWQoKTtcblxuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGV2ZW50SWRBcmJpdHJhcnksXG4gICAgICAgIGFjdGl2aXR5SWRBcmJpdHJhcnksXG4gICAgICAgIGFzeW5jIChldmVudElkLCBhY3Rpdml0eUlkKSA9PiB7XG4gICAgICAgICAgLy8gTW9jayBldmVudCBkZWxldGlvblxuICAgICAgICAgIGNvbnN0IG1vY2tEZWxldGVFdmVudCA9IGplc3Quc3B5T24oZXZlbnRTZXJ2aWNlLCAnZGVsZXRlRXZlbnQnKTtcbiAgICAgICAgICBtb2NrRGVsZXRlRXZlbnQubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9IGFzIGFueSk7XG5cbiAgICAgICAgICAvLyBNb2NrIGFjdGl2aXR5IGdldCAtIHNob3VsZCByZXR1cm4gYWN0aXZpdHkgd2l0aCBudWxsIGV2ZW50SWRcbiAgICAgICAgICBjb25zdCBtb2NrR2V0QWN0aXZpdHkgPSBqZXN0LnNweU9uKGFjdGl2aXR5U2VydmljZSwgJ2dldCcpO1xuICAgICAgICAgIG1vY2tHZXRBY3Rpdml0eS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBpZDogYWN0aXZpdHlJZCxcbiAgICAgICAgICAgICAgZXZlbnRJZDogbnVsbCwgLy8gUmVmZXJlbnRpYWwgaW50ZWdyaXR5IG1haW50YWluZWRcbiAgICAgICAgICAgICAgbmFtZTogJ1Rlc3QgQWN0aXZpdHknLFxuICAgICAgICAgICAgICBhY3Rpdml0eVR5cGU6ICdhY3Rpdml0eScsXG4gICAgICAgICAgICAgIHN0YXJ0VGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgbG9jYXRpb25JZDogbnVsbCxcbiAgICAgICAgICAgICAgZW5kVGltZTogbnVsbCxcbiAgICAgICAgICAgICAgY2FwYWNpdHk6IG51bGwsXG4gICAgICAgICAgICAgIGNvc3RQZXJQZXJzb246IG51bGwsXG4gICAgICAgICAgICAgIGhvc3RTdWJzaWR5OiBudWxsLFxuICAgICAgICAgICAgICBhZHVsdHNPbmx5OiBmYWxzZSxcbiAgICAgICAgICAgICAgcGx1c09uZUFsbG93ZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHZpc2liaWxpdHk6IFtdLFxuICAgICAgICAgICAgICBzdGF0dXM6ICdkcmFmdCcsXG4gICAgICAgICAgICAgIGRpc3BsYXlPcmRlcjogMCxcbiAgICAgICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9IGFzIGFueSk7XG5cbiAgICAgICAgICAvLyBEZWxldGUgZXZlbnRcbiAgICAgICAgICBjb25zdCBkZWxldGVSZXN1bHQgPSBhd2FpdCBldmVudFNlcnZpY2UuZGVsZXRlRXZlbnQoZXZlbnRJZCk7XG4gICAgICAgICAgZXhwZWN0KGRlbGV0ZVJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuXG4gICAgICAgICAgLy8gR2V0IGFjdGl2aXR5XG4gICAgICAgICAgY29uc3QgYWN0aXZpdHlSZXN1bHQgPSBhd2FpdCBhY3Rpdml0eVNlcnZpY2UuZ2V0KGFjdGl2aXR5SWQpO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHkgMTogQWN0aXZpdHkgc2hvdWxkIGV4aXN0XG4gICAgICAgICAgZXhwZWN0KGFjdGl2aXR5UmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoYWN0aXZpdHlSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgLy8gUHJvcGVydHkgMjogZXZlbnRJZCBzaG91bGQgYmUgbnVsbCAobm90IHBvaW50aW5nIHRvIGRlbGV0ZWQgZXZlbnQpXG4gICAgICAgICAgICBleHBlY3QoYWN0aXZpdHlSZXN1bHQuZGF0YS5ldmVudElkKS50b0JlTnVsbCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eSAzOiBBY3Rpdml0eSBzaG91bGQgbm90IHJlZmVyZW5jZSB0aGUgZGVsZXRlZCBldmVudFxuICAgICAgICAgICAgZXhwZWN0KGFjdGl2aXR5UmVzdWx0LmRhdGEuZXZlbnRJZCkubm90LnRvQmUoZXZlbnRJZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbW9ja0RlbGV0ZUV2ZW50Lm1vY2tSZXN0b3JlKCk7XG4gICAgICAgICAgbW9ja0dldEFjdGl2aXR5Lm1vY2tSZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwLCB0aW1lb3V0OiAzMDAwMCB9XG4gICAgKTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImRlc2NyaWJlIiwic2tpcCIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsIlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkiLCJpdCIsImV2ZW50SWRBcmJpdHJhcnkiLCJmYyIsInV1aWQiLCJhY3Rpdml0eUFyYml0cmFyeSIsInJlY29yZCIsImlkIiwibmFtZSIsInN0cmluZyIsIm1pbkxlbmd0aCIsIm1heExlbmd0aCIsImFjdGl2aXR5VHlwZSIsImNvbnN0YW50RnJvbSIsInN0YXJ0VGltZSIsImRhdGUiLCJtaW4iLCJEYXRlIiwibWF4IiwibWFwIiwiZCIsInRvSVNPU3RyaW5nIiwiYXNzZXJ0IiwiYXN5bmNQcm9wZXJ0eSIsImFycmF5IiwiZXZlbnRJZCIsImFjdGl2aXRpZXMiLCJhY3Rpdml0aWVzV2l0aEV2ZW50IiwiYSIsIm1vY2tEZWxldGVFdmVudCIsInNweU9uIiwiZXZlbnRTZXJ2aWNlIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJzdWNjZXNzIiwiZGF0YSIsInVuZGVmaW5lZCIsIm1vY2tMaXN0QWN0aXZpdGllcyIsImFjdGl2aXR5U2VydmljZSIsImFjdGl2aXRpZXNBZnRlckRlbGV0aW9uIiwibG9jYXRpb25JZCIsImRlc2NyaXB0aW9uIiwiZW5kVGltZSIsImNhcGFjaXR5IiwiY29zdFBlclBlcnNvbiIsImhvc3RTdWJzaWR5IiwiYWR1bHRzT25seSIsInBsdXNPbmVBbGxvd2VkIiwidmlzaWJpbGl0eSIsInN0YXR1cyIsImRpc3BsYXlPcmRlciIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsInRvdGFsIiwibGVuZ3RoIiwicGFnZSIsInBhZ2VTaXplIiwidG90YWxQYWdlcyIsImRlbGV0ZVJlc3VsdCIsImRlbGV0ZUV2ZW50IiwiZXhwZWN0IiwidG9CZSIsImFjdGl2aXR5SWRzIiwibGlzdFJlc3VsdCIsImxpc3QiLCJyZXRyaWV2ZWRBY3Rpdml0eUlkcyIsImFjdGl2aXR5SWQiLCJ0b0NvbnRhaW4iLCJhY3Rpdml0eSIsImluY2x1ZGVzIiwidG9CZU51bGwiLCJtb2NrUmVzdG9yZSIsIm51bVJ1bnMiLCJ0aW1lb3V0Iiwib3B0aW9uIiwibmlsIiwiaW50ZWdlciIsImZsb2F0IiwiYWN0aXZpdHlEYXRhIiwibW9ja0dldEFjdGl2aXR5IiwiYWN0aXZpdHlSZXN1bHQiLCJnZXQiLCJub3QiLCJvcmlnaW5hbEV2ZW50SWRBcmJpdHJhcnkiLCJuZXdFdmVudElkQXJiaXRyYXJ5IiwiYWN0aXZpdHlJZEFyYml0cmFyeSIsIm9yaWdpbmFsRXZlbnRJZCIsIm5ld0V2ZW50SWQiLCJwcmUiLCJtb2NrVXBkYXRlQWN0aXZpdHkiLCJ1cGRhdGVSZXN1bHQiLCJ1cGRhdGUiLCJtaWRwb2ludCIsIk1hdGgiLCJmbG9vciIsImRlcGVuZGVudEFjdGl2aXRpZXMiLCJzbGljZSIsImluZGVwZW5kZW50QWN0aXZpdGllcyIsImFsbEFjdGl2aXRpZXNBZnRlckRlbGV0aW9uIiwiYWxsQWN0aXZpdHlJZHMiXSwibWFwcGluZ3MiOiI7QUFJQSxnQkFBZ0I7QUFDaEJBLEtBQUtDLElBQUksQ0FBQzs7OzttRUFMVTtzRUFDVTt5RUFDRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS2pDOzs7Ozs7Ozs7Q0FTQyxHQUVEQyxTQUFTQyxJQUFJLENBQUMsZ0ZBQWdGO0lBQzVGQyxXQUFXO1FBQ1RKLEtBQUtLLGFBQWE7UUFDbEJDLFFBQVFDLEdBQUcsQ0FBQ0Msd0JBQXdCLEdBQUc7UUFDdkNGLFFBQVFDLEdBQUcsQ0FBQ0UseUJBQXlCLEdBQUc7SUFDMUM7SUFFQUMsR0FBRyw4REFBOEQ7UUFDL0QsTUFBTUMsbUJBQW1CQyxXQUFHQyxJQUFJO1FBQ2hDLE1BQU1DLG9CQUFvQkYsV0FBR0csTUFBTSxDQUFDO1lBQ2xDQyxJQUFJSixXQUFHQyxJQUFJO1lBQ1hJLE1BQU1MLFdBQUdNLE1BQU0sQ0FBQztnQkFBRUMsV0FBVztnQkFBR0MsV0FBVztZQUFJO1lBQy9DQyxjQUFjVCxXQUFHVSxZQUFZLENBQUMsWUFBWSxhQUFhLFFBQVEsYUFBYTtZQUM1RUMsV0FBV1gsV0FBR1ksSUFBSSxDQUFDO2dCQUNqQkMsS0FBSyxJQUFJQyxLQUFLO2dCQUNkQyxLQUFLLElBQUlELEtBQUs7WUFDaEIsR0FBR0UsR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxXQUFXO1FBQzNCO1FBRUFsQixXQUFHbUIsTUFBTSxDQUNQbkIsV0FBR29CLGFBQWEsQ0FDZHJCLGtCQUNBQyxXQUFHcUIsS0FBSyxDQUFDbkIsbUJBQW1CO1lBQUVLLFdBQVc7WUFBR0MsV0FBVztRQUFHLElBQzFELE9BQU9jLFNBQVNDO1lBQ2QsNENBQTRDO1lBQzVDLE1BQU1DLHNCQUFzQkQsV0FBV1AsR0FBRyxDQUFDUyxDQUFBQSxJQUFNLENBQUE7b0JBQy9DLEdB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