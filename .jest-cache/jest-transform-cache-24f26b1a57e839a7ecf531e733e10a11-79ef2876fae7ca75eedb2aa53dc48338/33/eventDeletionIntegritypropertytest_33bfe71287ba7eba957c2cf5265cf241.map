{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/services/eventDeletionIntegrity.property.test.ts"],"sourcesContent":["import * as fc from 'fast-check';\nimport * as eventService from './eventService';\nimport * as activityService from './activityService';\n\n// Mock Supabase\njest.mock('@supabase/supabase-js');\n\n/**\n * Property-based tests for event deletion integrity.\n * Feature: destination-wedding-platform, Property 10: Event Deletion Integrity\n * \n * Validates: Requirements 6.13\n * \n * This test validates that when an event is deleted, associated independent activities\n * (activities with event_id set to the deleted event) are not cascade deleted but instead\n * have their event_id set to NULL, preserving data integrity.\n */\n\ndescribe.skip('Feature: destination-wedding-platform, Property 10: Event Deletion Integrity', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://test.supabase.co';\n    process.env.SUPABASE_SERVICE_ROLE_KEY = 'test-service-role-key';\n  });\n\n  it('should not cascade delete activities when event is deleted', () => {\n    const eventIdArbitrary = fc.uuid();\n    const activityArbitrary = fc.record({\n      id: fc.uuid(),\n      name: fc.string({ minLength: 1, maxLength: 100 }),\n      activityType: fc.constantFrom('ceremony', 'reception', 'meal', 'transport', 'activity'),\n      startTime: fc.date({\n        min: new Date('2025-01-01'),\n        max: new Date('2025-12-31'),\n      }).map(d => d.toISOString()),\n    });\n\n    fc.assert(\n      fc.asyncProperty(\n        eventIdArbitrary,\n        fc.array(activityArbitrary, { minLength: 1, maxLength: 10 }),\n        async (eventId, activities) => {\n          // Mock activities associated with the event\n          const activitiesWithEvent = activities.map(a => ({\n            ...a,\n            eventId,\n          }));\n\n          // Mock the event deletion\n          const mockDeleteEvent = jest.spyOn(eventService, 'deleteEvent');\n          mockDeleteEvent.mockResolvedValue({\n            success: true,\n            data: undefined,\n          } as any);\n\n          // Mock activity retrieval after deletion (activities should still exist with eventId = null)\n          const mockListActivities = jest.spyOn(activityService, 'list');\n          const activitiesAfterDeletion = activities.map(a => ({\n            ...a,\n            eventId: null, // Event ID should be set to NULL, not deleted\n            locationId: null,\n            description: null,\n            endTime: null,\n            capacity: null,\n            costPerPerson: null,\n            hostSubsidy: null,\n            adultsOnly: false,\n            plusOneAllowed: true,\n            visibility: [],\n            status: 'draft' as const,\n            displayOrder: 0,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n          }));\n\n          mockListActivities.mockResolvedValue({\n            success: true,\n            data: {\n              activities: activitiesAfterDeletion,\n              total: activitiesAfterDeletion.length,\n              page: 1,\n              pageSize: 50,\n              totalPages: 1,\n            },\n          } as any);\n\n          // Delete the event\n          const deleteResult = await eventService.deleteEvent(eventId);\n\n          // Property 1: Event deletion should succeed\n          expect(deleteResult.success).toBe(true);\n\n          // Query for activities that were associated with the event\n          const activityIds = activities.map(a => a.id);\n          const listResult = await activityService.list({});\n\n          // Property 2: Activities should still exist\n          expect(listResult.success).toBe(true);\n          if (listResult.success) {\n            const retrievedActivityIds = listResult.data.activities.map(a => a.id);\n            \n            // Property 3: All original activities should still be present\n            for (const activityId of activityIds) {\n              expect(retrievedActivityIds).toContain(activityId);\n            }\n\n            // Property 4: Activities should have eventId set to null (not deleted)\n            for (const activity of listResult.data.activities) {\n              if (activityIds.includes(activity.id)) {\n                expect(activity.eventId).toBeNull();\n              }\n            }\n          }\n\n          mockDeleteEvent.mockRestore();\n          mockListActivities.mockRestore();\n        }\n      ),\n      { numRuns: 10, timeout: 30000 }\n    );\n  });\n\n  it('should preserve activity data when event is deleted', () => {\n    const eventIdArbitrary = fc.uuid();\n    const activityArbitrary = fc.record({\n      id: fc.uuid(),\n      name: fc.string({ minLength: 1, maxLength: 100 }),\n      activityType: fc.constantFrom('ceremony', 'reception', 'meal', 'transport', 'activity'),\n      startTime: fc.date({\n        min: new Date('2025-01-01'),\n        max: new Date('2025-12-31'),\n      }).map(d => d.toISOString()),\n      description: fc.option(fc.string({ maxLength: 200 }), { nil: null }),\n      capacity: fc.option(fc.integer({ min: 1, max: 100 }), { nil: null }),\n      costPerPerson: fc.option(fc.float({ min: 0, max: 1000 }), { nil: null }),\n    });\n\n    fc.assert(\n      fc.asyncProperty(\n        eventIdArbitrary,\n        activityArbitrary,\n        async (eventId, activityData) => {\n          // Mock the event deletion\n          const mockDeleteEvent = jest.spyOn(eventService, 'deleteEvent');\n          mockDeleteEvent.mockResolvedValue({\n            success: true,\n            data: undefined,\n          } as any);\n\n          // Mock activity retrieval - activity should exist with same data except eventId\n          const mockGetActivity = jest.spyOn(activityService, 'get');\n          mockGetActivity.mockResolvedValue({\n            success: true,\n            data: {\n              ...activityData,\n              eventId: null, // Changed from eventId to null\n              locationId: null,\n              endTime: null,\n              hostSubsidy: null,\n              adultsOnly: false,\n              plusOneAllowed: true,\n              visibility: [],\n              status: 'draft',\n              displayOrder: 0,\n              createdAt: new Date().toISOString(),\n              updatedAt: new Date().toISOString(),\n            },\n          } as any);\n\n          // Delete the event\n          const deleteResult = await eventService.deleteEvent(eventId);\n          expect(deleteResult.success).toBe(true);\n\n          // Retrieve the activity\n          const activityResult = await activityService.get(activityData.id);\n\n          // Property 1: Activity should still exist\n          expect(activityResult.success).toBe(true);\n\n          if (activityResult.success) {\n            // Property 2: Activity data should be preserved (except eventId)\n            expect(activityResult.data.name).toBe(activityData.name);\n            expect(activityResult.data.activityType).toBe(activityData.activityType);\n            expect(activityResult.data.startTime).toBe(activityData.startTime);\n            expect(activityResult.data.description).toBe(activityData.description);\n            expect(activityResult.data.capacity).toBe(activityData.capacity);\n            expect(activityResult.data.costPerPerson).toBe(activityData.costPerPerson);\n\n            // Property 3: eventId should be null (not the deleted event ID)\n            expect(activityResult.data.eventId).toBeNull();\n            expect(activityResult.data.eventId).not.toBe(eventId);\n          }\n\n          mockDeleteEvent.mockRestore();\n          mockGetActivity.mockRestore();\n        }\n      ),\n      { numRuns: 10, timeout: 30000 }\n    );\n  });\n\n  it('should allow activities to be reassigned to different events after original event deletion', () => {\n    const originalEventIdArbitrary = fc.uuid();\n    const newEventIdArbitrary = fc.uuid();\n    const activityIdArbitrary = fc.uuid();\n\n    fc.assert(\n      fc.asyncProperty(\n        originalEventIdArbitrary,\n        newEventIdArbitrary,\n        activityIdArbitrary,\n        async (originalEventId, newEventId, activityId) => {\n          // Ensure event IDs are different\n          fc.pre(originalEventId !== newEventId);\n\n          // Mock event deletion\n          const mockDeleteEvent = jest.spyOn(eventService, 'deleteEvent');\n          mockDeleteEvent.mockResolvedValue({\n            success: true,\n            data: undefined,\n          } as any);\n\n          // Mock activity update to new event\n          const mockUpdateActivity = jest.spyOn(activityService, 'update');\n          mockUpdateActivity.mockResolvedValue({\n            success: true,\n            data: {\n              id: activityId,\n              eventId: newEventId, // Successfully reassigned\n              name: 'Test Activity',\n              activityType: 'activity',\n              startTime: new Date().toISOString(),\n              description: null,\n              locationId: null,\n              endTime: null,\n              capacity: null,\n              costPerPerson: null,\n              hostSubsidy: null,\n              adultsOnly: false,\n              plusOneAllowed: true,\n              visibility: [],\n              status: 'draft',\n              displayOrder: 0,\n              createdAt: new Date().toISOString(),\n              updatedAt: new Date().toISOString(),\n            },\n          } as any);\n\n          // Delete original event\n          const deleteResult = await eventService.deleteEvent(originalEventId);\n          expect(deleteResult.success).toBe(true);\n\n          // Reassign activity to new event\n          const updateResult = await activityService.update(activityId, {\n            eventId: newEventId,\n          } as any);\n\n          // Property 1: Update should succeed\n          expect(updateResult.success).toBe(true);\n\n          if (updateResult.success) {\n            // Property 2: Activity should be assigned to new event\n            expect(updateResult.data.eventId).toBe(newEventId);\n            expect(updateResult.data.eventId).not.toBe(originalEventId);\n          }\n\n          mockDeleteEvent.mockRestore();\n          mockUpdateActivity.mockRestore();\n        }\n      ),\n      { numRuns: 10, timeout: 30000 }\n    );\n  });\n\n  it('should handle deletion of events with no associated activities', () => {\n    const eventIdArbitrary = fc.uuid();\n\n    fc.assert(\n      fc.asyncProperty(\n        eventIdArbitrary,\n        async (eventId) => {\n          // Mock event deletion (event with no activities)\n          const mockDeleteEvent = jest.spyOn(eventService, 'deleteEvent');\n          mockDeleteEvent.mockResolvedValue({\n            success: true,\n            data: undefined,\n          } as any);\n\n          // Delete the event\n          const deleteResult = await eventService.deleteEvent(eventId);\n\n          // Property 1: Deletion should succeed even with no activities\n          expect(deleteResult.success).toBe(true);\n\n          mockDeleteEvent.mockRestore();\n        }\n      ),\n      { numRuns: 10, timeout: 30000 }\n    );\n  });\n\n  it('should handle deletion of events with mix of dependent and independent activities', () => {\n    const eventIdArbitrary = fc.uuid();\n    const activityArbitrary = fc.record({\n      id: fc.uuid(),\n      name: fc.string({ minLength: 1, maxLength: 100 }),\n      activityType: fc.constantFrom('ceremony', 'reception', 'meal', 'transport', 'activity'),\n      startTime: fc.date({\n        min: new Date('2025-01-01'),\n        max: new Date('2025-12-31'),\n      }).map(d => d.toISOString()),\n    });\n\n    fc.assert(\n      fc.asyncProperty(\n        eventIdArbitrary,\n        fc.array(activityArbitrary, { minLength: 2, maxLength: 10 }),\n        async (eventId, activities) => {\n          // Split activities into dependent (with eventId) and independent (without eventId)\n          const midpoint = Math.floor(activities.length / 2);\n          const dependentActivities = activities.slice(0, midpoint).map(a => ({\n            ...a,\n            eventId,\n          }));\n          const independentActivities = activities.slice(midpoint).map(a => ({\n            ...a,\n            eventId: null,\n          }));\n\n          // Mock event deletion\n          const mockDeleteEvent = jest.spyOn(eventService, 'deleteEvent');\n          mockDeleteEvent.mockResolvedValue({\n            success: true,\n            data: undefined,\n          } as any);\n\n          // Mock activity list - all activities should exist after deletion\n          const mockListActivities = jest.spyOn(activityService, 'list');\n          const allActivitiesAfterDeletion = [\n            ...dependentActivities.map(a => ({ ...a, eventId: null })), // Dependent activities now have null eventId\n            ...independentActivities, // Independent activities unchanged\n          ].map(a => ({\n            ...a,\n            locationId: null,\n            description: null,\n            endTime: null,\n            capacity: null,\n            costPerPerson: null,\n            hostSubsidy: null,\n            adultsOnly: false,\n            plusOneAllowed: true,\n            visibility: [],\n            status: 'draft' as const,\n            displayOrder: 0,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n          }));\n\n          mockListActivities.mockResolvedValue({\n            success: true,\n            data: {\n              activities: allActivitiesAfterDeletion,\n              total: allActivitiesAfterDeletion.length,\n              page: 1,\n              pageSize: 50,\n              totalPages: 1,\n            },\n          } as any);\n\n          // Delete the event\n          const deleteResult = await eventService.deleteEvent(eventId);\n          expect(deleteResult.success).toBe(true);\n\n          // Query all activities\n          const listResult = await activityService.list({});\n\n          // Property 1: All activities should still exist\n          expect(listResult.success).toBe(true);\n          if (listResult.success) {\n            const allActivityIds = activities.map(a => a.id);\n            const retrievedActivityIds = listResult.data.activities.map(a => a.id);\n\n            // Property 2: Count should match original count\n            expect(retrievedActivityIds.length).toBe(allActivityIds.length);\n\n            // Property 3: All activities should be present\n            for (const activityId of allActivityIds) {\n              expect(retrievedActivityIds).toContain(activityId);\n            }\n\n            // Property 4: All activities should have eventId = null\n            for (const activity of listResult.data.activities) {\n              expect(activity.eventId).toBeNull();\n            }\n          }\n\n          mockDeleteEvent.mockRestore();\n          mockListActivities.mockRestore();\n        }\n      ),\n      { numRuns: 10, timeout: 30000 }\n    );\n  });\n\n  it('should maintain referential integrity after event deletion', () => {\n    const eventIdArbitrary = fc.uuid();\n    const activityIdArbitrary = fc.uuid();\n\n    fc.assert(\n      fc.asyncProperty(\n        eventIdArbitrary,\n        activityIdArbitrary,\n        async (eventId, activityId) => {\n          // Mock event deletion\n          const mockDeleteEvent = jest.spyOn(eventService, 'deleteEvent');\n          mockDeleteEvent.mockResolvedValue({\n            success: true,\n            data: undefined,\n          } as any);\n\n          // Mock activity get - should return activity with null eventId\n          const mockGetActivity = jest.spyOn(activityService, 'get');\n          mockGetActivity.mockResolvedValue({\n            success: true,\n            data: {\n              id: activityId,\n              eventId: null, // Referential integrity maintained\n              name: 'Test Activity',\n              activityType: 'activity',\n              startTime: new Date().toISOString(),\n              description: null,\n              locationId: null,\n              endTime: null,\n              capacity: null,\n              costPerPerson: null,\n              hostSubsidy: null,\n              adultsOnly: false,\n              plusOneAllowed: true,\n              visibility: [],\n              status: 'draft',\n              displayOrder: 0,\n              createdAt: new Date().toISOString(),\n              updatedAt: new Date().toISOString(),\n            },\n          } as any);\n\n          // Delete event\n          const deleteResult = await eventService.deleteEvent(eventId);\n          expect(deleteResult.success).toBe(true);\n\n          // Get activity\n          const activityResult = await activityService.get(activityId);\n\n          // Property 1: Activity should exist\n          expect(activityResult.success).toBe(true);\n\n          if (activityResult.success) {\n            // Property 2: eventId should be null (not pointing to deleted event)\n            expect(activityResult.data.eventId).toBeNull();\n            \n            // Property 3: Activity should not reference the deleted event\n            expect(activityResult.data.eventId).not.toBe(eventId);\n          }\n\n          mockDeleteEvent.mockRestore();\n          mockGetActivity.mockRestore();\n        }\n      ),\n      { numRuns: 10, timeout: 30000 }\n    );\n  });\n});\n"],"names":["jest","mock","describe","skip","beforeEach","clearAllMocks","process","env","NEXT_PUBLIC_SUPABASE_URL","SUPABASE_SERVICE_ROLE_KEY","it","eventIdArbitrary","fc","uuid","activityArbitrary","record","id","name","string","minLength","maxLength","activityType","constantFrom","startTime","date","min","Date","max","map","d","toISOString","assert","asyncProperty","array","eventId","activities","activitiesWithEvent","a","mockDeleteEvent","spyOn","eventService","mockResolvedValue","success","data","undefined","mockListActivities","activityService","activitiesAfterDeletion","locationId","description","endTime","capacity","costPerPerson","hostSubsidy","adultsOnly","plusOneAllowed","visibility","status","displayOrder","createdAt","updatedAt","total","length","page","pageSize","totalPages","deleteResult","deleteEvent","expect","toBe","activityIds","listResult","list","retrievedActivityIds","activityId","toContain","activity","includes","toBeNull","mockRestore","numRuns","timeout","option","nil","integer","float","activityData","mockGetActivity","activityResult","get","not","originalEventIdArbitrary","newEventIdArbitrary","activityIdArbitrary","originalEventId","newEventId","pre","mockUpdateActivity","updateResult","update","midpoint","Math","floor","dependentActivities","slice","independentActivities","allActivitiesAfterDeletion","allActivityIds"],"mappings":"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"}