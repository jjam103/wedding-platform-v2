db08899e8ba1977eb9ad50752575ba7c
"use strict";
// Mock Supabase client creation - service creates its own client
jest.mock('@supabase/supabase-js', ()=>{
    const mockFrom = jest.fn();
    const mockSupabaseClient = {
        from: mockFrom
    };
    return {
        createClient: jest.fn(()=>mockSupabaseClient),
        // Export mockFrom so we can access it in tests
        __mockFrom: mockFrom
    };
});
// Mock sanitization
jest.mock('../utils/sanitization', ()=>({
        sanitizeInput: jest.fn((input)=>input?.replace(/<script>/g, '') || '')
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _vendorService = require("./vendorService");
// Get the mocked from function
const { __mockFrom: mockFrom } = require('@supabase/supabase-js');
describe('vendorService', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        // Set up environment variables for the service
        process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://test.supabase.co';
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY = 'test-anon-key';
        // Reset Supabase mocks to default successful state
        mockFrom.mockReturnValue({
            select: jest.fn().mockResolvedValue({
                data: [],
                error: null
            }),
            insert: jest.fn().mockResolvedValue({
                error: null
            }),
            update: jest.fn().mockResolvedValue({
                error: null
            }),
            delete: jest.fn().mockResolvedValue({
                error: null
            })
        });
    });
    describe('create', ()=>{
        it('should return success with vendor data when valid input provided', async ()=>{
            const validData = {
                name: 'Costa Rica Photography',
                category: 'photography',
                contactName: 'John Doe',
                email: 'john@example.com',
                phone: '+1234567890',
                pricingModel: 'flat_rate',
                baseCost: 2500,
                notes: 'Professional wedding photography'
            };
            const mockCreatedVendor = {
                id: 'vendor-123',
                name: 'Costa Rica Photography',
                category: 'photography',
                contact_name: 'John Doe',
                email: 'john@example.com',
                phone: '+1234567890',
                pricing_model: 'flat_rate',
                base_cost: '2500.00',
                payment_status: 'unpaid',
                amount_paid: '0.00',
                notes: 'Professional wedding photography',
                created_at: '2024-01-01T10:00:00Z',
                updated_at: '2024-01-01T10:00:00Z'
            };
            // Set up the complete mock chain for insert operation
            mockFrom.mockReturnValue({
                insert: jest.fn().mockReturnValue({
                    select: jest.fn().mockReturnValue({
                        single: jest.fn().mockResolvedValue({
                            data: mockCreatedVendor,
                            error: null
                        })
                    })
                })
            });
            const result = await (0, _vendorService.create)(validData);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.id).toBe('vendor-123');
                expect(result.data.name).toBe('Costa Rica Photography');
                expect(result.data.baseCost).toBe(2500);
                expect(result.data.paymentStatus).toBe('unpaid');
            }
        });
        it('should return VALIDATION_ERROR when invalid input provided', async ()=>{
            const invalidData = {
                name: '',
                category: 'invalid',
                pricingModel: 'invalid',
                baseCost: -100
            };
            const result = await (0, _vendorService.create)(invalidData);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        it('should return DATABASE_ERROR when insert fails', async ()=>{
            const validData = {
                name: 'Costa Rica Photography',
                category: 'photography',
                contactName: 'John Doe',
                email: 'john@example.com',
                phone: '+1234567890',
                pricingModel: 'flat_rate',
                baseCost: 2500,
                notes: 'Professional wedding photography'
            };
            // Set up the complete mock chain for database error
            mockFrom.mockReturnValue({
                insert: jest.fn().mockReturnValue({
                    select: jest.fn().mockReturnValue({
                        single: jest.fn().mockResolvedValue({
                            data: null,
                            error: {
                                message: 'Database connection failed',
                                code: 'CONNECTION_ERROR'
                            }
                        })
                    })
                })
            });
            const result = await (0, _vendorService.create)(validData);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('DATABASE_ERROR');
            }
        });
        it('should sanitize input to prevent XSS attacks', async ()=>{
            const maliciousData = {
                name: '<script>alert("xss")</script>Costa Rica Photography',
                category: 'photography',
                contactName: '<script>alert("xss")</script>John Doe',
                email: 'john@example.com',
                phone: '+1234567890',
                pricingModel: 'flat_rate',
                baseCost: 2500,
                notes: '<script>alert("xss")</script>Professional wedding photography'
            };
            const mockCreatedVendor = {
                id: 'vendor-123',
                name: 'Costa Rica Photography',
                category: 'photography',
                contact_name: 'John Doe',
                email: 'john@example.com',
                phone: '+1234567890',
                pricing_model: 'flat_rate',
                base_cost: '2500.00',
                payment_status: 'unpaid',
                amount_paid: '0.00',
                notes: 'Professional wedding photography',
                created_at: '2024-01-01T10:00:00Z',
                updated_at: '2024-01-01T10:00:00Z'
            };
            // Set up the complete mock chain for successful insert
            mockFrom.mockReturnValue({
                insert: jest.fn().mockReturnValue({
                    select: jest.fn().mockReturnValue({
                        single: jest.fn().mockResolvedValue({
                            data: mockCreatedVendor,
                            error: null
                        })
                    })
                })
            });
            const result = await (0, _vendorService.create)(maliciousData);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.name).not.toContain('<script>');
                expect(result.data.contactName).not.toContain('<script>');
                expect(result.data.notes).not.toContain('<script>');
            }
        });
    });
    describe('get', ()=>{
        it('should return success with vendor data when vendor exists', async ()=>{
            const mockVendor = {
                id: 'vendor-123',
                name: 'Test Vendor',
                category: 'photography',
                contact_name: 'John Doe',
                email: 'john@example.com',
                phone: '+1234567890',
                pricing_model: 'flat_rate',
                base_cost: '2500.00',
                payment_status: 'unpaid',
                amount_paid: '0.00',
                notes: 'Test notes',
                created_at: '2024-01-01T10:00:00Z',
                updated_at: '2024-01-01T10:00:00Z'
            };
            // Set up the complete mock chain for select operation
            mockFrom.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        single: jest.fn().mockResolvedValue({
                            data: mockVendor,
                            error: null
                        })
                    })
                })
            });
            const result = await (0, _vendorService.get)('vendor-123');
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.id).toBe('vendor-123');
                expect(result.data.name).toBe('Test Vendor');
            }
        });
        it('should return NOT_FOUND when vendor does not exist', async ()=>{
            // Set up the complete mock chain for not found scenario
            mockFrom.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        single: jest.fn().mockResolvedValue({
                            data: null,
                            error: {
                                code: 'PGRST116',
                                message: 'No rows found'
                            }
                        })
                    })
                })
            });
            const result = await (0, _vendorService.get)('nonexistent-vendor');
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('NOT_FOUND');
            }
        });
        it('should return DATABASE_ERROR when query fails', async ()=>{
            // Set up the complete mock chain for database error
            mockFrom.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        single: jest.fn().mockResolvedValue({
                            data: null,
                            error: {
                                message: 'Database connection failed',
                                code: 'CONNECTION_ERROR'
                            }
                        })
                    })
                })
            });
            const result = await (0, _vendorService.get)('vendor-123');
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('DATABASE_ERROR');
            }
        });
    });
    describe('update', ()=>{
        it('should return success with updated vendor data when valid input provided', async ()=>{
            const updateData = {
                name: 'Updated Vendor Name',
                baseCost: 3000
            };
            const mockUpdatedVendor = {
                id: 'vendor-123',
                name: 'Updated Vendor Name',
                category: 'photography',
                contact_name: 'John Doe',
                email: 'john@example.com',
                phone: '+1234567890',
                pricing_model: 'flat_rate',
                base_cost: '3000.00',
                payment_status: 'unpaid',
                amount_paid: '0.00',
                notes: 'Test notes',
                created_at: '2024-01-01T10:00:00Z',
                updated_at: '2024-01-01T11:00:00Z'
            };
            // Set up the complete mock chain for update operation
            mockFrom.mockReturnValue({
                update: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        select: jest.fn().mockReturnValue({
                            single: jest.fn().mockResolvedValue({
                                data: mockUpdatedVendor,
                                error: null
                            })
                        })
                    })
                })
            });
            const result = await (0, _vendorService.update)('vendor-123', updateData);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.name).toBe('Updated Vendor Name');
                expect(result.data.baseCost).toBe(3000);
            }
        });
        it('should return VALIDATION_ERROR when invalid input provided', async ()=>{
            const invalidData = {
                baseCost: -100
            };
            const result = await (0, _vendorService.update)('vendor-123', invalidData);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        it('should return NOT_FOUND when vendor does not exist', async ()=>{
            const updateData = {
                name: 'Updated Name'
            };
            // Set up the complete mock chain for not found scenario
            mockFrom.mockReturnValue({
                update: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        select: jest.fn().mockReturnValue({
                            single: jest.fn().mockResolvedValue({
                                data: null,
                                error: {
                                    code: 'PGRST116',
                                    message: 'No rows found'
                                }
                            })
                        })
                    })
                })
            });
            const result = await (0, _vendorService.update)('nonexistent-vendor', updateData);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('NOT_FOUND');
            }
        });
        it('should return DATABASE_ERROR when update fails', async ()=>{
            const updateData = {
                name: 'Updated Name'
            };
            // Set up the complete mock chain for database error
            mockFrom.mockReturnValue({
                update: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        select: jest.fn().mockReturnValue({
                            single: jest.fn().mockResolvedValue({
                                data: null,
                                error: {
                                    message: 'Database connection failed',
                                    code: 'CONNECTION_ERROR'
                                }
                            })
                        })
                    })
                })
            });
            const result = await (0, _vendorService.update)('vendor-123', updateData);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('DATABASE_ERROR');
            }
        });
        it('should sanitize input to prevent XSS attacks', async ()=>{
            const maliciousData = {
                name: '<script>alert("xss")</script>Updated Name',
                contactName: '<script>alert("xss")</script>Updated Contact'
            };
            const mockUpdatedVendor = {
                id: 'vendor-123',
                name: 'Updated Name',
                category: 'photography',
                contact_name: 'Updated Contact',
                email: 'john@example.com',
                phone: '+1234567890',
                pricing_model: 'flat_rate',
                base_cost: '2500.00',
                payment_status: 'unpaid',
                amount_paid: '0.00',
                notes: 'Test notes',
                created_at: '2024-01-01T10:00:00Z',
                updated_at: '2024-01-01T11:00:00Z'
            };
            // Set up the complete mock chain for successful update
            mockFrom.mockReturnValue({
                update: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        select: jest.fn().mockReturnValue({
                            single: jest.fn().mockResolvedValue({
                                data: mockUpdatedVendor,
                                error: null
                            })
                        })
                    })
                })
            });
            const result = await (0, _vendorService.update)('vendor-123', maliciousData);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.name).not.toContain('<script>');
                expect(result.data.contactName).not.toContain('<script>');
            }
        });
    });
    describe('deleteVendor', ()=>{
        it('should return success when vendor deleted successfully', async ()=>{
            // Set up the complete mock chain for successful delete
            mockFrom.mockReturnValue({
                delete: jest.fn().mockReturnValue({
                    eq: jest.fn().mockResolvedValue({
                        data: null,
                        error: null
                    })
                })
            });
            const result = await (0, _vendorService.deleteVendor)('vendor-123');
            expect(result.success).toBe(true);
        });
        it('should return DATABASE_ERROR when delete fails', async ()=>{
            // Set up the complete mock chain for database error
            mockFrom.mockReturnValue({
                delete: jest.fn().mockReturnValue({
                    eq: jest.fn().mockResolvedValue({
                        data: null,
                        error: {
                            message: 'Database connection failed',
                            code: 'CONNECTION_ERROR'
                        }
                    })
                })
            });
            const result = await (0, _vendorService.deleteVendor)('vendor-123');
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('DATABASE_ERROR');
            }
        });
    });
    describe('list', ()=>{
        it('should return success with paginated vendor list when vendors exist', async ()=>{
            const mockVendors = [
                {
                    id: 'vendor-1',
                    name: 'Vendor 1',
                    category: 'photography',
                    contact_name: 'John Doe',
                    email: 'john@example.com',
                    phone: '+1234567890',
                    pricing_model: 'flat_rate',
                    base_cost: '2500.00',
                    payment_status: 'unpaid',
                    amount_paid: '0.00',
                    notes: 'Test notes',
                    created_at: '2024-01-01T10:00:00Z',
                    updated_at: '2024-01-01T10:00:00Z'
                },
                {
                    id: 'vendor-2',
                    name: 'Vendor 2',
                    category: 'catering',
                    contact_name: 'Jane Smith',
                    email: 'jane@example.com',
                    phone: '+1234567891',
                    pricing_model: 'per_guest',
                    base_cost: '50.00',
                    payment_status: 'paid',
                    amount_paid: '5000.00',
                    notes: 'Another test',
                    created_at: '2024-01-01T11:00:00Z',
                    updated_at: '2024-01-01T11:00:00Z'
                }
            ];
            // Set up the complete mock chain for list operation
            mockFrom.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    range: jest.fn().mockReturnValue({
                        order: jest.fn().mockResolvedValue({
                            data: mockVendors,
                            error: null,
                            count: 2
                        })
                    })
                })
            });
            const result = await (0, _vendorService.list)();
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.vendors).toHaveLength(2);
                expect(result.data.total).toBe(2);
            }
        });
        it('should return success with filtered vendor list when filters provided', async ()=>{
            const filters = {
                category: 'photography',
                paymentStatus: 'unpaid'
            };
            const mockVendors = [
                {
                    id: 'vendor-1',
                    name: 'Photography Vendor',
                    category: 'photography',
                    contact_name: 'John Doe',
                    email: 'john@example.com',
                    phone: '+1234567890',
                    pricing_model: 'flat_rate',
                    base_cost: '2500.00',
                    payment_status: 'unpaid',
                    amount_paid: '0.00',
                    notes: 'Test notes',
                    created_at: '2024-01-01T10:00:00Z',
                    updated_at: '2024-01-01T10:00:00Z'
                }
            ];
            // Set up the complete mock chain for filtered list operation
            mockFrom.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        eq: jest.fn().mockReturnValue({
                            range: jest.fn().mockReturnValue({
                                order: jest.fn().mockResolvedValue({
                                    data: mockVendors,
                                    error: null,
                                    count: 15
                                })
                            })
                        })
                    })
                })
            });
            const result = await (0, _vendorService.list)(filters);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.vendors).toHaveLength(1);
                expect(result.data.total).toBe(15);
            }
        });
        it('should return success with empty list when no vendors exist', async ()=>{
            // Set up the complete mock chain for empty list
            mockFrom.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    range: jest.fn().mockReturnValue({
                        order: jest.fn().mockResolvedValue({
                            data: [],
                            error: null,
                            count: 0
                        })
                    })
                })
            });
            const result = await (0, _vendorService.list)();
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.vendors).toHaveLength(0);
                expect(result.data.total).toBe(0);
            }
        });
        it('should return DATABASE_ERROR when query fails', async ()=>{
            // Set up the complete mock chain for database error
            mockFrom.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    range: jest.fn().mockReturnValue({
                        order: jest.fn().mockResolvedValue({
                            data: null,
                            error: {
                                message: 'Database connection failed',
                                code: 'CONNECTION_ERROR'
                            }
                        })
                    })
                })
            });
            const result = await (0, _vendorService.list)();
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('DATABASE_ERROR');
            }
        });
    });
    describe('search', ()=>{
        it('should return success with search results when vendors found', async ()=>{
            const searchParams = {
                query: 'photography',
                category: 'photography'
            };
            const mockVendors = [
                {
                    id: 'vendor-1',
                    name: 'Photography Vendor',
                    category: 'photography',
                    contact_name: 'John Doe',
                    email: 'john@example.com',
                    phone: '+1234567890',
                    pricing_model: 'flat_rate',
                    base_cost: '2500.00',
                    payment_status: 'unpaid',
                    amount_paid: '0.00',
                    notes: 'Professional photography',
                    created_at: '2024-01-01T10:00:00Z',
                    updated_at: '2024-01-01T10:00:00Z'
                }
            ];
            // Set up the complete mock chain for search operation
            mockFrom.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    or: jest.fn().mockReturnValue({
                        range: jest.fn().mockReturnValue({
                            order: jest.fn().mockResolvedValue({
                                data: mockVendors,
                                error: null,
                                count: 1
                            })
                        })
                    })
                })
            });
            const result = await (0, _vendorService.search)(searchParams);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.vendors).toHaveLength(1);
                expect(result.data.total).toBe(1);
            }
        });
        it('should return success with empty results when no vendors match', async ()=>{
            const searchParams = {
                query: 'nonexistent'
            };
            // Set up the complete mock chain for empty search results
            mockFrom.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    or: jest.fn().mockReturnValue({
                        range: jest.fn().mockReturnValue({
                            order: jest.fn().mockResolvedValue({
                                data: [],
                                error: null,
                                count: 0
                            })
                        })
                    })
                })
            });
            const result = await (0, _vendorService.search)(searchParams);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.vendors).toHaveLength(0);
                expect(result.data.total).toBe(0);
            }
        });
        it('should return VALIDATION_ERROR when invalid search params provided', async ()=>{
            const invalidParams = {
                page: -1
            };
            const result = await (0, _vendorService.search)(invalidParams);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        it('should return DATABASE_ERROR when search query fails', async ()=>{
            const searchParams = {
                query: 'photography'
            };
            // Set up the complete mock chain for database error
            mockFrom.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    or: jest.fn().mockReturnValue({
                        range: jest.fn().mockReturnValue({
                            order: jest.fn().mockResolvedValue({
                                data: null,
                                error: {
                                    message: 'Database connection failed',
                                    code: 'CONNECTION_ERROR'
                                }
                            })
                        })
                    })
                })
            });
            const result = await (0, _vendorService.search)(searchParams);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('DATABASE_ERROR');
            }
        });
    });
    describe('recordPayment', ()=>{
        it('should return success with payment info when payment recorded successfully', async ()=>{
            const paymentData = {
                vendorId: '123e4567-e89b-12d3-a456-426614174000',
                amount: 1000,
                notes: 'Partial payment'
            };
            // Mock vendor lookup for get() call
            const mockVendor = {
                id: '123e4567-e89b-12d3-a456-426614174000',
                name: 'Test Vendor',
                category: 'photography',
                contact_name: 'John Doe',
                email: 'john@example.com',
                phone: '+1234567890',
                pricing_model: 'flat_rate',
                base_cost: '2500.00',
                payment_status: 'unpaid',
                amount_paid: '0.00',
                notes: 'Test notes',
                created_at: '2024-01-01T10:00:00Z',
                updated_at: '2024-01-01T10:00:00Z'
            };
            // Mock updated vendor after payment for update() call
            const mockUpdatedVendor = {
                ...mockVendor,
                payment_status: 'partial',
                amount_paid: '1000.00',
                updated_at: '2024-01-15T10:00:00Z'
            };
            // Set up mock to handle both get() and update() calls sequentially
            let callCount = 0;
            mockFrom.mockImplementation(()=>{
                callCount++;
                if (callCount === 1) {
                    // First call is get() - select operation
                    return {
                        select: jest.fn().mockReturnValue({
                            eq: jest.fn().mockReturnValue({
                                single: jest.fn().mockResolvedValue({
                                    data: mockVendor,
                                    error: null
                                })
                            })
                        })
                    };
                } else {
                    // Second call is update() - update operation
                    return {
                        update: jest.fn().mockReturnValue({
                            eq: jest.fn().mockReturnValue({
                                select: jest.fn().mockReturnValue({
                                    single: jest.fn().mockResolvedValue({
                                        data: mockUpdatedVendor,
                                        error: null
                                    })
                                })
                            })
                        })
                    };
                }
            });
            const result = await (0, _vendorService.recordPayment)(paymentData);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.vendorId).toBe('123e4567-e89b-12d3-a456-426614174000');
                expect(result.data.vendorName).toBe('Test Vendor');
                expect(result.data.amountPaid).toBe(1000);
                expect(result.data.paymentStatus).toBe('partial');
            }
        });
        it('should return VALIDATION_ERROR when invalid payment data provided', async ()=>{
            const invalidData = {
                vendorId: '',
                amount: -100
            };
            const result = await (0, _vendorService.recordPayment)(invalidData);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        it('should return VALIDATION_ERROR when payment exceeds base cost', async ()=>{
            const paymentData = {
                vendorId: '123e4567-e89b-12d3-a456-426614174000',
                amount: 3000
            };
            const mockVendor = {
                id: '123e4567-e89b-12d3-a456-426614174000',
                name: 'Test Vendor',
                category: 'photography',
                contact_name: 'John Doe',
                email: 'john@example.com',
                phone: '+1234567890',
                pricing_model: 'flat_rate',
                base_cost: '2500.00',
                payment_status: 'unpaid',
                amount_paid: '0.00',
                notes: 'Test notes',
                created_at: '2024-01-01T10:00:00Z',
                updated_at: '2024-01-01T10:00:00Z'
            };
            // Set up the complete mock chain for get operation
            mockFrom.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        single: jest.fn().mockResolvedValue({
                            data: mockVendor,
                            error: null
                        })
                    })
                })
            });
            const result = await (0, _vendorService.recordPayment)(paymentData);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('VALIDATION_ERROR');
                expect(result.error.message).toContain('Payment amount exceeds vendor base cost');
            }
        });
        it('should return NOT_FOUND when vendor does not exist', async ()=>{
            const paymentData = {
                vendorId: '123e4567-e89b-12d3-a456-426614174000',
                amount: 1000
            };
            // Set up the complete mock chain for not found scenario
            mockFrom.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        single: jest.fn().mockResolvedValue({
                            data: null,
                            error: {
                                code: 'PGRST116',
                                message: 'No rows found'
                            }
                        })
                    })
                })
            });
            const result = await (0, _vendorService.recordPayment)(paymentData);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('NOT_FOUND');
            }
        });
    });
    describe('getPaymentInfo', ()=>{
        it('should return success with payment info when vendor exists', async ()=>{
            const mockVendor = {
                id: 'vendor-123',
                name: 'Test Vendor',
                category: 'photography',
                contact_name: 'John Doe',
                email: 'john@example.com',
                phone: '+1234567890',
                pricing_model: 'flat_rate',
                base_cost: '2500.00',
                payment_status: 'partial',
                amount_paid: '1000.00',
                notes: 'Test notes',
                created_at: '2024-01-01T10:00:00Z',
                updated_at: '2024-01-01T10:00:00Z'
            };
            // Set up the complete mock chain for select operation
            mockFrom.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        single: jest.fn().mockResolvedValue({
                            data: mockVendor,
                            error: null
                        })
                    })
                })
            });
            const result = await (0, _vendorService.getPaymentInfo)('vendor-123');
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.vendorId).toBe('vendor-123');
                expect(result.data.vendorName).toBe('Test Vendor');
                expect(result.data.baseCost).toBe(2500);
                expect(result.data.amountPaid).toBe(1000);
                expect(result.data.balanceDue).toBe(1500);
                expect(result.data.paymentStatus).toBe('partial');
            }
        });
        it('should return NOT_FOUND when vendor does not exist', async ()=>{
            // Set up the complete mock chain for not found scenario
            mockFrom.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        single: jest.fn().mockResolvedValue({
                            data: null,
                            error: {
                                code: 'PGRST116',
                                message: 'No rows found'
                            }
                        })
                    })
                })
            });
            const result = await (0, _vendorService.getPaymentInfo)('nonexistent-vendor');
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('NOT_FOUND');
            }
        });
        it('should return DATABASE_ERROR when query fails', async ()=>{
            // Set up the complete mock chain for database error
            mockFrom.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        single: jest.fn().mockResolvedValue({
                            data: null,
                            error: {
                                message: 'Database connection failed',
                                code: 'CONNECTION_ERROR'
                            }
                        })
                    })
                })
            });
            const result = await (0, _vendorService.getPaymentInfo)('vendor-123');
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('DATABASE_ERROR');
            }
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvdmVuZG9yU2VydmljZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE1vY2sgU3VwYWJhc2UgY2xpZW50IGNyZWF0aW9uIC0gc2VydmljZSBjcmVhdGVzIGl0cyBvd24gY2xpZW50XG5qZXN0Lm1vY2soJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcycsICgpID0+IHtcbiAgY29uc3QgbW9ja0Zyb20gPSBqZXN0LmZuKCk7XG4gIGNvbnN0IG1vY2tTdXBhYmFzZUNsaWVudCA9IHtcbiAgICBmcm9tOiBtb2NrRnJvbSxcbiAgfTtcbiAgXG4gIHJldHVybiB7XG4gICAgY3JlYXRlQ2xpZW50OiBqZXN0LmZuKCgpID0+IG1vY2tTdXBhYmFzZUNsaWVudCksXG4gICAgLy8gRXhwb3J0IG1vY2tGcm9tIHNvIHdlIGNhbiBhY2Nlc3MgaXQgaW4gdGVzdHNcbiAgICBfX21vY2tGcm9tOiBtb2NrRnJvbSxcbiAgfTtcbn0pO1xuXG4vLyBNb2NrIHNhbml0aXphdGlvblxuamVzdC5tb2NrKCcuLi91dGlscy9zYW5pdGl6YXRpb24nLCAoKSA9PiAoe1xuICBzYW5pdGl6ZUlucHV0OiBqZXN0LmZuKChpbnB1dCkgPT4gaW5wdXQ/LnJlcGxhY2UoLzxzY3JpcHQ+L2csICcnKSB8fCAnJyksXG59KSk7XG5cbi8vIEltcG9ydCBzZXJ2aWNlIEFGVEVSIG1vY2tpbmcgZGVwZW5kZW5jaWVzXG5pbXBvcnQge1xuICBjcmVhdGUsXG4gIGdldCxcbiAgdXBkYXRlLFxuICBkZWxldGVWZW5kb3IsXG4gIGxpc3QsXG4gIHNlYXJjaCxcbiAgcmVjb3JkUGF5bWVudCxcbiAgZ2V0UGF5bWVudEluZm8sXG59IGZyb20gJy4vdmVuZG9yU2VydmljZSc7XG5cbi8vIEdldCB0aGUgbW9ja2VkIGZyb20gZnVuY3Rpb25cbmNvbnN0IHsgX19tb2NrRnJvbTogbW9ja0Zyb20gfSA9IHJlcXVpcmUoJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcycpO1xuXG5kZXNjcmliZSgndmVuZG9yU2VydmljZScsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgXG4gICAgLy8gU2V0IHVwIGVudmlyb25tZW50IHZhcmlhYmxlcyBmb3IgdGhlIHNlcnZpY2VcbiAgICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwgPSAnaHR0cHM6Ly90ZXN0LnN1cGFiYXNlLmNvJztcbiAgICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSA9ICd0ZXN0LWFub24ta2V5JztcbiAgICBcbiAgICAvLyBSZXNldCBTdXBhYmFzZSBtb2NrcyB0byBkZWZhdWx0IHN1Y2Nlc3NmdWwgc3RhdGVcbiAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBkYXRhOiBbXSwgZXJyb3I6IG51bGwgfSksXG4gICAgICBpbnNlcnQ6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGVycm9yOiBudWxsIH0pLFxuICAgICAgdXBkYXRlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBlcnJvcjogbnVsbCB9KSxcbiAgICAgIGRlbGV0ZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZXJyb3I6IG51bGwgfSksXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdjcmVhdGUnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2VzcyB3aXRoIHZlbmRvciBkYXRhIHdoZW4gdmFsaWQgaW5wdXQgcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZERhdGEgPSB7XG4gICAgICAgIG5hbWU6ICdDb3N0YSBSaWNhIFBob3RvZ3JhcGh5JyxcbiAgICAgICAgY2F0ZWdvcnk6ICdwaG90b2dyYXBoeScgYXMgY29uc3QsXG4gICAgICAgIGNvbnRhY3ROYW1lOiAnSm9obiBEb2UnLFxuICAgICAgICBlbWFpbDogJ2pvaG5AZXhhbXBsZS5jb20nLFxuICAgICAgICBwaG9uZTogJysxMjM0NTY3ODkwJyxcbiAgICAgICAgcHJpY2luZ01vZGVsOiAnZmxhdF9yYXRlJyBhcyBjb25zdCxcbiAgICAgICAgYmFzZUNvc3Q6IDI1MDAsXG4gICAgICAgIG5vdGVzOiAnUHJvZmVzc2lvbmFsIHdlZGRpbmcgcGhvdG9ncmFwaHknLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja0NyZWF0ZWRWZW5kb3IgPSB7XG4gICAgICAgIGlkOiAndmVuZG9yLTEyMycsXG4gICAgICAgIG5hbWU6ICdDb3N0YSBSaWNhIFBob3RvZ3JhcGh5JyxcbiAgICAgICAgY2F0ZWdvcnk6ICdwaG90b2dyYXBoeScsXG4gICAgICAgIGNvbnRhY3RfbmFtZTogJ0pvaG4gRG9lJyxcbiAgICAgICAgZW1haWw6ICdqb2huQGV4YW1wbGUuY29tJyxcbiAgICAgICAgcGhvbmU6ICcrMTIzNDU2Nzg5MCcsXG4gICAgICAgIHByaWNpbmdfbW9kZWw6ICdmbGF0X3JhdGUnLFxuICAgICAgICBiYXNlX2Nvc3Q6ICcyNTAwLjAwJyxcbiAgICAgICAgcGF5bWVudF9zdGF0dXM6ICd1bnBhaWQnLFxuICAgICAgICBhbW91bnRfcGFpZDogJzAuMDAnLFxuICAgICAgICBub3RlczogJ1Byb2Zlc3Npb25hbCB3ZWRkaW5nIHBob3RvZ3JhcGh5JyxcbiAgICAgICAgY3JlYXRlZF9hdDogJzIwMjQtMDEtMDFUMTA6MDA6MDBaJyxcbiAgICAgICAgdXBkYXRlZF9hdDogJzIwMjQtMDEtMDFUMTA6MDA6MDBaJyxcbiAgICAgIH07XG5cbiAgICAgIC8vIFNldCB1cCB0aGUgY29tcGxldGUgbW9jayBjaGFpbiBmb3IgaW5zZXJ0IG9wZXJhdGlvblxuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgaW5zZXJ0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICBkYXRhOiBtb2NrQ3JlYXRlZFZlbmRvcixcbiAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3JlYXRlKHZhbGlkRGF0YSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuaWQpLnRvQmUoJ3ZlbmRvci0xMjMnKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLm5hbWUpLnRvQmUoJ0Nvc3RhIFJpY2EgUGhvdG9ncmFwaHknKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmJhc2VDb3N0KS50b0JlKDI1MDApO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEucGF5bWVudFN0YXR1cykudG9CZSgndW5wYWlkJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBWQUxJREFUSU9OX0VSUk9SIHdoZW4gaW52YWxpZCBpbnB1dCBwcm92aWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWREYXRhID0ge1xuICAgICAgICBuYW1lOiAnJywgLy8gSW52YWxpZDogZW1wdHkgbmFtZVxuICAgICAgICBjYXRlZ29yeTogJ2ludmFsaWQnIGFzIGFueSxcbiAgICAgICAgcHJpY2luZ01vZGVsOiAnaW52YWxpZCcgYXMgYW55LFxuICAgICAgICBiYXNlQ29zdDogLTEwMCwgLy8gSW52YWxpZDogbmVnYXRpdmUgY29zdFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3JlYXRlKGludmFsaWREYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdWQUxJREFUSU9OX0VSUk9SJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBEQVRBQkFTRV9FUlJPUiB3aGVuIGluc2VydCBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkRGF0YSA9IHtcbiAgICAgICAgbmFtZTogJ0Nvc3RhIFJpY2EgUGhvdG9ncmFwaHknLFxuICAgICAgICBjYXRlZ29yeTogJ3Bob3RvZ3JhcGh5JyBhcyBjb25zdCxcbiAgICAgICAgY29udGFjdE5hbWU6ICdKb2huIERvZScsXG4gICAgICAgIGVtYWlsOiAnam9obkBleGFtcGxlLmNvbScsXG4gICAgICAgIHBob25lOiAnKzEyMzQ1Njc4OTAnLFxuICAgICAgICBwcmljaW5nTW9kZWw6ICdmbGF0X3JhdGUnIGFzIGNvbnN0LFxuICAgICAgICBiYXNlQ29zdDogMjUwMCxcbiAgICAgICAgbm90ZXM6ICdQcm9mZXNzaW9uYWwgd2VkZGluZyBwaG90b2dyYXBoeScsXG4gICAgICB9O1xuXG4gICAgICAvLyBTZXQgdXAgdGhlIGNvbXBsZXRlIG1vY2sgY2hhaW4gZm9yIGRhdGFiYXNlIGVycm9yXG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBpbnNlcnQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6ICdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcsIGNvZGU6ICdDT05ORUNUSU9OX0VSUk9SJyB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNyZWF0ZSh2YWxpZERhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ0RBVEFCQVNFX0VSUk9SJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNhbml0aXplIGlucHV0IHRvIHByZXZlbnQgWFNTIGF0dGFja3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtYWxpY2lvdXNEYXRhID0ge1xuICAgICAgICBuYW1lOiAnPHNjcmlwdD5hbGVydChcInhzc1wiKTwvc2NyaXB0PkNvc3RhIFJpY2EgUGhvdG9ncmFwaHknLFxuICAgICAgICBjYXRlZ29yeTogJ3Bob3RvZ3JhcGh5JyBhcyBjb25zdCxcbiAgICAgICAgY29udGFjdE5hbWU6ICc8c2NyaXB0PmFsZXJ0KFwieHNzXCIpPC9zY3JpcHQ+Sm9obiBEb2UnLFxuICAgICAgICBlbWFpbDogJ2pvaG5AZXhhbXBsZS5jb20nLFxuICAgICAgICBwaG9uZTogJysxMjM0NTY3ODkwJyxcbiAgICAgICAgcHJpY2luZ01vZGVsOiAnZmxhdF9yYXRlJyBhcyBjb25zdCxcbiAgICAgICAgYmFzZUNvc3Q6IDI1MDAsXG4gICAgICAgIG5vdGVzOiAnPHNjcmlwdD5hbGVydChcInhzc1wiKTwvc2NyaXB0PlByb2Zlc3Npb25hbCB3ZWRkaW5nIHBob3RvZ3JhcGh5JyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1vY2tDcmVhdGVkVmVuZG9yID0ge1xuICAgICAgICBpZDogJ3ZlbmRvci0xMjMnLFxuICAgICAgICBuYW1lOiAnQ29zdGEgUmljYSBQaG90b2dyYXBoeScsXG4gICAgICAgIGNhdGVnb3J5OiAncGhvdG9ncmFwaHknLFxuICAgICAgICBjb250YWN0X25hbWU6ICdKb2huIERvZScsXG4gICAgICAgIGVtYWlsOiAnam9obkBleGFtcGxlLmNvbScsXG4gICAgICAgIHBob25lOiAnKzEyMzQ1Njc4OTAnLFxuICAgICAgICBwcmljaW5nX21vZGVsOiAnZmxhdF9yYXRlJyxcbiAgICAgICAgYmFzZV9jb3N0OiAnMjUwMC4wMCcsXG4gICAgICAgIHBheW1lbnRfc3RhdHVzOiAndW5wYWlkJyxcbiAgICAgICAgYW1vdW50X3BhaWQ6ICcwLjAwJyxcbiAgICAgICAgbm90ZXM6ICdQcm9mZXNzaW9uYWwgd2VkZGluZyBwaG90b2dyYXBoeScsXG4gICAgICAgIGNyZWF0ZWRfYXQ6ICcyMDI0LTAxLTAxVDEwOjAwOjAwWicsXG4gICAgICAgIHVwZGF0ZWRfYXQ6ICcyMDI0LTAxLTAxVDEwOjAwOjAwWicsXG4gICAgICB9O1xuXG4gICAgICAvLyBTZXQgdXAgdGhlIGNvbXBsZXRlIG1vY2sgY2hhaW4gZm9yIHN1Y2Nlc3NmdWwgaW5zZXJ0XG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBpbnNlcnQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgIGRhdGE6IG1vY2tDcmVhdGVkVmVuZG9yLFxuICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcmVhdGUobWFsaWNpb3VzRGF0YSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEubmFtZSkubm90LnRvQ29udGFpbignPHNjcmlwdD4nKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmNvbnRhY3ROYW1lKS5ub3QudG9Db250YWluKCc8c2NyaXB0PicpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEubm90ZXMpLm5vdC50b0NvbnRhaW4oJzxzY3JpcHQ+Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2VzcyB3aXRoIHZlbmRvciBkYXRhIHdoZW4gdmVuZG9yIGV4aXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tWZW5kb3IgPSB7XG4gICAgICAgIGlkOiAndmVuZG9yLTEyMycsXG4gICAgICAgIG5hbWU6ICdUZXN0IFZlbmRvcicsXG4gICAgICAgIGNhdGVnb3J5OiAncGhvdG9ncmFwaHknLFxuICAgICAgICBjb250YWN0X25hbWU6ICdKb2huIERvZScsXG4gICAgICAgIGVtYWlsOiAnam9obkBleGFtcGxlLmNvbScsXG4gICAgICAgIHBob25lOiAnKzEyMzQ1Njc4OTAnLFxuICAgICAgICBwcmljaW5nX21vZGVsOiAnZmxhdF9yYXRlJyxcbiAgICAgICAgYmFzZV9jb3N0OiAnMjUwMC4wMCcsXG4gICAgICAgIHBheW1lbnRfc3RhdHVzOiAndW5wYWlkJyxcbiAgICAgICAgYW1vdW50X3BhaWQ6ICcwLjAwJyxcbiAgICAgICAgbm90ZXM6ICdUZXN0IG5vdGVzJyxcbiAgICAgICAgY3JlYXRlZF9hdDogJzIwMjQtMDEtMDFUMTA6MDA6MDBaJyxcbiAgICAgICAgdXBkYXRlZF9hdDogJzIwMjQtMDEtMDFUMTA6MDA6MDBaJyxcbiAgICAgIH07XG5cbiAgICAgIC8vIFNldCB1cCB0aGUgY29tcGxldGUgbW9jayBjaGFpbiBmb3Igc2VsZWN0IG9wZXJhdGlvblxuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgIGRhdGE6IG1vY2tWZW5kb3IsXG4gICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldCgndmVuZG9yLTEyMycpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmlkKS50b0JlKCd2ZW5kb3ItMTIzJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5uYW1lKS50b0JlKCdUZXN0IFZlbmRvcicpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gTk9UX0ZPVU5EIHdoZW4gdmVuZG9yIGRvZXMgbm90IGV4aXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gU2V0IHVwIHRoZSBjb21wbGV0ZSBtb2NrIGNoYWluIGZvciBub3QgZm91bmQgc2NlbmFyaW9cbiAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICBlcnJvcjogeyBjb2RlOiAnUEdSU1QxMTYnLCBtZXNzYWdlOiAnTm8gcm93cyBmb3VuZCcgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXQoJ25vbmV4aXN0ZW50LXZlbmRvcicpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ05PVF9GT1VORCcpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gREFUQUJBU0VfRVJST1Igd2hlbiBxdWVyeSBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFNldCB1cCB0aGUgY29tcGxldGUgbW9jayBjaGFpbiBmb3IgZGF0YWJhc2UgZXJyb3JcbiAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnLCBjb2RlOiAnQ09OTkVDVElPTl9FUlJPUicgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXQoJ3ZlbmRvci0xMjMnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdEQVRBQkFTRV9FUlJPUicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgndXBkYXRlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3Mgd2l0aCB1cGRhdGVkIHZlbmRvciBkYXRhIHdoZW4gdmFsaWQgaW5wdXQgcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVEYXRhID0ge1xuICAgICAgICBuYW1lOiAnVXBkYXRlZCBWZW5kb3IgTmFtZScsXG4gICAgICAgIGJhc2VDb3N0OiAzMDAwLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1VwZGF0ZWRWZW5kb3IgPSB7XG4gICAgICAgIGlkOiAndmVuZG9yLTEyMycsXG4gICAgICAgIG5hbWU6ICdVcGRhdGVkIFZlbmRvciBOYW1lJyxcbiAgICAgICAgY2F0ZWdvcnk6ICdwaG90b2dyYXBoeScsXG4gICAgICAgIGNvbnRhY3RfbmFtZTogJ0pvaG4gRG9lJyxcbiAgICAgICAgZW1haWw6ICdqb2huQGV4YW1wbGUuY29tJyxcbiAgICAgICAgcGhvbmU6ICcrMTIzNDU2Nzg5MCcsXG4gICAgICAgIHByaWNpbmdfbW9kZWw6ICdmbGF0X3JhdGUnLFxuICAgICAgICBiYXNlX2Nvc3Q6ICczMDAwLjAwJyxcbiAgICAgICAgcGF5bWVudF9zdGF0dXM6ICd1bnBhaWQnLFxuICAgICAgICBhbW91bnRfcGFpZDogJzAuMDAnLFxuICAgICAgICBub3RlczogJ1Rlc3Qgbm90ZXMnLFxuICAgICAgICBjcmVhdGVkX2F0OiAnMjAyNC0wMS0wMVQxMDowMDowMFonLFxuICAgICAgICB1cGRhdGVkX2F0OiAnMjAyNC0wMS0wMVQxMTowMDowMFonLFxuICAgICAgfTtcblxuICAgICAgLy8gU2V0IHVwIHRoZSBjb21wbGV0ZSBtb2NrIGNoYWluIGZvciB1cGRhdGUgb3BlcmF0aW9uXG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBtb2NrVXBkYXRlZFZlbmRvcixcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXBkYXRlKCd2ZW5kb3ItMTIzJywgdXBkYXRlRGF0YSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEubmFtZSkudG9CZSgnVXBkYXRlZCBWZW5kb3IgTmFtZScpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuYmFzZUNvc3QpLnRvQmUoMzAwMCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBWQUxJREFUSU9OX0VSUk9SIHdoZW4gaW52YWxpZCBpbnB1dCBwcm92aWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWREYXRhID0ge1xuICAgICAgICBiYXNlQ29zdDogLTEwMCwgLy8gSW52YWxpZDogbmVnYXRpdmUgY29zdFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXBkYXRlKCd2ZW5kb3ItMTIzJywgaW52YWxpZERhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ1ZBTElEQVRJT05fRVJST1InKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIE5PVF9GT1VORCB3aGVuIHZlbmRvciBkb2VzIG5vdCBleGlzdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZURhdGEgPSB7IG5hbWU6ICdVcGRhdGVkIE5hbWUnIH07XG5cbiAgICAgIC8vIFNldCB1cCB0aGUgY29tcGxldGUgbW9jayBjaGFpbiBmb3Igbm90IGZvdW5kIHNjZW5hcmlvXG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiB7IGNvZGU6ICdQR1JTVDExNicsIG1lc3NhZ2U6ICdObyByb3dzIGZvdW5kJyB9LFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1cGRhdGUoJ25vbmV4aXN0ZW50LXZlbmRvcicsIHVwZGF0ZURhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ05PVF9GT1VORCcpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gREFUQUJBU0VfRVJST1Igd2hlbiB1cGRhdGUgZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVEYXRhID0geyBuYW1lOiAnVXBkYXRlZCBOYW1lJyB9O1xuXG4gICAgICAvLyBTZXQgdXAgdGhlIGNvbXBsZXRlIG1vY2sgY2hhaW4gZm9yIGRhdGFiYXNlIGVycm9yXG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6ICdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcsIGNvZGU6ICdDT05ORUNUSU9OX0VSUk9SJyB9LFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1cGRhdGUoJ3ZlbmRvci0xMjMnLCB1cGRhdGVEYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdEQVRBQkFTRV9FUlJPUicpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzYW5pdGl6ZSBpbnB1dCB0byBwcmV2ZW50IFhTUyBhdHRhY2tzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbWFsaWNpb3VzRGF0YSA9IHtcbiAgICAgICAgbmFtZTogJzxzY3JpcHQ+YWxlcnQoXCJ4c3NcIik8L3NjcmlwdD5VcGRhdGVkIE5hbWUnLFxuICAgICAgICBjb250YWN0TmFtZTogJzxzY3JpcHQ+YWxlcnQoXCJ4c3NcIik8L3NjcmlwdD5VcGRhdGVkIENvbnRhY3QnLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1VwZGF0ZWRWZW5kb3IgPSB7XG4gICAgICAgIGlkOiAndmVuZG9yLTEyMycsXG4gICAgICAgIG5hbWU6ICdVcGRhdGVkIE5hbWUnLFxuICAgICAgICBjYXRlZ29yeTogJ3Bob3RvZ3JhcGh5JyxcbiAgICAgICAgY29udGFjdF9uYW1lOiAnVXBkYXRlZCBDb250YWN0JyxcbiAgICAgICAgZW1haWw6ICdqb2huQGV4YW1wbGUuY29tJyxcbiAgICAgICAgcGhvbmU6ICcrMTIzNDU2Nzg5MCcsXG4gICAgICAgIHByaWNpbmdfbW9kZWw6ICdmbGF0X3JhdGUnLFxuICAgICAgICBiYXNlX2Nvc3Q6ICcyNTAwLjAwJyxcbiAgICAgICAgcGF5bWVudF9zdGF0dXM6ICd1bnBhaWQnLFxuICAgICAgICBhbW91bnRfcGFpZDogJzAuMDAnLFxuICAgICAgICBub3RlczogJ1Rlc3Qgbm90ZXMnLFxuICAgICAgICBjcmVhdGVkX2F0OiAnMjAyNC0wMS0wMVQxMDowMDowMFonLFxuICAgICAgICB1cGRhdGVkX2F0OiAnMjAyNC0wMS0wMVQxMTowMDowMFonLFxuICAgICAgfTtcblxuICAgICAgLy8gU2V0IHVwIHRoZSBjb21wbGV0ZSBtb2NrIGNoYWluIGZvciBzdWNjZXNzZnVsIHVwZGF0ZVxuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgdXBkYXRlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogbW9ja1VwZGF0ZWRWZW5kb3IsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwZGF0ZSgndmVuZG9yLTEyMycsIG1hbGljaW91c0RhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLm5hbWUpLm5vdC50b0NvbnRhaW4oJzxzY3JpcHQ+Jyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5jb250YWN0TmFtZSkubm90LnRvQ29udGFpbignPHNjcmlwdD4nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2RlbGV0ZVZlbmRvcicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIHdoZW4gdmVuZG9yIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gU2V0IHVwIHRoZSBjb21wbGV0ZSBtb2NrIGNoYWluIGZvciBzdWNjZXNzZnVsIGRlbGV0ZVxuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgZGVsZXRlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGVsZXRlVmVuZG9yKCd2ZW5kb3ItMTIzJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIERBVEFCQVNFX0VSUk9SIHdoZW4gZGVsZXRlIGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gU2V0IHVwIHRoZSBjb21wbGV0ZSBtb2NrIGNoYWluIGZvciBkYXRhYmFzZSBlcnJvclxuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgZGVsZXRlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnLCBjb2RlOiAnQ09OTkVDVElPTl9FUlJPUicgfSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGVsZXRlVmVuZG9yKCd2ZW5kb3ItMTIzJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnREFUQUJBU0VfRVJST1InKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2xpc3QnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2VzcyB3aXRoIHBhZ2luYXRlZCB2ZW5kb3IgbGlzdCB3aGVuIHZlbmRvcnMgZXhpc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrVmVuZG9ycyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAndmVuZG9yLTEnLFxuICAgICAgICAgIG5hbWU6ICdWZW5kb3IgMScsXG4gICAgICAgICAgY2F0ZWdvcnk6ICdwaG90b2dyYXBoeScsXG4gICAgICAgICAgY29udGFjdF9uYW1lOiAnSm9obiBEb2UnLFxuICAgICAgICAgIGVtYWlsOiAnam9obkBleGFtcGxlLmNvbScsXG4gICAgICAgICAgcGhvbmU6ICcrMTIzNDU2Nzg5MCcsXG4gICAgICAgICAgcHJpY2luZ19tb2RlbDogJ2ZsYXRfcmF0ZScsXG4gICAgICAgICAgYmFzZV9jb3N0OiAnMjUwMC4wMCcsXG4gICAgICAgICAgcGF5bWVudF9zdGF0dXM6ICd1bnBhaWQnLFxuICAgICAgICAgIGFtb3VudF9wYWlkOiAnMC4wMCcsXG4gICAgICAgICAgbm90ZXM6ICdUZXN0IG5vdGVzJyxcbiAgICAgICAgICBjcmVhdGVkX2F0OiAnMjAyNC0wMS0wMVQxMDowMDowMFonLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6ICcyMDI0LTAxLTAxVDEwOjAwOjAwWicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3ZlbmRvci0yJyxcbiAgICAgICAgICBuYW1lOiAnVmVuZG9yIDInLFxuICAgICAgICAgIGNhdGVnb3J5OiAnY2F0ZXJpbmcnLFxuICAgICAgICAgIGNvbnRhY3RfbmFtZTogJ0phbmUgU21pdGgnLFxuICAgICAgICAgIGVtYWlsOiAnamFuZUBleGFtcGxlLmNvbScsXG4gICAgICAgICAgcGhvbmU6ICcrMTIzNDU2Nzg5MScsXG4gICAgICAgICAgcHJpY2luZ19tb2RlbDogJ3Blcl9ndWVzdCcsXG4gICAgICAgICAgYmFzZV9jb3N0OiAnNTAuMDAnLFxuICAgICAgICAgIHBheW1lbnRfc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgYW1vdW50X3BhaWQ6ICc1MDAwLjAwJyxcbiAgICAgICAgICBub3RlczogJ0Fub3RoZXIgdGVzdCcsXG4gICAgICAgICAgY3JlYXRlZF9hdDogJzIwMjQtMDEtMDFUMTE6MDA6MDBaJyxcbiAgICAgICAgICB1cGRhdGVkX2F0OiAnMjAyNC0wMS0wMVQxMTowMDowMFonLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgLy8gU2V0IHVwIHRoZSBjb21wbGV0ZSBtb2NrIGNoYWluIGZvciBsaXN0IG9wZXJhdGlvblxuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICByYW5nZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBvcmRlcjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgZGF0YTogbW9ja1ZlbmRvcnMsXG4gICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICBjb3VudDogMixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsaXN0KCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudmVuZG9ycykudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudG90YWwpLnRvQmUoMik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIHdpdGggZmlsdGVyZWQgdmVuZG9yIGxpc3Qgd2hlbiBmaWx0ZXJzIHByb3ZpZGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZmlsdGVycyA9IHtcbiAgICAgICAgY2F0ZWdvcnk6ICdwaG90b2dyYXBoeScgYXMgY29uc3QsXG4gICAgICAgIHBheW1lbnRTdGF0dXM6ICd1bnBhaWQnIGFzIGNvbnN0LFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1ZlbmRvcnMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3ZlbmRvci0xJyxcbiAgICAgICAgICBuYW1lOiAnUGhvdG9ncmFwaHkgVmVuZG9yJyxcbiAgICAgICAgICBjYXRlZ29yeTogJ3Bob3RvZ3JhcGh5JyxcbiAgICAgICAgICBjb250YWN0X25hbWU6ICdKb2huIERvZScsXG4gICAgICAgICAgZW1haWw6ICdqb2huQGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBwaG9uZTogJysxMjM0NTY3ODkwJyxcbiAgICAgICAgICBwcmljaW5nX21vZGVsOiAnZmxhdF9yYXRlJyxcbiAgICAgICAgICBiYXNlX2Nvc3Q6ICcyNTAwLjAwJyxcbiAgICAgICAgICBwYXltZW50X3N0YXR1czogJ3VucGFpZCcsXG4gICAgICAgICAgYW1vdW50X3BhaWQ6ICcwLjAwJyxcbiAgICAgICAgICBub3RlczogJ1Rlc3Qgbm90ZXMnLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6ICcyMDI0LTAxLTAxVDEwOjAwOjAwWicsXG4gICAgICAgICAgdXBkYXRlZF9hdDogJzIwMjQtMDEtMDFUMTA6MDA6MDBaJyxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIC8vIFNldCB1cCB0aGUgY29tcGxldGUgbW9jayBjaGFpbiBmb3IgZmlsdGVyZWQgbGlzdCBvcGVyYXRpb25cbiAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICByYW5nZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgb3JkZXI6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICBkYXRhOiBtb2NrVmVuZG9ycyxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgY291bnQ6IDE1LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsaXN0KGZpbHRlcnMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnZlbmRvcnMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnRvdGFsKS50b0JlKDE1KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3Mgd2l0aCBlbXB0eSBsaXN0IHdoZW4gbm8gdmVuZG9ycyBleGlzdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFNldCB1cCB0aGUgY29tcGxldGUgbW9jayBjaGFpbiBmb3IgZW1wdHkgbGlzdFxuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICByYW5nZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBvcmRlcjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsaXN0KCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudmVuZG9ycykudG9IYXZlTGVuZ3RoKDApO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudG90YWwpLnRvQmUoMCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBEQVRBQkFTRV9FUlJPUiB3aGVuIHF1ZXJ5IGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gU2V0IHVwIHRoZSBjb21wbGV0ZSBtb2NrIGNoYWluIGZvciBkYXRhYmFzZSBlcnJvclxuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICByYW5nZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBvcmRlcjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJywgY29kZTogJ0NPTk5FQ1RJT05fRVJST1InIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbGlzdCgpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ0RBVEFCQVNFX0VSUk9SJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdzZWFyY2gnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2VzcyB3aXRoIHNlYXJjaCByZXN1bHRzIHdoZW4gdmVuZG9ycyBmb3VuZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHtcbiAgICAgICAgcXVlcnk6ICdwaG90b2dyYXBoeScsXG4gICAgICAgIGNhdGVnb3J5OiAncGhvdG9ncmFwaHknIGFzIGNvbnN0LFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1ZlbmRvcnMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3ZlbmRvci0xJyxcbiAgICAgICAgICBuYW1lOiAnUGhvdG9ncmFwaHkgVmVuZG9yJyxcbiAgICAgICAgICBjYXRlZ29yeTogJ3Bob3RvZ3JhcGh5JyxcbiAgICAgICAgICBjb250YWN0X25hbWU6ICdKb2huIERvZScsXG4gICAgICAgICAgZW1haWw6ICdqb2huQGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBwaG9uZTogJysxMjM0NTY3ODkwJyxcbiAgICAgICAgICBwcmljaW5nX21vZGVsOiAnZmxhdF9yYXRlJyxcbiAgICAgICAgICBiYXNlX2Nvc3Q6ICcyNTAwLjAwJyxcbiAgICAgICAgICBwYXltZW50X3N0YXR1czogJ3VucGFpZCcsXG4gICAgICAgICAgYW1vdW50X3BhaWQ6ICcwLjAwJyxcbiAgICAgICAgICBub3RlczogJ1Byb2Zlc3Npb25hbCBwaG90b2dyYXBoeScsXG4gICAgICAgICAgY3JlYXRlZF9hdDogJzIwMjQtMDEtMDFUMTA6MDA6MDBaJyxcbiAgICAgICAgICB1cGRhdGVkX2F0OiAnMjAyNC0wMS0wMVQxMDowMDowMFonLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgLy8gU2V0IHVwIHRoZSBjb21wbGV0ZSBtb2NrIGNoYWluIGZvciBzZWFyY2ggb3BlcmF0aW9uXG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIG9yOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgIHJhbmdlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgb3JkZXI6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogbW9ja1ZlbmRvcnMsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgY291bnQ6IDEsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlYXJjaChzZWFyY2hQYXJhbXMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnZlbmRvcnMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnRvdGFsKS50b0JlKDEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2VzcyB3aXRoIGVtcHR5IHJlc3VsdHMgd2hlbiBubyB2ZW5kb3JzIG1hdGNoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc2VhcmNoUGFyYW1zID0ge1xuICAgICAgICBxdWVyeTogJ25vbmV4aXN0ZW50JyxcbiAgICAgIH07XG5cbiAgICAgIC8vIFNldCB1cCB0aGUgY29tcGxldGUgbW9jayBjaGFpbiBmb3IgZW1wdHkgc2VhcmNoIHJlc3VsdHNcbiAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgb3I6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgcmFuZ2U6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICBvcmRlcjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VhcmNoKHNlYXJjaFBhcmFtcyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudmVuZG9ycykudG9IYXZlTGVuZ3RoKDApO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudG90YWwpLnRvQmUoMCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBWQUxJREFUSU9OX0VSUk9SIHdoZW4gaW52YWxpZCBzZWFyY2ggcGFyYW1zIHByb3ZpZGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFBhcmFtcyA9IHtcbiAgICAgICAgcGFnZTogLTEsIC8vIEludmFsaWQ6IG5lZ2F0aXZlIHBhZ2VcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlYXJjaChpbnZhbGlkUGFyYW1zKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdWQUxJREFUSU9OX0VSUk9SJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBEQVRBQkFTRV9FUlJPUiB3aGVuIHNlYXJjaCBxdWVyeSBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHtcbiAgICAgICAgcXVlcnk6ICdwaG90b2dyYXBoeScsXG4gICAgICB9O1xuXG4gICAgICAvLyBTZXQgdXAgdGhlIGNvbXBsZXRlIG1vY2sgY2hhaW4gZm9yIGRhdGFiYXNlIGVycm9yXG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIG9yOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgIHJhbmdlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgb3JkZXI6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnLCBjb2RlOiAnQ09OTkVDVElPTl9FUlJPUicgfSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VhcmNoKHNlYXJjaFBhcmFtcyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnREFUQUJBU0VfRVJST1InKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3JlY29yZFBheW1lbnQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2VzcyB3aXRoIHBheW1lbnQgaW5mbyB3aGVuIHBheW1lbnQgcmVjb3JkZWQgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bWVudERhdGEgPSB7XG4gICAgICAgIHZlbmRvcklkOiAnMTIzZTQ1NjctZTg5Yi0xMmQzLWE0NTYtNDI2NjE0MTc0MDAwJywgLy8gVmFsaWQgVVVJRCBmb3JtYXRcbiAgICAgICAgYW1vdW50OiAxMDAwLFxuICAgICAgICBub3RlczogJ1BhcnRpYWwgcGF5bWVudCcsXG4gICAgICB9O1xuXG4gICAgICAvLyBNb2NrIHZlbmRvciBsb29rdXAgZm9yIGdldCgpIGNhbGxcbiAgICAgIGNvbnN0IG1vY2tWZW5kb3IgPSB7XG4gICAgICAgIGlkOiAnMTIzZTQ1NjctZTg5Yi0xMmQzLWE0NTYtNDI2NjE0MTc0MDAwJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVmVuZG9yJyxcbiAgICAgICAgY2F0ZWdvcnk6ICdwaG90b2dyYXBoeScsXG4gICAgICAgIGNvbnRhY3RfbmFtZTogJ0pvaG4gRG9lJyxcbiAgICAgICAgZW1haWw6ICdqb2huQGV4YW1wbGUuY29tJyxcbiAgICAgICAgcGhvbmU6ICcrMTIzNDU2Nzg5MCcsXG4gICAgICAgIHByaWNpbmdfbW9kZWw6ICdmbGF0X3JhdGUnLFxuICAgICAgICBiYXNlX2Nvc3Q6ICcyNTAwLjAwJyxcbiAgICAgICAgcGF5bWVudF9zdGF0dXM6ICd1bnBhaWQnLFxuICAgICAgICBhbW91bnRfcGFpZDogJzAuMDAnLFxuICAgICAgICBub3RlczogJ1Rlc3Qgbm90ZXMnLFxuICAgICAgICBjcmVhdGVkX2F0OiAnMjAyNC0wMS0wMVQxMDowMDowMFonLFxuICAgICAgICB1cGRhdGVkX2F0OiAnMjAyNC0wMS0wMVQxMDowMDowMFonLFxuICAgICAgfTtcblxuICAgICAgLy8gTW9jayB1cGRhdGVkIHZlbmRvciBhZnRlciBwYXltZW50IGZvciB1cGRhdGUoKSBjYWxsXG4gICAgICBjb25zdCBtb2NrVXBkYXRlZFZlbmRvciA9IHtcbiAgICAgICAgLi4ubW9ja1ZlbmRvcixcbiAgICAgICAgcGF5bWVudF9zdGF0dXM6ICdwYXJ0aWFsJyxcbiAgICAgICAgYW1vdW50X3BhaWQ6ICcxMDAwLjAwJyxcbiAgICAgICAgdXBkYXRlZF9hdDogJzIwMjQtMDEtMTVUMTA6MDA6MDBaJyxcbiAgICAgIH07XG5cbiAgICAgIC8vIFNldCB1cCBtb2NrIHRvIGhhbmRsZSBib3RoIGdldCgpIGFuZCB1cGRhdGUoKSBjYWxscyBzZXF1ZW50aWFsbHlcbiAgICAgIGxldCBjYWxsQ291bnQgPSAwO1xuICAgICAgbW9ja0Zyb20ubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgY2FsbENvdW50Kys7XG4gICAgICAgIGlmIChjYWxsQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAvLyBGaXJzdCBjYWxsIGlzIGdldCgpIC0gc2VsZWN0IG9wZXJhdGlvblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgZGF0YTogbW9ja1ZlbmRvcixcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2Vjb25kIGNhbGwgaXMgdXBkYXRlKCkgLSB1cGRhdGUgb3BlcmF0aW9uXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBtb2NrVXBkYXRlZFZlbmRvcixcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVjb3JkUGF5bWVudChwYXltZW50RGF0YSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudmVuZG9ySWQpLnRvQmUoJzEyM2U0NTY3LWU4OWItMTJkMy1hNDU2LTQyNjYxNDE3NDAwMCcpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudmVuZG9yTmFtZSkudG9CZSgnVGVzdCBWZW5kb3InKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmFtb3VudFBhaWQpLnRvQmUoMTAwMCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5wYXltZW50U3RhdHVzKS50b0JlKCdwYXJ0aWFsJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBWQUxJREFUSU9OX0VSUk9SIHdoZW4gaW52YWxpZCBwYXltZW50IGRhdGEgcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkRGF0YSA9IHtcbiAgICAgICAgdmVuZG9ySWQ6ICcnLCAvLyBJbnZhbGlkOiBlbXB0eSB2ZW5kb3IgSURcbiAgICAgICAgYW1vdW50OiAtMTAwLCAvLyBJbnZhbGlkOiBuZWdhdGl2ZSBhbW91bnRcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlY29yZFBheW1lbnQoaW52YWxpZERhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ1ZBTElEQVRJT05fRVJST1InKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIFZBTElEQVRJT05fRVJST1Igd2hlbiBwYXltZW50IGV4Y2VlZHMgYmFzZSBjb3N0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bWVudERhdGEgPSB7XG4gICAgICAgIHZlbmRvcklkOiAnMTIzZTQ1NjctZTg5Yi0xMmQzLWE0NTYtNDI2NjE0MTc0MDAwJywgLy8gVmFsaWQgVVVJRCBmb3JtYXRcbiAgICAgICAgYW1vdW50OiAzMDAwLCAvLyBFeGNlZWRzIGJhc2UgY29zdCBvZiAyNTAwXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrVmVuZG9yID0ge1xuICAgICAgICBpZDogJzEyM2U0NTY3LWU4OWItMTJkMy1hNDU2LTQyNjYxNDE3NDAwMCcsXG4gICAgICAgIG5hbWU6ICdUZXN0IFZlbmRvcicsXG4gICAgICAgIGNhdGVnb3J5OiAncGhvdG9ncmFwaHknLFxuICAgICAgICBjb250YWN0X25hbWU6ICdKb2huIERvZScsXG4gICAgICAgIGVtYWlsOiAnam9obkBleGFtcGxlLmNvbScsXG4gICAgICAgIHBob25lOiAnKzEyMzQ1Njc4OTAnLFxuICAgICAgICBwcmljaW5nX21vZGVsOiAnZmxhdF9yYXRlJyxcbiAgICAgICAgYmFzZV9jb3N0OiAnMjUwMC4wMCcsXG4gICAgICAgIHBheW1lbnRfc3RhdHVzOiAndW5wYWlkJyxcbiAgICAgICAgYW1vdW50X3BhaWQ6ICcwLjAwJyxcbiAgICAgICAgbm90ZXM6ICdUZXN0IG5vdGVzJyxcbiAgICAgICAgY3JlYXRlZF9hdDogJzIwMjQtMDEtMDFUMTA6MDA6MDBaJyxcbiAgICAgICAgdXBkYXRlZF9hdDogJzIwMjQtMDEtMDFUMTA6MDA6MDBaJyxcbiAgICAgIH07XG5cbiAgICAgIC8vIFNldCB1cCB0aGUgY29tcGxldGUgbW9jayBjaGFpbiBmb3IgZ2V0IG9wZXJhdGlvblxuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgIGRhdGE6IG1vY2tWZW5kb3IsXG4gICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlY29yZFBheW1lbnQocGF5bWVudERhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ1ZBTElEQVRJT05fRVJST1InKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ1BheW1lbnQgYW1vdW50IGV4Y2VlZHMgdmVuZG9yIGJhc2UgY29zdCcpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gTk9UX0ZPVU5EIHdoZW4gdmVuZG9yIGRvZXMgbm90IGV4aXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bWVudERhdGEgPSB7XG4gICAgICAgIHZlbmRvcklkOiAnMTIzZTQ1NjctZTg5Yi0xMmQzLWE0NTYtNDI2NjE0MTc0MDAwJywgLy8gVmFsaWQgVVVJRCBmb3JtYXQgYnV0IG5vbmV4aXN0ZW50IHZlbmRvclxuICAgICAgICBhbW91bnQ6IDEwMDAsXG4gICAgICB9O1xuXG4gICAgICAvLyBTZXQgdXAgdGhlIGNvbXBsZXRlIG1vY2sgY2hhaW4gZm9yIG5vdCBmb3VuZCBzY2VuYXJpb1xuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgIGVycm9yOiB7IGNvZGU6ICdQR1JTVDExNicsIG1lc3NhZ2U6ICdObyByb3dzIGZvdW5kJyB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlY29yZFBheW1lbnQocGF5bWVudERhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ05PVF9GT1VORCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0UGF5bWVudEluZm8nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2VzcyB3aXRoIHBheW1lbnQgaW5mbyB3aGVuIHZlbmRvciBleGlzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrVmVuZG9yID0ge1xuICAgICAgICBpZDogJ3ZlbmRvci0xMjMnLFxuICAgICAgICBuYW1lOiAnVGVzdCBWZW5kb3InLFxuICAgICAgICBjYXRlZ29yeTogJ3Bob3RvZ3JhcGh5JyxcbiAgICAgICAgY29udGFjdF9uYW1lOiAnSm9obiBEb2UnLFxuICAgICAgICBlbWFpbDogJ2pvaG5AZXhhbXBsZS5jb20nLFxuICAgICAgICBwaG9uZTogJysxMjM0NTY3ODkwJyxcbiAgICAgICAgcHJpY2luZ19tb2RlbDogJ2ZsYXRfcmF0ZScsXG4gICAgICAgIGJhc2VfY29zdDogJzI1MDAuMDAnLFxuICAgICAgICBwYXltZW50X3N0YXR1czogJ3BhcnRpYWwnLFxuICAgICAgICBhbW91bnRfcGFpZDogJzEwMDAuMDAnLFxuICAgICAgICBub3RlczogJ1Rlc3Qgbm90ZXMnLFxuICAgICAgICBjcmVhdGVkX2F0OiAnMjAyNC0wMS0wMVQxMDowMDowMFonLFxuICAgICAgICB1cGRhdGVkX2F0OiAnMjAyNC0wMS0wMVQxMDowMDowMFonLFxuICAgICAgfTtcblxuICAgICAgLy8gU2V0IHVwIHRoZSBjb21wbGV0ZSBtb2NrIGNoYWluIGZvciBzZWxlY3Qgb3BlcmF0aW9uXG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgZGF0YTogbW9ja1ZlbmRvcixcbiAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0UGF5bWVudEluZm8oJ3ZlbmRvci0xMjMnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS52ZW5kb3JJZCkudG9CZSgndmVuZG9yLTEyMycpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudmVuZG9yTmFtZSkudG9CZSgnVGVzdCBWZW5kb3InKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmJhc2VDb3N0KS50b0JlKDI1MDApO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuYW1vdW50UGFpZCkudG9CZSgxMDAwKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmJhbGFuY2VEdWUpLnRvQmUoMTUwMCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5wYXltZW50U3RhdHVzKS50b0JlKCdwYXJ0aWFsJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBOT1RfRk9VTkQgd2hlbiB2ZW5kb3IgZG9lcyBub3QgZXhpc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBTZXQgdXAgdGhlIGNvbXBsZXRlIG1vY2sgY2hhaW4gZm9yIG5vdCBmb3VuZCBzY2VuYXJpb1xuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgIGVycm9yOiB7IGNvZGU6ICdQR1JTVDExNicsIG1lc3NhZ2U6ICdObyByb3dzIGZvdW5kJyB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFBheW1lbnRJbmZvKCdub25leGlzdGVudC12ZW5kb3InKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdOT1RfRk9VTkQnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIERBVEFCQVNFX0VSUk9SIHdoZW4gcXVlcnkgZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBTZXQgdXAgdGhlIGNvbXBsZXRlIG1vY2sgY2hhaW4gZm9yIGRhdGFiYXNlIGVycm9yXG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJywgY29kZTogJ0NPTk5FQ1RJT05fRVJST1InIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0UGF5bWVudEluZm8oJ3ZlbmRvci0xMjMnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdEQVRBQkFTRV9FUlJPUicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsIm1vY2tGcm9tIiwiZm4iLCJtb2NrU3VwYWJhc2VDbGllbnQiLCJmcm9tIiwiY3JlYXRlQ2xpZW50IiwiX19tb2NrRnJvbSIsInNhbml0aXplSW5wdXQiLCJpbnB1dCIsInJlcGxhY2UiLCJyZXF1aXJlIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsIm1vY2tSZXR1cm5WYWx1ZSIsInNlbGVjdCIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiZGF0YSIsImVycm9yIiwiaW5zZXJ0IiwidXBkYXRlIiwiZGVsZXRlIiwiaXQiLCJ2YWxpZERhdGEiLCJuYW1lIiwiY2F0ZWdvcnkiLCJjb250YWN0TmFtZSIsImVtYWlsIiwicGhvbmUiLCJwcmljaW5nTW9kZWwiLCJiYXNlQ29zdCIsIm5vdGVzIiwibW9ja0NyZWF0ZWRWZW5kb3IiLCJpZCIsImNvbnRhY3RfbmFtZSIsInByaWNpbmdfbW9kZWwiLCJiYXNlX2Nvc3QiLCJwYXltZW50X3N0YXR1cyIsImFtb3VudF9wYWlkIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJzaW5nbGUiLCJyZXN1bHQiLCJjcmVhdGUiLCJleHBlY3QiLCJzdWNjZXNzIiwidG9CZSIsInBheW1lbnRTdGF0dXMiLCJpbnZhbGlkRGF0YSIsImNvZGUiLCJtZXNzYWdlIiwibWFsaWNpb3VzRGF0YSIsIm5vdCIsInRvQ29udGFpbiIsIm1vY2tWZW5kb3IiLCJlcSIsImdldCIsInVwZGF0ZURhdGEiLCJtb2NrVXBkYXRlZFZlbmRvciIsImRlbGV0ZVZlbmRvciIsIm1vY2tWZW5kb3JzIiwicmFuZ2UiLCJvcmRlciIsImNvdW50IiwibGlzdCIsInZlbmRvcnMiLCJ0b0hhdmVMZW5ndGgiLCJ0b3RhbCIsImZpbHRlcnMiLCJzZWFyY2hQYXJhbXMiLCJxdWVyeSIsIm9yIiwic2VhcmNoIiwiaW52YWxpZFBhcmFtcyIsInBhZ2UiLCJwYXltZW50RGF0YSIsInZlbmRvcklkIiwiYW1vdW50IiwiY2FsbENvdW50IiwibW9ja0ltcGxlbWVudGF0aW9uIiwicmVjb3JkUGF5bWVudCIsInZlbmRvck5hbWUiLCJhbW91bnRQYWlkIiwiZ2V0UGF5bWVudEluZm8iLCJiYWxhbmNlRHVlIl0sIm1hcHBpbmdzIjoiO0FBQUEsaUVBQWlFO0FBQ2pFQSxLQUFLQyxJQUFJLENBQUMseUJBQXlCO0lBQ2pDLE1BQU1DLFdBQVdGLEtBQUtHLEVBQUU7SUFDeEIsTUFBTUMscUJBQXFCO1FBQ3pCQyxNQUFNSDtJQUNSO0lBRUEsT0FBTztRQUNMSSxjQUFjTixLQUFLRyxFQUFFLENBQUMsSUFBTUM7UUFDNUIsK0NBQStDO1FBQy9DRyxZQUFZTDtJQUNkO0FBQ0Y7QUFFQSxvQkFBb0I7QUFDcEJGLEtBQUtDLElBQUksQ0FBQyx5QkFBeUIsSUFBTyxDQUFBO1FBQ3hDTyxlQUFlUixLQUFLRyxFQUFFLENBQUMsQ0FBQ00sUUFBVUEsT0FBT0MsUUFBUSxhQUFhLE9BQU87SUFDdkUsQ0FBQTs7OzsrQkFZTztBQUVQLCtCQUErQjtBQUMvQixNQUFNLEVBQUVILFlBQVlMLFFBQVEsRUFBRSxHQUFHUyxRQUFRO0FBRXpDQyxTQUFTLGlCQUFpQjtJQUN4QkMsV0FBVztRQUNUYixLQUFLYyxhQUFhO1FBRWxCLCtDQUErQztRQUMvQ0MsUUFBUUMsR0FBRyxDQUFDQyx3QkFBd0IsR0FBRztRQUN2Q0YsUUFBUUMsR0FBRyxDQUFDRSw2QkFBNkIsR0FBRztRQUU1QyxtREFBbUQ7UUFDbkRoQixTQUFTaUIsZUFBZSxDQUFDO1lBQ3ZCQyxRQUFRcEIsS0FBS0csRUFBRSxHQUFHa0IsaUJBQWlCLENBQUM7Z0JBQUVDLE1BQU0sRUFBRTtnQkFBRUMsT0FBTztZQUFLO1lBQzVEQyxRQUFReEIsS0FBS0csRUFBRSxHQUFHa0IsaUJBQWlC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