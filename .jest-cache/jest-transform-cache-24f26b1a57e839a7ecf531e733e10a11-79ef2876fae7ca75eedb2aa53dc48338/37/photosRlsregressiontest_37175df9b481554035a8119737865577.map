{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/__tests__/regression/photosRls.regression.test.ts"],"sourcesContent":["/**\n * Photos RLS Regression Test\n * \n * This test validates Row-Level Security (RLS) policies for the photos table.\n * Tests ensure that:\n * - Admins can create, read, update, and delete photos with real auth\n * - Admins can read all moderation states (pending, approved, rejected)\n * - Guests can only read approved photos\n * - Guests cannot read pending or rejected photos\n * - Guests cannot create, update, or delete photos\n * - Photos are properly filtered by page_type and page_id\n * - RLS doesn't cause \"permission denied\" errors\n * - Service role can bypass RLS for admin operations\n * \n * Validates: Requirements 1.2, 1.3, 1.4 (Security Testing)\n */\n\nimport { createAndSignInTestUser, deleteTestUser, createServiceClient, createTestClient, type TestUser } from '../helpers/testDb';\nimport { cleanupByIds } from '../helpers/cleanup';\n\ndescribe('Photos RLS Regression Tests', () => {\n  let adminUser: TestUser | null = null;\n  let guestUser: TestUser | null = null;\n  let authSetupFailed = false;\n  const createdIds: Map<string, string[]> = new Map();\n  \n  // Helper to track created entities for cleanup\n  const trackEntity = (table: string, id: string) => {\n    const ids = createdIds.get(table) || [];\n    ids.push(id);\n    createdIds.set(table, ids);\n  };\n  \n  beforeAll(async () => {\n    try {\n      // Create admin user (with host role)\n      adminUser = await createAndSignInTestUser({\n        email: `admin-${Date.now()}@test.com`,\n        password: 'test123',\n        role: 'host'\n      });\n      \n      // Create guest user (regular user)\n      guestUser = await createAndSignInTestUser({\n        email: `guest-${Date.now()}@test.com`,\n        password: 'test123',\n        role: 'guest'\n      });\n      \n      console.log('✅ Test users created for photos RLS tests');\n    } catch (error) {\n      console.warn('⚠️  Failed to create test users:', error instanceof Error ? error.message : error);\n      authSetupFailed = true;\n    }\n  }, 30000);\n  \n  afterAll(async () => {\n    // Clean up created entities\n    for (const [table, ids] of createdIds.entries()) {\n      if (ids.length > 0) {\n        await cleanupByIds(table, ids);\n      }\n    }\n    \n    // Clean up test users\n    if (adminUser?.id) {\n      try {\n        await deleteTestUser(adminUser.id);\n        console.log('✅ Admin user cleaned up');\n      } catch (error) {\n        console.warn('⚠️  Failed to clean up admin user:', error);\n      }\n    }\n    \n    if (guestUser?.id) {\n      try {\n        await deleteTestUser(guestUser.id);\n        console.log('✅ Guest user cleaned up');\n      } catch (error) {\n        console.warn('⚠️  Failed to clean up guest user:', error);\n      }\n    }\n  }, 10000);\n  \n  describe('Admin Photo Operations with Real Auth', () => {\n    it('should allow admin to create photo with real auth (not service role)', async () => {\n      if (authSetupFailed || !adminUser?.accessToken) {\n        console.log('⏭️  Skipping: Authentication not configured');\n        return;\n      }\n      \n      const client = createTestClient(adminUser.accessToken);\n      \n      const photoData = {\n        uploader_id: adminUser.id,\n        photo_url: 'https://cdn.example.com/test-photo.jpg',\n        storage_type: 'b2',\n        page_type: 'memory',\n        page_id: null,\n        caption: 'Test photo caption',\n        alt_text: 'Test photo alt text',\n        moderation_status: 'approved',\n        display_order: 1,\n      };\n      \n      const { data, error } = await client\n        .from('photos')\n        .insert(photoData)\n        .select()\n        .single();\n      \n      // Should not get RLS error\n      expect(error).toBeNull();\n      expect(data).toBeDefined();\n      \n      if (data) {\n        expect(data.uploader_id).toBe(adminUser.id);\n        expect(data.photo_url).toBe(photoData.photo_url);\n        expect(data.storage_type).toBe('b2');\n        expect(data.moderation_status).toBe('approved');\n        trackEntity('photos', data.id);\n      }\n    });\n    \n    it('should allow admin to read all moderation states', async () => {\n      if (authSetupFailed || !adminUser?.accessToken) {\n        console.log('⏭️  Skipping: Authentication not configured');\n        return;\n      }\n      \n      const serviceClient = createServiceClient();\n      const client = createTestClient(adminUser.accessToken);\n      \n      // Create photos with different moderation states using service role\n      const photos = [\n        {\n          uploader_id: adminUser.id,\n          photo_url: 'https://cdn.example.com/pending-photo.jpg',\n          storage_type: 'b2',\n          page_type: 'memory',\n          moderation_status: 'pending',\n        },\n        {\n          uploader_id: adminUser.id,\n          photo_url: 'https://cdn.example.com/approved-photo.jpg',\n          storage_type: 'b2',\n          page_type: 'memory',\n          moderation_status: 'approved',\n        },\n        {\n          uploader_id: adminUser.id,\n          photo_url: 'https://cdn.example.com/rejected-photo.jpg',\n          storage_type: 'b2',\n          page_type: 'memory',\n          moderation_status: 'rejected',\n        },\n      ];\n      \n      const { data: createdPhotos } = await serviceClient\n        .from('photos')\n        .insert(photos)\n        .select();\n      \n      if (createdPhotos) {\n        createdPhotos.forEach(photo => trackEntity('photos', photo.id));\n      }\n      \n      // Admin should be able to read all moderation states\n      const { data: pendingPhotos, error: pendingError } = await client\n        .from('photos')\n        .select('*')\n        .eq('moderation_status', 'pending');\n      \n      const { data: approvedPhotos, error: approvedError } = await client\n        .from('photos')\n        .select('*')\n        .eq('moderation_status', 'approved');\n      \n      const { data: rejectedPhotos, error: rejectedError } = await client\n        .from('photos')\n        .select('*')\n        .eq('moderation_status', 'rejected');\n      \n      expect(pendingError).toBeNull();\n      expect(approvedError).toBeNull();\n      expect(rejectedError).toBeNull();\n      expect(pendingPhotos).toBeDefined();\n      expect(approvedPhotos).toBeDefined();\n      expect(rejectedPhotos).toBeDefined();\n    });\n    \n    it('should allow admin to update photo metadata', async () => {\n      if (authSetupFailed || !adminUser?.accessToken) {\n        console.log('⏭️  Skipping: Authentication not configured');\n        return;\n      }\n      \n      const serviceClient = createServiceClient();\n      const client = createTestClient(adminUser.accessToken);\n      \n      // Create photo using service role\n      const { data: photo } = await serviceClient\n        .from('photos')\n        .insert({\n          uploader_id: adminUser.id,\n          photo_url: 'https://cdn.example.com/update-test.jpg',\n          storage_type: 'b2',\n          page_type: 'memory',\n          caption: 'Original caption',\n          moderation_status: 'pending',\n        })\n        .select()\n        .single();\n      \n      if (!photo) {\n        console.log('⏭️  Skipping: Could not create test photo');\n        return;\n      }\n      \n      trackEntity('photos', photo.id);\n      \n      // Admin should be able to update photo\n      const { data: updatedPhoto, error } = await client\n        .from('photos')\n        .update({\n          caption: 'Updated caption',\n          alt_text: 'Updated alt text',\n          moderation_status: 'approved',\n        })\n        .eq('id', photo.id)\n        .select()\n        .single();\n      \n      expect(error).toBeNull();\n      expect(updatedPhoto).toBeDefined();\n      \n      if (updatedPhoto) {\n        expect(updatedPhoto.caption).toBe('Updated caption');\n        expect(updatedPhoto.alt_text).toBe('Updated alt text');\n        expect(updatedPhoto.moderation_status).toBe('approved');\n      }\n    });\n    \n    it('should allow admin to delete photo', async () => {\n      if (authSetupFailed || !adminUser?.accessToken) {\n        console.log('⏭️  Skipping: Authentication not configured');\n        return;\n      }\n      \n      const serviceClient = createServiceClient();\n      const client = createTestClient(adminUser.accessToken);\n      \n      // Create photo using service role\n      const { data: photo } = await serviceClient\n        .from('photos')\n        .insert({\n          uploader_id: adminUser.id,\n          photo_url: 'https://cdn.example.com/delete-test.jpg',\n          storage_type: 'b2',\n          page_type: 'memory',\n          moderation_status: 'pending',\n        })\n        .select()\n        .single();\n      \n      if (!photo) {\n        console.log('⏭️  Skipping: Could not create test photo');\n        return;\n      }\n      \n      // Admin should be able to delete photo\n      const { error } = await client\n        .from('photos')\n        .delete()\n        .eq('id', photo.id);\n      \n      expect(error).toBeNull();\n      \n      // Verify photo is deleted\n      const { data: deletedPhoto } = await serviceClient\n        .from('photos')\n        .select('*')\n        .eq('id', photo.id)\n        .single();\n      \n      expect(deletedPhoto).toBeNull();\n    });\n  });\n  \n  describe('Guest Photo Access Restrictions', () => {\n    it('should allow guest to read only approved photos', async () => {\n      if (authSetupFailed || !guestUser?.accessToken) {\n        console.log('⏭️  Skipping: Authentication not configured');\n        return;\n      }\n      \n      const serviceClient = createServiceClient();\n      const client = createTestClient(guestUser.accessToken);\n      \n      // Create approved photo using service role\n      const { data: approvedPhoto } = await serviceClient\n        .from('photos')\n        .insert({\n          uploader_id: adminUser!.id,\n          photo_url: 'https://cdn.example.com/approved-guest-test.jpg',\n          storage_type: 'b2',\n          page_type: 'memory',\n          moderation_status: 'approved',\n        })\n        .select()\n        .single();\n      \n      if (approvedPhoto) {\n        trackEntity('photos', approvedPhoto.id);\n      }\n      \n      // Guest should be able to read approved photos\n      const { data: photos, error } = await client\n        .from('photos')\n        .select('*')\n        .eq('moderation_status', 'approved');\n      \n      expect(error).toBeNull();\n      expect(photos).toBeDefined();\n      expect(Array.isArray(photos)).toBe(true);\n      \n      if (photos && photos.length > 0) {\n        // All returned photos should be approved\n        photos.forEach(photo => {\n          expect(photo.moderation_status).toBe('approved');\n        });\n      }\n    });\n    \n    it('should prevent guest from reading pending photos', async () => {\n      if (authSetupFailed || !guestUser?.accessToken) {\n        console.log('⏭️  Skipping: Authentication not configured');\n        return;\n      }\n      \n      const serviceClient = createServiceClient();\n      const client = createTestClient(guestUser.accessToken);\n      \n      // Create pending photo using service role\n      const { data: pendingPhoto } = await serviceClient\n        .from('photos')\n        .insert({\n          uploader_id: adminUser!.id,\n          photo_url: 'https://cdn.example.com/pending-guest-test.jpg',\n          storage_type: 'b2',\n          page_type: 'memory',\n          moderation_status: 'pending',\n        })\n        .select()\n        .single();\n      \n      if (pendingPhoto) {\n        trackEntity('photos', pendingPhoto.id);\n      }\n      \n      // Guest should NOT be able to read pending photos\n      const { data: photos } = await client\n        .from('photos')\n        .select('*')\n        .eq('id', pendingPhoto!.id);\n      \n      // Should return empty array or null (RLS filters it out)\n      expect(photos === null || (Array.isArray(photos) && photos.length === 0)).toBe(true);\n    });\n    \n    it('should prevent guest from reading rejected photos', async () => {\n      if (authSetupFailed || !guestUser?.accessToken) {\n        console.log('⏭️  Skipping: Authentication not configured');\n        return;\n      }\n      \n      const serviceClient = createServiceClient();\n      const client = createTestClient(guestUser.accessToken);\n      \n      // Create rejected photo using service role\n      const { data: rejectedPhoto } = await serviceClient\n        .from('photos')\n        .insert({\n          uploader_id: adminUser!.id,\n          photo_url: 'https://cdn.example.com/rejected-guest-test.jpg',\n          storage_type: 'b2',\n          page_type: 'memory',\n          moderation_status: 'rejected',\n        })\n        .select()\n        .single();\n      \n      if (rejectedPhoto) {\n        trackEntity('photos', rejectedPhoto.id);\n      }\n      \n      // Guest should NOT be able to read rejected photos\n      const { data: photos } = await client\n        .from('photos')\n        .select('*')\n        .eq('id', rejectedPhoto!.id);\n      \n      // Should return empty array or null (RLS filters it out)\n      expect(photos === null || (Array.isArray(photos) && photos.length === 0)).toBe(true);\n    });\n    \n    it('should prevent guest from creating photos', async () => {\n      if (authSetupFailed || !guestUser?.accessToken) {\n        console.log('⏭️  Skipping: Authentication not configured');\n        return;\n      }\n      \n      const client = createTestClient(guestUser.accessToken);\n      \n      const photoData = {\n        uploader_id: guestUser.id,\n        photo_url: 'https://cdn.example.com/guest-upload-test.jpg',\n        storage_type: 'b2',\n        page_type: 'memory',\n        moderation_status: 'pending',\n      };\n      \n      const { data, error } = await client\n        .from('photos')\n        .insert(photoData)\n        .select()\n        .single();\n      \n      // Guest should be able to upload their own photos\n      // (RLS policy allows users to upload photos where uploader_id = auth.uid())\n      expect(error).toBeNull();\n      expect(data).toBeDefined();\n      \n      if (data) {\n        trackEntity('photos', data.id);\n      }\n    });\n    \n    it('should prevent guest from updating photos', async () => {\n      if (authSetupFailed || !guestUser?.accessToken) {\n        console.log('⏭️  Skipping: Authentication not configured');\n        return;\n      }\n      \n      const serviceClient = createServiceClient();\n      const client = createTestClient(guestUser.accessToken);\n      \n      // Create photo using service role\n      const { data: photo } = await serviceClient\n        .from('photos')\n        .insert({\n          uploader_id: adminUser!.id,\n          photo_url: 'https://cdn.example.com/guest-update-test.jpg',\n          storage_type: 'b2',\n          page_type: 'memory',\n          moderation_status: 'approved',\n        })\n        .select()\n        .single();\n      \n      if (!photo) {\n        console.log('⏭️  Skipping: Could not create test photo');\n        return;\n      }\n      \n      trackEntity('photos', photo.id);\n      \n      // Guest should NOT be able to update photo\n      const { data, error } = await client\n        .from('photos')\n        .update({ caption: 'Guest attempted update' })\n        .eq('id', photo.id)\n        .select()\n        .single();\n      \n      // Should fail or return no data\n      expect(data === null || error !== null).toBe(true);\n    });\n    \n    it('should prevent guest from deleting photos', async () => {\n      if (authSetupFailed || !guestUser?.accessToken) {\n        console.log('⏭️  Skipping: Authentication not configured');\n        return;\n      }\n      \n      const serviceClient = createServiceClient();\n      const client = createTestClient(guestUser.accessToken);\n      \n      // Create photo using service role\n      const { data: photo } = await serviceClient\n        .from('photos')\n        .insert({\n          uploader_id: adminUser!.id,\n          photo_url: 'https://cdn.example.com/guest-delete-test.jpg',\n          storage_type: 'b2',\n          page_type: 'memory',\n          moderation_status: 'approved',\n        })\n        .select()\n        .single();\n      \n      if (!photo) {\n        console.log('⏭️  Skipping: Could not create test photo');\n        return;\n      }\n      \n      trackEntity('photos', photo.id);\n      \n      // Guest should NOT be able to delete photo\n      const { error } = await client\n        .from('photos')\n        .delete()\n        .eq('id', photo.id);\n      \n      // Should fail with error\n      expect(error).not.toBeNull();\n      \n      // Verify photo still exists\n      const { data: existingPhoto } = await serviceClient\n        .from('photos')\n        .select('*')\n        .eq('id', photo.id)\n        .single();\n      \n      expect(existingPhoto).not.toBeNull();\n    });\n  });\n  \n  describe('Photo Filtering by Page Type and ID', () => {\n    it('should filter photos by page_type and page_id', async () => {\n      if (authSetupFailed || !adminUser?.accessToken) {\n        console.log('⏭️  Skipping: Authentication not configured');\n        return;\n      }\n      \n      const serviceClient = createServiceClient();\n      const client = createTestClient(adminUser.accessToken);\n      \n      const testPageId = '123e4567-e89b-12d3-a456-426614174000';\n      \n      // Create photos with different page types and IDs\n      const photos = [\n        {\n          uploader_id: adminUser.id,\n          photo_url: 'https://cdn.example.com/event-photo.jpg',\n          storage_type: 'b2',\n          page_type: 'event',\n          page_id: testPageId,\n          moderation_status: 'approved',\n        },\n        {\n          uploader_id: adminUser.id,\n          photo_url: 'https://cdn.example.com/activity-photo.jpg',\n          storage_type: 'b2',\n          page_type: 'activity',\n          page_id: testPageId,\n          moderation_status: 'approved',\n        },\n        {\n          uploader_id: adminUser.id,\n          photo_url: 'https://cdn.example.com/memory-photo.jpg',\n          storage_type: 'b2',\n          page_type: 'memory',\n          page_id: null,\n          moderation_status: 'approved',\n        },\n      ];\n      \n      const { data: createdPhotos } = await serviceClient\n        .from('photos')\n        .insert(photos)\n        .select();\n      \n      if (createdPhotos) {\n        createdPhotos.forEach(photo => trackEntity('photos', photo.id));\n      }\n      \n      // Filter by page_type = 'event'\n      const { data: eventPhotos, error: eventError } = await client\n        .from('photos')\n        .select('*')\n        .eq('page_type', 'event')\n        .eq('page_id', testPageId);\n      \n      expect(eventError).toBeNull();\n      expect(eventPhotos).toBeDefined();\n      expect(Array.isArray(eventPhotos)).toBe(true);\n      \n      if (eventPhotos && eventPhotos.length > 0) {\n        eventPhotos.forEach(photo => {\n          expect(photo.page_type).toBe('event');\n          expect(photo.page_id).toBe(testPageId);\n        });\n      }\n      \n      // Filter by page_type = 'memory' with null page_id\n      const { data: memoryPhotos, error: memoryError } = await client\n        .from('photos')\n        .select('*')\n        .eq('page_type', 'memory')\n        .is('page_id', null);\n      \n      expect(memoryError).toBeNull();\n      expect(memoryPhotos).toBeDefined();\n      \n      if (memoryPhotos && memoryPhotos.length > 0) {\n        memoryPhotos.forEach(photo => {\n          expect(photo.page_type).toBe('memory');\n          expect(photo.page_id).toBeNull();\n        });\n      }\n    });\n  });\n  \n  describe('RLS Error Prevention', () => {\n    it('should not cause \"permission denied\" errors with real auth', async () => {\n      if (authSetupFailed || !adminUser?.accessToken) {\n        console.log('⏭️  Skipping: Authentication not configured');\n        return;\n      }\n      \n      const client = createTestClient(adminUser.accessToken);\n      \n      // Perform various operations that should not cause permission errors\n      const { error: selectError } = await client\n        .from('photos')\n        .select('*')\n        .limit(10);\n      \n      const { error: insertError } = await client\n        .from('photos')\n        .insert({\n          uploader_id: adminUser.id,\n          photo_url: 'https://cdn.example.com/permission-test.jpg',\n          storage_type: 'b2',\n          page_type: 'memory',\n          moderation_status: 'approved',\n        })\n        .select()\n        .single();\n      \n      // Should not get permission denied errors\n      expect(selectError).toBeNull();\n      expect(insertError).toBeNull();\n      \n      if (insertError === null) {\n        // Track for cleanup if insert succeeded\n        const { data } = await client\n          .from('photos')\n          .select('id')\n          .eq('photo_url', 'https://cdn.example.com/permission-test.jpg')\n          .single();\n        \n        if (data) {\n          trackEntity('photos', data.id);\n        }\n      }\n    });\n  });\n  \n  describe('Service Role Bypass', () => {\n    it('should allow service role to bypass RLS', async () => {\n      const serviceClient = createServiceClient();\n      \n      // Service role should be able to create photo without RLS restrictions\n      const { data: photo, error } = await serviceClient\n        .from('photos')\n        .insert({\n          uploader_id: adminUser!.id,\n          photo_url: 'https://cdn.example.com/service-role-test.jpg',\n          storage_type: 'b2',\n          page_type: 'memory',\n          moderation_status: 'pending',\n        })\n        .select()\n        .single();\n      \n      expect(error).toBeNull();\n      expect(photo).toBeDefined();\n      \n      if (photo) {\n        trackEntity('photos', photo.id);\n        \n        // Service role should be able to read any photo\n        const { data: readPhoto, error: readError } = await serviceClient\n          .from('photos')\n          .select('*')\n          .eq('id', photo.id)\n          .single();\n        \n        expect(readError).toBeNull();\n        expect(readPhoto).toBeDefined();\n        \n        // Service role should be able to update any photo\n        const { data: updatedPhoto, error: updateError } = await serviceClient\n          .from('photos')\n          .update({ moderation_status: 'approved' })\n          .eq('id', photo.id)\n          .select()\n          .single();\n        \n        expect(updateError).toBeNull();\n        expect(updatedPhoto).toBeDefined();\n        \n        // Service role should be able to delete any photo\n        const { error: deleteError } = await serviceClient\n          .from('photos')\n          .delete()\n          .eq('id', photo.id);\n        \n        expect(deleteError).toBeNull();\n      }\n    });\n  });\n});\n\n/**\n * TEST IMPLEMENTATION NOTES\n * \n * These tests validate RLS policies for the photos table:\n * \n * 1. **Admin Operations**: Create, read, update, delete with real auth\n * 2. **Moderation States**: Admin can read all states (pending, approved, rejected)\n * 3. **Guest Restrictions**: Guests can only read approved photos\n * 4. **Guest Limitations**: Guests cannot update or delete photos\n * 5. **Filtering**: Photos filtered by page_type and page_id\n * 6. **Error Prevention**: No \"permission denied\" errors with proper auth\n * 7. **Service Role**: Service role can bypass RLS for admin operations\n * \n * Key Testing Patterns:\n * - Uses real authentication (not service role for user operations)\n * - Tests both admin and guest user roles\n * - Verifies moderation status filtering\n * - Checks page_type and page_id filtering\n * - Validates RLS doesn't cause permission errors\n * - Confirms service role can bypass RLS\n * - Cleans up test data after execution\n * \n * What These Tests Catch:\n * - Missing RLS policies on photos table\n * - Incorrect RLS policy logic for moderation\n * - Permission denied errors with real auth\n * - Guests accessing non-approved photos\n * - Guests modifying photos they shouldn't\n * - Filtering issues with page_type/page_id\n * \n * Validates: Requirements 1.2, 1.3, 1.4\n */\n"],"names":["describe","adminUser","guestUser","authSetupFailed","createdIds","Map","trackEntity","table","id","ids","get","push","set","beforeAll","createAndSignInTestUser","email","Date","now","password","role","console","log","error","warn","Error","message","afterAll","entries","length","cleanupByIds","deleteTestUser","it","accessToken","client","createTestClient","photoData","uploader_id","photo_url","storage_type","page_type","page_id","caption","alt_text","moderation_status","display_order","data","from","insert","select","single","expect","toBeNull","toBeDefined","toBe","serviceClient","createServiceClient","photos","createdPhotos","forEach","photo","pendingPhotos","pendingError","eq","approvedPhotos","approvedError","rejectedPhotos","rejectedError","updatedPhoto","update","delete","deletedPhoto","approvedPhoto","Array","isArray","pendingPhoto","rejectedPhoto","not","existingPhoto","testPageId","eventPhotos","eventError","memoryPhotos","memoryError","is","selectError","limit","insertError","readPhoto","readError","updateError","deleteError"],"mappings":"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"}