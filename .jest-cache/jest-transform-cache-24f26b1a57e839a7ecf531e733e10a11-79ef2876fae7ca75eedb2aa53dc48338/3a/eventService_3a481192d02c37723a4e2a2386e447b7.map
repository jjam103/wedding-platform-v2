{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/services/eventService.ts"],"sourcesContent":["import { createClient } from '@supabase/supabase-js';\nimport { sanitizeInput, sanitizeRichText } from \"../utils/sanitization\";\nimport {\n  createEventSchema,\n  updateEventSchema,\n  eventFilterSchema,\n  eventSearchSchema,\n  conflictCheckSchema,\n  type CreateEventDTO,\n  type UpdateEventDTO,\n  type EventFilterDTO,\n  type EventSearchDTO,\n  type ConflictCheckDTO,\n  type Event,\n  type PaginatedEvents,\n  type SchedulingConflict,\n} from '../schemas/eventSchemas';\n\n/**\n * Result type for consistent error handling.\n */\ntype Result<T> =\n  | { success: true; data: T }\n  | { success: false; error: { code: string; message: string; details?: any } };\n\n/**\n * Converts camelCase to snake_case for database columns.\n */\nfunction toSnakeCase(obj: any): any {\n  const snakeObj: any = {};\n  for (const key in obj) {\n    const snakeKey = key.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n    snakeObj[snakeKey] = obj[key];\n  }\n  return snakeObj;\n}\n\n/**\n * Converts snake_case to camelCase for TypeScript objects.\n */\nfunction toCamelCase(obj: any): any {\n  const camelObj: any = {};\n  for (const key in obj) {\n    const camelKey = key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());\n    camelObj[camelKey] = obj[key];\n  }\n  return camelObj;\n}\n\n/**\n * Creates a new event in the system.\n *\n * @param data - Event data including name, type, dates, and location\n * @returns Result containing the created event or error details\n *\n * @example\n * const result = await eventService.create({\n *   name: 'Wedding Ceremony',\n *   eventType: 'ceremony',\n *   startDate: '2025-06-15T14:00:00Z',\n *   locationId: '123e4567-e89b-12d3-a456-426614174000',\n * });\n */\nexport async function create(data: CreateEventDTO): Promise<Result<Event>> {\n  try {\n    // 1. Validate\n    const validation = createEventSchema.safeParse(data);\n    if (!validation.success) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Validation failed',\n          details: validation.error.issues,\n        },\n      };\n    }\n\n    // 2. Sanitize user input\n    const sanitized = {\n      ...validation.data,\n      name: sanitizeInput(validation.data.name),\n      description: validation.data.description ? sanitizeRichText(validation.data.description) : null,\n    };\n\n    // 3. Check for scheduling conflicts if location is specified\n    if (sanitized.locationId) {\n      const conflictCheck = await checkSchedulingConflicts({\n        locationId: sanitized.locationId,\n        startDate: sanitized.startDate,\n        endDate: sanitized.endDate || null,\n      });\n\n      if (!conflictCheck.success) {\n        return conflictCheck as Result<Event>;\n      }\n\n      if (conflictCheck.data.hasConflict) {\n        return {\n          success: false,\n          error: {\n            code: 'SCHEDULING_CONFLICT',\n            message: 'Event conflicts with existing events at this location',\n            details: conflictCheck.data.conflictingEvents,\n          },\n        };\n      }\n    }\n\n    // 4. Database operation\n    const supabase = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!\n    );\n\n    const dbData = toSnakeCase(sanitized);\n    const { data: result, error } = await supabase\n      .from('events')\n      .insert(dbData)\n      .select()\n      .single();\n\n    if (error) {\n      return {\n        success: false,\n        error: { code: 'DATABASE_ERROR', message: error.message, details: error },\n      };\n    }\n\n    return { success: true, data: toCamelCase(result) as Event };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error',\n      },\n    };\n  }\n}\n\n/**\n * Retrieves a single event by ID.\n *\n * @param id - Event UUID\n * @returns Result containing the event or error details\n */\nexport async function get(id: string): Promise<Result<Event>> {\n  try {\n    const supabase = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!\n    );\n\n    const { data, error } = await supabase\n      .from('events')\n      .select('*')\n      .eq('id', id)\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return {\n          success: false,\n          error: { code: 'NOT_FOUND', message: 'Event not found' },\n        };\n      }\n      return {\n        success: false,\n        error: { code: 'DATABASE_ERROR', message: error.message, details: error },\n      };\n    }\n\n    return { success: true, data: toCamelCase(data) as Event };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error',\n      },\n    };\n  }\n}\n\n/**\n * Updates an existing event.\n *\n * @param id - Event UUID\n * @param data - Partial event data to update\n * @returns Result containing the updated event or error details\n */\nexport async function update(id: string, data: UpdateEventDTO): Promise<Result<Event>> {\n  try {\n    // 1. Validate\n    const validation = updateEventSchema.safeParse(data);\n    if (!validation.success) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Validation failed',\n          details: validation.error.issues,\n        },\n      };\n    }\n\n    // 2. Sanitize user input\n    const sanitized: any = { ...validation.data };\n    if (sanitized.name) {\n      sanitized.name = sanitizeInput(sanitized.name);\n    }\n    if (sanitized.description) {\n      sanitized.description = sanitizeRichText(sanitized.description);\n    }\n\n    // 3. Check for scheduling conflicts if location or dates are being updated\n    if (sanitized.locationId || sanitized.startDate || sanitized.endDate) {\n      // Get current event data to fill in missing fields\n      const currentEvent = await get(id);\n      if (!currentEvent.success) {\n        return currentEvent;\n      }\n\n      const locationId = sanitized.locationId || currentEvent.data.locationId;\n      const startDate = sanitized.startDate || currentEvent.data.startDate;\n      const endDate = sanitized.endDate !== undefined ? sanitized.endDate : currentEvent.data.endDate;\n\n      if (locationId) {\n        const conflictCheck = await checkSchedulingConflicts({\n          locationId,\n          startDate,\n          endDate,\n          excludeEventId: id,\n        });\n\n        if (!conflictCheck.success) {\n          return conflictCheck as Result<Event>;\n        }\n\n        if (conflictCheck.data.hasConflict) {\n          return {\n            success: false,\n            error: {\n              code: 'SCHEDULING_CONFLICT',\n              message: 'Event conflicts with existing events at this location',\n              details: conflictCheck.data.conflictingEvents,\n            },\n          };\n        }\n      }\n    }\n\n    // 4. Database operation\n    const supabase = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!\n    );\n\n    const dbData = toSnakeCase(sanitized);\n    const { data: result, error } = await supabase\n      .from('events')\n      .update(dbData)\n      .eq('id', id)\n      .select()\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return {\n          success: false,\n          error: { code: 'NOT_FOUND', message: 'Event not found' },\n        };\n      }\n      return {\n        success: false,\n        error: { code: 'DATABASE_ERROR', message: error.message, details: error },\n      };\n    }\n\n    return { success: true, data: toCamelCase(result) as Event };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error',\n      },\n    };\n  }\n}\n\n/**\n * Deletes an event by ID.\n * Note: Activities with event_id set to this event will have their event_id set to NULL (not deleted).\n *\n * @param id - Event UUID\n * @returns Result indicating success or error details\n */\nexport async function deleteEvent(id: string): Promise<Result<void>> {\n  try {\n    const supabase = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!\n    );\n\n    const { error } = await supabase.from('events').delete().eq('id', id);\n\n    if (error) {\n      return {\n        success: false,\n        error: { code: 'DATABASE_ERROR', message: error.message, details: error },\n      };\n    }\n\n    return { success: true, data: undefined };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error',\n      },\n    };\n  }\n}\n\n/**\n * Lists events with optional filtering and pagination.\n *\n * @param filters - Filter criteria and pagination options\n * @returns Result containing paginated events or error details\n */\nexport async function list(filters: EventFilterDTO = {}): Promise<Result<PaginatedEvents>> {\n  try {\n    // 1. Validate\n    const validation = eventFilterSchema.safeParse(filters);\n    if (!validation.success) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Validation failed',\n          details: validation.error.issues,\n        },\n      };\n    }\n\n    const { page = 1, pageSize = 50, ...filterParams } = validation.data;\n    const from = (page - 1) * pageSize;\n    const to = from + pageSize - 1;\n\n    // 2. Database operation\n    const supabase = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!\n    );\n\n    let query = supabase.from('events').select('*', { count: 'exact' });\n\n    // Apply filters\n    if (filterParams.eventType) {\n      query = query.eq('event_type', filterParams.eventType);\n    }\n    if (filterParams.status) {\n      query = query.eq('status', filterParams.status);\n    }\n    if (filterParams.locationId) {\n      query = query.eq('location_id', filterParams.locationId);\n    }\n    if (filterParams.startDateFrom) {\n      query = query.gte('start_date', filterParams.startDateFrom);\n    }\n    if (filterParams.startDateTo) {\n      query = query.lte('start_date', filterParams.startDateTo);\n    }\n\n    // Apply pagination and ordering\n    query = query.order('start_date', { ascending: true }).range(from, to);\n\n    const { data, error, count } = await query;\n\n    if (error) {\n      return {\n        success: false,\n        error: { code: 'DATABASE_ERROR', message: error.message, details: error },\n      };\n    }\n\n    const events = data.map((event) => toCamelCase(event) as Event);\n    const total = count || 0;\n    const totalPages = Math.ceil(total / pageSize);\n\n    return {\n      success: true,\n      data: {\n        events,\n        total,\n        page,\n        pageSize,\n        totalPages,\n      },\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error',\n      },\n    };\n  }\n}\n\n/**\n * Searches events by name or description.\n *\n * @param searchParams - Search query and pagination options\n * @returns Result containing paginated search results or error details\n */\nexport async function search(searchParams: EventSearchDTO): Promise<Result<PaginatedEvents>> {\n  try {\n    // 1. Validate\n    const validation = eventSearchSchema.safeParse(searchParams);\n    if (!validation.success) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Validation failed',\n          details: validation.error.issues,\n        },\n      };\n    }\n\n    const { query, page = 1, pageSize = 50 } = validation.data;\n    const from = (page - 1) * pageSize;\n    const to = from + pageSize - 1;\n\n    // 2. Sanitize search query\n    const sanitizedQuery = sanitizeInput(query);\n\n    // 3. Database operation\n    const supabase = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!\n    );\n\n    const { data, error, count } = await supabase\n      .from('events')\n      .select('*', { count: 'exact' })\n      .or(`name.ilike.%${sanitizedQuery}%,description.ilike.%${sanitizedQuery}%`)\n      .order('start_date', { ascending: true })\n      .range(from, to);\n\n    if (error) {\n      return {\n        success: false,\n        error: { code: 'DATABASE_ERROR', message: error.message, details: error },\n      };\n    }\n\n    const events = data.map((event) => toCamelCase(event) as Event);\n    const total = count || 0;\n    const totalPages = Math.ceil(total / pageSize);\n\n    return {\n      success: true,\n      data: {\n        events,\n        total,\n        page,\n        pageSize,\n        totalPages,\n      },\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error',\n      },\n    };\n  }\n}\n\n/**\n * Checks for scheduling conflicts at a specific location and time range.\n *\n * @param params - Location, date range, and optional event ID to exclude\n * @returns Result containing conflict information or error details\n */\nexport async function checkSchedulingConflicts(\n  params: ConflictCheckDTO\n): Promise<Result<SchedulingConflict>> {\n  try {\n    // 1. Validate\n    const validation = conflictCheckSchema.safeParse(params);\n    if (!validation.success) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Validation failed',\n          details: validation.error.issues,\n        },\n      };\n    }\n\n    const { locationId, startDate, endDate, excludeEventId } = validation.data;\n\n    // 2. Database operation\n    const supabase = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!\n    );\n\n    // Query for overlapping events at the same location\n    let query = supabase\n      .from('events')\n      .select('id, name, start_date, end_date')\n      .eq('location_id', locationId);\n\n    // Exclude the current event if updating\n    if (excludeEventId) {\n      query = query.neq('id', excludeEventId);\n    }\n\n    const { data, error } = await query;\n\n    if (error) {\n      return {\n        success: false,\n        error: { code: 'DATABASE_ERROR', message: error.message, details: error },\n      };\n    }\n\n    // Check for time overlaps\n    const conflictingEvents = data.filter((event) => {\n      const eventStart = new Date(event.start_date);\n      const eventEnd = event.end_date ? new Date(event.end_date) : eventStart;\n      const checkStart = new Date(startDate);\n      const checkEnd = endDate ? new Date(endDate) : checkStart;\n\n      // Two events overlap if:\n      // (StartA <= EndB) and (EndA >= StartB)\n      return eventStart <= checkEnd && eventEnd >= checkStart;\n    });\n\n    return {\n      success: true,\n      data: {\n        hasConflict: conflictingEvents.length > 0,\n        conflictingEvents: conflictingEvents.map((event) => ({\n          id: event.id,\n          name: event.name,\n          startDate: event.start_date,\n          endDate: event.end_date,\n        })),\n      },\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error',\n      },\n    };\n  }\n}\n"],"names":["checkSchedulingConflicts","create","deleteEvent","get","list","search","update","toSnakeCase","obj","snakeObj","key","snakeKey","replace","letter","toLowerCase","toCamelCase","camelObj","camelKey","_","toUpperCase","data","validation","createEventSchema","safeParse","success","error","code","message","details","issues","sanitized","name","sanitizeInput","description","sanitizeRichText","locationId","conflictCheck","startDate","endDate","hasConflict","conflictingEvents","supabase","createClient","process","env","NEXT_PUBLIC_SUPABASE_URL","SUPABASE_SERVICE_ROLE_KEY","dbData","result","from","insert","select","single","Error","id","eq","updateEventSchema","currentEvent","undefined","excludeEventId","delete","filters","eventFilterSchema","page","pageSize","filterParams","to","query","count","eventType","status","startDateFrom","gte","startDateTo","lte","order","ascending","range","events","map","event","total","totalPages","Math","ceil","searchParams","eventSearchSchema","sanitizedQuery","or","params","conflictCheckSchema","neq","filter","eventStart","Date","start_date","eventEnd","end_date","checkStart","checkEnd","length"],"mappings":"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"}