{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/services/eventService.slugPreservation.property.test.ts"],"sourcesContent":["/**\n * Property-Based Tests for Event Service Slug Preservation\n * \n * **Property 25: Slug Preservation on Update**\n * **Validates: Requirements 24.7**\n * \n * Tests that slugs are preserved when updating event names and not regenerated automatically.\n */\n\nimport * as fc from 'fast-check';\nimport { create, update, deleteEvent } from './eventService';\n\ndescribe('Feature: guest-portal-and-admin-enhancements, Property 25: Slug Preservation on Update', () => {\n  // Clean up test events after each test\n  const createdEventIds: string[] = [];\n\n  afterEach(async () => {\n    // Clean up all created events\n    for (const id of createdEventIds) {\n      await deleteEvent(id);\n    }\n    createdEventIds.length = 0;\n  });\n\n  /**\n   * Property: Updating event name does not change the slug\n   * \n   * When an event's name is updated, the slug should remain unchanged\n   * to preserve existing URLs and references.\n   */\n  it('should preserve slug when updating event name', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.string({ minLength: 3, maxLength: 30 }).filter(s => /[a-zA-Z0-9]/.test(s)),\n        fc.string({ minLength: 3, maxLength: 30 }).filter(s => /[a-zA-Z0-9]/.test(s)),\n        fc.date(),\n        async (originalName, newName, startDate) => {\n          // Skip if names are the same\n          if (originalName === newName) {\n            return true;\n          }\n\n          // Create event with original name\n          const createResult = await create({\n            name: originalName,\n            eventType: 'ceremony',\n            startDate: startDate.toISOString(),\n          });\n\n          if (!createResult.success) {\n            return true;\n          }\n\n          createdEventIds.push(createResult.data.id);\n          const originalSlug = createResult.data.slug;\n\n          // Update event name\n          const updateResult = await update(createResult.data.id, {\n            name: newName,\n          });\n\n          if (!updateResult.success) {\n            return true;\n          }\n\n          // Slug should remain unchanged\n          expect(updateResult.data.slug).toBe(originalSlug);\n          expect(updateResult.data.name).toBe(newName);\n\n          return true;\n        }\n      ),\n      { numRuns: 50 }\n    );\n  });\n\n  /**\n   * Property: Multiple updates preserve the original slug\n   */\n  it('should preserve slug across multiple name updates', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.string({ minLength: 3, maxLength: 20 }).filter(s => /[a-zA-Z0-9]/.test(s)),\n        fc.array(fc.string({ minLength: 3, maxLength: 20 }).filter(s => /[a-zA-Z0-9]/.test(s)), { minLength: 2, maxLength: 5 }),\n        fc.date(),\n        async (originalName, newNames, startDate) => {\n          // Create event\n          const createResult = await create({\n            name: originalName,\n            eventType: 'reception',\n            startDate: startDate.toISOString(),\n          });\n\n          if (!createResult.success) {\n            return true;\n          }\n\n          createdEventIds.push(createResult.data.id);\n          const originalSlug = createResult.data.slug;\n\n          // Update name multiple times\n          for (const newName of newNames) {\n            const updateResult = await update(createResult.data.id, {\n              name: newName,\n            });\n\n            if (!updateResult.success) {\n              continue;\n            }\n\n            // Slug should always remain the original\n            expect(updateResult.data.slug).toBe(originalSlug);\n          }\n\n          return true;\n        }\n      ),\n      { numRuns: 20 }\n    );\n  });\n\n  /**\n   * Property: Updating other fields does not affect slug\n   */\n  it('should preserve slug when updating non-name fields', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.string({ minLength: 3, maxLength: 30 }).filter(s => /[a-zA-Z0-9]/.test(s)),\n        fc.string({ minLength: 10, maxLength: 100 }),\n        fc.date(),\n        fc.date(),\n        async (name, description, startDate, newStartDate) => {\n          // Create event\n          const createResult = await create({\n            name,\n            eventType: 'meal',\n            startDate: startDate.toISOString(),\n            description,\n          });\n\n          if (!createResult.success) {\n            return true;\n          }\n\n          createdEventIds.push(createResult.data.id);\n          const originalSlug = createResult.data.slug;\n\n          // Update description and start date\n          const updateResult = await update(createResult.data.id, {\n            description: `${description} - Updated`,\n            startDate: newStartDate.toISOString(),\n          });\n\n          if (!updateResult.success) {\n            return true;\n          }\n\n          // Slug should remain unchanged\n          expect(updateResult.data.slug).toBe(originalSlug);\n\n          return true;\n        }\n      ),\n      { numRuns: 30 }\n    );\n  });\n\n  /**\n   * Property: Slug preservation works with special characters in new names\n   */\n  it('should preserve slug even when new name contains special characters', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.string({ minLength: 3, maxLength: 20 }).filter(s => /[a-zA-Z0-9]/.test(s)),\n        fc.string({ minLength: 3, maxLength: 20 }).filter(s => /[a-zA-Z0-9]/.test(s)),\n        fc.constantFrom('!', '@', '#', '$', '%', '&', '*'),\n        fc.date(),\n        async (originalName, baseName, specialChar, startDate) => {\n          // Create event\n          const createResult = await create({\n            name: originalName,\n            eventType: 'activity',\n            startDate: startDate.toISOString(),\n          });\n\n          if (!createResult.success) {\n            return true;\n          }\n\n          createdEventIds.push(createResult.data.id);\n          const originalSlug = createResult.data.slug;\n\n          // Update with name containing special characters\n          const newName = `${baseName}${specialChar}${baseName}`;\n          const updateResult = await update(createResult.data.id, {\n            name: newName,\n          });\n\n          if (!updateResult.success) {\n            return true;\n          }\n\n          // Slug should remain unchanged despite special characters in new name\n          expect(updateResult.data.slug).toBe(originalSlug);\n          expect(updateResult.data.name).toBe(newName);\n\n          return true;\n        }\n      ),\n      { numRuns: 25 }\n    );\n  });\n\n  /**\n   * Property: Slug preservation is idempotent\n   */\n  it('should maintain slug consistency across repeated updates', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.string({ minLength: 3, maxLength: 20 }).filter(s => /[a-zA-Z0-9]/.test(s)),\n        fc.string({ minLength: 3, maxLength: 20 }).filter(s => /[a-zA-Z0-9]/.test(s)),\n        fc.date(),\n        async (originalName, newName, startDate) => {\n          // Create event\n          const createResult = await create({\n            name: originalName,\n            eventType: 'transport',\n            startDate: startDate.toISOString(),\n          });\n\n          if (!createResult.success) {\n            return true;\n          }\n\n          createdEventIds.push(createResult.data.id);\n          const originalSlug = createResult.data.slug;\n\n          // Update name back and forth multiple times\n          for (let i = 0; i < 3; i++) {\n            // Update to new name\n            const update1 = await update(createResult.data.id, { name: newName });\n            if (update1.success) {\n              expect(update1.data.slug).toBe(originalSlug);\n            }\n\n            // Update back to original name\n            const update2 = await update(createResult.data.id, { name: originalName });\n            if (update2.success) {\n              expect(update2.data.slug).toBe(originalSlug);\n            }\n          }\n\n          return true;\n        }\n      ),\n      { numRuns: 15 }\n    );\n  });\n});\n"],"names":["describe","createdEventIds","afterEach","id","deleteEvent","length","it","fc","assert","asyncProperty","string","minLength","maxLength","filter","s","test","date","originalName","newName","startDate","createResult","create","name","eventType","toISOString","success","push","data","originalSlug","slug","updateResult","update","expect","toBe","numRuns","array","newNames","description","newStartDate","constantFrom","baseName","specialChar","i","update1","update2"],"mappings":"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"}