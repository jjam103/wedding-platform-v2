794ebaaa44cd1521d5dcd8bb59049f69
/**
 * Performance Tests for Inline RSVP System
 * 
 * Tests performance requirements:
 * - Rendering time for 500 guests < 2 seconds
 * - RSVP section expansion time < 500ms
 * - Save operation time < 1 second
 * - Debounced input delay = 500ms
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _perf_hooks = require("perf_hooks");
describe('Inline RSVP Performance Tests', ()=>{
    describe('Guest List Rendering Performance', ()=>{
        it('should render 500 guests in under 2 seconds', ()=>{
            // Generate 500 mock guests
            const guests = Array.from({
                length: 500
            }, (_, i)=>({
                    id: `guest-${i}`,
                    firstName: `First${i}`,
                    lastName: `Last${i}`,
                    email: `guest${i}@example.com`,
                    groupId: `group-${i % 10}`,
                    ageType: 'adult',
                    guestType: 'wedding_guest',
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                }));
            const startTime = _perf_hooks.performance.now();
            // Simulate rendering logic (data processing)
            const processedGuests = guests.map((guest)=>({
                    ...guest,
                    fullName: `${guest.firstName} ${guest.lastName}`,
                    groupName: `Group ${guest.groupId}`
                }));
            const endTime = _perf_hooks.performance.now();
            const renderTime = endTime - startTime;
            // Should process 500 guests in under 2 seconds (2000ms)
            expect(renderTime).toBeLessThan(2000);
            expect(processedGuests).toHaveLength(500);
        });
        it('should handle pagination efficiently with 50 guests per page', ()=>{
            const totalGuests = 500;
            const pageSize = 50;
            const guests = Array.from({
                length: totalGuests
            }, (_, i)=>({
                    id: `guest-${i}`,
                    firstName: `First${i}`,
                    lastName: `Last${i}`
                }));
            const startTime = _perf_hooks.performance.now();
            // Simulate pagination
            const page = 1;
            const from = (page - 1) * pageSize;
            const to = from + pageSize;
            const paginatedGuests = guests.slice(from, to);
            const endTime = _perf_hooks.performance.now();
            const paginationTime = endTime - startTime;
            // Pagination should be instant (< 10ms)
            expect(paginationTime).toBeLessThan(10);
            expect(paginatedGuests).toHaveLength(50);
        });
    });
    describe('RSVP Section Expansion Performance', ()=>{
        it('should expand RSVP section in under 500ms', async ()=>{
            // Mock RSVP data for a guest
            const mockRSVPData = {
                activities: Array.from({
                    length: 20
                }, (_, i)=>({
                        id: `activity-${i}`,
                        name: `Activity ${i}`,
                        type: 'activity',
                        status: 'pending',
                        capacity: 100,
                        capacityRemaining: 50
                    })),
                events: Array.from({
                    length: 5
                }, (_, i)=>({
                        id: `event-${i}`,
                        name: `Event ${i}`,
                        type: 'event',
                        status: 'pending'
                    })),
                accommodations: Array.from({
                    length: 3
                }, (_, i)=>({
                        id: `accommodation-${i}`,
                        name: `Accommodation ${i}`,
                        type: 'accommodation',
                        status: 'pending'
                    }))
            };
            const startTime = _perf_hooks.performance.now();
            // Simulate data processing for expansion
            const processedData = {
                activities: mockRSVPData.activities.map((a)=>({
                        ...a,
                        capacityPercentage: a.capacityRemaining ? a.capacityRemaining / a.capacity * 100 : 0
                    })),
                events: mockRSVPData.events,
                accommodations: mockRSVPData.accommodations
            };
            const endTime = _perf_hooks.performance.now();
            const expansionTime = endTime - startTime;
            // Expansion should be fast (< 500ms)
            expect(expansionTime).toBeLessThan(500);
            expect(processedData.activities).toHaveLength(20);
        });
        it('should handle multiple concurrent expansions efficiently', async ()=>{
            const guestCount = 10;
            const startTime = _perf_hooks.performance.now();
            // Simulate expanding multiple RSVP sections concurrently
            const expansions = Array.from({
                length: guestCount
            }, async (_, i)=>{
                return {
                    guestId: `guest-${i}`,
                    rsvps: Array.from({
                        length: 10
                    }, (_, j)=>({
                            id: `rsvp-${i}-${j}`,
                            status: 'pending'
                        }))
                };
            });
            await Promise.all(expansions);
            const endTime = _perf_hooks.performance.now();
            const totalTime = endTime - startTime;
            // Should handle 10 concurrent expansions in under 1 second
            expect(totalTime).toBeLessThan(1000);
        });
    });
    describe('RSVP Save Operation Performance', ()=>{
        it('should complete save operation in under 1 second', async ()=>{
            const mockRSVP = {
                id: 'rsvp-1',
                guestId: 'guest-1',
                activityId: 'activity-1',
                status: 'attending'
            };
            const startTime = _perf_hooks.performance.now();
            // Simulate save operation (data validation and processing)
            const validatedData = {
                ...mockRSVP,
                updatedAt: new Date().toISOString()
            };
            // Simulate network delay (typical API response time)
            await new Promise((resolve)=>setTimeout(resolve, 100));
            const endTime = _perf_hooks.performance.now();
            const saveTime = endTime - startTime;
            // Save should complete in under 1 second (including network delay)
            expect(saveTime).toBeLessThan(1000);
            expect(validatedData.status).toBe('attending');
        });
        it('should handle optimistic UI updates instantly', ()=>{
            const currentStatus = 'pending';
            const newStatus = 'attending';
            const startTime = _perf_hooks.performance.now();
            // Simulate optimistic update
            const optimisticState = {
                status: newStatus,
                isOptimistic: true
            };
            const endTime = _perf_hooks.performance.now();
            const updateTime = endTime - startTime;
            // Optimistic update should be instant (< 1ms)
            expect(updateTime).toBeLessThan(1);
            expect(optimisticState.status).toBe('attending');
        });
        it('should rollback failed saves efficiently', ()=>{
            const originalStatus = 'pending';
            const attemptedStatus = 'attending';
            const startTime = _perf_hooks.performance.now();
            // Simulate rollback
            const rolledBackState = {
                status: originalStatus,
                error: 'Save failed'
            };
            const endTime = _perf_hooks.performance.now();
            const rollbackTime = endTime - startTime;
            // Rollback should be instant (< 1ms)
            expect(rollbackTime).toBeLessThan(1);
            expect(rolledBackState.status).toBe('pending');
        });
    });
    describe('Debounced Input Performance', ()=>{
        it('should debounce text input with 500ms delay', async ()=>{
            let callCount = 0;
            const debouncedFunction = ()=>{
                callCount++;
            };
            // Simulate rapid typing (10 keystrokes in 100ms)
            const startTime = _perf_hooks.performance.now();
            for(let i = 0; i < 10; i++){
                // In real implementation, only the last call after 500ms would execute
                if (i === 9) {
                    debouncedFunction();
                }
            }
            const endTime = _perf_hooks.performance.now();
            // Typing should be instant
            expect(endTime - startTime).toBeLessThan(100);
            // Only one call should be made (the debounced one)
            expect(callCount).toBe(1);
        });
        it('should not block UI during debounce period', ()=>{
            const inputValues = [];
            const startTime = _perf_hooks.performance.now();
            // Simulate rapid input changes
            for(let i = 0; i < 100; i++){
                inputValues.push(`value-${i}`);
            }
            const endTime = _perf_hooks.performance.now();
            const processingTime = endTime - startTime;
            // Processing 100 input changes should be fast (< 10ms)
            expect(processingTime).toBeLessThan(10);
            expect(inputValues).toHaveLength(100);
        });
    });
    describe('Memory Performance', ()=>{
        it('should not leak memory when expanding/collapsing sections', ()=>{
            const initialMemory = process.memoryUsage().heapUsed;
            // Simulate multiple expand/collapse cycles
            const expandedSections = new Set();
            for(let i = 0; i < 100; i++){
                const guestId = `guest-${i}`;
                expandedSections.add(guestId);
                expandedSections.delete(guestId);
            }
            const finalMemory = process.memoryUsage().heapUsed;
            const memoryIncrease = finalMemory - initialMemory;
            // Memory increase should be minimal (< 1MB)
            expect(memoryIncrease).toBeLessThan(1024 * 1024);
        });
        it('should efficiently manage large RSVP datasets', ()=>{
            const initialMemory = process.memoryUsage().heapUsed;
            // Create large dataset
            const rsvps = Array.from({
                length: 1000
            }, (_, i)=>({
                    id: `rsvp-${i}`,
                    guestId: `guest-${i % 100}`,
                    activityId: `activity-${i % 50}`,
                    status: 'pending'
                }));
            // Filter and process data
            const attendingRSVPs = rsvps.filter((r)=>r.status === 'pending');
            const groupedByGuest = attendingRSVPs.reduce((acc, rsvp)=>{
                if (!acc[rsvp.guestId]) {
                    acc[rsvp.guestId] = [];
                }
                acc[rsvp.guestId].push(rsvp);
                return acc;
            }, {});
            const finalMemory = process.memoryUsage().heapUsed;
            const memoryIncrease = finalMemory - initialMemory;
            // Memory increase should be reasonable (< 5MB for 1000 RSVPs)
            expect(memoryIncrease).toBeLessThan(5 * 1024 * 1024);
            expect(Object.keys(groupedByGuest).length).toBeGreaterThan(0);
        });
    });
    describe('Capacity Validation Performance', ()=>{
        it('should validate capacity constraints quickly', ()=>{
            const activity = {
                id: 'activity-1',
                capacity: 100,
                capacityRemaining: 10
            };
            const startTime = _perf_hooks.performance.now();
            // Validate capacity
            const canAttend = activity.capacityRemaining > 0;
            const isNearlyFull = activity.capacityRemaining / activity.capacity < 0.1;
            const warningMessage = isNearlyFull ? 'Nearly full' : null;
            const endTime = _perf_hooks.performance.now();
            const validationTime = endTime - startTime;
            // Validation should be instant (< 1ms)
            expect(validationTime).toBeLessThan(1);
            expect(canAttend).toBe(true);
            expect(isNearlyFull).toBe(true);
            expect(warningMessage).toBe('Nearly full');
        });
        it('should handle batch capacity checks efficiently', ()=>{
            const activities = Array.from({
                length: 100
            }, (_, i)=>({
                    id: `activity-${i}`,
                    capacity: 100,
                    capacityRemaining: i % 10
                }));
            const startTime = _perf_hooks.performance.now();
            // Batch validate
            const validationResults = activities.map((activity)=>({
                    id: activity.id,
                    canAttend: activity.capacityRemaining > 0,
                    isNearlyFull: activity.capacityRemaining / activity.capacity < 0.1
                }));
            const endTime = _perf_hooks.performance.now();
            const batchValidationTime = endTime - startTime;
            // Batch validation should be fast (< 10ms for 100 activities)
            expect(batchValidationTime).toBeLessThan(10);
            expect(validationResults).toHaveLength(100);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvX190ZXN0c19fL3BlcmZvcm1hbmNlL2lubGluZVJTVlAucGVyZm9ybWFuY2UudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBlcmZvcm1hbmNlIFRlc3RzIGZvciBJbmxpbmUgUlNWUCBTeXN0ZW1cbiAqIFxuICogVGVzdHMgcGVyZm9ybWFuY2UgcmVxdWlyZW1lbnRzOlxuICogLSBSZW5kZXJpbmcgdGltZSBmb3IgNTAwIGd1ZXN0cyA8IDIgc2Vjb25kc1xuICogLSBSU1ZQIHNlY3Rpb24gZXhwYW5zaW9uIHRpbWUgPCA1MDBtc1xuICogLSBTYXZlIG9wZXJhdGlvbiB0aW1lIDwgMSBzZWNvbmRcbiAqIC0gRGVib3VuY2VkIGlucHV0IGRlbGF5ID0gNTAwbXNcbiAqL1xuXG5pbXBvcnQgeyBwZXJmb3JtYW5jZSB9IGZyb20gJ3BlcmZfaG9va3MnO1xuXG5kZXNjcmliZSgnSW5saW5lIFJTVlAgUGVyZm9ybWFuY2UgVGVzdHMnLCAoKSA9PiB7XG4gIGRlc2NyaWJlKCdHdWVzdCBMaXN0IFJlbmRlcmluZyBQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJlbmRlciA1MDAgZ3Vlc3RzIGluIHVuZGVyIDIgc2Vjb25kcycsICgpID0+IHtcbiAgICAgIC8vIEdlbmVyYXRlIDUwMCBtb2NrIGd1ZXN0c1xuICAgICAgY29uc3QgZ3Vlc3RzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogNTAwIH0sIChfLCBpKSA9PiAoe1xuICAgICAgICBpZDogYGd1ZXN0LSR7aX1gLFxuICAgICAgICBmaXJzdE5hbWU6IGBGaXJzdCR7aX1gLFxuICAgICAgICBsYXN0TmFtZTogYExhc3Qke2l9YCxcbiAgICAgICAgZW1haWw6IGBndWVzdCR7aX1AZXhhbXBsZS5jb21gLFxuICAgICAgICBncm91cElkOiBgZ3JvdXAtJHtpICUgMTB9YCxcbiAgICAgICAgYWdlVHlwZTogJ2FkdWx0JyBhcyBjb25zdCxcbiAgICAgICAgZ3Vlc3RUeXBlOiAnd2VkZGluZ19ndWVzdCcgYXMgY29uc3QsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH0pKTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIHJlbmRlcmluZyBsb2dpYyAoZGF0YSBwcm9jZXNzaW5nKVxuICAgICAgY29uc3QgcHJvY2Vzc2VkR3Vlc3RzID0gZ3Vlc3RzLm1hcChndWVzdCA9PiAoe1xuICAgICAgICAuLi5ndWVzdCxcbiAgICAgICAgZnVsbE5hbWU6IGAke2d1ZXN0LmZpcnN0TmFtZX0gJHtndWVzdC5sYXN0TmFtZX1gLFxuICAgICAgICBncm91cE5hbWU6IGBHcm91cCAke2d1ZXN0Lmdyb3VwSWR9YCxcbiAgICAgIH0pKTtcblxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgcmVuZGVyVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG5cbiAgICAgIC8vIFNob3VsZCBwcm9jZXNzIDUwMCBndWVzdHMgaW4gdW5kZXIgMiBzZWNvbmRzICgyMDAwbXMpXG4gICAgICBleHBlY3QocmVuZGVyVGltZSkudG9CZUxlc3NUaGFuKDIwMDApO1xuICAgICAgZXhwZWN0KHByb2Nlc3NlZEd1ZXN0cykudG9IYXZlTGVuZ3RoKDUwMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBwYWdpbmF0aW9uIGVmZmljaWVudGx5IHdpdGggNTAgZ3Vlc3RzIHBlciBwYWdlJywgKCkgPT4ge1xuICAgICAgY29uc3QgdG90YWxHdWVzdHMgPSA1MDA7XG4gICAgICBjb25zdCBwYWdlU2l6ZSA9IDUwO1xuICAgICAgY29uc3QgZ3Vlc3RzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdG90YWxHdWVzdHMgfSwgKF8sIGkpID0+ICh7XG4gICAgICAgIGlkOiBgZ3Vlc3QtJHtpfWAsXG4gICAgICAgIGZpcnN0TmFtZTogYEZpcnN0JHtpfWAsXG4gICAgICAgIGxhc3ROYW1lOiBgTGFzdCR7aX1gLFxuICAgICAgfSkpO1xuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgLy8gU2ltdWxhdGUgcGFnaW5hdGlvblxuICAgICAgY29uc3QgcGFnZSA9IDE7XG4gICAgICBjb25zdCBmcm9tID0gKHBhZ2UgLSAxKSAqIHBhZ2VTaXplO1xuICAgICAgY29uc3QgdG8gPSBmcm9tICsgcGFnZVNpemU7XG4gICAgICBjb25zdCBwYWdpbmF0ZWRHdWVzdHMgPSBndWVzdHMuc2xpY2UoZnJvbSwgdG8pO1xuXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBwYWdpbmF0aW9uVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG5cbiAgICAgIC8vIFBhZ2luYXRpb24gc2hvdWxkIGJlIGluc3RhbnQgKDwgMTBtcylcbiAgICAgIGV4cGVjdChwYWdpbmF0aW9uVGltZSkudG9CZUxlc3NUaGFuKDEwKTtcbiAgICAgIGV4cGVjdChwYWdpbmF0ZWRHdWVzdHMpLnRvSGF2ZUxlbmd0aCg1MCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSU1ZQIFNlY3Rpb24gRXhwYW5zaW9uIFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZXhwYW5kIFJTVlAgc2VjdGlvbiBpbiB1bmRlciA1MDBtcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgUlNWUCBkYXRhIGZvciBhIGd1ZXN0XG4gICAgICBjb25zdCBtb2NrUlNWUERhdGEgPSB7XG4gICAgICAgIGFjdGl2aXRpZXM6IEFycmF5LmZyb20oeyBsZW5ndGg6IDIwIH0sIChfLCBpKSA9PiAoe1xuICAgICAgICAgIGlkOiBgYWN0aXZpdHktJHtpfWAsXG4gICAgICAgICAgbmFtZTogYEFjdGl2aXR5ICR7aX1gLFxuICAgICAgICAgIHR5cGU6ICdhY3Rpdml0eScgYXMgY29uc3QsXG4gICAgICAgICAgc3RhdHVzOiAncGVuZGluZycgYXMgY29uc3QsXG4gICAgICAgICAgY2FwYWNpdHk6IDEwMCxcbiAgICAgICAgICBjYXBhY2l0eVJlbWFpbmluZzogNTAsXG4gICAgICAgIH0pKSxcbiAgICAgICAgZXZlbnRzOiBBcnJheS5mcm9tKHsgbGVuZ3RoOiA1IH0sIChfLCBpKSA9PiAoe1xuICAgICAgICAgIGlkOiBgZXZlbnQtJHtpfWAsXG4gICAgICAgICAgbmFtZTogYEV2ZW50ICR7aX1gLFxuICAgICAgICAgIHR5cGU6ICdldmVudCcgYXMgY29uc3QsXG4gICAgICAgICAgc3RhdHVzOiAncGVuZGluZycgYXMgY29uc3QsXG4gICAgICAgIH0pKSxcbiAgICAgICAgYWNjb21tb2RhdGlvbnM6IEFycmF5LmZyb20oeyBsZW5ndGg6IDMgfSwgKF8sIGkpID0+ICh7XG4gICAgICAgICAgaWQ6IGBhY2NvbW1vZGF0aW9uLSR7aX1gLFxuICAgICAgICAgIG5hbWU6IGBBY2NvbW1vZGF0aW9uICR7aX1gLFxuICAgICAgICAgIHR5cGU6ICdhY2NvbW1vZGF0aW9uJyBhcyBjb25zdCxcbiAgICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyBhcyBjb25zdCxcbiAgICAgICAgfSkpLFxuICAgICAgfTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIGRhdGEgcHJvY2Vzc2luZyBmb3IgZXhwYW5zaW9uXG4gICAgICBjb25zdCBwcm9jZXNzZWREYXRhID0ge1xuICAgICAgICBhY3Rpdml0aWVzOiBtb2NrUlNWUERhdGEuYWN0aXZpdGllcy5tYXAoYSA9PiAoe1xuICAgICAgICAgIC4uLmEsXG4gICAgICAgICAgY2FwYWNpdHlQZXJjZW50YWdlOiBhLmNhcGFjaXR5UmVtYWluaW5nID8gKGEuY2FwYWNpdHlSZW1haW5pbmcgLyBhLmNhcGFjaXR5KSAqIDEwMCA6IDAsXG4gICAgICAgIH0pKSxcbiAgICAgICAgZXZlbnRzOiBtb2NrUlNWUERhdGEuZXZlbnRzLFxuICAgICAgICBhY2NvbW1vZGF0aW9uczogbW9ja1JTVlBEYXRhLmFjY29tbW9kYXRpb25zLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgZXhwYW5zaW9uVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG5cbiAgICAgIC8vIEV4cGFuc2lvbiBzaG91bGQgYmUgZmFzdCAoPCA1MDBtcylcbiAgICAgIGV4cGVjdChleHBhbnNpb25UaW1lKS50b0JlTGVzc1RoYW4oNTAwKTtcbiAgICAgIGV4cGVjdChwcm9jZXNzZWREYXRhLmFjdGl2aXRpZXMpLnRvSGF2ZUxlbmd0aCgyMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtdWx0aXBsZSBjb25jdXJyZW50IGV4cGFuc2lvbnMgZWZmaWNpZW50bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBndWVzdENvdW50ID0gMTA7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgLy8gU2ltdWxhdGUgZXhwYW5kaW5nIG11bHRpcGxlIFJTVlAgc2VjdGlvbnMgY29uY3VycmVudGx5XG4gICAgICBjb25zdCBleHBhbnNpb25zID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogZ3Vlc3RDb3VudCB9LCBhc3luYyAoXywgaSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGd1ZXN0SWQ6IGBndWVzdC0ke2l9YCxcbiAgICAgICAgICByc3ZwczogQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAgfSwgKF8sIGopID0+ICh7XG4gICAgICAgICAgICBpZDogYHJzdnAtJHtpfS0ke2p9YCxcbiAgICAgICAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgICAgIH0pKSxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChleHBhbnNpb25zKTtcblxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgdG90YWxUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcblxuICAgICAgLy8gU2hvdWxkIGhhbmRsZSAxMCBjb25jdXJyZW50IGV4cGFuc2lvbnMgaW4gdW5kZXIgMSBzZWNvbmRcbiAgICAgIGV4cGVjdCh0b3RhbFRpbWUpLnRvQmVMZXNzVGhhbigxMDAwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JTVlAgU2F2ZSBPcGVyYXRpb24gUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjb21wbGV0ZSBzYXZlIG9wZXJhdGlvbiBpbiB1bmRlciAxIHNlY29uZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tSU1ZQID0ge1xuICAgICAgICBpZDogJ3JzdnAtMScsXG4gICAgICAgIGd1ZXN0SWQ6ICdndWVzdC0xJyxcbiAgICAgICAgYWN0aXZpdHlJZDogJ2FjdGl2aXR5LTEnLFxuICAgICAgICBzdGF0dXM6ICdhdHRlbmRpbmcnIGFzIGNvbnN0LFxuICAgICAgfTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIHNhdmUgb3BlcmF0aW9uIChkYXRhIHZhbGlkYXRpb24gYW5kIHByb2Nlc3NpbmcpXG4gICAgICBjb25zdCB2YWxpZGF0ZWREYXRhID0ge1xuICAgICAgICAuLi5tb2NrUlNWUCxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9O1xuXG4gICAgICAvLyBTaW11bGF0ZSBuZXR3b3JrIGRlbGF5ICh0eXBpY2FsIEFQSSByZXNwb25zZSB0aW1lKVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xuXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBzYXZlVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG5cbiAgICAgIC8vIFNhdmUgc2hvdWxkIGNvbXBsZXRlIGluIHVuZGVyIDEgc2Vjb25kIChpbmNsdWRpbmcgbmV0d29yayBkZWxheSlcbiAgICAgIGV4cGVjdChzYXZlVGltZSkudG9CZUxlc3NUaGFuKDEwMDApO1xuICAgICAgZXhwZWN0KHZhbGlkYXRlZERhdGEuc3RhdHVzKS50b0JlKCdhdHRlbmRpbmcnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG9wdGltaXN0aWMgVUkgdXBkYXRlcyBpbnN0YW50bHknLCAoKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50U3RhdHVzID0gJ3BlbmRpbmcnO1xuICAgICAgY29uc3QgbmV3U3RhdHVzID0gJ2F0dGVuZGluZyc7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBvcHRpbWlzdGljIHVwZGF0ZVxuICAgICAgY29uc3Qgb3B0aW1pc3RpY1N0YXRlID0ge1xuICAgICAgICBzdGF0dXM6IG5ld1N0YXR1cyxcbiAgICAgICAgaXNPcHRpbWlzdGljOiB0cnVlLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgdXBkYXRlVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG5cbiAgICAgIC8vIE9wdGltaXN0aWMgdXBkYXRlIHNob3VsZCBiZSBpbnN0YW50ICg8IDFtcylcbiAgICAgIGV4cGVjdCh1cGRhdGVUaW1lKS50b0JlTGVzc1RoYW4oMSk7XG4gICAgICBleHBlY3Qob3B0aW1pc3RpY1N0YXRlLnN0YXR1cykudG9CZSgnYXR0ZW5kaW5nJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJvbGxiYWNrIGZhaWxlZCBzYXZlcyBlZmZpY2llbnRseScsICgpID0+IHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsU3RhdHVzID0gJ3BlbmRpbmcnO1xuICAgICAgY29uc3QgYXR0ZW1wdGVkU3RhdHVzID0gJ2F0dGVuZGluZyc7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAvLyBTaW11bGF0ZSByb2xsYmFja1xuICAgICAgY29uc3Qgcm9sbGVkQmFja1N0YXRlID0ge1xuICAgICAgICBzdGF0dXM6IG9yaWdpbmFsU3RhdHVzLFxuICAgICAgICBlcnJvcjogJ1NhdmUgZmFpbGVkJyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHJvbGxiYWNrVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG5cbiAgICAgIC8vIFJvbGxiYWNrIHNob3VsZCBiZSBpbnN0YW50ICg8IDFtcylcbiAgICAgIGV4cGVjdChyb2xsYmFja1RpbWUpLnRvQmVMZXNzVGhhbigxKTtcbiAgICAgIGV4cGVjdChyb2xsZWRCYWNrU3RhdGUuc3RhdHVzKS50b0JlKCdwZW5kaW5nJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdEZWJvdW5jZWQgSW5wdXQgUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBkZWJvdW5jZSB0ZXh0IGlucHV0IHdpdGggNTAwbXMgZGVsYXknLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgY2FsbENvdW50ID0gMDtcbiAgICAgIGNvbnN0IGRlYm91bmNlZEZ1bmN0aW9uID0gKCkgPT4ge1xuICAgICAgICBjYWxsQ291bnQrKztcbiAgICAgIH07XG5cbiAgICAgIC8vIFNpbXVsYXRlIHJhcGlkIHR5cGluZyAoMTAga2V5c3Ryb2tlcyBpbiAxMDBtcylcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIC8vIEluIHJlYWwgaW1wbGVtZW50YXRpb24sIG9ubHkgdGhlIGxhc3QgY2FsbCBhZnRlciA1MDBtcyB3b3VsZCBleGVjdXRlXG4gICAgICAgIGlmIChpID09PSA5KSB7XG4gICAgICAgICAgZGVib3VuY2VkRnVuY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAvLyBUeXBpbmcgc2hvdWxkIGJlIGluc3RhbnRcbiAgICAgIGV4cGVjdChlbmRUaW1lIC0gc3RhcnRUaW1lKS50b0JlTGVzc1RoYW4oMTAwKTtcbiAgICAgIFxuICAgICAgLy8gT25seSBvbmUgY2FsbCBzaG91bGQgYmUgbWFkZSAodGhlIGRlYm91bmNlZCBvbmUpXG4gICAgICBleHBlY3QoY2FsbENvdW50KS50b0JlKDEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBub3QgYmxvY2sgVUkgZHVyaW5nIGRlYm91bmNlIHBlcmlvZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGlucHV0VmFsdWVzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgLy8gU2ltdWxhdGUgcmFwaWQgaW5wdXQgY2hhbmdlc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgICAgICBpbnB1dFZhbHVlcy5wdXNoKGB2YWx1ZS0ke2l9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHByb2Nlc3NpbmdUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcblxuICAgICAgLy8gUHJvY2Vzc2luZyAxMDAgaW5wdXQgY2hhbmdlcyBzaG91bGQgYmUgZmFzdCAoPCAxMG1zKVxuICAgICAgZXhwZWN0KHByb2Nlc3NpbmdUaW1lKS50b0JlTGVzc1RoYW4oMTApO1xuICAgICAgZXhwZWN0KGlucHV0VmFsdWVzKS50b0hhdmVMZW5ndGgoMTAwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ01lbW9yeSBQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIG5vdCBsZWFrIG1lbW9yeSB3aGVuIGV4cGFuZGluZy9jb2xsYXBzaW5nIHNlY3Rpb25zJywgKCkgPT4ge1xuICAgICAgY29uc3QgaW5pdGlhbE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZDtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgbXVsdGlwbGUgZXhwYW5kL2NvbGxhcHNlIGN5Y2xlc1xuICAgICAgY29uc3QgZXhwYW5kZWRTZWN0aW9ucyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGd1ZXN0SWQgPSBgZ3Vlc3QtJHtpfWA7XG4gICAgICAgIGV4cGFuZGVkU2VjdGlvbnMuYWRkKGd1ZXN0SWQpO1xuICAgICAgICBleHBhbmRlZFNlY3Rpb25zLmRlbGV0ZShndWVzdElkKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmluYWxNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQ7XG4gICAgICBjb25zdCBtZW1vcnlJbmNyZWFzZSA9IGZpbmFsTWVtb3J5IC0gaW5pdGlhbE1lbW9yeTtcblxuICAgICAgLy8gTWVtb3J5IGluY3JlYXNlIHNob3VsZCBiZSBtaW5pbWFsICg8IDFNQilcbiAgICAgIGV4cGVjdChtZW1vcnlJbmNyZWFzZSkudG9CZUxlc3NUaGFuKDEwMjQgKiAxMDI0KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZWZmaWNpZW50bHkgbWFuYWdlIGxhcmdlIFJTVlAgZGF0YXNldHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbml0aWFsTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuXG4gICAgICAvLyBDcmVhdGUgbGFyZ2UgZGF0YXNldFxuICAgICAgY29uc3QgcnN2cHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAwIH0sIChfLCBpKSA9PiAoe1xuICAgICAgICBpZDogYHJzdnAtJHtpfWAsXG4gICAgICAgIGd1ZXN0SWQ6IGBndWVzdC0ke2kgJSAxMDB9YCxcbiAgICAgICAgYWN0aXZpdHlJZDogYGFjdGl2aXR5LSR7aSAlIDUwfWAsXG4gICAgICAgIHN0YXR1czogJ3BlbmRpbmcnIGFzIGNvbnN0LFxuICAgICAgfSkpO1xuXG4gICAgICAvLyBGaWx0ZXIgYW5kIHByb2Nlc3MgZGF0YVxuICAgICAgY29uc3QgYXR0ZW5kaW5nUlNWUHMgPSByc3Zwcy5maWx0ZXIociA9PiByLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKTtcbiAgICAgIGNvbnN0IGdyb3VwZWRCeUd1ZXN0ID0gYXR0ZW5kaW5nUlNWUHMucmVkdWNlKChhY2MsIHJzdnApID0+IHtcbiAgICAgICAgaWYgKCFhY2NbcnN2cC5ndWVzdElkXSkge1xuICAgICAgICAgIGFjY1tyc3ZwLmd1ZXN0SWRdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgYWNjW3JzdnAuZ3Vlc3RJZF0ucHVzaChyc3ZwKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIHR5cGVvZiByc3Zwcz4pO1xuXG4gICAgICBjb25zdCBmaW5hbE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZDtcbiAgICAgIGNvbnN0IG1lbW9yeUluY3JlYXNlID0gZmluYWxNZW1vcnkgLSBpbml0aWFsTWVtb3J5O1xuXG4gICAgICAvLyBNZW1vcnkgaW5jcmVhc2Ugc2hvdWxkIGJlIHJlYXNvbmFibGUgKDwgNU1CIGZvciAxMDAwIFJTVlBzKVxuICAgICAgZXhwZWN0KG1lbW9yeUluY3JlYXNlKS50b0JlTGVzc1RoYW4oNSAqIDEwMjQgKiAxMDI0KTtcbiAgICAgIGV4cGVjdChPYmplY3Qua2V5cyhncm91cGVkQnlHdWVzdCkubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDYXBhY2l0eSBWYWxpZGF0aW9uIFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgY2FwYWNpdHkgY29uc3RyYWludHMgcXVpY2tseScsICgpID0+IHtcbiAgICAgIGNvbnN0IGFjdGl2aXR5ID0ge1xuICAgICAgICBpZDogJ2FjdGl2aXR5LTEnLFxuICAgICAgICBjYXBhY2l0eTogMTAwLFxuICAgICAgICBjYXBhY2l0eVJlbWFpbmluZzogMTAsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgLy8gVmFsaWRhdGUgY2FwYWNpdHlcbiAgICAgIGNvbnN0IGNhbkF0dGVuZCA9IGFjdGl2aXR5LmNhcGFjaXR5UmVtYWluaW5nID4gMDtcbiAgICAgIGNvbnN0IGlzTmVhcmx5RnVsbCA9IChhY3Rpdml0eS5jYXBhY2l0eVJlbWFpbmluZyAvIGFjdGl2aXR5LmNhcGFjaXR5KSA8IDAuMTtcbiAgICAgIGNvbnN0IHdhcm5pbmdNZXNzYWdlID0gaXNOZWFybHlGdWxsID8gJ05lYXJseSBmdWxsJyA6IG51bGw7XG5cbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb25UaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcblxuICAgICAgLy8gVmFsaWRhdGlvbiBzaG91bGQgYmUgaW5zdGFudCAoPCAxbXMpXG4gICAgICBleHBlY3QodmFsaWRhdGlvblRpbWUpLnRvQmVMZXNzVGhhbigxKTtcbiAgICAgIGV4cGVjdChjYW5BdHRlbmQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoaXNOZWFybHlGdWxsKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHdhcm5pbmdNZXNzYWdlKS50b0JlKCdOZWFybHkgZnVsbCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYmF0Y2ggY2FwYWNpdHkgY2hlY2tzIGVmZmljaWVudGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgYWN0aXZpdGllcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMCB9LCAoXywgaSkgPT4gKHtcbiAgICAgICAgaWQ6IGBhY3Rpdml0eS0ke2l9YCxcbiAgICAgICAgY2FwYWNpdHk6IDEwMCxcbiAgICAgICAgY2FwYWNpdHlSZW1haW5pbmc6IGkgJSAxMCxcbiAgICAgIH0pKTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgIC8vIEJhdGNoIHZhbGlkYXRlXG4gICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0cyA9IGFjdGl2aXRpZXMubWFwKGFjdGl2aXR5ID0+ICh7XG4gICAgICAgIGlkOiBhY3Rpdml0eS5pZCxcbiAgICAgICAgY2FuQXR0ZW5kOiBhY3Rpdml0eS5jYXBhY2l0eVJlbWFpbmluZyA+IDAsXG4gICAgICAgIGlzTmVhcmx5RnVsbDogKGFjdGl2aXR5LmNhcGFjaXR5UmVtYWluaW5nIC8gYWN0aXZpdHkuY2FwYWNpdHkpIDwgMC4xLFxuICAgICAgfSkpO1xuXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBiYXRjaFZhbGlkYXRpb25UaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcblxuICAgICAgLy8gQmF0Y2ggdmFsaWRhdGlvbiBzaG91bGQgYmUgZmFzdCAoPCAxMG1zIGZvciAxMDAgYWN0aXZpdGllcylcbiAgICAgIGV4cGVjdChiYXRjaFZhbGlkYXRpb25UaW1lKS50b0JlTGVzc1RoYW4oMTApO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb25SZXN1bHRzKS50b0hhdmVMZW5ndGgoMTAwKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJkZXNjcmliZSIsIml0IiwiZ3Vlc3RzIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJpZCIsImZpcnN0TmFtZSIsImxhc3ROYW1lIiwiZW1haWwiLCJncm91cElkIiwiYWdlVHlwZSIsImd1ZXN0VHlwZSIsImNyZWF0ZWRBdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInVwZGF0ZWRBdCIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwicHJvY2Vzc2VkR3Vlc3RzIiwibWFwIiwiZ3Vlc3QiLCJmdWxsTmFtZSIsImdyb3VwTmFtZSIsImVuZFRpbWUiLCJyZW5kZXJUaW1lIiwiZXhwZWN0IiwidG9CZUxlc3NUaGFuIiwidG9IYXZlTGVuZ3RoIiwidG90YWxHdWVzdHMiLCJwYWdlU2l6ZSIsInBhZ2UiLCJ0byIsInBhZ2luYXRlZEd1ZXN0cyIsInNsaWNlIiwicGFnaW5hdGlvblRpbWUiLCJtb2NrUlNWUERhdGEiLCJhY3Rpdml0aWVzIiwibmFtZSIsInR5cGUiLCJzdGF0dXMiLCJjYXBhY2l0eSIsImNhcGFjaXR5UmVtYWluaW5nIiwiZXZlbnRzIiwiYWNjb21tb2RhdGlvbnMiLCJwcm9jZXNzZWREYXRhIiwiYSIsImNhcGFjaXR5UGVyY2VudGFnZSIsImV4cGFuc2lvblRpbWUiLCJndWVzdENvdW50IiwiZXhwYW5zaW9ucyIsImd1ZXN0SWQiLCJyc3ZwcyIsImoiLCJQcm9taXNlIiwiYWxsIiwidG90YWxUaW1lIiwibW9ja1JTVlAiLCJhY3Rpdml0eUlkIiwidmFsaWRhdGVkRGF0YSIsInJlc29sdmUiLCJzZXRUaW1lb3V0Iiwic2F2ZVRpbWUiLCJ0b0JlIiwiY3VycmVudFN0YXR1cyIsIm5ld1N0YXR1cyIsIm9wdGltaXN0aWNTdGF0ZSIsImlzT3B0aW1pc3RpYyIsInVwZGF0ZVRpbWUiLCJvcmlnaW5hbFN0YXR1cyIsImF0dGVtcHRlZFN0YXR1cyIsInJvbGxlZEJhY2tTdGF0ZSIsImVycm9yIiwicm9sbGJhY2tUaW1lIiwiY2FsbENvdW50IiwiZGVib3VuY2VkRnVuY3Rpb24iLCJpbnB1dFZhbHVlcyIsInB1c2giLCJwcm9jZXNzaW5nVGltZSIsImluaXRpYWxNZW1vcnkiLCJwcm9jZXNzIiwibWVtb3J5VXNhZ2UiLCJoZWFwVXNlZCIsImV4cGFuZGVkU2VjdGlvbnMiLCJTZXQiLCJhZGQiLCJkZWxldGUiLCJmaW5hbE1lbW9yeSIsIm1lbW9yeUluY3JlYXNlIiwiYXR0ZW5kaW5nUlNWUHMiLCJmaWx0ZXIiLCJyIiwiZ3JvdXBlZEJ5R3Vlc3QiLCJyZWR1Y2UiLCJhY2MiLCJyc3ZwIiwiT2JqZWN0Iiwia2V5cyIsInRvQmVHcmVhdGVyVGhhbiIsImFjdGl2aXR5IiwiY2FuQXR0ZW5kIiwiaXNOZWFybHlGdWxsIiwid2FybmluZ01lc3NhZ2UiLCJ2YWxpZGF0aW9uVGltZSIsInZhbGlkYXRpb25SZXN1bHRzIiwiYmF0Y2hWYWxpZGF0aW9uVGltZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0NBUUM7Ozs7NEJBRTJCO0FBRTVCQSxTQUFTLGlDQUFpQztJQUN4Q0EsU0FBUyxvQ0FBb0M7UUFDM0NDLEdBQUcsK0NBQStDO1lBQ2hELDJCQUEyQjtZQUMzQixNQUFNQyxTQUFTQyxNQUFNQyxJQUFJLENBQUM7Z0JBQUVDLFFBQVE7WUFBSSxHQUFHLENBQUNDLEdBQUdDLElBQU8sQ0FBQTtvQkFDcERDLElBQUksQ0FBQyxNQUFNLEVBQUVELEdBQUc7b0JBQ2hCRSxXQUFXLENBQUMsS0FBSyxFQUFFRixHQUFHO29CQUN0QkcsVUFBVSxDQUFDLElBQUksRUFBRUgsR0FBRztvQkFDcEJJLE9BQU8sQ0FBQyxLQUFLLEVBQUVKLEVBQUUsWUFBWSxDQUFDO29CQUM5QkssU0FBUyxDQUFDLE1BQU0sRUFBRUwsSUFBSSxJQUFJO29CQUMxQk0sU0FBUztvQkFDVEMsV0FBVztvQkFDWEMsV0FBVyxJQUFJQyxPQUFPQyxXQUFXO29CQUNqQ0MsV0FBVyxJQUFJRixPQUFPQyxXQUFXO2dCQUNuQyxDQUFBO1lBRUEsTUFBTUUsWUFBWUMsdUJBQVcsQ0FBQ0MsR0FB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