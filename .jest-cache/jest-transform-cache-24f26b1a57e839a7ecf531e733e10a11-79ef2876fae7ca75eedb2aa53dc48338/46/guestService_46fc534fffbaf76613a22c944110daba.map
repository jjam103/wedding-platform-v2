{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/services/guestService.ts"],"sourcesContent":["import { sanitizeInput } from '@/utils/sanitization';\nimport { \n  success, \n  validationError, \n  databaseError, \n  notFoundError, \n  unknownError \n} from '@/utils/errors';\nimport type { Result } from '@/types';\nimport {\n  createGuestSchema,\n  updateGuestSchema,\n  guestFilterSchema,\n  guestSearchSchema,\n  type CreateGuestDTO,\n  type UpdateGuestDTO,\n  type GuestFilterDTO,\n  type GuestSearchDTO,\n  type Guest,\n  type PaginatedGuests,\n} from '@/schemas/guestSchemas';\n\n// Lazy load supabase to avoid initialization issues in tests\nlet _supabase: any = null;\nfunction getSupabase() {\n  if (!_supabase) {\n    const { supabase } = require('@/lib/supabase');\n    _supabase = supabase;\n  }\n  return _supabase;\n}\n\n/**\n * Creates a new guest in the system.\n * \n * @param data - Guest data including name, email, and group assignment\n * @returns Result containing the created guest or error details\n * \n * @example\n * const result = await guestService.create({\n *   firstName: 'John',\n *   lastName: 'Doe',\n *   email: 'john@example.com',\n *   groupId: '123e4567-e89b-12d3-a456-426614174000',\n *   ageType: 'adult',\n *   guestType: 'wedding_guest',\n * });\n */\nexport async function create(data: CreateGuestDTO): Promise<Result<Guest>> {\n  try {\n    // 1. Validate\n    const validation = createGuestSchema.safeParse(data);\n    if (!validation.success) {\n      return validationError('Validation failed', validation.error.issues);\n    }\n\n    // 2. Get default auth method if not provided\n    // Import settingsService dynamically to avoid circular dependencies\n    const { getDefaultAuthMethod } = await import('./settingsService');\n    const defaultAuthResult = await getDefaultAuthMethod();\n    const authMethod = defaultAuthResult.success \n      ? defaultAuthResult.data \n      : 'email_matching'; // Fallback to email_matching if settings fetch fails\n\n    // 3. Sanitize user input\n    const sanitized = {\n      group_id: validation.data.groupId,\n      first_name: sanitizeInput(validation.data.firstName),\n      last_name: sanitizeInput(validation.data.lastName),\n      email: validation.data.email ? sanitizeInput(validation.data.email) : null,\n      phone: validation.data.phone ? sanitizeInput(validation.data.phone) : null,\n      age_type: validation.data.ageType,\n      guest_type: sanitizeInput(validation.data.guestType),\n      dietary_restrictions: validation.data.dietaryRestrictions \n        ? sanitizeInput(validation.data.dietaryRestrictions) \n        : null,\n      plus_one_name: validation.data.plusOneName \n        ? sanitizeInput(validation.data.plusOneName) \n        : null,\n      plus_one_attending: validation.data.plusOneAttending ?? false,\n      arrival_date: validation.data.arrivalDate ?? null,\n      departure_date: validation.data.departureDate ?? null,\n      airport_code: validation.data.airportCode ?? null,\n      flight_number: validation.data.flightNumber \n        ? sanitizeInput(validation.data.flightNumber) \n        : null,\n      invitation_sent: validation.data.invitationSent ?? false,\n      invitation_sent_date: validation.data.invitationSentDate ?? null,\n      rsvp_deadline: validation.data.rsvpDeadline ?? null,\n      notes: validation.data.notes ? sanitizeInput(validation.data.notes) : null,\n      auth_method: authMethod, // Set auth method from system settings\n    };\n\n    // 4. Database operation\n    const { data: result, error } = await getSupabase()\n      .from('guests')\n      .insert(sanitized)\n      .select()\n      .single();\n\n    if (error) {\n      return databaseError(error.message, error);\n    }\n\n    return success(mapDatabaseToGuest(result));\n  } catch (error) {\n    return unknownError(error);\n  }\n}\n\n/**\n * Retrieves a guest by ID.\n * \n * @param id - Guest UUID\n * @returns Result containing the guest or error details\n */\nexport async function get(id: string): Promise<Result<Guest>> {\n  try {\n    // Validate UUID format\n    if (!isValidUUID(id)) {\n      return validationError('Invalid guest ID format');\n    }\n\n    const { data, error } = await getSupabase()\n      .from('guests')\n      .select('*')\n      .eq('id', id)\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return notFoundError('Guest');\n      }\n      return databaseError(error.message, error);\n    }\n\n    return success(mapDatabaseToGuest(data));\n  } catch (error) {\n    return unknownError(error);\n  }\n}\n\n/**\n * Updates an existing guest.\n * \n * @param id - Guest UUID\n * @param data - Partial guest data to update\n * @returns Result containing the updated guest or error details\n */\nexport async function update(\n  id: string,\n  data: UpdateGuestDTO\n): Promise<Result<Guest>> {\n  try {\n    // Validate UUID format\n    if (!isValidUUID(id)) {\n      return validationError('Invalid guest ID format');\n    }\n\n    // 1. Validate\n    const validation = updateGuestSchema.safeParse(data);\n    if (!validation.success) {\n      return validationError('Validation failed', validation.error.issues);\n    }\n\n    // 2. Sanitize user input\n    const sanitized: Record<string, unknown> = {};\n    \n    if (validation.data.groupId !== undefined) {\n      sanitized.group_id = validation.data.groupId;\n    }\n    if (validation.data.firstName !== undefined) {\n      sanitized.first_name = sanitizeInput(validation.data.firstName);\n    }\n    if (validation.data.lastName !== undefined) {\n      sanitized.last_name = sanitizeInput(validation.data.lastName);\n    }\n    if (validation.data.email !== undefined) {\n      sanitized.email = validation.data.email ? sanitizeInput(validation.data.email) : null;\n    }\n    if (validation.data.phone !== undefined) {\n      sanitized.phone = validation.data.phone ? sanitizeInput(validation.data.phone) : null;\n    }\n    if (validation.data.ageType !== undefined) {\n      sanitized.age_type = validation.data.ageType;\n    }\n    if (validation.data.guestType !== undefined) {\n      sanitized.guest_type = sanitizeInput(validation.data.guestType);\n    }\n    if (validation.data.dietaryRestrictions !== undefined) {\n      sanitized.dietary_restrictions = validation.data.dietaryRestrictions \n        ? sanitizeInput(validation.data.dietaryRestrictions) \n        : null;\n    }\n    if (validation.data.plusOneName !== undefined) {\n      sanitized.plus_one_name = validation.data.plusOneName \n        ? sanitizeInput(validation.data.plusOneName) \n        : null;\n    }\n    if (validation.data.plusOneAttending !== undefined) {\n      sanitized.plus_one_attending = validation.data.plusOneAttending;\n    }\n    if (validation.data.arrivalDate !== undefined) {\n      sanitized.arrival_date = validation.data.arrivalDate;\n    }\n    if (validation.data.departureDate !== undefined) {\n      sanitized.departure_date = validation.data.departureDate;\n    }\n    if (validation.data.airportCode !== undefined) {\n      sanitized.airport_code = validation.data.airportCode;\n    }\n    if (validation.data.flightNumber !== undefined) {\n      sanitized.flight_number = validation.data.flightNumber \n        ? sanitizeInput(validation.data.flightNumber) \n        : null;\n    }\n    if (validation.data.invitationSent !== undefined) {\n      sanitized.invitation_sent = validation.data.invitationSent;\n    }\n    if (validation.data.invitationSentDate !== undefined) {\n      sanitized.invitation_sent_date = validation.data.invitationSentDate;\n    }\n    if (validation.data.rsvpDeadline !== undefined) {\n      sanitized.rsvp_deadline = validation.data.rsvpDeadline;\n    }\n    if (validation.data.notes !== undefined) {\n      sanitized.notes = validation.data.notes ? sanitizeInput(validation.data.notes) : null;\n    }\n\n    // 3. Database operation\n    const { data: result, error } = await getSupabase()\n      .from('guests')\n      .update(sanitized)\n      .eq('id', id)\n      .select()\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return notFoundError('Guest');\n      }\n      return databaseError(error.message, error);\n    }\n\n    return success(mapDatabaseToGuest(result));\n  } catch (error) {\n    return unknownError(error);\n  }\n}\n\n/**\n * Deletes a guest by ID.\n * \n * @param id - Guest UUID\n * @returns Result indicating success or error details\n */\nexport async function deleteGuest(id: string): Promise<Result<void>> {\n  try {\n    // Validate UUID format\n    if (!isValidUUID(id)) {\n      return validationError('Invalid guest ID format');\n    }\n\n    const { error } = await getSupabase()\n      .from('guests')\n      .delete()\n      .eq('id', id);\n\n    if (error) {\n      return databaseError(error.message, error);\n    }\n\n    return success(undefined);\n  } catch (error) {\n    return unknownError(error);\n  }\n}\n\n/**\n * Lists guests with optional filtering and pagination.\n * \n * @param filters - Optional filters for group, age type, guest type, etc.\n * @returns Result containing paginated guest list or error details\n */\nexport async function list(\n  filters: GuestFilterDTO = {}\n): Promise<Result<PaginatedGuests>> {\n  try {\n    // 1. Validate\n    const validation = guestFilterSchema.safeParse(filters);\n    if (!validation.success) {\n      return validationError('Invalid filters', validation.error.issues);\n    }\n\n    const { groupId, ageType, guestType, invitationSent, page = 1, pageSize = 50 } = validation.data;\n\n    // Build query\n    let query = getSupabase().from('guests').select('*', { count: 'exact' });\n\n    if (groupId) {\n      query = query.eq('group_id', groupId);\n    }\n    if (ageType) {\n      query = query.eq('age_type', ageType);\n    }\n    if (guestType) {\n      query = query.eq('guest_type', guestType);\n    }\n    if (invitationSent !== undefined) {\n      query = query.eq('invitation_sent', invitationSent);\n    }\n\n    // Apply pagination\n    const from = (page - 1) * pageSize;\n    const to = from + pageSize - 1;\n    query = query.range(from, to);\n\n    // Order by last name, first name\n    query = query.order('last_name', { ascending: true }).order('first_name', { ascending: true });\n\n    const { data, error, count } = await query;\n\n    if (error) {\n      return databaseError(error.message, error);\n    }\n\n    const guests = data.map(mapDatabaseToGuest);\n    const total = count ?? 0;\n    const totalPages = Math.ceil(total / pageSize);\n\n    return success({\n      guests,\n      total,\n      page,\n      pageSize,\n      totalPages,\n    });\n  } catch (error) {\n    return unknownError(error);\n  }\n}\n\n/**\n * Searches guests by name or email.\n * \n * @param searchParams - Search query and pagination options\n * @returns Result containing paginated search results or error details\n */\nexport async function search(\n  searchParams: GuestSearchDTO\n): Promise<Result<PaginatedGuests>> {\n  try {\n    // 1. Validate\n    const validation = guestSearchSchema.safeParse(searchParams);\n    if (!validation.success) {\n      return validationError('Invalid search parameters', validation.error.issues);\n    }\n\n    const { query, page = 1, pageSize = 50 } = validation.data;\n\n    // Sanitize search query\n    const sanitizedQuery = sanitizeInput(query);\n\n    // Build search query - search in first_name, last_name, and email\n    const { data, error, count } = await getSupabase()\n      .from('guests')\n      .select('*', { count: 'exact' })\n      .or(`first_name.ilike.%${sanitizedQuery}%,last_name.ilike.%${sanitizedQuery}%,email.ilike.%${sanitizedQuery}%`)\n      .range((page - 1) * pageSize, page * pageSize - 1)\n      .order('last_name', { ascending: true })\n      .order('first_name', { ascending: true });\n\n    if (error) {\n      return databaseError(error.message, error);\n    }\n\n    const guests = data.map(mapDatabaseToGuest);\n    const total = count ?? 0;\n    const totalPages = Math.ceil(total / pageSize);\n\n    return success({\n      guests,\n      total,\n      page,\n      pageSize,\n      totalPages,\n    });\n  } catch (error) {\n    return unknownError(error);\n  }\n}\n\n/**\n * Maps database column names to camelCase Guest object.\n * \n * @param dbGuest - Guest data from database with snake_case columns\n * @returns Guest object with camelCase properties\n */\nfunction mapDatabaseToGuest(dbGuest: any): Guest {\n  return {\n    id: dbGuest.id,\n    groupId: dbGuest.group_id,\n    firstName: dbGuest.first_name,\n    lastName: dbGuest.last_name,\n    email: dbGuest.email,\n    phone: dbGuest.phone,\n    ageType: dbGuest.age_type,\n    guestType: dbGuest.guest_type,\n    dietaryRestrictions: dbGuest.dietary_restrictions,\n    plusOneName: dbGuest.plus_one_name,\n    plusOneAttending: dbGuest.plus_one_attending,\n    arrivalDate: dbGuest.arrival_date,\n    departureDate: dbGuest.departure_date,\n    airportCode: dbGuest.airport_code,\n    flightNumber: dbGuest.flight_number,\n    invitationSent: dbGuest.invitation_sent,\n    invitationSentDate: dbGuest.invitation_sent_date,\n    rsvpDeadline: dbGuest.rsvp_deadline,\n    notes: dbGuest.notes,\n    authMethod: dbGuest.auth_method || 'email_matching', // Default to email_matching if not set\n    createdAt: dbGuest.created_at,\n    updatedAt: dbGuest.updated_at,\n  };\n}\n\n/**\n * Alias for deleteGuest to match common naming conventions.\n * Deletes a guest by ID.\n * \n * @param id - Guest UUID\n * @returns Result indicating success or error details\n */\nexport const remove = deleteGuest;\n\n/**\n * Bulk creates multiple guests at once.\n * Validates and sanitizes each guest individually before creating.\n * \n * @param guestsData - Array of guest data to create\n * @returns Result containing array of created guests or error details\n * \n * @example\n * const result = await guestService.bulkCreate([\n *   { firstName: 'John', lastName: 'Doe', email: 'john@example.com', groupId: 'uuid', ageType: 'adult', guestType: 'wedding_guest' },\n *   { firstName: 'Jane', lastName: 'Doe', email: 'jane@example.com', groupId: 'uuid', ageType: 'adult', guestType: 'wedding_guest' }\n * ]);\n */\nexport async function bulkCreate(guestsData: CreateGuestDTO[]): Promise<Result<Guest[]>> {\n  try {\n    // Validate input\n    if (!Array.isArray(guestsData) || guestsData.length === 0) {\n      return validationError('Guests data array is required and must not be empty');\n    }\n\n    // Get default auth method once for all guests\n    const { getDefaultAuthMethod } = await import('./settingsService');\n    const defaultAuthResult = await getDefaultAuthMethod();\n    const authMethod = defaultAuthResult.success \n      ? defaultAuthResult.data \n      : 'email_matching'; // Fallback to email_matching if settings fetch fails\n\n    // Validate and sanitize all guests first\n    const sanitizedGuests: any[] = [];\n    const validationErrors: Array<{ index: number; error: string }> = [];\n\n    for (let i = 0; i < guestsData.length; i++) {\n      const guestData = guestsData[i];\n      \n      // 1. Validate\n      const validation = createGuestSchema.safeParse(guestData);\n      if (!validation.success) {\n        validationErrors.push({\n          index: i,\n          error: `Validation failed: ${validation.error.issues.map(issue => `${issue.path.join('.')}: ${issue.message}`).join(', ')}`,\n        });\n        continue;\n      }\n\n      // 2. Sanitize user input\n      const sanitized = {\n        group_id: validation.data.groupId,\n        first_name: sanitizeInput(validation.data.firstName),\n        last_name: sanitizeInput(validation.data.lastName),\n        email: validation.data.email ? sanitizeInput(validation.data.email) : null,\n        phone: validation.data.phone ? sanitizeInput(validation.data.phone) : null,\n        age_type: validation.data.ageType,\n        guest_type: sanitizeInput(validation.data.guestType),\n        dietary_restrictions: validation.data.dietaryRestrictions \n          ? sanitizeInput(validation.data.dietaryRestrictions) \n          : null,\n        plus_one_name: validation.data.plusOneName \n          ? sanitizeInput(validation.data.plusOneName) \n          : null,\n        plus_one_attending: validation.data.plusOneAttending ?? false,\n        arrival_date: validation.data.arrivalDate ?? null,\n        departure_date: validation.data.departureDate ?? null,\n        airport_code: validation.data.airportCode ?? null,\n        flight_number: validation.data.flightNumber \n          ? sanitizeInput(validation.data.flightNumber) \n          : null,\n        invitation_sent: validation.data.invitationSent ?? false,\n        invitation_sent_date: validation.data.invitationSentDate ?? null,\n        rsvp_deadline: validation.data.rsvpDeadline ?? null,\n        notes: validation.data.notes ? sanitizeInput(validation.data.notes) : null,\n        auth_method: authMethod, // Set auth method from system settings\n      };\n\n      sanitizedGuests.push(sanitized);\n    }\n\n    // If there were validation errors, return them\n    if (validationErrors.length > 0) {\n      return validationError(\n        `Bulk create failed with ${validationErrors.length} validation error(s)`,\n        validationErrors\n      );\n    }\n\n    // 3. Database operation - bulk insert\n    const { data: result, error } = await getSupabase()\n      .from('guests')\n      .insert(sanitizedGuests)\n      .select();\n\n    if (error) {\n      return databaseError(error.message, error);\n    }\n\n    return success(result.map(mapDatabaseToGuest));\n  } catch (error) {\n    return unknownError(error);\n  }\n}\n\n/**\n * Bulk updates multiple guests with the same data.\n * Applies the same validation and sanitization as single updates.\n * \n * @param ids - Array of guest UUIDs to update\n * @param data - Partial guest data to apply to all guests\n * @returns Result containing array of updated guests or error details\n * \n * @example\n * const result = await guestService.bulkUpdate(\n *   ['uuid1', 'uuid2', 'uuid3'],\n *   { invitationSent: true, invitationSentDate: '2025-01-25' }\n * );\n */\nexport async function bulkUpdate(\n  ids: string[],\n  data: UpdateGuestDTO\n): Promise<Result<Guest[]>> {\n  try {\n    // Validate input\n    if (!Array.isArray(ids) || ids.length === 0) {\n      return validationError('Guest IDs array is required and must not be empty');\n    }\n\n    // Validate all UUIDs\n    for (const id of ids) {\n      if (!isValidUUID(id)) {\n        return validationError(`Invalid guest ID format: ${id}`);\n      }\n    }\n\n    // 1. Validate data using same schema as single update\n    const validation = updateGuestSchema.safeParse(data);\n    if (!validation.success) {\n      return validationError('Validation failed', validation.error.issues);\n    }\n\n    // 2. Sanitize user input using same logic as single update\n    const sanitized: Record<string, unknown> = {};\n    \n    if (validation.data.groupId !== undefined) {\n      sanitized.group_id = validation.data.groupId;\n    }\n    if (validation.data.firstName !== undefined) {\n      sanitized.first_name = sanitizeInput(validation.data.firstName);\n    }\n    if (validation.data.lastName !== undefined) {\n      sanitized.last_name = sanitizeInput(validation.data.lastName);\n    }\n    if (validation.data.email !== undefined) {\n      sanitized.email = validation.data.email ? sanitizeInput(validation.data.email) : null;\n    }\n    if (validation.data.phone !== undefined) {\n      sanitized.phone = validation.data.phone ? sanitizeInput(validation.data.phone) : null;\n    }\n    if (validation.data.ageType !== undefined) {\n      sanitized.age_type = validation.data.ageType;\n    }\n    if (validation.data.guestType !== undefined) {\n      sanitized.guest_type = sanitizeInput(validation.data.guestType);\n    }\n    if (validation.data.dietaryRestrictions !== undefined) {\n      sanitized.dietary_restrictions = validation.data.dietaryRestrictions \n        ? sanitizeInput(validation.data.dietaryRestrictions) \n        : null;\n    }\n    if (validation.data.plusOneName !== undefined) {\n      sanitized.plus_one_name = validation.data.plusOneName \n        ? sanitizeInput(validation.data.plusOneName) \n        : null;\n    }\n    if (validation.data.plusOneAttending !== undefined) {\n      sanitized.plus_one_attending = validation.data.plusOneAttending;\n    }\n    if (validation.data.arrivalDate !== undefined) {\n      sanitized.arrival_date = validation.data.arrivalDate;\n    }\n    if (validation.data.departureDate !== undefined) {\n      sanitized.departure_date = validation.data.departureDate;\n    }\n    if (validation.data.airportCode !== undefined) {\n      sanitized.airport_code = validation.data.airportCode;\n    }\n    if (validation.data.flightNumber !== undefined) {\n      sanitized.flight_number = validation.data.flightNumber \n        ? sanitizeInput(validation.data.flightNumber) \n        : null;\n    }\n    if (validation.data.invitationSent !== undefined) {\n      sanitized.invitation_sent = validation.data.invitationSent;\n    }\n    if (validation.data.invitationSentDate !== undefined) {\n      sanitized.invitation_sent_date = validation.data.invitationSentDate;\n    }\n    if (validation.data.rsvpDeadline !== undefined) {\n      sanitized.rsvp_deadline = validation.data.rsvpDeadline;\n    }\n    if (validation.data.notes !== undefined) {\n      sanitized.notes = validation.data.notes ? sanitizeInput(validation.data.notes) : null;\n    }\n\n    // 3. Database operation - bulk update\n    const { data: result, error } = await getSupabase()\n      .from('guests')\n      .update(sanitized)\n      .in('id', ids)\n      .select();\n\n    if (error) {\n      return databaseError(error.message, error);\n    }\n\n    // Check if all guests were updated\n    if (!result || result.length !== ids.length) {\n      return validationError(\n        `Expected to update ${ids.length} guests, but only ${result?.length || 0} were updated. Some guest IDs may not exist.`\n      );\n    }\n\n    return success(result.map(mapDatabaseToGuest));\n  } catch (error) {\n    return unknownError(error);\n  }\n}\n\n/**\n * Bulk deletes multiple guests by their IDs.\n * \n * @param ids - Array of guest UUIDs to delete\n * @returns Result indicating success or error details\n * \n * @example\n * const result = await guestService.bulkDelete(['uuid1', 'uuid2', 'uuid3']);\n */\nexport async function bulkDelete(ids: string[]): Promise<Result<void>> {\n  try {\n    // Validate input\n    if (!Array.isArray(ids) || ids.length === 0) {\n      return validationError('Guest IDs array is required and must not be empty');\n    }\n\n    // Validate all UUIDs\n    for (const id of ids) {\n      if (!isValidUUID(id)) {\n        return validationError(`Invalid guest ID format: ${id}`);\n      }\n    }\n\n    // Database operation - bulk delete\n    const { error, count } = await getSupabase()\n      .from('guests')\n      .delete({ count: 'exact' })\n      .in('id', ids);\n\n    if (error) {\n      return databaseError(error.message, error);\n    }\n\n    // Note: Supabase doesn't return an error if some IDs don't exist,\n    // it just deletes the ones that do exist. This is acceptable behavior\n    // for bulk delete operations.\n\n    return success(undefined);\n  } catch (error) {\n    return unknownError(error);\n  }\n}\n\n/**\n * Validates UUID format.\n * \n * @param uuid - String to validate\n * @returns True if valid UUID format\n */\nfunction isValidUUID(uuid: string): boolean {\n  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n  return uuidRegex.test(uuid);\n}\n\n/**\n * CSV column headers in the order they appear in the CSV file.\n */\nconst CSV_HEADERS = [\n  'groupId',\n  'firstName',\n  'lastName',\n  'email',\n  'phone',\n  'ageType',\n  'guestType',\n  'dietaryRestrictions',\n  'plusOneName',\n  'plusOneAttending',\n  'arrivalDate',\n  'departureDate',\n  'airportCode',\n  'flightNumber',\n  'invitationSent',\n  'invitationSentDate',\n  'rsvpDeadline',\n  'notes',\n] as const;\n\n/**\n * Escapes a CSV field value by wrapping in quotes if needed.\n * \n * @param value - Field value to escape\n * @returns Escaped CSV field value\n */\nfunction escapeCSVField(value: string | null | boolean): string {\n  if (value === null || value === undefined) {\n    return '';\n  }\n  \n  const stringValue = String(value);\n  \n  // If the value contains comma, quote, or newline, wrap in quotes and escape internal quotes\n  if (stringValue.includes(',') || stringValue.includes('\"') || stringValue.includes('\\n')) {\n    return `\"${stringValue.replace(/\"/g, '\"\"')}\"`;\n  }\n  \n  return stringValue;\n}\n\n/**\n * Parses a CSV field value, handling quoted fields.\n * \n * @param value - CSV field value to parse\n * @returns Unescaped field value\n */\nfunction parseCSVField(value: string): string {\n  if (!value) {\n    return '';\n  }\n  \n  // If wrapped in quotes, remove them and unescape internal quotes\n  if (value.startsWith('\"') && value.endsWith('\"')) {\n    return value.slice(1, -1).replace(/\"\"/g, '\"');\n  }\n  \n  return value;\n}\n\n/**\n * Parses a CSV line into fields, handling quoted fields with commas.\n * \n * @param line - CSV line to parse\n * @returns Array of field values\n */\nfunction parseCSVLine(line: string): string[] {\n  const fields: string[] = [];\n  let currentField = '';\n  let inQuotes = false;\n  \n  for (let i = 0; i < line.length; i++) {\n    const char = line[i];\n    const nextChar = line[i + 1];\n    \n    if (char === '\"') {\n      if (inQuotes && nextChar === '\"') {\n        // Escaped quote\n        currentField += '\"';\n        i++; // Skip next quote\n      } else {\n        // Toggle quote state\n        inQuotes = !inQuotes;\n      }\n    } else if (char === ',' && !inQuotes) {\n      // End of field\n      fields.push(currentField);\n      currentField = '';\n    } else {\n      currentField += char;\n    }\n  }\n  \n  // Add last field\n  fields.push(currentField);\n  \n  return fields;\n}\n\n/**\n * Exports guests to CSV format (Pretty_Printer).\n * \n * @param guests - Array of guests to export\n * @returns Result containing CSV string or error details\n * \n * @example\n * const result = await guestService.exportToCSV(guests);\n * if (result.success) {\n *   // Download or save result.data as CSV file\n * }\n */\nexport async function exportToCSV(guests: Guest[]): Promise<Result<string>> {\n  try {\n    if (!Array.isArray(guests)) {\n      return validationError('Guests must be an array');\n    }\n\n    // Build CSV header\n    const headerLine = CSV_HEADERS.join(',');\n    \n    // Build CSV rows\n    const rows = guests.map(guest => {\n      const row = CSV_HEADERS.map(header => {\n        const value = guest[header as keyof Guest];\n        return escapeCSVField(value);\n      });\n      return row.join(',');\n    });\n    \n    // Combine header and rows\n    const csv = [headerLine, ...rows].join('\\n');\n    \n    return success(csv);\n  } catch (error) {\n    return unknownError(error);\n  }\n}\n\n/**\n * Imports guests from CSV format.\n * Validates each row against the guest schema before importing.\n * \n * @param csvContent - CSV string content to import\n * @returns Result containing array of created guests or error details\n * \n * @example\n * const result = await guestService.importFromCSV(csvFileContent);\n * if (result.success) {\n *   console.log(`Imported ${result.data.length} guests`);\n * }\n */\nexport async function importFromCSV(csvContent: string): Promise<Result<Guest[]>> {\n  try {\n    if (typeof csvContent !== 'string' || !csvContent.trim()) {\n      return validationError('CSV content is required');\n    }\n\n    // Split into lines\n    const lines = csvContent.trim().split('\\n');\n    \n    if (lines.length < 1) {\n      return validationError('CSV must contain at least a header row');\n    }\n\n    // Parse header\n    const headerLine = lines[0];\n    const headers = parseCSVLine(headerLine);\n    \n    // Validate headers match expected format\n    const expectedHeaders = [...CSV_HEADERS];\n    if (headers.length !== expectedHeaders.length) {\n      return validationError(\n        `CSV header mismatch. Expected ${expectedHeaders.length} columns, got ${headers.length}. Expected: ${expectedHeaders.join(', ')}`\n      );\n    }\n    \n    for (let i = 0; i < headers.length; i++) {\n      if (headers[i] !== expectedHeaders[i]) {\n        return validationError(\n          `CSV header mismatch at column ${i + 1}. Expected \"${expectedHeaders[i]}\", got \"${headers[i]}\"`\n        );\n      }\n    }\n    \n    // If only header row (no data), return validation error\n    if (lines.length < 2) {\n      return validationError('CSV must contain at least one data row');\n    }\n\n    // Parse data rows\n    const guestsToCreate: CreateGuestDTO[] = [];\n    const errors: Array<{ line: number; error: string }> = [];\n    \n    for (let i = 1; i < lines.length; i++) {\n      const line = lines[i].trim();\n      if (!line) continue; // Skip empty lines\n      \n      const fields = parseCSVLine(line);\n      \n      if (fields.length !== headers.length) {\n        errors.push({\n          line: i + 1,\n          error: `Expected ${headers.length} fields, got ${fields.length}`,\n        });\n        continue;\n      }\n      \n      // Build guest object from CSV fields\n      const guestData: any = {};\n      \n      for (let j = 0; j < headers.length; j++) {\n        const header = headers[j];\n        const value = parseCSVField(fields[j]);\n        \n        // Convert empty strings to null for nullable fields\n        if (value === '') {\n          if (['email', 'phone', 'dietaryRestrictions', 'plusOneName', 'arrivalDate', \n               'departureDate', 'airportCode', 'flightNumber', 'invitationSentDate', \n               'rsvpDeadline', 'notes'].includes(header)) {\n            guestData[header] = null;\n          }\n        } else if (header === 'plusOneAttending' || header === 'invitationSent') {\n          // Convert boolean fields\n          guestData[header] = value.toLowerCase() === 'true';\n        } else {\n          guestData[header] = value;\n        }\n      }\n      \n      // Validate guest data\n      const validation = createGuestSchema.safeParse(guestData);\n      \n      if (!validation.success) {\n        errors.push({\n          line: i + 1,\n          error: `Validation failed: ${validation.error.issues.map(issue => `${issue.path.join('.')}: ${issue.message}`).join(', ')}`,\n        });\n        continue;\n      }\n      \n      guestsToCreate.push(validation.data);\n    }\n    \n    // If there were validation errors, return them\n    if (errors.length > 0) {\n      return validationError(\n        `CSV import failed with ${errors.length} error(s)`,\n        errors\n      );\n    }\n    \n    // Create all guests (or return empty array if none to create)\n    const createdGuests: Guest[] = [];\n    \n    if (guestsToCreate.length === 0) {\n      return success(createdGuests);\n    }\n    \n    const createErrors: Array<{ guest: string; error: string }> = [];\n    \n    for (const guestData of guestsToCreate) {\n      const result = await create(guestData);\n      \n      if (result.success) {\n        createdGuests.push(result.data);\n      } else {\n        createErrors.push({\n          guest: `${guestData.firstName} ${guestData.lastName}`,\n          error: result.error.message,\n        });\n      }\n    }\n    \n    // If some guests failed to create, return partial success with details\n    if (createErrors.length > 0) {\n      return {\n        success: false,\n        error: {\n          code: 'PARTIAL_IMPORT_FAILURE',\n          message: `Imported ${createdGuests.length} of ${guestsToCreate.length} guests. ${createErrors.length} failed.`,\n          details: { createdGuests, errors: createErrors },\n        },\n      };\n    }\n    \n    return success(createdGuests);\n  } catch (error) {\n    return unknownError(error);\n  }\n}\n\n// Export alias for delete to match test expectations\nexport { deleteGuest as delete };\n"],"names":["bulkCreate","bulkDelete","bulkUpdate","create","delete","deleteGuest","exportToCSV","get","importFromCSV","list","remove","search","update","_supabase","getSupabase","supabase","require","data","validation","createGuestSchema","safeParse","success","validationError","error","issues","getDefaultAuthMethod","defaultAuthResult","authMethod","sanitized","group_id","groupId","first_name","sanitizeInput","firstName","last_name","lastName","email","phone","age_type","ageType","guest_type","guestType","dietary_restrictions","dietaryRestrictions","plus_one_name","plusOneName","plus_one_attending","plusOneAttending","arrival_date","arrivalDate","departure_date","departureDate","airport_code","airportCode","flight_number","flightNumber","invitation_sent","invitationSent","invitation_sent_date","invitationSentDate","rsvp_deadline","rsvpDeadline","notes","auth_method","result","from","insert","select","single","databaseError","message","mapDatabaseToGuest","unknownError","id","isValidUUID","eq","code","notFoundError","updateGuestSchema","undefined","filters","guestFilterSchema","page","pageSize","query","count","to","range","order","ascending","guests","map","total","totalPages","Math","ceil","searchParams","guestSearchSchema","sanitizedQuery","or","dbGuest","createdAt","created_at","updatedAt","updated_at","guestsData","Array","isArray","length","sanitizedGuests","validationErrors","i","guestData","push","index","issue","path","join","ids","in","uuid","uuidRegex","test","CSV_HEADERS","escapeCSVField","value","stringValue","String","includes","replace","parseCSVField","startsWith","endsWith","slice","parseCSVLine","line","fields","currentField","inQuotes","char","nextChar","headerLine","rows","guest","row","header","csv","csvContent","trim","lines","split","headers","expectedHeaders","guestsToCreate","errors","j","toLowerCase","createdGuests","createErrors","details"],"mappings":"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"}