{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/services/eventService.ts"],"sourcesContent":["import { createClient } from '@supabase/supabase-js';\nimport { sanitizeInput, sanitizeRichText } from \"../utils/sanitization\";\nimport { generateSlug, isValidSlug, makeUniqueSlug } from \"../utils/slugs\";\nimport {\n  createEventSchema,\n  updateEventSchema,\n  eventFilterSchema,\n  eventSearchSchema,\n  conflictCheckSchema,\n  type CreateEventDTO,\n  type UpdateEventDTO,\n  type EventFilterDTO,\n  type EventSearchDTO,\n  type ConflictCheckDTO,\n  type Event,\n  type PaginatedEvents,\n  type SchedulingConflict,\n} from '../schemas/eventSchemas';\n\n/**\n * Result type for consistent error handling.\n */\ntype Result<T> =\n  | { success: true; data: T }\n  | { success: false; error: { code: string; message: string; details?: any } };\n\n/**\n * Converts camelCase to snake_case for database columns.\n */\nfunction toSnakeCase(obj: any): any {\n  const snakeObj: any = {};\n  for (const key in obj) {\n    const snakeKey = key.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n    snakeObj[snakeKey] = obj[key];\n  }\n  return snakeObj;\n}\n\n/**\n * Converts snake_case to camelCase for TypeScript objects.\n */\nfunction toCamelCase(obj: any): any {\n  const camelObj: any = {};\n  for (const key in obj) {\n    const camelKey = key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());\n    camelObj[camelKey] = obj[key];\n  }\n  return camelObj;\n}\n\n/**\n * Ensures slug is unique by checking existing events and appending a number if necessary.\n * \n * @param slug - Desired slug\n * @param excludeId - ID to exclude from uniqueness check (for updates)\n * @returns Unique slug\n */\nasync function ensureUniqueSlug(slug: string, excludeId?: string): Promise<string> {\n  const supabase = createClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.SUPABASE_SERVICE_ROLE_KEY!\n  );\n\n  // Get all existing slugs\n  let query = supabase.from('events').select('slug');\n  \n  if (excludeId) {\n    query = query.neq('id', excludeId);\n  }\n\n  const { data, error } = await query;\n\n  if (error) {\n    // If we can't check, return the original slug and let database handle uniqueness\n    return slug;\n  }\n\n  const existingSlugs = data.map((event: any) => event.slug).filter(Boolean);\n  return makeUniqueSlug(slug, existingSlugs);\n}\n\n/**\n * Creates a new event in the system.\n *\n * @param data - Event data including name, type, dates, and location\n * @returns Result containing the created event or error details\n *\n * @example\n * const result = await eventService.create({\n *   name: 'Wedding Ceremony',\n *   eventType: 'ceremony',\n *   startDate: '2025-06-15T14:00:00Z',\n *   locationId: '123e4567-e89b-12d3-a456-426614174000',\n * });\n */\nexport async function create(data: CreateEventDTO): Promise<Result<Event>> {\n  try {\n    // 1. Validate\n    const validation = createEventSchema.safeParse(data);\n    if (!validation.success) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Validation failed',\n          details: validation.error.issues,\n        },\n      };\n    }\n\n    // 2. Sanitize user input\n    const sanitized = {\n      ...validation.data,\n      name: sanitizeInput(validation.data.name),\n      description: validation.data.description ? sanitizeRichText(validation.data.description) : null,\n    };\n\n    // 2.1. Generate slug if not provided\n    const baseSlug = generateSlug(sanitized.name);\n    if (!isValidSlug(baseSlug)) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Event name must contain at least one alphanumeric character to generate a valid slug',\n          details: {\n            field: 'name',\n            value: sanitized.name,\n            reason: 'Generated slug is invalid or empty after normalization',\n          },\n        },\n      };\n    }\n\n    // 2.2. Ensure slug is unique\n    const uniqueSlug = await ensureUniqueSlug(baseSlug);\n    const sanitizedWithSlug = {\n      ...sanitized,\n      slug: uniqueSlug,\n    };\n\n    // 3. Check for scheduling conflicts if location is specified\n    if (sanitizedWithSlug.locationId) {\n      const conflictCheck = await checkSchedulingConflicts({\n        locationId: sanitizedWithSlug.locationId,\n        startDate: sanitizedWithSlug.startDate,\n        endDate: sanitizedWithSlug.endDate || null,\n      });\n\n      if (!conflictCheck.success) {\n        return conflictCheck as Result<Event>;\n      }\n\n      if (conflictCheck.data.hasConflict) {\n        return {\n          success: false,\n          error: {\n            code: 'SCHEDULING_CONFLICT',\n            message: 'Event conflicts with existing events at this location',\n            details: conflictCheck.data.conflictingEvents,\n          },\n        };\n      }\n    }\n\n    // 4. Database operation\n    const supabase = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!\n    );\n\n    const dbData = toSnakeCase(sanitizedWithSlug);\n    const { data: result, error } = await supabase\n      .from('events')\n      .insert(dbData)\n      .select()\n      .single();\n\n    if (error) {\n      return {\n        success: false,\n        error: { code: 'DATABASE_ERROR', message: error.message, details: error },\n      };\n    }\n\n    return { success: true, data: toCamelCase(result) as Event };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error',\n      },\n    };\n  }\n}\n\n/**\n * Retrieves a single event by ID.\n *\n * @param id - Event UUID\n * @returns Result containing the event or error details\n */\nexport async function get(id: string): Promise<Result<Event>> {\n  try {\n    const supabase = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!\n    );\n\n    const { data, error } = await supabase\n      .from('events')\n      .select('*')\n      .eq('id', id)\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return {\n          success: false,\n          error: { code: 'NOT_FOUND', message: 'Event not found' },\n        };\n      }\n      return {\n        success: false,\n        error: { code: 'DATABASE_ERROR', message: error.message, details: error },\n      };\n    }\n\n    return { success: true, data: toCamelCase(data) as Event };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error',\n      },\n    };\n  }\n}\n\n/**\n * Updates an existing event.\n *\n * @param id - Event UUID\n * @param data - Partial event data to update\n * @returns Result containing the updated event or error details\n */\nexport async function update(id: string, data: UpdateEventDTO): Promise<Result<Event>> {\n  try {\n    // 1. Validate\n    const validation = updateEventSchema.safeParse(data);\n    if (!validation.success) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Validation failed',\n          details: validation.error.issues,\n        },\n      };\n    }\n\n    // 2. Sanitize user input\n    const sanitized: any = { ...validation.data };\n    if (sanitized.name) {\n      sanitized.name = sanitizeInput(sanitized.name);\n    }\n    if (sanitized.description) {\n      sanitized.description = sanitizeRichText(sanitized.description);\n    }\n\n    // 2.1. Preserve slug - do not regenerate from name on update\n    // Slug should only be set on creation or explicitly updated by admin\n\n    // 3. Check for scheduling conflicts if location or dates are being updated\n    if (sanitized.locationId || sanitized.startDate || sanitized.endDate) {\n      // Get current event data to fill in missing fields\n      const currentEvent = await get(id);\n      if (!currentEvent.success) {\n        return currentEvent;\n      }\n\n      const locationId = sanitized.locationId || currentEvent.data.locationId;\n      const startDate = sanitized.startDate || currentEvent.data.startDate;\n      const endDate = sanitized.endDate !== undefined ? sanitized.endDate : currentEvent.data.endDate;\n\n      if (locationId) {\n        const conflictCheck = await checkSchedulingConflicts({\n          locationId,\n          startDate,\n          endDate,\n          excludeEventId: id,\n        });\n\n        if (!conflictCheck.success) {\n          return conflictCheck as Result<Event>;\n        }\n\n        if (conflictCheck.data.hasConflict) {\n          return {\n            success: false,\n            error: {\n              code: 'SCHEDULING_CONFLICT',\n              message: 'Event conflicts with existing events at this location',\n              details: conflictCheck.data.conflictingEvents,\n            },\n          };\n        }\n      }\n    }\n\n    // 4. Database operation\n    const supabase = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!\n    );\n\n    const dbData = toSnakeCase(sanitized);\n    const { data: result, error } = await supabase\n      .from('events')\n      .update(dbData)\n      .eq('id', id)\n      .select()\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return {\n          success: false,\n          error: { code: 'NOT_FOUND', message: 'Event not found' },\n        };\n      }\n      return {\n        success: false,\n        error: { code: 'DATABASE_ERROR', message: error.message, details: error },\n      };\n    }\n\n    return { success: true, data: toCamelCase(result) as Event };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error',\n      },\n    };\n  }\n}\n\n/**\n * Deletes an event by ID.\n * Note: Activities with event_id set to this event will have their event_id set to NULL (not deleted).\n *\n * @param id - Event UUID\n * @param options - Delete options (soft delete or permanent)\n * @returns Result indicating success or error details\n * \n * @example\n * // Soft delete (default)\n * await deleteEvent('event-id');\n * \n * // Permanent delete\n * await deleteEvent('event-id', { permanent: true });\n */\nexport async function deleteEvent(\n  id: string,\n  options: { permanent?: boolean; deletedBy?: string } = {}\n): Promise<Result<void>> {\n  try {\n    const supabase = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!\n    );\n\n    const { permanent = false, deletedBy } = options;\n\n    if (permanent) {\n      // Permanent deletion - remove from database\n      const { error } = await supabase.from('events').delete().eq('id', id);\n\n      if (error) {\n        return {\n          success: false,\n          error: { code: 'DATABASE_ERROR', message: error.message, details: error },\n        };\n      }\n    } else {\n      // Soft delete - set deleted_at timestamp\n      const now = new Date().toISOString();\n\n      // Soft delete associated activities\n      await supabase\n        .from('activities')\n        .update({ deleted_at: now, deleted_by: deletedBy })\n        .eq('event_id', id)\n        .is('deleted_at', null);\n\n      // Soft delete associated RSVPs\n      const { data: activities } = await supabase\n        .from('activities')\n        .select('id')\n        .eq('event_id', id);\n\n      if (activities && activities.length > 0) {\n        const activityIds = activities.map((a: any) => a.id);\n        await supabase\n          .from('rsvps')\n          .update({ deleted_at: now, deleted_by: deletedBy })\n          .in('activity_id', activityIds)\n          .is('deleted_at', null);\n      }\n\n      // Soft delete event\n      const { error } = await supabase\n        .from('events')\n        .update({ deleted_at: now, deleted_by: deletedBy })\n        .eq('id', id)\n        .is('deleted_at', null);\n\n      if (error) {\n        return {\n          success: false,\n          error: { code: 'DATABASE_ERROR', message: error.message, details: error },\n        };\n      }\n    }\n\n    return { success: true, data: undefined };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error',\n      },\n    };\n  }\n}\n\n/**\n * Restores a soft-deleted event and all associated activities and RSVPs\n * \n * @param id - Event ID\n * @returns Result containing the restored event or error details\n * \n * @example\n * const result = await restoreEvent('event-id');\n */\nexport async function restoreEvent(id: string): Promise<Result<Event>> {\n  try {\n    const supabase = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!\n    );\n\n    // Restore associated activities\n    const { data: activities } = await supabase\n      .from('activities')\n      .select('id')\n      .eq('event_id', id)\n      .not('deleted_at', 'is', null);\n\n    if (activities && activities.length > 0) {\n      const activityIds = activities.map((a: any) => a.id);\n\n      // Restore RSVPs\n      await supabase\n        .from('rsvps')\n        .update({ deleted_at: null, deleted_by: null })\n        .in('activity_id', activityIds);\n\n      // Restore activities\n      await supabase\n        .from('activities')\n        .update({ deleted_at: null, deleted_by: null })\n        .in('id', activityIds);\n    }\n\n    // Restore event\n    const { data, error } = await supabase\n      .from('events')\n      .update({ deleted_at: null, deleted_by: null })\n      .eq('id', id)\n      .select()\n      .single();\n\n    if (error) {\n      return {\n        success: false,\n        error: { code: 'DATABASE_ERROR', message: error.message, details: error },\n      };\n    }\n\n    return { success: true, data };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error',\n      },\n    };\n  }\n}\n\n/**\n * Lists events with optional filtering and pagination.\n *\n * @param filters - Filter criteria and pagination options\n * @returns Result containing paginated events or error details\n */\nexport async function list(filters: EventFilterDTO = {}): Promise<Result<PaginatedEvents>> {\n  try {\n    // 1. Validate\n    const validation = eventFilterSchema.safeParse(filters);\n    if (!validation.success) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Validation failed',\n          details: validation.error.issues,\n        },\n      };\n    }\n\n    const { page = 1, pageSize = 50, ...filterParams } = validation.data;\n    const from = (page - 1) * pageSize;\n    const to = from + pageSize - 1;\n\n    // 2. Database operation\n    const supabase = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!\n    );\n\n    let query = supabase.from('events').select('*', { count: 'exact' });\n\n    // Apply filters\n    if (filterParams.eventType) {\n      query = query.eq('event_type', filterParams.eventType);\n    }\n    if (filterParams.status) {\n      query = query.eq('status', filterParams.status);\n    }\n    if (filterParams.locationId) {\n      query = query.eq('location_id', filterParams.locationId);\n    }\n    if (filterParams.startDateFrom) {\n      query = query.gte('start_date', filterParams.startDateFrom);\n    }\n    if (filterParams.startDateTo) {\n      query = query.lte('start_date', filterParams.startDateTo);\n    }\n\n    // Apply pagination and ordering\n    query = query.order('start_date', { ascending: true }).range(from, to);\n\n    const { data, error, count } = await query;\n\n    if (error) {\n      return {\n        success: false,\n        error: { code: 'DATABASE_ERROR', message: error.message, details: error },\n      };\n    }\n\n    const events = data.map((event) => toCamelCase(event) as Event);\n    const total = count || 0;\n    const totalPages = Math.ceil(total / pageSize);\n\n    return {\n      success: true,\n      data: {\n        events,\n        total,\n        page,\n        pageSize,\n        totalPages,\n      },\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error',\n      },\n    };\n  }\n}\n\n/**\n * Searches events by name or description.\n *\n * @param searchParams - Search query and pagination options\n * @returns Result containing paginated search results or error details\n */\nexport async function search(searchParams: EventSearchDTO): Promise<Result<PaginatedEvents>> {\n  try {\n    // 1. Validate\n    const validation = eventSearchSchema.safeParse(searchParams);\n    if (!validation.success) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Validation failed',\n          details: validation.error.issues,\n        },\n      };\n    }\n\n    const { query, page = 1, pageSize = 50 } = validation.data;\n    const from = (page - 1) * pageSize;\n    const to = from + pageSize - 1;\n\n    // 2. Sanitize search query\n    const sanitizedQuery = sanitizeInput(query);\n\n    // 3. Database operation\n    const supabase = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!\n    );\n\n    const { data, error, count } = await supabase\n      .from('events')\n      .select('*', { count: 'exact' })\n      .or(`name.ilike.%${sanitizedQuery}%,description.ilike.%${sanitizedQuery}%`)\n      .order('start_date', { ascending: true })\n      .range(from, to);\n\n    if (error) {\n      return {\n        success: false,\n        error: { code: 'DATABASE_ERROR', message: error.message, details: error },\n      };\n    }\n\n    const events = data.map((event) => toCamelCase(event) as Event);\n    const total = count || 0;\n    const totalPages = Math.ceil(total / pageSize);\n\n    return {\n      success: true,\n      data: {\n        events,\n        total,\n        page,\n        pageSize,\n        totalPages,\n      },\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error',\n      },\n    };\n  }\n}\n\n/**\n * Checks for scheduling conflicts at a specific location and time range.\n *\n * @param params - Location, date range, and optional event ID to exclude\n * @returns Result containing conflict information or error details\n */\nexport async function checkSchedulingConflicts(\n  params: ConflictCheckDTO\n): Promise<Result<SchedulingConflict>> {\n  try {\n    // 1. Validate\n    const validation = conflictCheckSchema.safeParse(params);\n    if (!validation.success) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Validation failed',\n          details: validation.error.issues,\n        },\n      };\n    }\n\n    const { locationId, startDate, endDate, excludeEventId } = validation.data;\n\n    // 2. Database operation\n    const supabase = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!\n    );\n\n    // Query for overlapping events at the same location\n    let query = supabase\n      .from('events')\n      .select('id, name, start_date, end_date')\n      .eq('location_id', locationId);\n\n    // Exclude the current event if updating\n    if (excludeEventId) {\n      query = query.neq('id', excludeEventId);\n    }\n\n    const { data, error } = await query;\n\n    if (error) {\n      return {\n        success: false,\n        error: { code: 'DATABASE_ERROR', message: error.message, details: error },\n      };\n    }\n\n    // Check for time overlaps\n    const conflictingEvents = data.filter((event) => {\n      const eventStart = new Date(event.start_date);\n      const eventEnd = event.end_date ? new Date(event.end_date) : eventStart;\n      const checkStart = new Date(startDate);\n      const checkEnd = endDate ? new Date(endDate) : checkStart;\n\n      // Two events overlap if:\n      // (StartA <= EndB) and (EndA >= StartB)\n      return eventStart <= checkEnd && eventEnd >= checkStart;\n    });\n\n    return {\n      success: true,\n      data: {\n        hasConflict: conflictingEvents.length > 0,\n        conflictingEvents: conflictingEvents.map((event) => ({\n          id: event.id,\n          name: event.name,\n          startDate: event.start_date,\n          endDate: event.end_date,\n        })),\n      },\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error',\n      },\n    };\n  }\n}\n\n/**\n * Retrieves a single event by slug.\n *\n * @param slug - Event slug (URL-safe identifier)\n * @returns Result containing the event or error details\n *\n * @example\n * const result = await eventService.getBySlug('wedding-ceremony');\n */\nexport async function getBySlug(slug: string): Promise<Result<Event>> {\n  try {\n    // Validate slug format\n    if (!slug || typeof slug !== 'string' || slug.trim() === '') {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Invalid slug provided',\n        },\n      };\n    }\n\n    const supabase = createClient(\n      process.env.NEXT_PUBLIC_SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!\n    );\n\n    const { data, error } = await supabase\n      .from('events')\n      .select('*')\n      .eq('slug', slug.toLowerCase())\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return {\n          success: false,\n          error: { code: 'NOT_FOUND', message: 'Event not found' },\n        };\n      }\n      return {\n        success: false,\n        error: { code: 'DATABASE_ERROR', message: error.message, details: error },\n      };\n    }\n\n    return { success: true, data: toCamelCase(data) as Event };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error',\n      },\n    };\n  }\n}\n"],"names":["checkSchedulingConflicts","create","deleteEvent","get","getBySlug","list","restoreEvent","search","update","toSnakeCase","obj","snakeObj","key","snakeKey","replace","letter","toLowerCase","toCamelCase","camelObj","camelKey","_","toUpperCase","ensureUniqueSlug","slug","excludeId","supabase","createClient","process","env","NEXT_PUBLIC_SUPABASE_URL","SUPABASE_SERVICE_ROLE_KEY","query","from","select","neq","data","error","existingSlugs","map","event","filter","Boolean","makeUniqueSlug","validation","createEventSchema","safeParse","success","code","message","details","issues","sanitized","name","sanitizeInput","description","sanitizeRichText","baseSlug","generateSlug","isValidSlug","field","value","reason","uniqueSlug","sanitizedWithSlug","locationId","conflictCheck","startDate","endDate","hasConflict","conflictingEvents","dbData","result","insert","single","Error","id","eq","updateEventSchema","currentEvent","undefined","excludeEventId","options","permanent","deletedBy","delete","now","Date","toISOString","deleted_at","deleted_by","is","activities","length","activityIds","a","in","not","filters","eventFilterSchema","page","pageSize","filterParams","to","count","eventType","status","startDateFrom","gte","startDateTo","lte","order","ascending","range","events","total","totalPages","Math","ceil","searchParams","eventSearchSchema","sanitizedQuery","or","params","conflictCheckSchema","eventStart","start_date","eventEnd","end_date","checkStart","checkEnd","trim"],"mappings":"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"}