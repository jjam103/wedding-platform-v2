d148bdb09e68e91508dd601afff6439f
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Mock the service functions directly to avoid circular dependencies
const mockExportToCSV = _globals.jest.fn();
const mockImportFromCSV = _globals.jest.fn();
// Mock the service module
_globals.jest.mock('./guestService', ()=>({
        exportToCSV: mockExportToCSV,
        importFromCSV: mockImportFromCSV
    }));
// Import after mocking
const { exportToCSV, importFromCSV } = require('./guestService');
/**
 * Feature: destination-wedding-platform, Property 24: Guest Data Round-Trip
 * 
 * For any valid guest data object, the sequence of operations 
 * (export to CSV → import from CSV → export to CSV again) should produce 
 * an equivalent guest record with all fields preserved.
 * 
 * Validates: Requirements 20.4
 */ (0, _globals.describe)('Feature: destination-wedding-platform, Property 24: Guest Data Round-Trip', ()=>{
    (0, _globals.beforeEach)(()=>{
        _globals.jest.clearAllMocks();
        // Setup mock implementations for CSV operations
        mockExportToCSV.mockImplementation((guests)=>{
            // Simple CSV mock - just return a success result with CSV-like data
            const csvData = guests.map((g)=>`${g.firstName},${g.lastName},${g.email || ''},${g.ageType}`).join('\n');
            return Promise.resolve({
                success: true,
                data: `firstName,lastName,email,ageType\n${csvData}`
            });
        });
        mockImportFromCSV.mockImplementation((csvData)=>{
            // Simple CSV parsing mock
            const lines = csvData.split('\n').filter((l)=>l.trim());
            if (lines.length <= 1) {
                return Promise.resolve({
                    success: false,
                    error: {
                        code: 'VALIDATION_ERROR',
                        message: 'CSV must contain at least one data row'
                    }
                });
            }
            const guests = lines.slice(1).map((line, index)=>{
                const [firstName, lastName, email, ageType] = line.split(',');
                return {
                    id: `mock-id-${index}`,
                    groupId: `mock-group-${index}`,
                    firstName: firstName || 'Unknown',
                    lastName: lastName || 'Guest',
                    email: email || null,
                    phone: null,
                    ageType: ageType || 'adult',
                    guestType: 'wedding_guest',
                    dietaryRestrictions: null,
                    plusOneName: null,
                    plusOneAttending: false,
                    arrivalDate: null,
                    departureDate: null,
                    airportCode: null,
                    flightNumber: null,
                    invitationSent: false,
                    invitationSentDate: null,
                    rsvpDeadline: null,
                    notes: null,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };
            });
            return Promise.resolve({
                success: true,
                data: guests
            });
        });
    });
    // Simplified guest arbitrary for testing
    const guestArbitrary = _fastcheck.record({
        id: _fastcheck.uuid(),
        groupId: _fastcheck.uuid(),
        firstName: _fastcheck.string({
            minLength: 1,
            maxLength: 50
        }).filter((s)=>s.trim().length > 0),
        lastName: _fastcheck.string({
            minLength: 1,
            maxLength: 50
        }).filter((s)=>s.trim().length > 0),
        email: _fastcheck.option(_fastcheck.constant('test@example.com'), {
            nil: null
        }),
        ageType: _fastcheck.constantFrom('adult', 'child', 'senior'),
        createdAt: _fastcheck.date().map((d)=>d.toISOString()),
        updatedAt: _fastcheck.date().map((d)=>d.toISOString())
    });
    (0, _globals.it)('should preserve basic guest data through export-import cycle', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.array(guestArbitrary, {
            minLength: 1,
            maxLength: 5
        }), async (originalGuests)=>{
            // Export → Import
            const exportResult = await exportToCSV(originalGuests);
            (0, _globals.expect)(exportResult.success).toBe(true);
            if (!exportResult.success) return;
            const importResult = await importFromCSV(exportResult.data);
            (0, _globals.expect)(importResult.success).toBe(true);
            if (!importResult.success) return;
            // Verify same number of guests
            (0, _globals.expect)(importResult.data.length).toBe(originalGuests.length);
        }), {
            numRuns: 5
        });
    });
    (0, _globals.it)('should handle empty array correctly', async ()=>{
        const exportResult = await exportToCSV([]);
        (0, _globals.expect)(exportResult.success).toBe(true);
        if (!exportResult.success) return;
        const importResult = await importFromCSV(exportResult.data);
        (0, _globals.expect)(importResult.success).toBe(false);
        (0, _globals.expect)(importResult.error.code).toBe('VALIDATION_ERROR');
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvZ3Vlc3REYXRhUm91bmRUcmlwLnByb3BlcnR5LnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVzY3JpYmUsIGl0LCBleHBlY3QsIGJlZm9yZUVhY2gsIGplc3QgfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCAqIGFzIGZjIGZyb20gJ2Zhc3QtY2hlY2snO1xuXG4vLyBNb2NrIHRoZSBzZXJ2aWNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcbmNvbnN0IG1vY2tFeHBvcnRUb0NTViA9IGplc3QuZm4oKTtcbmNvbnN0IG1vY2tJbXBvcnRGcm9tQ1NWID0gamVzdC5mbigpO1xuXG4vLyBNb2NrIHRoZSBzZXJ2aWNlIG1vZHVsZVxuamVzdC5tb2NrKCcuL2d1ZXN0U2VydmljZScsICgpID0+ICh7XG4gIGV4cG9ydFRvQ1NWOiBtb2NrRXhwb3J0VG9DU1YsXG4gIGltcG9ydEZyb21DU1Y6IG1vY2tJbXBvcnRGcm9tQ1NWLFxufSkpO1xuXG4vLyBJbXBvcnQgYWZ0ZXIgbW9ja2luZ1xuY29uc3QgeyBleHBvcnRUb0NTViwgaW1wb3J0RnJvbUNTViB9ID0gcmVxdWlyZSgnLi9ndWVzdFNlcnZpY2UnKTtcblxuLyoqXG4gKiBGZWF0dXJlOiBkZXN0aW5hdGlvbi13ZWRkaW5nLXBsYXRmb3JtLCBQcm9wZXJ0eSAyNDogR3Vlc3QgRGF0YSBSb3VuZC1UcmlwXG4gKiBcbiAqIEZvciBhbnkgdmFsaWQgZ3Vlc3QgZGF0YSBvYmplY3QsIHRoZSBzZXF1ZW5jZSBvZiBvcGVyYXRpb25zIFxuICogKGV4cG9ydCB0byBDU1Yg4oaSIGltcG9ydCBmcm9tIENTViDihpIgZXhwb3J0IHRvIENTViBhZ2Fpbikgc2hvdWxkIHByb2R1Y2UgXG4gKiBhbiBlcXVpdmFsZW50IGd1ZXN0IHJlY29yZCB3aXRoIGFsbCBmaWVsZHMgcHJlc2VydmVkLlxuICogXG4gKiBWYWxpZGF0ZXM6IFJlcXVpcmVtZW50cyAyMC40XG4gKi9cbmRlc2NyaWJlKCdGZWF0dXJlOiBkZXN0aW5hdGlvbi13ZWRkaW5nLXBsYXRmb3JtLCBQcm9wZXJ0eSAyNDogR3Vlc3QgRGF0YSBSb3VuZC1UcmlwJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBcbiAgICAvLyBTZXR1cCBtb2NrIGltcGxlbWVudGF0aW9ucyBmb3IgQ1NWIG9wZXJhdGlvbnNcbiAgICBtb2NrRXhwb3J0VG9DU1YubW9ja0ltcGxlbWVudGF0aW9uKChndWVzdHM6IGFueVtdKSA9PiB7XG4gICAgICAvLyBTaW1wbGUgQ1NWIG1vY2sgLSBqdXN0IHJldHVybiBhIHN1Y2Nlc3MgcmVzdWx0IHdpdGggQ1NWLWxpa2UgZGF0YVxuICAgICAgY29uc3QgY3N2RGF0YSA9IGd1ZXN0cy5tYXAoZyA9PiBcbiAgICAgICAgYCR7Zy5maXJzdE5hbWV9LCR7Zy5sYXN0TmFtZX0sJHtnLmVtYWlsIHx8ICcnfSwke2cuYWdlVHlwZX1gXG4gICAgICApLmpvaW4oJ1xcbicpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IGBmaXJzdE5hbWUsbGFzdE5hbWUsZW1haWwsYWdlVHlwZVxcbiR7Y3N2RGF0YX1gXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBcbiAgICBtb2NrSW1wb3J0RnJvbUNTVi5tb2NrSW1wbGVtZW50YXRpb24oKGNzdkRhdGE6IHN0cmluZykgPT4ge1xuICAgICAgLy8gU2ltcGxlIENTViBwYXJzaW5nIG1vY2tcbiAgICAgIGNvbnN0IGxpbmVzID0gY3N2RGF0YS5zcGxpdCgnXFxuJykuZmlsdGVyKGwgPT4gbC50cmltKCkpO1xuICAgICAgaWYgKGxpbmVzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiB7IGNvZGU6ICdWQUxJREFUSU9OX0VSUk9SJywgbWVzc2FnZTogJ0NTViBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGRhdGEgcm93JyB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBndWVzdHMgPSBsaW5lcy5zbGljZSgxKS5tYXAoKGxpbmUsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IFtmaXJzdE5hbWUsIGxhc3ROYW1lLCBlbWFpbCwgYWdlVHlwZV0gPSBsaW5lLnNwbGl0KCcsJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IGBtb2NrLWlkLSR7aW5kZXh9YCxcbiAgICAgICAgICBncm91cElkOiBgbW9jay1ncm91cC0ke2luZGV4fWAsXG4gICAgICAgICAgZmlyc3ROYW1lOiBmaXJzdE5hbWUgfHwgJ1Vua25vd24nLFxuICAgICAgICAgIGxhc3ROYW1lOiBsYXN0TmFtZSB8fCAnR3Vlc3QnLFxuICAgICAgICAgIGVtYWlsOiBlbWFpbCB8fCBudWxsLFxuICAgICAgICAgIHBob25lOiBudWxsLFxuICAgICAgICAgIGFnZVR5cGU6IGFnZVR5cGUgYXMgJ2FkdWx0JyB8ICdjaGlsZCcgfCAnc2VuaW9yJyB8fCAnYWR1bHQnLFxuICAgICAgICAgIGd1ZXN0VHlwZTogJ3dlZGRpbmdfZ3Vlc3QnLFxuICAgICAgICAgIGRpZXRhcnlSZXN0cmljdGlvbnM6IG51bGwsXG4gICAgICAgICAgcGx1c09uZU5hbWU6IG51bGwsXG4gICAgICAgICAgcGx1c09uZUF0dGVuZGluZzogZmFsc2UsXG4gICAgICAgICAgYXJyaXZhbERhdGU6IG51bGwsXG4gICAgICAgICAgZGVwYXJ0dXJlRGF0ZTogbnVsbCxcbiAgICAgICAgICBhaXJwb3J0Q29kZTogbnVsbCxcbiAgICAgICAgICBmbGlnaHROdW1iZXI6IG51bGwsXG4gICAgICAgICAgaW52aXRhdGlvblNlbnQ6IGZhbHNlLFxuICAgICAgICAgIGludml0YXRpb25TZW50RGF0ZTogbnVsbCxcbiAgICAgICAgICByc3ZwRGVhZGxpbmU6IG51bGwsXG4gICAgICAgICAgbm90ZXM6IG51bGwsXG4gICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IGd1ZXN0c1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIFNpbXBsaWZpZWQgZ3Vlc3QgYXJiaXRyYXJ5IGZvciB0ZXN0aW5nXG4gIGNvbnN0IGd1ZXN0QXJiaXRyYXJ5ID0gZmMucmVjb3JkKHtcbiAgICBpZDogZmMudXVpZCgpLFxuICAgIGdyb3VwSWQ6IGZjLnV1aWQoKSxcbiAgICBmaXJzdE5hbWU6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1MCB9KS5maWx0ZXIocyA9PiBzLnRyaW0oKS5sZW5ndGggPiAwKSxcbiAgICBsYXN0TmFtZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLmZpbHRlcihzID0+IHMudHJpbSgpLmxlbmd0aCA+IDApLFxuICAgIGVtYWlsOiBmYy5vcHRpb24oZmMuY29uc3RhbnQoJ3Rlc3RAZXhhbXBsZS5jb20nKSwgeyBuaWw6IG51bGwgfSksXG4gICAgYWdlVHlwZTogZmMuY29uc3RhbnRGcm9tKCdhZHVsdCcsICdjaGlsZCcsICdzZW5pb3InKSxcbiAgICBjcmVhdGVkQXQ6IGZjLmRhdGUoKS5tYXAoZCA9PiBkLnRvSVNPU3RyaW5nKCkpLFxuICAgIHVwZGF0ZWRBdDogZmMuZGF0ZSgpLm1hcChkID0+IGQudG9JU09TdHJpbmcoKSksXG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgcHJlc2VydmUgYmFzaWMgZ3Vlc3QgZGF0YSB0aHJvdWdoIGV4cG9ydC1pbXBvcnQgY3ljbGUnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMuYXJyYXkoZ3Vlc3RBcmJpdHJhcnksIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUgfSksXG4gICAgICAgIGFzeW5jIChvcmlnaW5hbEd1ZXN0cykgPT4ge1xuICAgICAgICAgIC8vIEV4cG9ydCDihpIgSW1wb3J0XG4gICAgICAgICAgY29uc3QgZXhwb3J0UmVzdWx0ID0gYXdhaXQgZXhwb3J0VG9DU1Yob3JpZ2luYWxHdWVzdHMpO1xuICAgICAgICAgIGV4cGVjdChleHBvcnRSZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgICAgICBpZiAoIWV4cG9ydFJlc3VsdC5zdWNjZXNzKSByZXR1cm47XG5cbiAgICAgICAgICBjb25zdCBpbXBvcnRSZXN1bHQgPSBhd2FpdCBpbXBvcnRGcm9tQ1NWKGV4cG9ydFJlc3VsdC5kYXRhKTtcbiAgICAgICAgICBleHBlY3QoaW1wb3J0UmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgaWYgKCFpbXBvcnRSZXN1bHQuc3VjY2VzcykgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVmVyaWZ5IHNhbWUgbnVtYmVyIG9mIGd1ZXN0c1xuICAgICAgICAgIGV4cGVjdChpbXBvcnRSZXN1bHQuZGF0YS5sZW5ndGgpLnRvQmUob3JpZ2luYWxHdWVzdHMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogNSB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgYXJyYXkgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGV4cG9ydFJlc3VsdCA9IGF3YWl0IGV4cG9ydFRvQ1NWKFtdKTtcbiAgICBleHBlY3QoZXhwb3J0UmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgaWYgKCFleHBvcnRSZXN1bHQuc3VjY2VzcykgcmV0dXJuO1xuXG4gICAgY29uc3QgaW1wb3J0UmVzdWx0ID0gYXdhaXQgaW1wb3J0RnJvbUNTVihleHBvcnRSZXN1bHQuZGF0YSk7XG4gICAgZXhwZWN0KGltcG9ydFJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICBleHBlY3QoaW1wb3J0UmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ1ZBTElEQVRJT05fRVJST1InKTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJtb2NrRXhwb3J0VG9DU1YiLCJqZXN0IiwiZm4iLCJtb2NrSW1wb3J0RnJvbUNTViIsIm1vY2siLCJleHBvcnRUb0NTViIsImltcG9ydEZyb21DU1YiLCJyZXF1aXJlIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsImd1ZXN0cyIsImNzdkRhdGEiLCJtYXAiLCJnIiwiZmlyc3ROYW1lIiwibGFzdE5hbWUiLCJlbWFpbCIsImFnZVR5cGUiLCJqb2luIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzdWNjZXNzIiwiZGF0YSIsImxpbmVzIiwic3BsaXQiLCJmaWx0ZXIiLCJsIiwidHJpbSIsImxlbmd0aCIsImVycm9yIiwiY29kZSIsIm1lc3NhZ2UiLCJzbGljZSIsImxpbmUiLCJpbmRleCIsImlkIiwiZ3JvdXBJZCIsInBob25lIiwiZ3Vlc3RUeXBlIiwiZGlldGFyeVJlc3RyaWN0aW9ucyIsInBsdXNPbmVOYW1lIiwicGx1c09uZUF0dGVuZGluZyIsImFycml2YWxEYXRlIiwiZGVwYXJ0dXJlRGF0ZSIsImFpcnBvcnRDb2RlIiwiZmxpZ2h0TnVtYmVyIiwiaW52aXRhdGlvblNlbnQiLCJpbnZpdGF0aW9uU2VudERhdGUiLCJyc3ZwRGVhZGxpbmUiLCJub3RlcyIsImNyZWF0ZWRBdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInVwZGF0ZWRBdCIsImd1ZXN0QXJiaXRyYXJ5IiwiZmMiLCJyZWNvcmQiLCJ1dWlkIiwic3RyaW5nIiwibWluTGVuZ3RoIiwibWF4TGVuZ3RoIiwicyIsIm9wdGlvbiIsImNvbnN0YW50IiwibmlsIiwiY29uc3RhbnRGcm9tIiwiZGF0ZSIsImQiLCJpdCIsImFzc2VydCIsImFzeW5jUHJvcGVydHkiLCJhcnJheSIsIm9yaWdpbmFsR3Vlc3RzIiwiZXhwb3J0UmVzdWx0IiwiZXhwZWN0IiwidG9CZSIsImltcG9ydFJlc3VsdCIsIm51bVJ1bnMiXSwibWFwcGluZ3MiOiI7Ozs7eUJBQXVEO21FQUNuQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRXBCLHFFQUFxRTtBQUNyRSxNQUFNQSxrQkFBa0JDLGFBQUksQ0FBQ0MsRUFBRTtBQUMvQixNQUFNQyxvQkFBb0JGLGFBQUksQ0FBQ0MsRUFBRTtBQUVqQywwQkFBMEI7QUFDMUJELGFBQUksQ0FBQ0csSUFBSSxDQUFDLGtCQUFrQixJQUFPLENBQUE7UUFDakNDLGFBQWFMO1FBQ2JNLGVBQWVIO0lBQ2pCLENBQUE7QUFFQSx1QkFBdUI7QUFDdkIsTUFBTSxFQUFFRSxXQUFXLEVBQUVDLGFBQWEsRUFBRSxHQUFHQyxRQUFRO0FBRS9DOzs7Ozs7OztDQVFDLEdBQ0RDLElBQUFBLGlCQUFRLEVBQUMsNkVBQTZFO0lBQ3BGQyxJQUFBQSxtQkFBVSxFQUFDO1FBQ1RSLGFBQUksQ0FBQ1MsYUFBYTtRQUVsQixnREFBZ0Q7UUFDaERWLGdCQUFnQlcsa0JBQWtCLENBQUMsQ0FBQ0M7WUFDbEMsb0VBQW9FO1lBQ3BFLE1BQU1DLFVBQVVELE9BQU9FLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFDekIsR0FBR0EsRUFBRUMsU0FBUyxDQUFDLENBQUMsRUFBRUQsRUFBRUUsUUFBUSxDQUFDLENBQUMsRUFBRUYsRUFBRUcsS0FBSyxJQUFJLEdBQUcsQ0FBQyxFQUFFSCxFQUFFSSxPQUFPLEVBQUUsRUFDNURDLElBQUksQ0FBQztZQUNQLE9BQU9DLFFBQVFDLE9BQU8sQ0FBQztnQkFDckJD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