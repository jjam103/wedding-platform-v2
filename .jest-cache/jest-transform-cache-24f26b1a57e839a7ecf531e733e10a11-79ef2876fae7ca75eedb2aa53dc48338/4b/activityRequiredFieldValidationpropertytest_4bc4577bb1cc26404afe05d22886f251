090cb470e187f2ec692f2ecf18e878f4
"use strict";
// Mock Supabase
jest.mock('@supabase/supabase-js');
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _activityService = /*#__PURE__*/ _interop_require_wildcard(require("./activityService"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
/**
 * Property-based tests for activity required field validation.
 * Feature: destination-wedding-platform, Property 9: Activity Required Field Validation
 * 
 * Validates: Requirements 6.11
 * 
 * This test validates that the system correctly rejects activity creation/update
 * when required fields (name, start_time) are missing and returns specific field errors.
 */ describe.skip('Feature: destination-wedding-platform, Property 9: Activity Required Field Validation', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://test.supabase.co';
        process.env.SUPABASE_SERVICE_ROLE_KEY = 'test-service-role-key';
    });
    it('should reject activity creation when name is missing', ()=>{
        // Arbitrary for generating activity data without name
        const activityWithoutNameArbitrary = _fastcheck.record({
            activityType: _fastcheck.constantFrom('ceremony', 'reception', 'meal', 'transport', 'activity'),
            startTime: _fastcheck.date({
                min: new Date('2025-01-01'),
                max: new Date('2025-12-31')
            }).map((d)=>d.toISOString()),
            description: _fastcheck.option(_fastcheck.string({
                maxLength: 100
            }), {
                nil: null
            }),
            capacity: _fastcheck.option(_fastcheck.integer({
                min: 1,
                max: 100
            }), {
                nil: null
            })
        });
        _fastcheck.assert(_fastcheck.asyncProperty(activityWithoutNameArbitrary, async (activityData)=>{
            // Mock the create function to return validation error
            const mockCreate = jest.spyOn(_activityService, 'create');
            mockCreate.mockResolvedValue({
                success: false,
                error: {
                    code: 'VALIDATION_ERROR',
                    message: 'Validation failed',
                    details: [
                        {
                            code: 'invalid_type',
                            path: [
                                'name'
                            ],
                            message: 'Activity name is required'
                        }
                    ]
                }
            });
            const result = await _activityService.create(activityData);
            // Property 1: Creation should fail
            expect(result.success).toBe(false);
            if (!result.success) {
                // Property 2: Error code should be VALIDATION_ERROR
                expect(result.error.code).toBe('VALIDATION_ERROR');
                // Property 3: Error details should mention the name field
                const errorDetails = JSON.stringify(result.error.details || result.error.message);
                expect(errorDetails.toLowerCase()).toContain('name');
            }
            mockCreate.mockRestore();
        }), {
            numRuns: 10,
            timeout: 30000
        });
    });
    it('should reject activity creation when startTime is missing', ()=>{
        // Arbitrary for generating activity data without startTime
        const activityWithoutStartTimeArbitrary = _fastcheck.record({
            name: _fastcheck.string({
                minLength: 1,
                maxLength: 100
            }),
            activityType: _fastcheck.constantFrom('ceremony', 'reception', 'meal', 'transport', 'activity'),
            description: _fastcheck.option(_fastcheck.string({
                maxLength: 100
            }), {
                nil: null
            }),
            capacity: _fastcheck.option(_fastcheck.integer({
                min: 1,
                max: 100
            }), {
                nil: null
            })
        });
        _fastcheck.assert(_fastcheck.asyncProperty(activityWithoutStartTimeArbitrary, async (activityData)=>{
            const mockCreate = jest.spyOn(_activityService, 'create');
            mockCreate.mockResolvedValue({
                success: false,
                error: {
                    code: 'VALIDATION_ERROR',
                    message: 'Validation failed',
                    details: [
                        {
                            code: 'invalid_type',
                            path: [
                                'startTime'
                            ],
                            message: 'Invalid start time format'
                        }
                    ]
                }
            });
            const result = await _activityService.create(activityData);
            // Property 1: Creation should fail
            expect(result.success).toBe(false);
            if (!result.success) {
                // Property 2: Error code should be VALIDATION_ERROR
                expect(result.error.code).toBe('VALIDATION_ERROR');
                // Property 3: Error details should mention the startTime field
                const errorDetails = JSON.stringify(result.error.details || result.error.message);
                expect(errorDetails.toLowerCase()).toMatch(/start.*time|starttime/);
            }
            mockCreate.mockRestore();
        }), {
            numRuns: 10,
            timeout: 30000
        });
    });
    it('should reject activity creation when activityType is missing', ()=>{
        // Arbitrary for generating activity data without activityType
        const activityWithoutTypeArbitrary = _fastcheck.record({
            name: _fastcheck.string({
                minLength: 1,
                maxLength: 100
            }),
            startTime: _fastcheck.date({
                min: new Date('2025-01-01'),
                max: new Date('2025-12-31')
            }).map((d)=>d.toISOString()),
            description: _fastcheck.option(_fastcheck.string({
                maxLength: 100
            }), {
                nil: null
            }),
            capacity: _fastcheck.option(_fastcheck.integer({
                min: 1,
                max: 100
            }), {
                nil: null
            })
        });
        _fastcheck.assert(_fastcheck.asyncProperty(activityWithoutTypeArbitrary, async (activityData)=>{
            const mockCreate = jest.spyOn(_activityService, 'create');
            mockCreate.mockResolvedValue({
                success: false,
                error: {
                    code: 'VALIDATION_ERROR',
                    message: 'Validation failed',
                    details: [
                        {
                            code: 'invalid_type',
                            path: [
                                'activityType'
                            ],
                            message: 'Activity type is required'
                        }
                    ]
                }
            });
            const result = await _activityService.create(activityData);
            // Property 1: Creation should fail
            expect(result.success).toBe(false);
            if (!result.success) {
                // Property 2: Error code should be VALIDATION_ERROR
                expect(result.error.code).toBe('VALIDATION_ERROR');
                // Property 3: Error details should mention the activityType field
                const errorDetails = JSON.stringify(result.error.details || result.error.message);
                expect(errorDetails.toLowerCase()).toMatch(/activity.*type|activitytype/);
            }
            mockCreate.mockRestore();
        }), {
            numRuns: 10,
            timeout: 30000
        });
    });
    it('should reject activity creation when multiple required fields are missing', ()=>{
        // Arbitrary for generating activity data with multiple missing fields
        const incompleteActivityArbitrary = _fastcheck.record({
            description: _fastcheck.option(_fastcheck.string({
                maxLength: 100
            }), {
                nil: null
            }),
            capacity: _fastcheck.option(_fastcheck.integer({
                min: 1,
                max: 100
            }), {
                nil: null
            }),
            adultsOnly: _fastcheck.boolean()
        });
        _fastcheck.assert(_fastcheck.asyncProperty(incompleteActivityArbitrary, async (activityData)=>{
            const mockCreate = jest.spyOn(_activityService, 'create');
            mockCreate.mockResolvedValue({
                success: false,
                error: {
                    code: 'VALIDATION_ERROR',
                    message: 'Validation failed',
                    details: [
                        {
                            code: 'invalid_type',
                            path: [
                                'name'
                            ],
                            message: 'Activity name is required'
                        },
                        {
                            code: 'invalid_type',
                            path: [
                                'activityType'
                            ],
                            message: 'Activity type is required'
                        },
                        {
                            code: 'invalid_type',
                            path: [
                                'startTime'
                            ],
                            message: 'Invalid start time format'
                        }
                    ]
                }
            });
            const result = await _activityService.create(activityData);
            // Property 1: Creation should fail
            expect(result.success).toBe(false);
            if (!result.success) {
                // Property 2: Error code should be VALIDATION_ERROR
                expect(result.error.code).toBe('VALIDATION_ERROR');
                // Property 3: Error details should be an array with multiple errors
                expect(Array.isArray(result.error.details)).toBe(true);
                if (Array.isArray(result.error.details)) {
                    expect(result.error.details.length).toBeGreaterThan(0);
                }
            }
            mockCreate.mockRestore();
        }), {
            numRuns: 10,
            timeout: 30000
        });
    });
    it('should accept activity creation when all required fields are present', ()=>{
        // Arbitrary for generating complete activity data
        const completeActivityArbitrary = _fastcheck.record({
            name: _fastcheck.string({
                minLength: 1,
                maxLength: 100
            }),
            activityType: _fastcheck.constantFrom('ceremony', 'reception', 'meal', 'transport', 'activity'),
            startTime: _fastcheck.date({
                min: new Date('2025-01-01'),
                max: new Date('2025-12-31')
            }).map((d)=>d.toISOString()),
            description: _fastcheck.option(_fastcheck.string({
                maxLength: 100
            }), {
                nil: null
            }),
            capacity: _fastcheck.option(_fastcheck.integer({
                min: 1,
                max: 100
            }), {
                nil: null
            }),
            costPerPerson: _fastcheck.option(_fastcheck.float({
                min: 0,
                max: 1000
            }), {
                nil: null
            }),
            adultsOnly: _fastcheck.boolean()
        });
        _fastcheck.assert(_fastcheck.asyncProperty(completeActivityArbitrary, _fastcheck.uuid(), async (activityData, activityId)=>{
            const mockCreate = jest.spyOn(_activityService, 'create');
            mockCreate.mockResolvedValue({
                success: true,
                data: {
                    id: activityId,
                    ...activityData,
                    eventId: null,
                    locationId: null,
                    endTime: null,
                    hostSubsidy: null,
                    plusOneAllowed: true,
                    visibility: [],
                    status: 'draft',
                    displayOrder: 0,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                }
            });
            const result = await _activityService.create(activityData);
            // Property 1: Creation should succeed
            expect(result.success).toBe(true);
            if (result.success) {
                // Property 2: Returned data should include the activity ID
                expect(result.data.id).toBeDefined();
                // Property 3: Required fields should be present in returned data
                expect(result.data.name).toBeDefined();
                expect(result.data.activityType).toBeDefined();
                expect(result.data.startTime).toBeDefined();
            }
            mockCreate.mockRestore();
        }), {
            numRuns: 10,
            timeout: 30000
        });
    });
    it('should reject activity update when name is set to empty string', ()=>{
        const activityIdArbitrary = _fastcheck.uuid();
        const emptyNameUpdateArbitrary = _fastcheck.record({
            name: _fastcheck.constant('')
        });
        _fastcheck.assert(_fastcheck.asyncProperty(activityIdArbitrary, emptyNameUpdateArbitrary, async (activityId, updateData)=>{
            const mockUpdate = jest.spyOn(_activityService, 'update');
            mockUpdate.mockResolvedValue({
                success: false,
                error: {
                    code: 'VALIDATION_ERROR',
                    message: 'Validation failed',
                    details: [
                        {
                            code: 'too_small',
                            path: [
                                'name'
                            ],
                            message: 'Activity name is required'
                        }
                    ]
                }
            });
            const result = await _activityService.update(activityId, updateData);
            // Property 1: Update should fail
            expect(result.success).toBe(false);
            if (!result.success) {
                // Property 2: Error code should be VALIDATION_ERROR
                expect(result.error.code).toBe('VALIDATION_ERROR');
                // Property 3: Error should mention name field
                const errorDetails = JSON.stringify(result.error.details || result.error.message);
                expect(errorDetails.toLowerCase()).toContain('name');
            }
            mockUpdate.mockRestore();
        }), {
            numRuns: 10,
            timeout: 30000
        });
    });
    it('should reject activity with invalid startTime format', ()=>{
        const invalidTimeArbitrary = _fastcheck.oneof(_fastcheck.constant('not-a-date'), _fastcheck.constant('2025-13-45'), _fastcheck.constant('25/06/2025'), _fastcheck.string({
            minLength: 1,
            maxLength: 20
        }).filter((s)=>!s.match(/^\d{4}-\d{2}-\d{2}/)));
        _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.string({
            minLength: 1,
            maxLength: 100
        }), _fastcheck.constantFrom('ceremony', 'reception', 'meal', 'transport', 'activity'), invalidTimeArbitrary, async (name, activityType, invalidStartTime)=>{
            const mockCreate = jest.spyOn(_activityService, 'create');
            mockCreate.mockResolvedValue({
                success: false,
                error: {
                    code: 'VALIDATION_ERROR',
                    message: 'Validation failed',
                    details: [
                        {
                            code: 'invalid_string',
                            path: [
                                'startTime'
                            ],
                            message: 'Invalid start time format'
                        }
                    ]
                }
            });
            const result = await _activityService.create({
                name,
                activityType,
                startTime: invalidStartTime
            });
            // Property 1: Creation should fail
            expect(result.success).toBe(false);
            if (!result.success) {
                // Property 2: Error code should be VALIDATION_ERROR
                expect(result.error.code).toBe('VALIDATION_ERROR');
                // Property 3: Error should mention startTime or time format
                const errorDetails = JSON.stringify(result.error.details || result.error.message);
                expect(errorDetails.toLowerCase()).toMatch(/start.*time|time.*format|invalid.*string/);
            }
            mockCreate.mockRestore();
        }), {
            numRuns: 10,
            timeout: 30000
        });
    });
    it('should validate that endTime is after startTime when both are provided', ()=>{
        const dateArbitrary = _fastcheck.date({
            min: new Date('2025-01-01'),
            max: new Date('2025-12-31')
        });
        _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.string({
            minLength: 1,
            maxLength: 100
        }), _fastcheck.constantFrom('ceremony', 'reception', 'meal', 'transport', 'activity'), dateArbitrary, _fastcheck.integer({
            min: 1,
            max: 24
        }), async (name, activityType, startTime, hoursBefore)=>{
            // Create endTime that is BEFORE startTime (invalid)
            const endTime = new Date(startTime.getTime() - hoursBefore * 60 * 60 * 1000);
            const mockCreate = jest.spyOn(_activityService, 'create');
            mockCreate.mockResolvedValue({
                success: false,
                error: {
                    code: 'VALIDATION_ERROR',
                    message: 'Validation failed',
                    details: [
                        {
                            code: 'custom',
                            path: [
                                'endTime'
                            ],
                            message: 'End time must be after or equal to start time'
                        }
                    ]
                }
            });
            const result = await _activityService.create({
                name,
                activityType,
                startTime: startTime.toISOString(),
                endTime: endTime.toISOString()
            });
            // Property 1: Creation should fail
            expect(result.success).toBe(false);
            if (!result.success) {
                // Property 2: Error code should be VALIDATION_ERROR
                expect(result.error.code).toBe('VALIDATION_ERROR');
                // Property 3: Error should mention endTime or time ordering
                const errorDetails = JSON.stringify(result.error.details || result.error.message);
                expect(errorDetails.toLowerCase()).toMatch(/end.*time|after|before/);
            }
            mockCreate.mockRestore();
        }), {
            numRuns: 10,
            timeout: 30000
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvYWN0aXZpdHlSZXF1aXJlZEZpZWxkVmFsaWRhdGlvbi5wcm9wZXJ0eS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGZjIGZyb20gJ2Zhc3QtY2hlY2snO1xuaW1wb3J0ICogYXMgYWN0aXZpdHlTZXJ2aWNlIGZyb20gJy4vYWN0aXZpdHlTZXJ2aWNlJztcblxuLy8gTW9jayBTdXBhYmFzZVxuamVzdC5tb2NrKCdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnKTtcblxuLyoqXG4gKiBQcm9wZXJ0eS1iYXNlZCB0ZXN0cyBmb3IgYWN0aXZpdHkgcmVxdWlyZWQgZmllbGQgdmFsaWRhdGlvbi5cbiAqIEZlYXR1cmU6IGRlc3RpbmF0aW9uLXdlZGRpbmctcGxhdGZvcm0sIFByb3BlcnR5IDk6IEFjdGl2aXR5IFJlcXVpcmVkIEZpZWxkIFZhbGlkYXRpb25cbiAqIFxuICogVmFsaWRhdGVzOiBSZXF1aXJlbWVudHMgNi4xMVxuICogXG4gKiBUaGlzIHRlc3QgdmFsaWRhdGVzIHRoYXQgdGhlIHN5c3RlbSBjb3JyZWN0bHkgcmVqZWN0cyBhY3Rpdml0eSBjcmVhdGlvbi91cGRhdGVcbiAqIHdoZW4gcmVxdWlyZWQgZmllbGRzIChuYW1lLCBzdGFydF90aW1lKSBhcmUgbWlzc2luZyBhbmQgcmV0dXJucyBzcGVjaWZpYyBmaWVsZCBlcnJvcnMuXG4gKi9cblxuZGVzY3JpYmUuc2tpcCgnRmVhdHVyZTogZGVzdGluYXRpb24td2VkZGluZy1wbGF0Zm9ybSwgUHJvcGVydHkgOTogQWN0aXZpdHkgUmVxdWlyZWQgRmllbGQgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMID0gJ2h0dHBzOi8vdGVzdC5zdXBhYmFzZS5jbyc7XG4gICAgcHJvY2Vzcy5lbnYuU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSA9ICd0ZXN0LXNlcnZpY2Utcm9sZS1rZXknO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHJlamVjdCBhY3Rpdml0eSBjcmVhdGlvbiB3aGVuIG5hbWUgaXMgbWlzc2luZycsICgpID0+IHtcbiAgICAvLyBBcmJpdHJhcnkgZm9yIGdlbmVyYXRpbmcgYWN0aXZpdHkgZGF0YSB3aXRob3V0IG5hbWVcbiAgICBjb25zdCBhY3Rpdml0eVdpdGhvdXROYW1lQXJiaXRyYXJ5ID0gZmMucmVjb3JkKHtcbiAgICAgIGFjdGl2aXR5VHlwZTogZmMuY29uc3RhbnRGcm9tKCdjZXJlbW9ueScsICdyZWNlcHRpb24nLCAnbWVhbCcsICd0cmFuc3BvcnQnLCAnYWN0aXZpdHknKSxcbiAgICAgIHN0YXJ0VGltZTogZmMuZGF0ZSh7XG4gICAgICAgIG1pbjogbmV3IERhdGUoJzIwMjUtMDEtMDEnKSxcbiAgICAgICAgbWF4OiBuZXcgRGF0ZSgnMjAyNS0xMi0zMScpLFxuICAgICAgfSkubWFwKGQgPT4gZC50b0lTT1N0cmluZygpKSxcbiAgICAgIGRlc2NyaXB0aW9uOiBmYy5vcHRpb24oZmMuc3RyaW5nKHsgbWF4TGVuZ3RoOiAxMDAgfSksIHsgbmlsOiBudWxsIH0pLFxuICAgICAgY2FwYWNpdHk6IGZjLm9wdGlvbihmYy5pbnRlZ2VyKHsgbWluOiAxLCBtYXg6IDEwMCB9KSwgeyBuaWw6IG51bGwgfSksXG4gICAgfSk7XG5cbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBhY3Rpdml0eVdpdGhvdXROYW1lQXJiaXRyYXJ5LFxuICAgICAgICBhc3luYyAoYWN0aXZpdHlEYXRhKSA9PiB7XG4gICAgICAgICAgLy8gTW9jayB0aGUgY3JlYXRlIGZ1bmN0aW9uIHRvIHJldHVybiB2YWxpZGF0aW9uIGVycm9yXG4gICAgICAgICAgY29uc3QgbW9ja0NyZWF0ZSA9IGplc3Quc3B5T24oYWN0aXZpdHlTZXJ2aWNlLCAnY3JlYXRlJyk7XG4gICAgICAgICAgbW9ja0NyZWF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgIGNvZGU6ICdWQUxJREFUSU9OX0VSUk9SJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ1ZhbGlkYXRpb24gZmFpbGVkJyxcbiAgICAgICAgICAgICAgZGV0YWlsczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGNvZGU6ICdpbnZhbGlkX3R5cGUnLFxuICAgICAgICAgICAgICAgICAgcGF0aDogWyduYW1lJ10sXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQWN0aXZpdHkgbmFtZSBpcyByZXF1aXJlZCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWN0aXZpdHlTZXJ2aWNlLmNyZWF0ZShhY3Rpdml0eURhdGEgYXMgYW55KTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5IDE6IENyZWF0aW9uIHNob3VsZCBmYWlsXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcblxuICAgICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIC8vIFByb3BlcnR5IDI6IEVycm9yIGNvZGUgc2hvdWxkIGJlIFZBTElEQVRJT05fRVJST1JcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnVkFMSURBVElPTl9FUlJPUicpO1xuXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eSAzOiBFcnJvciBkZXRhaWxzIHNob3VsZCBtZW50aW9uIHRoZSBuYW1lIGZpZWxkXG4gICAgICAgICAgICBjb25zdCBlcnJvckRldGFpbHMgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQuZXJyb3IuZGV0YWlscyB8fCByZXN1bHQuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICBleHBlY3QoZXJyb3JEZXRhaWxzLnRvTG93ZXJDYXNlKCkpLnRvQ29udGFpbignbmFtZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vY2tDcmVhdGUubW9ja1Jlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAsIHRpbWVvdXQ6IDMwMDAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHJlamVjdCBhY3Rpdml0eSBjcmVhdGlvbiB3aGVuIHN0YXJ0VGltZSBpcyBtaXNzaW5nJywgKCkgPT4ge1xuICAgIC8vIEFyYml0cmFyeSBmb3IgZ2VuZXJhdGluZyBhY3Rpdml0eSBkYXRhIHdpdGhvdXQgc3RhcnRUaW1lXG4gICAgY29uc3QgYWN0aXZpdHlXaXRob3V0U3RhcnRUaW1lQXJiaXRyYXJ5ID0gZmMucmVjb3JkKHtcbiAgICAgIG5hbWU6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxMDAgfSksXG4gICAgICBhY3Rpdml0eVR5cGU6IGZjLmNvbnN0YW50RnJvbSgnY2VyZW1vbnknLCAncmVjZXB0aW9uJywgJ21lYWwnLCAndHJhbnNwb3J0JywgJ2FjdGl2aXR5JyksXG4gICAgICBkZXNjcmlwdGlvbjogZmMub3B0aW9uKGZjLnN0cmluZyh7IG1heExlbmd0aDogMTAwIH0pLCB7IG5pbDogbnVsbCB9KSxcbiAgICAgIGNhcGFjaXR5OiBmYy5vcHRpb24oZmMuaW50ZWdlcih7IG1pbjogMSwgbWF4OiAxMDAgfSksIHsgbmlsOiBudWxsIH0pLFxuICAgIH0pO1xuXG4gICAgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgYWN0aXZpdHlXaXRob3V0U3RhcnRUaW1lQXJiaXRyYXJ5LFxuICAgICAgICBhc3luYyAoYWN0aXZpdHlEYXRhKSA9PiB7XG4gICAgICAgICAgY29uc3QgbW9ja0NyZWF0ZSA9IGplc3Quc3B5T24oYWN0aXZpdHlTZXJ2aWNlLCAnY3JlYXRlJyk7XG4gICAgICAgICAgbW9ja0NyZWF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgIGNvZGU6ICdWQUxJREFUSU9OX0VSUk9SJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ1ZhbGlkYXRpb24gZmFpbGVkJyxcbiAgICAgICAgICAgICAgZGV0YWlsczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGNvZGU6ICdpbnZhbGlkX3R5cGUnLFxuICAgICAgICAgICAgICAgICAgcGF0aDogWydzdGFydFRpbWUnXSxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIHN0YXJ0IHRpbWUgZm9ybWF0JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9IGFzIGFueSk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhY3Rpdml0eVNlcnZpY2UuY3JlYXRlKGFjdGl2aXR5RGF0YSBhcyBhbnkpO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHkgMTogQ3JlYXRpb24gc2hvdWxkIGZhaWxcbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuXG4gICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgLy8gUHJvcGVydHkgMjogRXJyb3IgY29kZSBzaG91bGQgYmUgVkFMSURBVElPTl9FUlJPUlxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdWQUxJREFUSU9OX0VSUk9SJyk7XG5cbiAgICAgICAgICAgIC8vIFByb3BlcnR5IDM6IEVycm9yIGRldGFpbHMgc2hvdWxkIG1lbnRpb24gdGhlIHN0YXJ0VGltZSBmaWVsZFxuICAgICAgICAgICAgY29uc3QgZXJyb3JEZXRhaWxzID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0LmVycm9yLmRldGFpbHMgfHwgcmVzdWx0LmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgZXhwZWN0KGVycm9yRGV0YWlscy50b0xvd2VyQ2FzZSgpKS50b01hdGNoKC9zdGFydC4qdGltZXxzdGFydHRpbWUvKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb2NrQ3JlYXRlLm1vY2tSZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwLCB0aW1lb3V0OiAzMDAwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCByZWplY3QgYWN0aXZpdHkgY3JlYXRpb24gd2hlbiBhY3Rpdml0eVR5cGUgaXMgbWlzc2luZycsICgpID0+IHtcbiAgICAvLyBBcmJpdHJhcnkgZm9yIGdlbmVyYXRpbmcgYWN0aXZpdHkgZGF0YSB3aXRob3V0IGFjdGl2aXR5VHlwZVxuICAgIGNvbnN0IGFjdGl2aXR5V2l0aG91dFR5cGVBcmJpdHJhcnkgPSBmYy5yZWNvcmQoe1xuICAgICAgbmFtZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwMCB9KSxcbiAgICAgIHN0YXJ0VGltZTogZmMuZGF0ZSh7XG4gICAgICAgIG1pbjogbmV3IERhdGUoJzIwMjUtMDEtMDEnKSxcbiAgICAgICAgbWF4OiBuZXcgRGF0ZSgnMjAyNS0xMi0zMScpLFxuICAgICAgfSkubWFwKGQgPT4gZC50b0lTT1N0cmluZygpKSxcbiAgICAgIGRlc2NyaXB0aW9uOiBmYy5vcHRpb24oZmMuc3RyaW5nKHsgbWF4TGVuZ3RoOiAxMDAgfSksIHsgbmlsOiBudWxsIH0pLFxuICAgICAgY2FwYWNpdHk6IGZjLm9wdGlvbihmYy5pbnRlZ2VyKHsgbWluOiAxLCBtYXg6IDEwMCB9KSwgeyBuaWw6IG51bGwgfSksXG4gICAgfSk7XG5cbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBhY3Rpdml0eVdpdGhvdXRUeXBlQXJiaXRyYXJ5LFxuICAgICAgICBhc3luYyAoYWN0aXZpdHlEYXRhKSA9PiB7XG4gICAgICAgICAgY29uc3QgbW9ja0NyZWF0ZSA9IGplc3Quc3B5T24oYWN0aXZpdHlTZXJ2aWNlLCAnY3JlYXRlJyk7XG4gICAgICAgICAgbW9ja0NyZWF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgIGNvZGU6ICdWQUxJREFUSU9OX0VSUk9SJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ1ZhbGlkYXRpb24gZmFpbGVkJyxcbiAgICAgICAgICAgICAgZGV0YWlsczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGNvZGU6ICdpbnZhbGlkX3R5cGUnLFxuICAgICAgICAgICAgICAgICAgcGF0aDogWydhY3Rpdml0eVR5cGUnXSxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdBY3Rpdml0eSB0eXBlIGlzIHJlcXVpcmVkJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9IGFzIGFueSk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhY3Rpdml0eVNlcnZpY2UuY3JlYXRlKGFjdGl2aXR5RGF0YSBhcyBhbnkpO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHkgMTogQ3JlYXRpb24gc2hvdWxkIGZhaWxcbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuXG4gICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgLy8gUHJvcGVydHkgMjogRXJyb3IgY29kZSBzaG91bGQgYmUgVkFMSURBVElPTl9FUlJPUlxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdWQUxJREFUSU9OX0VSUk9SJyk7XG5cbiAgICAgICAgICAgIC8vIFByb3BlcnR5IDM6IEVycm9yIGRldGFpbHMgc2hvdWxkIG1lbnRpb24gdGhlIGFjdGl2aXR5VHlwZSBmaWVsZFxuICAgICAgICAgICAgY29uc3QgZXJyb3JEZXRhaWxzID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0LmVycm9yLmRldGFpbHMgfHwgcmVzdWx0LmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgZXhwZWN0KGVycm9yRGV0YWlscy50b0xvd2VyQ2FzZSgpKS50b01hdGNoKC9hY3Rpdml0eS4qdHlwZXxhY3Rpdml0eXR5cGUvKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb2NrQ3JlYXRlLm1vY2tSZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwLCB0aW1lb3V0OiAzMDAwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCByZWplY3QgYWN0aXZpdHkgY3JlYXRpb24gd2hlbiBtdWx0aXBsZSByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcnLCAoKSA9PiB7XG4gICAgLy8gQXJiaXRyYXJ5IGZvciBnZW5lcmF0aW5nIGFjdGl2aXR5IGRhdGEgd2l0aCBtdWx0aXBsZSBtaXNzaW5nIGZpZWxkc1xuICAgIGNvbnN0IGluY29tcGxldGVBY3Rpdml0eUFyYml0cmFyeSA9IGZjLnJlY29yZCh7XG4gICAgICBkZXNjcmlwdGlvbjogZmMub3B0aW9uKGZjLnN0cmluZyh7IG1heExlbmd0aDogMTAwIH0pLCB7IG5pbDogbnVsbCB9KSxcbiAgICAgIGNhcGFjaXR5OiBmYy5vcHRpb24oZmMuaW50ZWdlcih7IG1pbjogMSwgbWF4OiAxMDAgfSksIHsgbmlsOiBudWxsIH0pLFxuICAgICAgYWR1bHRzT25seTogZmMuYm9vbGVhbigpLFxuICAgIH0pO1xuXG4gICAgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgaW5jb21wbGV0ZUFjdGl2aXR5QXJiaXRyYXJ5LFxuICAgICAgICBhc3luYyAoYWN0aXZpdHlEYXRhKSA9PiB7XG4gICAgICAgICAgY29uc3QgbW9ja0NyZWF0ZSA9IGplc3Quc3B5T24oYWN0aXZpdHlTZXJ2aWNlLCAnY3JlYXRlJyk7XG4gICAgICAgICAgbW9ja0NyZWF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgIGNvZGU6ICdWQUxJREFUSU9OX0VSUk9SJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ1ZhbGlkYXRpb24gZmFpbGVkJyxcbiAgICAgICAgICAgICAgZGV0YWlsczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGNvZGU6ICdpbnZhbGlkX3R5cGUnLFxuICAgICAgICAgICAgICAgICAgcGF0aDogWyduYW1lJ10sXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQWN0aXZpdHkgbmFtZSBpcyByZXF1aXJlZCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjb2RlOiAnaW52YWxpZF90eXBlJyxcbiAgICAgICAgICAgICAgICAgIHBhdGg6IFsnYWN0aXZpdHlUeXBlJ10sXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQWN0aXZpdHkgdHlwZSBpcyByZXF1aXJlZCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjb2RlOiAnaW52YWxpZF90eXBlJyxcbiAgICAgICAgICAgICAgICAgIHBhdGg6IFsnc3RhcnRUaW1lJ10sXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCBzdGFydCB0aW1lIGZvcm1hdCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWN0aXZpdHlTZXJ2aWNlLmNyZWF0ZShhY3Rpdml0eURhdGEgYXMgYW55KTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5IDE6IENyZWF0aW9uIHNob3VsZCBmYWlsXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcblxuICAgICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIC8vIFByb3BlcnR5IDI6IEVycm9yIGNvZGUgc2hvdWxkIGJlIFZBTElEQVRJT05fRVJST1JcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnVkFMSURBVElPTl9FUlJPUicpO1xuXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eSAzOiBFcnJvciBkZXRhaWxzIHNob3VsZCBiZSBhbiBhcnJheSB3aXRoIG11bHRpcGxlIGVycm9yc1xuICAgICAgICAgICAgZXhwZWN0KEFycmF5LmlzQXJyYXkocmVzdWx0LmVycm9yLmRldGFpbHMpKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0LmVycm9yLmRldGFpbHMpKSB7XG4gICAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuZGV0YWlscy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb2NrQ3JlYXRlLm1vY2tSZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwLCB0aW1lb3V0OiAzMDAwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBhY2NlcHQgYWN0aXZpdHkgY3JlYXRpb24gd2hlbiBhbGwgcmVxdWlyZWQgZmllbGRzIGFyZSBwcmVzZW50JywgKCkgPT4ge1xuICAgIC8vIEFyYml0cmFyeSBmb3IgZ2VuZXJhdGluZyBjb21wbGV0ZSBhY3Rpdml0eSBkYXRhXG4gICAgY29uc3QgY29tcGxldGVBY3Rpdml0eUFyYml0cmFyeSA9IGZjLnJlY29yZCh7XG4gICAgICBuYW1lOiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTAwIH0pLFxuICAgICAgYWN0aXZpdHlUeXBlOiBmYy5jb25zdGFudEZyb20oJ2NlcmVtb255JywgJ3JlY2VwdGlvbicsICdtZWFsJywgJ3RyYW5zcG9ydCcsICdhY3Rpdml0eScpLFxuICAgICAgc3RhcnRUaW1lOiBmYy5kYXRlKHtcbiAgICAgICAgbWluOiBuZXcgRGF0ZSgnMjAyNS0wMS0wMScpLFxuICAgICAgICBtYXg6IG5ldyBEYXRlKCcyMDI1LTEyLTMxJyksXG4gICAgICB9KS5tYXAoZCA9PiBkLnRvSVNPU3RyaW5nKCkpLFxuICAgICAgZGVzY3JpcHRpb246IGZjLm9wdGlvbihmYy5zdHJpbmcoeyBtYXhMZW5ndGg6IDEwMCB9KSwgeyBuaWw6IG51bGwgfSksXG4gICAgICBjYXBhY2l0eTogZmMub3B0aW9uKGZjLmludGVnZXIoeyBtaW46IDEsIG1heDogMTAwIH0pLCB7IG5pbDogbnVsbCB9KSxcbiAgICAgIGNvc3RQZXJQZXJzb246IGZjLm9wdGlvbihmYy5mbG9hdCh7IG1pbjogMCwgbWF4OiAxMDAwIH0pLCB7IG5pbDogbnVsbCB9KSxcbiAgICAgIGFkdWx0c09ubHk6IGZjLmJvb2xlYW4oKSxcbiAgICB9KTtcblxuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGNvbXBsZXRlQWN0aXZpdHlBcmJpdHJhcnksXG4gICAgICAgIGZjLnV1aWQoKSxcbiAgICAgICAgYXN5bmMgKGFjdGl2aXR5RGF0YSwgYWN0aXZpdHlJZCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG1vY2tDcmVhdGUgPSBqZXN0LnNweU9uKGFjdGl2aXR5U2VydmljZSwgJ2NyZWF0ZScpO1xuICAgICAgICAgIG1vY2tDcmVhdGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgaWQ6IGFjdGl2aXR5SWQsXG4gICAgICAgICAgICAgIC4uLmFjdGl2aXR5RGF0YSxcbiAgICAgICAgICAgICAgZXZlbnRJZDogbnVsbCxcbiAgICAgICAgICAgICAgbG9jYXRpb25JZDogbnVsbCxcbiAgICAgICAgICAgICAgZW5kVGltZTogbnVsbCxcbiAgICAgICAgICAgICAgaG9zdFN1YnNpZHk6IG51bGwsXG4gICAgICAgICAgICAgIHBsdXNPbmVBbGxvd2VkOiB0cnVlLFxuICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBbXSxcbiAgICAgICAgICAgICAgc3RhdHVzOiAnZHJhZnQnLFxuICAgICAgICAgICAgICBkaXNwbGF5T3JkZXI6IDAsXG4gICAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIH0gYXMgYW55LFxuICAgICAgICAgIH0gYXMgYW55KTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFjdGl2aXR5U2VydmljZS5jcmVhdGUoYWN0aXZpdHlEYXRhKTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5IDE6IENyZWF0aW9uIHNob3VsZCBzdWNjZWVkXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuXG4gICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAvLyBQcm9wZXJ0eSAyOiBSZXR1cm5lZCBkYXRhIHNob3VsZCBpbmNsdWRlIHRoZSBhY3Rpdml0eSBJRFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmlkKS50b0JlRGVmaW5lZCgpO1xuXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eSAzOiBSZXF1aXJlZCBmaWVsZHMgc2hvdWxkIGJlIHByZXNlbnQgaW4gcmV0dXJuZWQgZGF0YVxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLm5hbWUpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuYWN0aXZpdHlUeXBlKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnN0YXJ0VGltZSkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb2NrQ3JlYXRlLm1vY2tSZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwLCB0aW1lb3V0OiAzMDAwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCByZWplY3QgYWN0aXZpdHkgdXBkYXRlIHdoZW4gbmFtZSBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nJywgKCkgPT4ge1xuICAgIGNvbnN0IGFjdGl2aXR5SWRBcmJpdHJhcnkgPSBmYy51dWlkKCk7XG4gICAgY29uc3QgZW1wdHlOYW1lVXBkYXRlQXJiaXRyYXJ5ID0gZmMucmVjb3JkKHtcbiAgICAgIG5hbWU6IGZjLmNvbnN0YW50KCcnKSxcbiAgICB9KTtcblxuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGFjdGl2aXR5SWRBcmJpdHJhcnksXG4gICAgICAgIGVtcHR5TmFtZVVwZGF0ZUFyYml0cmFyeSxcbiAgICAgICAgYXN5bmMgKGFjdGl2aXR5SWQsIHVwZGF0ZURhdGEpID0+IHtcbiAgICAgICAgICBjb25zdCBtb2NrVXBkYXRlID0gamVzdC5zcHlPbihhY3Rpdml0eVNlcnZpY2UsICd1cGRhdGUnKTtcbiAgICAgICAgICBtb2NrVXBkYXRlLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgY29kZTogJ1ZBTElEQVRJT05fRVJST1InLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnVmFsaWRhdGlvbiBmYWlsZWQnLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgY29kZTogJ3Rvb19zbWFsbCcsXG4gICAgICAgICAgICAgICAgICBwYXRoOiBbJ25hbWUnXSxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdBY3Rpdml0eSBuYW1lIGlzIHJlcXVpcmVkJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9IGFzIGFueSk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhY3Rpdml0eVNlcnZpY2UudXBkYXRlKGFjdGl2aXR5SWQsIHVwZGF0ZURhdGEpO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHkgMTogVXBkYXRlIHNob3VsZCBmYWlsXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcblxuICAgICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIC8vIFByb3BlcnR5IDI6IEVycm9yIGNvZGUgc2hvdWxkIGJlIFZBTElEQVRJT05fRVJST1JcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnVkFMSURBVElPTl9FUlJPUicpO1xuXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eSAzOiBFcnJvciBzaG91bGQgbWVudGlvbiBuYW1lIGZpZWxkXG4gICAgICAgICAgICBjb25zdCBlcnJvckRldGFpbHMgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQuZXJyb3IuZGV0YWlscyB8fCByZXN1bHQuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICBleHBlY3QoZXJyb3JEZXRhaWxzLnRvTG93ZXJDYXNlKCkpLnRvQ29udGFpbignbmFtZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vY2tVcGRhdGUubW9ja1Jlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAsIHRpbWVvdXQ6IDMwMDAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHJlamVjdCBhY3Rpdml0eSB3aXRoIGludmFsaWQgc3RhcnRUaW1lIGZvcm1hdCcsICgpID0+IHtcbiAgICBjb25zdCBpbnZhbGlkVGltZUFyYml0cmFyeSA9IGZjLm9uZW9mKFxuICAgICAgZmMuY29uc3RhbnQoJ25vdC1hLWRhdGUnKSxcbiAgICAgIGZjLmNvbnN0YW50KCcyMDI1LTEzLTQ1JyksIC8vIEludmFsaWQgbW9udGgvZGF5XG4gICAgICBmYy5jb25zdGFudCgnMjUvMDYvMjAyNScpLCAvLyBXcm9uZyBmb3JtYXRcbiAgICAgIGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAyMCB9KS5maWx0ZXIocyA9PiAhcy5tYXRjaCgvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9LykpLFxuICAgICk7XG5cbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTAwIH0pLFxuICAgICAgICBmYy5jb25zdGFudEZyb20oJ2NlcmVtb255JywgJ3JlY2VwdGlvbicsICdtZWFsJywgJ3RyYW5zcG9ydCcsICdhY3Rpdml0eScpLFxuICAgICAgICBpbnZhbGlkVGltZUFyYml0cmFyeSxcbiAgICAgICAgYXN5bmMgKG5hbWUsIGFjdGl2aXR5VHlwZSwgaW52YWxpZFN0YXJ0VGltZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG1vY2tDcmVhdGUgPSBqZXN0LnNweU9uKGFjdGl2aXR5U2VydmljZSwgJ2NyZWF0ZScpO1xuICAgICAgICAgIG1vY2tDcmVhdGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICBjb2RlOiAnVkFMSURBVElPTl9FUlJPUicsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdWYWxpZGF0aW9uIGZhaWxlZCcsXG4gICAgICAgICAgICAgIGRldGFpbHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjb2RlOiAnaW52YWxpZF9zdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgcGF0aDogWydzdGFydFRpbWUnXSxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIHN0YXJ0IHRpbWUgZm9ybWF0JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9IGFzIGFueSk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhY3Rpdml0eVNlcnZpY2UuY3JlYXRlKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBhY3Rpdml0eVR5cGUsXG4gICAgICAgICAgICBzdGFydFRpbWU6IGludmFsaWRTdGFydFRpbWUsXG4gICAgICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHkgMTogQ3JlYXRpb24gc2hvdWxkIGZhaWxcbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuXG4gICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgLy8gUHJvcGVydHkgMjogRXJyb3IgY29kZSBzaG91bGQgYmUgVkFMSURBVElPTl9FUlJPUlxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdWQUxJREFUSU9OX0VSUk9SJyk7XG5cbiAgICAgICAgICAgIC8vIFByb3BlcnR5IDM6IEVycm9yIHNob3VsZCBtZW50aW9uIHN0YXJ0VGltZSBvciB0aW1lIGZvcm1hdFxuICAgICAgICAgICAgY29uc3QgZXJyb3JEZXRhaWxzID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0LmVycm9yLmRldGFpbHMgfHwgcmVzdWx0LmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgZXhwZWN0KGVycm9yRGV0YWlscy50b0xvd2VyQ2FzZSgpKS50b01hdGNoKC9zdGFydC4qdGltZXx0aW1lLipmb3JtYXR8aW52YWxpZC4qc3RyaW5nLyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbW9ja0NyZWF0ZS5tb2NrUmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMCwgdGltZW91dDogMzAwMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgdmFsaWRhdGUgdGhhdCBlbmRUaW1lIGlzIGFmdGVyIHN0YXJ0VGltZSB3aGVuIGJvdGggYXJlIHByb3ZpZGVkJywgKCkgPT4ge1xuICAgIGNvbnN0IGRhdGVBcmJpdHJhcnkgPSBmYy5kYXRlKHtcbiAgICAgIG1pbjogbmV3IERhdGUoJzIwMjUtMDEtMDEnKSxcbiAgICAgIG1heDogbmV3IERhdGUoJzIwMjUtMTItMzEnKSxcbiAgICB9KTtcblxuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxMDAgfSksXG4gICAgICAgIGZjLmNvbnN0YW50RnJvbSgnY2VyZW1vbnknLCAncmVjZXB0aW9uJywgJ21lYWwnLCAndHJhbnNwb3J0JywgJ2FjdGl2aXR5JyksXG4gICAgICAgIGRhdGVBcmJpdHJhcnksXG4gICAgICAgIGZjLmludGVnZXIoeyBtaW46IDEsIG1heDogMjQgfSksIC8vIGhvdXJzIGJlZm9yZSBzdGFydFxuICAgICAgICBhc3luYyAobmFtZSwgYWN0aXZpdHlUeXBlLCBzdGFydFRpbWUsIGhvdXJzQmVmb3JlKSA9PiB7XG4gICAgICAgICAgLy8gQ3JlYXRlIGVuZFRpbWUgdGhhdCBpcyBCRUZPUkUgc3RhcnRUaW1lIChpbnZhbGlkKVxuICAgICAgICAgIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZShzdGFydFRpbWUuZ2V0VGltZSgpIC0gaG91cnNCZWZvcmUgKiA2MCAqIDYwICogMTAwMCk7XG5cbiAgICAgICAgICBjb25zdCBtb2NrQ3JlYXRlID0gamVzdC5zcHlPbihhY3Rpdml0eVNlcnZpY2UsICdjcmVhdGUnKTtcbiAgICAgICAgICBtb2NrQ3JlYXRlLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgY29kZTogJ1ZBTElEQVRJT05fRVJST1InLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnVmFsaWRhdGlvbiBmYWlsZWQnLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgY29kZTogJ2N1c3RvbScsXG4gICAgICAgICAgICAgICAgICBwYXRoOiBbJ2VuZFRpbWUnXSxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdFbmQgdGltZSBtdXN0IGJlIGFmdGVyIG9yIGVxdWFsIHRvIHN0YXJ0IHRpbWUnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0gYXMgYW55KTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFjdGl2aXR5U2VydmljZS5jcmVhdGUoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGFjdGl2aXR5VHlwZSxcbiAgICAgICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBlbmRUaW1lOiBlbmRUaW1lLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHkgMTogQ3JlYXRpb24gc2hvdWxkIGZhaWxcbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuXG4gICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgLy8gUHJvcGVydHkgMjogRXJyb3IgY29kZSBzaG91bGQgYmUgVkFMSURBVElPTl9FUlJPUlxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdWQUxJREFUSU9OX0VSUk9SJyk7XG5cbiAgICAgICAgICAgIC8vIFByb3BlcnR5IDM6IEVycm9yIHNob3VsZCBtZW50aW9uIGVuZFRpbWUgb3IgdGltZSBvcmRlcmluZ1xuICAgICAgICAgICAgY29uc3QgZXJyb3JEZXRhaWxzID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0LmVycm9yLmRldGFpbHMgfHwgcmVzdWx0LmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgZXhwZWN0KGVycm9yRGV0YWlscy50b0xvd2VyQ2FzZSgpKS50b01hdGNoKC9lbmQuKnRpbWV8YWZ0ZXJ8YmVmb3JlLyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbW9ja0NyZWF0ZS5tb2NrUmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMCwgdGltZW91dDogMzAwMDAgfVxuICAgICk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJkZXNjcmliZSIsInNraXAiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJTVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZIiwiaXQiLCJhY3Rpdml0eVdpdGhvdXROYW1lQXJiaXRyYXJ5IiwiZmMiLCJyZWNvcmQiLCJhY3Rpdml0eVR5cGUiLCJjb25zdGFudEZyb20iLCJzdGFydFRpbWUiLCJkYXRlIiwibWluIiwiRGF0ZSIsIm1heCIsIm1hcCIsImQiLCJ0b0lTT1N0cmluZyIsImRlc2NyaXB0aW9uIiwib3B0aW9uIiwic3RyaW5nIiwibWF4TGVuZ3RoIiwibmlsIiwiY2FwYWNpdHkiLCJpbnRlZ2VyIiwiYXNzZXJ0IiwiYXN5bmNQcm9wZXJ0eSIsImFjdGl2aXR5RGF0YSIsIm1vY2tDcmVhdGUiLCJzcHlPbiIsImFjdGl2aXR5U2VydmljZSIsIm1vY2tSZXNvbHZlZFZhbHVlIiwic3VjY2VzcyIsImVycm9yIiwiY29kZSIsIm1lc3NhZ2UiLCJkZXRhaWxzIiwicGF0aCIsInJlc3VsdCIsImNyZWF0ZSIsImV4cGVjdCIsInRvQmUiLCJlcnJvckRldGFpbHMiLCJKU09OIiwic3RyaW5naWZ5IiwidG9Mb3dlckNhc2UiLCJ0b0NvbnRhaW4iLCJtb2NrUmVzdG9yZSIsIm51bVJ1bnMiLCJ0aW1lb3V0IiwiYWN0aXZpdHlXaXRob3V0U3RhcnRUaW1lQXJiaXRyYXJ5IiwibmFtZSIsIm1pbkxlbmd0aCIsInRvTWF0Y2giLCJhY3Rpdml0eVdpdGhvdXRUeXBlQXJiaXRyYXJ5IiwiaW5jb21wbGV0ZUFjdGl2aXR5QXJiaXRyYXJ5IiwiYWR1bHRzT25seSIsImJvb2xlYW4iLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJ0b0JlR3JlYXRlclRoYW4iLCJjb21wbGV0ZUFjdGl2aXR5QXJiaXRyYXJ5IiwiY29zdFBlclBlcnNvbiIsImZsb2F0IiwidXVpZCIsImFjdGl2aXR5SWQiLCJkYXRhIiwiaWQiLCJldmVudElkIiwibG9jYXRpb25JZCIsImVuZFRpbWUiLCJob3N0U3Vic2lkeSIsInBsdXNPbmVBbGxvd2VkIiwidmlzaWJpbGl0eSIsInN0YXR1cyIsImRpc3BsYXlPcmRlciIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsInRvQmVEZWZpbmVkIiwiYWN0aXZpdHlJZEFyYml0cmFyeSIsImVtcHR5TmFtZVVwZGF0ZUFyYml0cmFyeSIsImNvbnN0YW50IiwidXBkYXRlRGF0YSIsIm1vY2tVcGRhdGUiLCJ1cGRhdGUiLCJpbnZhbGlkVGltZUFyYml0cmFyeSIsIm9uZW9mIiwiZmlsdGVyIiwicyIsIm1hdGNoIiwiaW52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