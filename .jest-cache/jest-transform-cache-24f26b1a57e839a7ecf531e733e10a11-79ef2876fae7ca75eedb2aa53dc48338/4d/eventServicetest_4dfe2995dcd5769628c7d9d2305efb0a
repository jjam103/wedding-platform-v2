e69361aa2251cdf0c6fea73a2d0a1ea8
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
// Set environment variables FIRST
process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://test.supabase.co';
process.env.SUPABASE_SERVICE_ROLE_KEY = 'test-service-role-key';
// Mock sanitization utilities
_globals.jest.mock('../utils/sanitization', ()=>({
        sanitizeInput: _globals.jest.fn((input)=>input.trim()),
        sanitizeRichText: _globals.jest.fn((input)=>input.trim())
    }));
// Mock Supabase with shared client instance (Pattern A)
_globals.jest.mock('@supabase/supabase-js', ()=>{
    const mockFrom = _globals.jest.fn();
    const mockSupabaseClient = {
        from: mockFrom
    };
    return {
        createClient: _globals.jest.fn(()=>mockSupabaseClient),
        __mockFrom: mockFrom
    };
});
// Import service using require() AFTER mocking (Pattern A requirement)
const eventServiceModule = require('./eventService');
const eventService = eventServiceModule;
// Get the mocked from function
const { __mockFrom: mockFrom } = require('@supabase/supabase-js');
(0, _globals.describe)('eventService', ()=>{
    (0, _globals.beforeEach)(()=>{
        _globals.jest.clearAllMocks();
        // Set up environment variables
        process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://test.supabase.co';
        process.env.SUPABASE_SERVICE_ROLE_KEY = 'test-service-role-key';
    });
    (0, _globals.describe)('create', ()=>{
        const validData = {
            name: 'Wedding Ceremony',
            eventType: 'ceremony',
            startDate: '2025-06-15T14:00:00Z',
            endDate: '2025-06-15T15:00:00Z',
            locationId: '123e4567-e89b-12d3-a456-426614174000',
            description: 'Beautiful ceremony by the beach'
        };
        (0, _globals.it)('should return success with event data when valid input provided', async ()=>{
            const mockEvent = {
                id: 'event-1',
                name: 'Wedding Ceremony',
                event_type: 'ceremony',
                start_date: '2025-06-15T14:00:00Z',
                end_date: '2025-06-15T15:00:00Z',
                location_id: validData.locationId,
                description: 'Beautiful ceremony by the beach',
                created_at: '2024-01-01T00:00:00Z',
                updated_at: '2024-01-01T00:00:00Z'
            };
            // Mock conflict check (no conflicts) - first call to from()
            // Mock event creation - second call to from()
            let callCount = 0;
            mockFrom.mockImplementation(()=>{
                callCount++;
                if (callCount === 1) {
                    // Conflict check query
                    const mockEq = _globals.jest.fn().mockResolvedValue({
                        data: [],
                        error: null
                    });
                    const mockSelect = _globals.jest.fn().mockReturnValue({
                        eq: mockEq
                    });
                    return {
                        select: mockSelect
                    };
                } else {
                    // Insert query
                    const mockSingle = _globals.jest.fn().mockResolvedValue({
                        data: mockEvent,
                        error: null
                    });
                    const mockSelect = _globals.jest.fn().mockReturnValue({
                        single: mockSingle
                    });
                    const mockInsert = _globals.jest.fn().mockReturnValue({
                        select: mockSelect
                    });
                    return {
                        insert: mockInsert
                    };
                }
            });
            const result = await eventService.create(validData);
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.id).toBe('event-1');
                (0, _globals.expect)(result.data.name).toBe('Wedding Ceremony');
                (0, _globals.expect)(result.data.eventType).toBe('ceremony');
                (0, _globals.expect)(result.data.locationId).toBe(validData.locationId);
            }
        });
        (0, _globals.it)('should return VALIDATION_ERROR when name is missing', async ()=>{
            const invalidData = {
                ...validData,
                name: ''
            };
            const result = await eventService.create(invalidData);
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        (0, _globals.it)('should return VALIDATION_ERROR when eventType is invalid', async ()=>{
            const invalidData = {
                ...validData,
                eventType: 'invalid-type'
            };
            const result = await eventService.create(invalidData);
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        (0, _globals.it)('should return SCHEDULING_CONFLICT when event conflicts with existing events', async ()=>{
            const conflictingEvent = {
                id: 'existing-event',
                name: 'Existing Event',
                start_date: '2025-06-15T13:30:00Z',
                end_date: '2025-06-15T14:30:00Z'
            };
            // Mock conflict check (conflict found)
            const mockEq = _globals.jest.fn().mockResolvedValue({
                data: [
                    conflictingEvent
                ],
                error: null
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await eventService.create(validData);
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('SCHEDULING_CONFLICT');
                (0, _globals.expect)(result.error.details).toHaveLength(1);
            }
        });
        (0, _globals.it)('should return DATABASE_ERROR when insert fails', async ()=>{
            // Mock conflict check (no conflicts) - first call
            // Mock database error - second call
            let callCount = 0;
            mockFrom.mockImplementation(()=>{
                callCount++;
                if (callCount === 1) {
                    // Conflict check query
                    const mockEq = _globals.jest.fn().mockResolvedValue({
                        data: [],
                        error: null
                    });
                    const mockSelect = _globals.jest.fn().mockReturnValue({
                        eq: mockEq
                    });
                    return {
                        select: mockSelect
                    };
                } else {
                    // Insert query with error
                    const mockSingle = _globals.jest.fn().mockResolvedValue({
                        data: null,
                        error: {
                            message: 'Connection failed'
                        }
                    });
                    const mockSelect = _globals.jest.fn().mockReturnValue({
                        single: mockSingle
                    });
                    const mockInsert = _globals.jest.fn().mockReturnValue({
                        select: mockSelect
                    });
                    return {
                        insert: mockInsert
                    };
                }
            });
            const result = await eventService.create(validData);
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('DATABASE_ERROR');
            }
        });
        (0, _globals.it)('should sanitize input to prevent XSS attacks', async ()=>{
            const maliciousData = {
                ...validData,
                name: '<script>alert("xss")</script>Wedding',
                description: '<img src=x onerror=alert(1)>Description'
            };
            // Mock conflict check (no conflicts) - first call
            // Mock successful creation - second call
            let callCount = 0;
            mockFrom.mockImplementation(()=>{
                callCount++;
                if (callCount === 1) {
                    // Conflict check query
                    const mockEq = _globals.jest.fn().mockResolvedValue({
                        data: [],
                        error: null
                    });
                    const mockSelect = _globals.jest.fn().mockReturnValue({
                        eq: mockEq
                    });
                    return {
                        select: mockSelect
                    };
                } else {
                    // Insert query
                    const mockSingle = _globals.jest.fn().mockResolvedValue({
                        data: {
                            id: 'event-1',
                            name: 'Wedding',
                            description: 'Description'
                        },
                        error: null
                    });
                    const mockSelect = _globals.jest.fn().mockReturnValue({
                        single: mockSingle
                    });
                    const mockInsert = _globals.jest.fn().mockReturnValue({
                        select: mockSelect
                    });
                    return {
                        insert: mockInsert
                    };
                }
            });
            const result = await eventService.create(maliciousData);
            (0, _globals.expect)(result.success).toBe(true);
            // Verify sanitization was called
            const { sanitizeInput, sanitizeRichText } = require('../utils/sanitization');
            (0, _globals.expect)(sanitizeInput).toHaveBeenCalledWith(maliciousData.name);
            (0, _globals.expect)(sanitizeRichText).toHaveBeenCalledWith(maliciousData.description);
        });
    });
    (0, _globals.describe)('get', ()=>{
        (0, _globals.it)('should return success with event data when event exists', async ()=>{
            const mockEvent = {
                id: 'event-1',
                name: 'Wedding Ceremony',
                event_type: 'ceremony',
                start_date: '2025-06-15T14:00:00Z',
                end_date: '2025-06-15T15:00:00Z',
                location_id: '123e4567-e89b-12d3-a456-426614174000',
                description: 'Beautiful ceremony',
                created_at: '2024-01-01T00:00:00Z',
                updated_at: '2024-01-01T00:00:00Z'
            };
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: mockEvent,
                error: null
            });
            const mockEq = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await eventService.get('event-1');
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.id).toBe('event-1');
                (0, _globals.expect)(result.data.name).toBe('Wedding Ceremony');
                (0, _globals.expect)(result.data.eventType).toBe('ceremony');
            }
        });
        (0, _globals.it)('should return NOT_FOUND when event does not exist', async ()=>{
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: null,
                error: {
                    code: 'PGRST116'
                }
            });
            const mockEq = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await eventService.get('nonexistent-id');
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('NOT_FOUND');
            }
        });
        (0, _globals.it)('should return DATABASE_ERROR when database query fails', async ()=>{
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: null,
                error: {
                    message: 'Connection failed'
                }
            });
            const mockEq = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await eventService.get('event-1');
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('DATABASE_ERROR');
            }
        });
    });
    (0, _globals.describe)('update', ()=>{
        const updateData = {
            name: 'Updated Ceremony',
            description: 'Updated description'
        };
        (0, _globals.it)('should return success with updated event data when valid input provided', async ()=>{
            const mockUpdatedEvent = {
                id: 'event-1',
                name: 'Updated Ceremony',
                event_type: 'ceremony',
                start_date: '2025-06-15T14:00:00Z',
                end_date: '2025-06-15T15:00:00Z',
                location_id: '123e4567-e89b-12d3-a456-426614174000',
                description: 'Updated description',
                created_at: '2024-01-01T00:00:00Z',
                updated_at: '2024-01-02T00:00:00Z'
            };
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: mockUpdatedEvent,
                error: null
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockEq = _globals.jest.fn().mockReturnValue({
                select: mockSelect
            });
            const mockUpdate = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                update: mockUpdate
            });
            const result = await eventService.update('event-1', updateData);
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.name).toBe('Updated Ceremony');
                (0, _globals.expect)(result.data.description).toBe('Updated description');
            }
        });
        (0, _globals.it)('should check for scheduling conflicts when location or dates are updated', async ()=>{
            const eventId = '123e4567-e89b-12d3-a456-426614174001'; // Valid UUID
            const updateWithLocation = {
                locationId: '223e4567-e89b-12d3-a456-426614174000',
                startDate: '2025-06-15T16:00:00Z'
            };
            // Three separate calls to from():
            // 1. get() - fetch current event
            // 2. checkSchedulingConflicts() - check for conflicts
            // 3. update() - perform the update
            let callCount = 0;
            mockFrom.mockImplementation(()=>{
                callCount++;
                if (callCount === 1) {
                    // Get current event: .from('events').select('*').eq('id', id).single()
                    const mockSingle = _globals.jest.fn().mockResolvedValue({
                        data: {
                            id: eventId,
                            name: 'Wedding Ceremony',
                            event_type: 'ceremony',
                            start_date: '2025-06-15T14:00:00Z',
                            end_date: '2025-06-15T15:00:00Z',
                            location_id: '123e4567-e89b-12d3-a456-426614174000',
                            description: 'Beautiful ceremony',
                            created_at: '2024-01-01T00:00:00Z',
                            updated_at: '2024-01-01T00:00:00Z'
                        },
                        error: null
                    });
                    const mockEq = _globals.jest.fn().mockReturnValue({
                        single: mockSingle
                    });
                    const mockSelect = _globals.jest.fn().mockReturnValue({
                        eq: mockEq
                    });
                    return {
                        select: mockSelect
                    };
                } else if (callCount === 2) {
                    // Conflict check: .from('events').select(...).eq('location_id', ...).neq('id', ...)
                    const mockNeq = _globals.jest.fn().mockResolvedValue({
                        data: [],
                        error: null
                    });
                    const mockEq = _globals.jest.fn().mockReturnValue({
                        neq: mockNeq
                    });
                    const mockSelect = _globals.jest.fn().mockReturnValue({
                        eq: mockEq
                    });
                    return {
                        select: mockSelect
                    };
                } else {
                    // Update operation: .from('events').update(...).eq('id', ...).select().single()
                    const mockSingle = _globals.jest.fn().mockResolvedValue({
                        data: {
                            id: eventId,
                            name: 'Wedding Ceremony',
                            location_id: '223e4567-e89b-12d3-a456-426614174000',
                            start_date: '2025-06-15T16:00:00Z'
                        },
                        error: null
                    });
                    const mockSelect = _globals.jest.fn().mockReturnValue({
                        single: mockSingle
                    });
                    const mockEq = _globals.jest.fn().mockReturnValue({
                        select: mockSelect
                    });
                    const mockUpdate = _globals.jest.fn().mockReturnValue({
                        eq: mockEq
                    });
                    return {
                        update: mockUpdate
                    };
                }
            });
            const result = await eventService.update(eventId, updateWithLocation);
            (0, _globals.expect)(result.success).toBe(true);
        });
        (0, _globals.it)('should return NOT_FOUND when event to update does not exist', async ()=>{
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: null,
                error: {
                    code: 'PGRST116'
                }
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockEq = _globals.jest.fn().mockReturnValue({
                select: mockSelect
            });
            const mockUpdate = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                update: mockUpdate
            });
            const result = await eventService.update('nonexistent-id', updateData);
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('NOT_FOUND');
            }
        });
    });
    (0, _globals.describe)('deleteEvent', ()=>{
        (0, _globals.it)('should return success when event is deleted successfully', async ()=>{
            const mockEq = _globals.jest.fn().mockResolvedValue({
                error: null
            });
            const mockDelete = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                delete: mockDelete
            });
            const result = await eventService.deleteEvent('event-1');
            (0, _globals.expect)(result.success).toBe(true);
        });
        (0, _globals.it)('should return DATABASE_ERROR when delete fails', async ()=>{
            const mockEq = _globals.jest.fn().mockResolvedValue({
                error: {
                    message: 'Foreign key constraint violation'
                }
            });
            const mockDelete = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                delete: mockDelete
            });
            const result = await eventService.deleteEvent('event-1');
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('DATABASE_ERROR');
            }
        });
    });
    (0, _globals.describe)('list', ()=>{
        (0, _globals.it)('should return success with paginated events when valid filters provided', async ()=>{
            const mockEvents = [
                {
                    id: 'event-1',
                    name: 'Ceremony',
                    event_type: 'ceremony',
                    start_date: '2025-06-15T14:00:00Z',
                    end_date: '2025-06-15T15:00:00Z',
                    location_id: null,
                    description: null,
                    created_at: '2024-01-01T00:00:00Z',
                    updated_at: '2024-01-01T00:00:00Z'
                },
                {
                    id: 'event-2',
                    name: 'Reception',
                    event_type: 'reception',
                    start_date: '2025-06-15T18:00:00Z',
                    end_date: '2025-06-15T23:00:00Z',
                    location_id: null,
                    description: null,
                    created_at: '2024-01-01T00:00:00Z',
                    updated_at: '2024-01-01T00:00:00Z'
                }
            ];
            const mockRange = _globals.jest.fn().mockResolvedValue({
                data: mockEvents,
                error: null,
                count: 2
            });
            const mockOrder = _globals.jest.fn().mockReturnValue({
                range: mockRange
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                order: mockOrder
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const filters = {
                page: 1,
                pageSize: 10
            };
            const result = await eventService.list(filters);
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.events).toHaveLength(2);
                (0, _globals.expect)(result.data.total).toBe(2);
                (0, _globals.expect)(result.data.page).toBe(1);
                (0, _globals.expect)(result.data.pageSize).toBe(10);
            }
        });
        (0, _globals.it)('should filter by event type when provided', async ()=>{
            const filters = {
                eventType: 'ceremony',
                page: 1,
                pageSize: 10
            };
            const mockRange = _globals.jest.fn().mockResolvedValue({
                data: [],
                error: null,
                count: 0
            });
            const mockOrder = _globals.jest.fn().mockReturnValue({
                range: mockRange
            });
            const mockEq = _globals.jest.fn().mockReturnValue({
                order: mockOrder
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await eventService.list(filters);
            (0, _globals.expect)(result.success).toBe(true);
        });
        (0, _globals.it)('should filter by date range when provided', async ()=>{
            const filters = {
                startDateFrom: '2025-06-01T00:00:00Z',
                startDateTo: '2025-06-30T23:59:59Z',
                page: 1,
                pageSize: 10
            };
            const mockRange = _globals.jest.fn().mockResolvedValue({
                data: [],
                error: null,
                count: 0
            });
            const mockOrder = _globals.jest.fn().mockReturnValue({
                range: mockRange
            });
            const mockLte = _globals.jest.fn().mockReturnValue({
                order: mockOrder
            });
            const mockGte = _globals.jest.fn().mockReturnValue({
                lte: mockLte
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                gte: mockGte
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await eventService.list(filters);
            (0, _globals.expect)(result.success).toBe(true);
        });
        (0, _globals.it)('should return DATABASE_ERROR when query fails', async ()=>{
            const mockRange = _globals.jest.fn().mockResolvedValue({
                data: null,
                error: {
                    message: 'Connection failed'
                }
            });
            const mockOrder = _globals.jest.fn().mockReturnValue({
                range: mockRange
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                order: mockOrder
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await eventService.list();
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('DATABASE_ERROR');
            }
        });
    });
    (0, _globals.describe)('search', ()=>{
        const searchParams = {
            query: 'ceremony',
            page: 1,
            pageSize: 10
        };
        (0, _globals.it)('should return success with search results when valid query provided', async ()=>{
            const mockResults = [
                {
                    id: 'event-1',
                    name: 'Wedding Ceremony',
                    event_type: 'ceremony',
                    start_date: '2025-06-15T14:00:00Z',
                    end_date: '2025-06-15T15:00:00Z',
                    location_id: null,
                    description: 'Beautiful ceremony by the beach',
                    created_at: '2024-01-01T00:00:00Z',
                    updated_at: '2024-01-01T00:00:00Z'
                }
            ];
            const mockRange = _globals.jest.fn().mockResolvedValue({
                data: mockResults,
                error: null,
                count: 1
            });
            const mockOrder = _globals.jest.fn().mockReturnValue({
                range: mockRange
            });
            const mockOr = _globals.jest.fn().mockReturnValue({
                order: mockOrder
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                or: mockOr
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await eventService.search(searchParams);
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.events).toHaveLength(1);
                (0, _globals.expect)(result.data.events[0].name).toBe('Wedding Ceremony');
            }
        });
        (0, _globals.it)('should sanitize search query to prevent injection attacks', async ()=>{
            const maliciousSearch = {
                query: '<script>alert("xss")</script>ceremony',
                page: 1,
                pageSize: 10
            };
            const mockRange = _globals.jest.fn().mockResolvedValue({
                data: [],
                error: null,
                count: 0
            });
            const mockOrder = _globals.jest.fn().mockReturnValue({
                range: mockRange
            });
            const mockOr = _globals.jest.fn().mockReturnValue({
                order: mockOrder
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                or: mockOr
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await eventService.search(maliciousSearch);
            // Verify sanitization was called
            const { sanitizeInput } = require('../utils/sanitization');
            (0, _globals.expect)(sanitizeInput).toHaveBeenCalledWith(maliciousSearch.query);
            (0, _globals.expect)(result.success).toBe(true);
        });
        (0, _globals.it)('should return VALIDATION_ERROR when query is empty', async ()=>{
            const invalidSearch = {
                ...searchParams,
                query: ''
            };
            const result = await eventService.search(invalidSearch);
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
    });
    (0, _globals.describe)('checkSchedulingConflicts', ()=>{
        const conflictParams = {
            locationId: '123e4567-e89b-12d3-a456-426614174000',
            startDate: '2025-06-15T14:00:00Z',
            endDate: '2025-06-15T15:00:00Z'
        };
        (0, _globals.it)('should return success with no conflicts when no overlapping events exist', async ()=>{
            const mockEq = _globals.jest.fn().mockResolvedValue({
                data: [],
                error: null
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await eventService.checkSchedulingConflicts(conflictParams);
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.hasConflict).toBe(false);
                (0, _globals.expect)(result.data.conflictingEvents).toHaveLength(0);
            }
        });
        (0, _globals.it)('should return success with conflicts when overlapping events exist', async ()=>{
            const overlappingEvent = {
                id: 'existing-event',
                name: 'Existing Event',
                start_date: '2025-06-15T13:30:00Z',
                end_date: '2025-06-15T14:30:00Z'
            };
            const mockEq = _globals.jest.fn().mockResolvedValue({
                data: [
                    overlappingEvent
                ],
                error: null
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await eventService.checkSchedulingConflicts(conflictParams);
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.hasConflict).toBe(true);
                (0, _globals.expect)(result.data.conflictingEvents).toHaveLength(1);
                (0, _globals.expect)(result.data.conflictingEvents[0].id).toBe('existing-event');
                (0, _globals.expect)(result.data.conflictingEvents[0].name).toBe('Existing Event');
            }
        });
        (0, _globals.it)('should exclude specified event ID from conflict check', async ()=>{
            const paramsWithExclusion = {
                ...conflictParams,
                excludeEventId: '223e4567-e89b-12d3-a456-426614174001'
            };
            const mockNeq = _globals.jest.fn().mockResolvedValue({
                data: [],
                error: null
            });
            const mockEq = _globals.jest.fn().mockReturnValue({
                neq: mockNeq
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await eventService.checkSchedulingConflicts(paramsWithExclusion);
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.hasConflict).toBe(false);
            }
        });
        (0, _globals.it)('should handle events without end dates correctly', async ()=>{
            const eventWithoutEndDate = {
                id: 'point-event',
                name: 'Point Event',
                start_date: '2025-06-15T14:30:00Z',
                end_date: null
            };
            const mockEq = _globals.jest.fn().mockResolvedValue({
                data: [
                    eventWithoutEndDate
                ],
                error: null
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await eventService.checkSchedulingConflicts(conflictParams);
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.hasConflict).toBe(true); // Should still detect overlap
            }
        });
        (0, _globals.it)('should return DATABASE_ERROR when query fails', async ()=>{
            const mockEq = _globals.jest.fn().mockResolvedValue({
                data: null,
                error: {
                    message: 'Connection failed'
                }
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await eventService.checkSchedulingConflicts(conflictParams);
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('DATABASE_ERROR');
            }
        });
        (0, _globals.it)('should return VALIDATION_ERROR when locationId is invalid', async ()=>{
            const invalidParams = {
                ...conflictParams,
                locationId: 'invalid-uuid'
            };
            const result = await eventService.checkSchedulingConflicts(invalidParams);
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvZXZlbnRTZXJ2aWNlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVzY3JpYmUsIGl0LCBleHBlY3QsIGplc3QsIGJlZm9yZUVhY2ggfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB0eXBlIHsgQ3JlYXRlRXZlbnREVE8sIFVwZGF0ZUV2ZW50RFRPLCBFdmVudEZpbHRlckRUTywgRXZlbnRTZWFyY2hEVE8sIENvbmZsaWN0Q2hlY2tEVE8gfSBmcm9tICdAL3NjaGVtYXMvZXZlbnRTY2hlbWFzJztcblxuLy8gU2V0IGVudmlyb25tZW50IHZhcmlhYmxlcyBGSVJTVFxucHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMID0gJ2h0dHBzOi8vdGVzdC5zdXBhYmFzZS5jbyc7XG5wcm9jZXNzLmVudi5TVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZID0gJ3Rlc3Qtc2VydmljZS1yb2xlLWtleSc7XG5cbi8vIE1vY2sgc2FuaXRpemF0aW9uIHV0aWxpdGllc1xuamVzdC5tb2NrKCcuLi91dGlscy9zYW5pdGl6YXRpb24nLCAoKSA9PiAoe1xuICBzYW5pdGl6ZUlucHV0OiBqZXN0LmZuKChpbnB1dDogc3RyaW5nKSA9PiBpbnB1dC50cmltKCkpLFxuICBzYW5pdGl6ZVJpY2hUZXh0OiBqZXN0LmZuKChpbnB1dDogc3RyaW5nKSA9PiBpbnB1dC50cmltKCkpLFxufSkpO1xuXG4vLyBNb2NrIFN1cGFiYXNlIHdpdGggc2hhcmVkIGNsaWVudCBpbnN0YW5jZSAoUGF0dGVybiBBKVxuamVzdC5tb2NrKCdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnLCAoKSA9PiB7XG4gIGNvbnN0IG1vY2tGcm9tID0gamVzdC5mbigpO1xuICBjb25zdCBtb2NrU3VwYWJhc2VDbGllbnQgPSB7XG4gICAgZnJvbTogbW9ja0Zyb20sXG4gIH07XG4gIFxuICByZXR1cm4ge1xuICAgIGNyZWF0ZUNsaWVudDogamVzdC5mbigoKSA9PiBtb2NrU3VwYWJhc2VDbGllbnQpLFxuICAgIF9fbW9ja0Zyb206IG1vY2tGcm9tLFxuICB9O1xufSk7XG5cbi8vIEltcG9ydCBzZXJ2aWNlIHVzaW5nIHJlcXVpcmUoKSBBRlRFUiBtb2NraW5nIChQYXR0ZXJuIEEgcmVxdWlyZW1lbnQpXG5jb25zdCBldmVudFNlcnZpY2VNb2R1bGUgPSByZXF1aXJlKCcuL2V2ZW50U2VydmljZScpO1xuY29uc3QgZXZlbnRTZXJ2aWNlID0gZXZlbnRTZXJ2aWNlTW9kdWxlO1xuXG4vLyBHZXQgdGhlIG1vY2tlZCBmcm9tIGZ1bmN0aW9uXG5jb25zdCB7IF9fbW9ja0Zyb206IG1vY2tGcm9tIH0gPSByZXF1aXJlKCdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnKTtcblxuZGVzY3JpYmUoJ2V2ZW50U2VydmljZScsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgXG4gICAgLy8gU2V0IHVwIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCA9ICdodHRwczovL3Rlc3Quc3VwYWJhc2UuY28nO1xuICAgIHByb2Nlc3MuZW52LlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkgPSAndGVzdC1zZXJ2aWNlLXJvbGUta2V5JztcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NyZWF0ZScsICgpID0+IHtcbiAgICBjb25zdCB2YWxpZERhdGE6IENyZWF0ZUV2ZW50RFRPID0ge1xuICAgICAgbmFtZTogJ1dlZGRpbmcgQ2VyZW1vbnknLFxuICAgICAgZXZlbnRUeXBlOiAnY2VyZW1vbnknLFxuICAgICAgc3RhcnREYXRlOiAnMjAyNS0wNi0xNVQxNDowMDowMFonLFxuICAgICAgZW5kRGF0ZTogJzIwMjUtMDYtMTVUMTU6MDA6MDBaJyxcbiAgICAgIGxvY2F0aW9uSWQ6ICcxMjNlNDU2Ny1lODliLTEyZDMtYTQ1Ni00MjY2MTQxNzQwMDAnLFxuICAgICAgZGVzY3JpcHRpb246ICdCZWF1dGlmdWwgY2VyZW1vbnkgYnkgdGhlIGJlYWNoJyxcbiAgICB9O1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2VzcyB3aXRoIGV2ZW50IGRhdGEgd2hlbiB2YWxpZCBpbnB1dCBwcm92aWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tFdmVudCA9IHtcbiAgICAgICAgaWQ6ICdldmVudC0xJyxcbiAgICAgICAgbmFtZTogJ1dlZGRpbmcgQ2VyZW1vbnknLFxuICAgICAgICBldmVudF90eXBlOiAnY2VyZW1vbnknLFxuICAgICAgICBzdGFydF9kYXRlOiAnMjAyNS0wNi0xNVQxNDowMDowMFonLFxuICAgICAgICBlbmRfZGF0ZTogJzIwMjUtMDYtMTVUMTU6MDA6MDBaJyxcbiAgICAgICAgbG9jYXRpb25faWQ6IHZhbGlkRGF0YS5sb2NhdGlvbklkLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0JlYXV0aWZ1bCBjZXJlbW9ueSBieSB0aGUgYmVhY2gnLFxuICAgICAgICBjcmVhdGVkX2F0OiAnMjAyNC0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICB1cGRhdGVkX2F0OiAnMjAyNC0wMS0wMVQwMDowMDowMFonLFxuICAgICAgfTtcblxuICAgICAgLy8gTW9jayBjb25mbGljdCBjaGVjayAobm8gY29uZmxpY3RzKSAtIGZpcnN0IGNhbGwgdG8gZnJvbSgpXG4gICAgICAvLyBNb2NrIGV2ZW50IGNyZWF0aW9uIC0gc2Vjb25kIGNhbGwgdG8gZnJvbSgpXG4gICAgICBsZXQgY2FsbENvdW50ID0gMDtcbiAgICAgIG1vY2tGcm9tLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGNhbGxDb3VudCsrO1xuICAgICAgICBpZiAoY2FsbENvdW50ID09PSAxKSB7XG4gICAgICAgICAgLy8gQ29uZmxpY3QgY2hlY2sgcXVlcnlcbiAgICAgICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXEgfSk7XG4gICAgICAgICAgcmV0dXJuIHsgc2VsZWN0OiBtb2NrU2VsZWN0IH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSW5zZXJ0IHF1ZXJ5XG4gICAgICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICBkYXRhOiBtb2NrRXZlbnQsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHNpbmdsZTogbW9ja1NpbmdsZSB9KTtcbiAgICAgICAgICBjb25zdCBtb2NrSW5zZXJ0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHNlbGVjdDogbW9ja1NlbGVjdCB9KTtcbiAgICAgICAgICByZXR1cm4geyBpbnNlcnQ6IG1vY2tJbnNlcnQgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV2ZW50U2VydmljZS5jcmVhdGUodmFsaWREYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5pZCkudG9CZSgnZXZlbnQtMScpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEubmFtZSkudG9CZSgnV2VkZGluZyBDZXJlbW9ueScpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuZXZlbnRUeXBlKS50b0JlKCdjZXJlbW9ueScpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEubG9jYXRpb25JZCkudG9CZSh2YWxpZERhdGEubG9jYXRpb25JZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBWQUxJREFUSU9OX0VSUk9SIHdoZW4gbmFtZSBpcyBtaXNzaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZERhdGEgPSB7IC4uLnZhbGlkRGF0YSwgbmFtZTogJycgfTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV2ZW50U2VydmljZS5jcmVhdGUoaW52YWxpZERhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ1ZBTElEQVRJT05fRVJST1InKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIFZBTElEQVRJT05fRVJST1Igd2hlbiBldmVudFR5cGUgaXMgaW52YWxpZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWREYXRhID0geyAuLi52YWxpZERhdGEsIGV2ZW50VHlwZTogJ2ludmFsaWQtdHlwZScgYXMgYW55IH07XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBldmVudFNlcnZpY2UuY3JlYXRlKGludmFsaWREYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdWQUxJREFUSU9OX0VSUk9SJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBTQ0hFRFVMSU5HX0NPTkZMSUNUIHdoZW4gZXZlbnQgY29uZmxpY3RzIHdpdGggZXhpc3RpbmcgZXZlbnRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29uZmxpY3RpbmdFdmVudCA9IHtcbiAgICAgICAgaWQ6ICdleGlzdGluZy1ldmVudCcsXG4gICAgICAgIG5hbWU6ICdFeGlzdGluZyBFdmVudCcsXG4gICAgICAgIHN0YXJ0X2RhdGU6ICcyMDI1LTA2LTE1VDEzOjMwOjAwWicsXG4gICAgICAgIGVuZF9kYXRlOiAnMjAyNS0wNi0xNVQxNDozMDowMFonLFxuICAgICAgfTtcblxuICAgICAgLy8gTW9jayBjb25mbGljdCBjaGVjayAoY29uZmxpY3QgZm91bmQpXG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBbY29uZmxpY3RpbmdFdmVudF0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXEgfSk7XG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV2ZW50U2VydmljZS5jcmVhdGUodmFsaWREYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdTQ0hFRFVMSU5HX0NPTkZMSUNUJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuZGV0YWlscykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gREFUQUJBU0VfRVJST1Igd2hlbiBpbnNlcnQgZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGNvbmZsaWN0IGNoZWNrIChubyBjb25mbGljdHMpIC0gZmlyc3QgY2FsbFxuICAgICAgLy8gTW9jayBkYXRhYmFzZSBlcnJvciAtIHNlY29uZCBjYWxsXG4gICAgICBsZXQgY2FsbENvdW50ID0gMDtcbiAgICAgIG1vY2tGcm9tLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGNhbGxDb3VudCsrO1xuICAgICAgICBpZiAoY2FsbENvdW50ID09PSAxKSB7XG4gICAgICAgICAgLy8gQ29uZmxpY3QgY2hlY2sgcXVlcnlcbiAgICAgICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXEgfSk7XG4gICAgICAgICAgcmV0dXJuIHsgc2VsZWN0OiBtb2NrU2VsZWN0IH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSW5zZXJ0IHF1ZXJ5IHdpdGggZXJyb3JcbiAgICAgICAgICBjb25zdCBtb2NrU2luZ2xlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnQ29ubmVjdGlvbiBmYWlsZWQnIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzaW5nbGU6IG1vY2tTaW5nbGUgfSk7XG4gICAgICAgICAgY29uc3QgbW9ja0luc2VydCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG4gICAgICAgICAgcmV0dXJuIHsgaW5zZXJ0OiBtb2NrSW5zZXJ0IH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBldmVudFNlcnZpY2UuY3JlYXRlKHZhbGlkRGF0YSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnREFUQUJBU0VfRVJST1InKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc2FuaXRpemUgaW5wdXQgdG8gcHJldmVudCBYU1MgYXR0YWNrcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1hbGljaW91c0RhdGEgPSB7XG4gICAgICAgIC4uLnZhbGlkRGF0YSxcbiAgICAgICAgbmFtZTogJzxzY3JpcHQ+YWxlcnQoXCJ4c3NcIik8L3NjcmlwdD5XZWRkaW5nJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICc8aW1nIHNyYz14IG9uZXJyb3I9YWxlcnQoMSk+RGVzY3JpcHRpb24nLFxuICAgICAgfTtcblxuICAgICAgLy8gTW9jayBjb25mbGljdCBjaGVjayAobm8gY29uZmxpY3RzKSAtIGZpcnN0IGNhbGxcbiAgICAgIC8vIE1vY2sgc3VjY2Vzc2Z1bCBjcmVhdGlvbiAtIHNlY29uZCBjYWxsXG4gICAgICBsZXQgY2FsbENvdW50ID0gMDtcbiAgICAgIG1vY2tGcm9tLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGNhbGxDb3VudCsrO1xuICAgICAgICBpZiAoY2FsbENvdW50ID09PSAxKSB7XG4gICAgICAgICAgLy8gQ29uZmxpY3QgY2hlY2sgcXVlcnlcbiAgICAgICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXEgfSk7XG4gICAgICAgICAgcmV0dXJuIHsgc2VsZWN0OiBtb2NrU2VsZWN0IH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSW5zZXJ0IHF1ZXJ5XG4gICAgICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGlkOiAnZXZlbnQtMScsXG4gICAgICAgICAgICAgIG5hbWU6ICdXZWRkaW5nJyxcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdEZXNjcmlwdGlvbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzaW5nbGU6IG1vY2tTaW5nbGUgfSk7XG4gICAgICAgICAgY29uc3QgbW9ja0luc2VydCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG4gICAgICAgICAgcmV0dXJuIHsgaW5zZXJ0OiBtb2NrSW5zZXJ0IH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBldmVudFNlcnZpY2UuY3JlYXRlKG1hbGljaW91c0RhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBzYW5pdGl6YXRpb24gd2FzIGNhbGxlZFxuICAgICAgY29uc3QgeyBzYW5pdGl6ZUlucHV0LCBzYW5pdGl6ZVJpY2hUZXh0IH0gPSByZXF1aXJlKCcuLi91dGlscy9zYW5pdGl6YXRpb24nKTtcbiAgICAgIGV4cGVjdChzYW5pdGl6ZUlucHV0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChtYWxpY2lvdXNEYXRhLm5hbWUpO1xuICAgICAgZXhwZWN0KHNhbml0aXplUmljaFRleHQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG1hbGljaW91c0RhdGEuZGVzY3JpcHRpb24pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3Mgd2l0aCBldmVudCBkYXRhIHdoZW4gZXZlbnQgZXhpc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0V2ZW50ID0ge1xuICAgICAgICBpZDogJ2V2ZW50LTEnLFxuICAgICAgICBuYW1lOiAnV2VkZGluZyBDZXJlbW9ueScsXG4gICAgICAgIGV2ZW50X3R5cGU6ICdjZXJlbW9ueScsXG4gICAgICAgIHN0YXJ0X2RhdGU6ICcyMDI1LTA2LTE1VDE0OjAwOjAwWicsXG4gICAgICAgIGVuZF9kYXRlOiAnMjAyNS0wNi0xNVQxNTowMDowMFonLFxuICAgICAgICBsb2NhdGlvbl9pZDogJzEyM2U0NTY3LWU4OWItMTJkMy1hNDU2LTQyNjYxNDE3NDAwMCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQmVhdXRpZnVsIGNlcmVtb255JyxcbiAgICAgICAgY3JlYXRlZF9hdDogJzIwMjQtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgICAgdXBkYXRlZF9hdDogJzIwMjQtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBtb2NrRXZlbnQsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2luZ2xlOiBtb2NrU2luZ2xlIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxIH0pO1xuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBldmVudFNlcnZpY2UuZ2V0KCdldmVudC0xJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuaWQpLnRvQmUoJ2V2ZW50LTEnKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLm5hbWUpLnRvQmUoJ1dlZGRpbmcgQ2VyZW1vbnknKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmV2ZW50VHlwZSkudG9CZSgnY2VyZW1vbnknKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIE5PVF9GT1VORCB3aGVuIGV2ZW50IGRvZXMgbm90IGV4aXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiB7IGNvZGU6ICdQR1JTVDExNicgfSxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHNpbmdsZTogbW9ja1NpbmdsZSB9KTtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcSB9KTtcbiAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZSh7IHNlbGVjdDogbW9ja1NlbGVjdCB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXZlbnRTZXJ2aWNlLmdldCgnbm9uZXhpc3RlbnQtaWQnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdOT1RfRk9VTkQnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIERBVEFCQVNFX0VSUk9SIHdoZW4gZGF0YWJhc2UgcXVlcnkgZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogJ0Nvbm5lY3Rpb24gZmFpbGVkJyB9LFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2luZ2xlOiBtb2NrU2luZ2xlIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxIH0pO1xuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBldmVudFNlcnZpY2UuZ2V0KCdldmVudC0xJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnREFUQUJBU0VfRVJST1InKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3VwZGF0ZScsICgpID0+IHtcbiAgICBjb25zdCB1cGRhdGVEYXRhOiBVcGRhdGVFdmVudERUTyA9IHtcbiAgICAgIG5hbWU6ICdVcGRhdGVkIENlcmVtb255JyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnVXBkYXRlZCBkZXNjcmlwdGlvbicsXG4gICAgfTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3Mgd2l0aCB1cGRhdGVkIGV2ZW50IGRhdGEgd2hlbiB2YWxpZCBpbnB1dCBwcm92aWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tVcGRhdGVkRXZlbnQgPSB7XG4gICAgICAgIGlkOiAnZXZlbnQtMScsXG4gICAgICAgIG5hbWU6ICdVcGRhdGVkIENlcmVtb255JyxcbiAgICAgICAgZXZlbnRfdHlwZTogJ2NlcmVtb255JyxcbiAgICAgICAgc3RhcnRfZGF0ZTogJzIwMjUtMDYtMTVUMTQ6MDA6MDBaJyxcbiAgICAgICAgZW5kX2RhdGU6ICcyMDI1LTA2LTE1VDE1OjAwOjAwWicsXG4gICAgICAgIGxvY2F0aW9uX2lkOiAnMTIzZTQ1NjctZTg5Yi0xMmQzLWE0NTYtNDI2NjE0MTc0MDAwJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdVcGRhdGVkIGRlc2NyaXB0aW9uJyxcbiAgICAgICAgY3JlYXRlZF9hdDogJzIwMjQtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgICAgdXBkYXRlZF9hdDogJzIwMjQtMDEtMDJUMDA6MDA6MDBaJyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBtb2NrVXBkYXRlZEV2ZW50LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzaW5nbGU6IG1vY2tTaW5nbGUgfSk7XG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0pO1xuICAgICAgY29uc3QgbW9ja1VwZGF0ZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxIH0pO1xuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHsgdXBkYXRlOiBtb2NrVXBkYXRlIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBldmVudFNlcnZpY2UudXBkYXRlKCdldmVudC0xJywgdXBkYXRlRGF0YSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEubmFtZSkudG9CZSgnVXBkYXRlZCBDZXJlbW9ueScpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuZGVzY3JpcHRpb24pLnRvQmUoJ1VwZGF0ZWQgZGVzY3JpcHRpb24nKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY2hlY2sgZm9yIHNjaGVkdWxpbmcgY29uZmxpY3RzIHdoZW4gbG9jYXRpb24gb3IgZGF0ZXMgYXJlIHVwZGF0ZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBldmVudElkID0gJzEyM2U0NTY3LWU4OWItMTJkMy1hNDU2LTQyNjYxNDE3NDAwMSc7IC8vIFZhbGlkIFVVSURcbiAgICAgIGNvbnN0IHVwZGF0ZVdpdGhMb2NhdGlvbiA9IHtcbiAgICAgICAgbG9jYXRpb25JZDogJzIyM2U0NTY3LWU4OWItMTJkMy1hNDU2LTQyNjYxNDE3NDAwMCcsIC8vIFZhbGlkIFVVSURcbiAgICAgICAgc3RhcnREYXRlOiAnMjAyNS0wNi0xNVQxNjowMDowMFonLFxuICAgICAgfTtcblxuICAgICAgLy8gVGhyZWUgc2VwYXJhdGUgY2FsbHMgdG8gZnJvbSgpOlxuICAgICAgLy8gMS4gZ2V0KCkgLSBmZXRjaCBjdXJyZW50IGV2ZW50XG4gICAgICAvLyAyLiBjaGVja1NjaGVkdWxpbmdDb25mbGljdHMoKSAtIGNoZWNrIGZvciBjb25mbGljdHNcbiAgICAgIC8vIDMuIHVwZGF0ZSgpIC0gcGVyZm9ybSB0aGUgdXBkYXRlXG4gICAgICBsZXQgY2FsbENvdW50ID0gMDtcbiAgICAgIG1vY2tGcm9tLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIGNhbGxDb3VudCsrO1xuICAgICAgICBpZiAoY2FsbENvdW50ID09PSAxKSB7XG4gICAgICAgICAgLy8gR2V0IGN1cnJlbnQgZXZlbnQ6IC5mcm9tKCdldmVudHMnKS5zZWxlY3QoJyonKS5lcSgnaWQnLCBpZCkuc2luZ2xlKClcbiAgICAgICAgICBjb25zdCBtb2NrU2luZ2xlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgaWQ6IGV2ZW50SWQsXG4gICAgICAgICAgICAgIG5hbWU6ICdXZWRkaW5nIENlcmVtb255JyxcbiAgICAgICAgICAgICAgZXZlbnRfdHlwZTogJ2NlcmVtb255JyxcbiAgICAgICAgICAgICAgc3RhcnRfZGF0ZTogJzIwMjUtMDYtMTVUMTQ6MDA6MDBaJyxcbiAgICAgICAgICAgICAgZW5kX2RhdGU6ICcyMDI1LTA2LTE1VDE1OjAwOjAwWicsXG4gICAgICAgICAgICAgIGxvY2F0aW9uX2lkOiAnMTIzZTQ1NjctZTg5Yi0xMmQzLWE0NTYtNDI2NjE0MTc0MDAwJyxcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdCZWF1dGlmdWwgY2VyZW1vbnknLFxuICAgICAgICAgICAgICBjcmVhdGVkX2F0OiAnMjAyNC0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICAgICAgICB1cGRhdGVkX2F0OiAnMjAyNC0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzaW5nbGU6IG1vY2tTaW5nbGUgfSk7XG4gICAgICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxIH0pO1xuICAgICAgICAgIHJldHVybiB7IHNlbGVjdDogbW9ja1NlbGVjdCB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNhbGxDb3VudCA9PT0gMikge1xuICAgICAgICAgIC8vIENvbmZsaWN0IGNoZWNrOiAuZnJvbSgnZXZlbnRzJykuc2VsZWN0KC4uLikuZXEoJ2xvY2F0aW9uX2lkJywgLi4uKS5uZXEoJ2lkJywgLi4uKVxuICAgICAgICAgIGNvbnN0IG1vY2tOZXEgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgbmVxOiBtb2NrTmVxIH0pO1xuICAgICAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcSB9KTtcbiAgICAgICAgICByZXR1cm4geyBzZWxlY3Q6IG1vY2tTZWxlY3QgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBVcGRhdGUgb3BlcmF0aW9uOiAuZnJvbSgnZXZlbnRzJykudXBkYXRlKC4uLikuZXEoJ2lkJywgLi4uKS5zZWxlY3QoKS5zaW5nbGUoKVxuICAgICAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBpZDogZXZlbnRJZCxcbiAgICAgICAgICAgICAgbmFtZTogJ1dlZGRpbmcgQ2VyZW1vbnknLFxuICAgICAgICAgICAgICBsb2NhdGlvbl9pZDogJzIyM2U0NTY3LWU4OWItMTJkMy1hNDU2LTQyNjYxNDE3NDAwMCcsXG4gICAgICAgICAgICAgIHN0YXJ0X2RhdGU6ICcyMDI1LTA2LTE1VDE2OjAwOjAwWicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzaW5nbGU6IG1vY2tTaW5nbGUgfSk7XG4gICAgICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHNlbGVjdDogbW9ja1NlbGVjdCB9KTtcbiAgICAgICAgICBjb25zdCBtb2NrVXBkYXRlID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXEgfSk7XG4gICAgICAgICAgcmV0dXJuIHsgdXBkYXRlOiBtb2NrVXBkYXRlIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBldmVudFNlcnZpY2UudXBkYXRlKGV2ZW50SWQsIHVwZGF0ZVdpdGhMb2NhdGlvbik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIE5PVF9GT1VORCB3aGVuIGV2ZW50IHRvIHVwZGF0ZSBkb2VzIG5vdCBleGlzdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogeyBjb2RlOiAnUEdSU1QxMTYnIH0sXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2luZ2xlOiBtb2NrU2luZ2xlIH0pO1xuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHNlbGVjdDogbW9ja1NlbGVjdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tVcGRhdGUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcSB9KTtcbiAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZSh7IHVwZGF0ZTogbW9ja1VwZGF0ZSB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXZlbnRTZXJ2aWNlLnVwZGF0ZSgnbm9uZXhpc3RlbnQtaWQnLCB1cGRhdGVEYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdOT1RfRk9VTkQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2RlbGV0ZUV2ZW50JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3Mgd2hlbiBldmVudCBpcyBkZWxldGVkIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrRGVsZXRlID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXEgfSk7XG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBkZWxldGU6IG1vY2tEZWxldGUgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV2ZW50U2VydmljZS5kZWxldGVFdmVudCgnZXZlbnQtMScpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBEQVRBQkFTRV9FUlJPUiB3aGVuIGRlbGV0ZSBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6ICdGb3JlaWduIGtleSBjb25zdHJhaW50IHZpb2xhdGlvbicgfSxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbW9ja0RlbGV0ZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxIH0pO1xuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHsgZGVsZXRlOiBtb2NrRGVsZXRlIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBldmVudFNlcnZpY2UuZGVsZXRlRXZlbnQoJ2V2ZW50LTEnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdEQVRBQkFTRV9FUlJPUicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnbGlzdCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIHdpdGggcGFnaW5hdGVkIGV2ZW50cyB3aGVuIHZhbGlkIGZpbHRlcnMgcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRXZlbnRzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdldmVudC0xJyxcbiAgICAgICAgICBuYW1lOiAnQ2VyZW1vbnknLFxuICAgICAgICAgIGV2ZW50X3R5cGU6ICdjZXJlbW9ueScsXG4gICAgICAgICAgc3RhcnRfZGF0ZTogJzIwMjUtMDYtMTVUMTQ6MDA6MDBaJyxcbiAgICAgICAgICBlbmRfZGF0ZTogJzIwMjUtMDYtMTVUMTU6MDA6MDBaJyxcbiAgICAgICAgICBsb2NhdGlvbl9pZDogbnVsbCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogbnVsbCxcbiAgICAgICAgICBjcmVhdGVkX2F0OiAnMjAyNC0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6ICcyMDI0LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ2V2ZW50LTInLFxuICAgICAgICAgIG5hbWU6ICdSZWNlcHRpb24nLFxuICAgICAgICAgIGV2ZW50X3R5cGU6ICdyZWNlcHRpb24nLFxuICAgICAgICAgIHN0YXJ0X2RhdGU6ICcyMDI1LTA2LTE1VDE4OjAwOjAwWicsXG4gICAgICAgICAgZW5kX2RhdGU6ICcyMDI1LTA2LTE1VDIzOjAwOjAwWicsXG4gICAgICAgICAgbG9jYXRpb25faWQ6IG51bGwsXG4gICAgICAgICAgZGVzY3JpcHRpb246IG51bGwsXG4gICAgICAgICAgY3JlYXRlZF9hdDogJzIwMjQtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgICAgICB1cGRhdGVkX2F0OiAnMjAyNC0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgY29uc3QgbW9ja1JhbmdlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbW9ja0V2ZW50cyxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIGNvdW50OiAyLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrT3JkZXIgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgcmFuZ2U6IG1vY2tSYW5nZSB9KTtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgb3JkZXI6IG1vY2tPcmRlciB9KTtcbiAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZSh7IHNlbGVjdDogbW9ja1NlbGVjdCB9KTtcblxuICAgICAgY29uc3QgZmlsdGVyczogRXZlbnRGaWx0ZXJEVE8gPSB7IHBhZ2U6IDEsIHBhZ2VTaXplOiAxMCB9O1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXZlbnRTZXJ2aWNlLmxpc3QoZmlsdGVycyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuZXZlbnRzKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS50b3RhbCkudG9CZSgyKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnBhZ2UpLnRvQmUoMSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5wYWdlU2l6ZSkudG9CZSgxMCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGZpbHRlciBieSBldmVudCB0eXBlIHdoZW4gcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBmaWx0ZXJzOiBFdmVudEZpbHRlckRUTyA9IHtcbiAgICAgICAgZXZlbnRUeXBlOiAnY2VyZW1vbnknLFxuICAgICAgICBwYWdlOiAxLFxuICAgICAgICBwYWdlU2l6ZTogMTAsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrUmFuZ2UgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIGNvdW50OiAwLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrT3JkZXIgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgcmFuZ2U6IG1vY2tSYW5nZSB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBvcmRlcjogbW9ja09yZGVyIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxIH0pO1xuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBldmVudFNlcnZpY2UubGlzdChmaWx0ZXJzKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBmaWx0ZXIgYnkgZGF0ZSByYW5nZSB3aGVuIHByb3ZpZGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZmlsdGVyczogRXZlbnRGaWx0ZXJEVE8gPSB7XG4gICAgICAgIHN0YXJ0RGF0ZUZyb206ICcyMDI1LTA2LTAxVDAwOjAwOjAwWicsXG4gICAgICAgIHN0YXJ0RGF0ZVRvOiAnMjAyNS0wNi0zMFQyMzo1OTo1OVonLFxuICAgICAgICBwYWdlOiAxLFxuICAgICAgICBwYWdlU2l6ZTogMTAsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrUmFuZ2UgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIGNvdW50OiAwLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrT3JkZXIgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgcmFuZ2U6IG1vY2tSYW5nZSB9KTtcbiAgICAgIGNvbnN0IG1vY2tMdGUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgb3JkZXI6IG1vY2tPcmRlciB9KTtcbiAgICAgIGNvbnN0IG1vY2tHdGUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgbHRlOiBtb2NrTHRlIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBndGU6IG1vY2tHdGUgfSk7XG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV2ZW50U2VydmljZS5saXN0KGZpbHRlcnMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBEQVRBQkFTRV9FUlJPUiB3aGVuIHF1ZXJ5IGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1JhbmdlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogJ0Nvbm5lY3Rpb24gZmFpbGVkJyB9LFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrT3JkZXIgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgcmFuZ2U6IG1vY2tSYW5nZSB9KTtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgb3JkZXI6IG1vY2tPcmRlciB9KTtcbiAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZSh7IHNlbGVjdDogbW9ja1NlbGVjdCB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXZlbnRTZXJ2aWNlLmxpc3QoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdEQVRBQkFTRV9FUlJPUicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnc2VhcmNoJywgKCkgPT4ge1xuICAgIGNvbnN0IHNlYXJjaFBhcmFtczogRXZlbnRTZWFyY2hEVE8gPSB7XG4gICAgICBxdWVyeTogJ2NlcmVtb255JyxcbiAgICAgIHBhZ2U6IDEsXG4gICAgICBwYWdlU2l6ZTogMTAsXG4gICAgfTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3Mgd2l0aCBzZWFyY2ggcmVzdWx0cyB3aGVuIHZhbGlkIHF1ZXJ5IHByb3ZpZGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1Jlc3VsdHMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ2V2ZW50LTEnLFxuICAgICAgICAgIG5hbWU6ICdXZWRkaW5nIENlcmVtb255JyxcbiAgICAgICAgICBldmVudF90eXBlOiAnY2VyZW1vbnknLFxuICAgICAgICAgIHN0YXJ0X2RhdGU6ICcyMDI1LTA2LTE1VDE0OjAwOjAwWicsXG4gICAgICAgICAgZW5kX2RhdGU6ICcyMDI1LTA2LTE1VDE1OjAwOjAwWicsXG4gICAgICAgICAgbG9jYXRpb25faWQ6IG51bGwsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdCZWF1dGlmdWwgY2VyZW1vbnkgYnkgdGhlIGJlYWNoJyxcbiAgICAgICAgICBjcmVhdGVkX2F0OiAnMjAyNC0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6ICcyMDI0LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBtb2NrUmFuZ2UgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBtb2NrUmVzdWx0cyxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIGNvdW50OiAxLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrT3JkZXIgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgcmFuZ2U6IG1vY2tSYW5nZSB9KTtcbiAgICAgIGNvbnN0IG1vY2tPciA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBvcmRlcjogbW9ja09yZGVyIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBvcjogbW9ja09yIH0pO1xuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBldmVudFNlcnZpY2Uuc2VhcmNoKHNlYXJjaFBhcmFtcyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuZXZlbnRzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5ldmVudHNbMF0ubmFtZSkudG9CZSgnV2VkZGluZyBDZXJlbW9ueScpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzYW5pdGl6ZSBzZWFyY2ggcXVlcnkgdG8gcHJldmVudCBpbmplY3Rpb24gYXR0YWNrcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1hbGljaW91c1NlYXJjaCA9IHtcbiAgICAgICAgcXVlcnk6ICc8c2NyaXB0PmFsZXJ0KFwieHNzXCIpPC9zY3JpcHQ+Y2VyZW1vbnknLFxuICAgICAgICBwYWdlOiAxLFxuICAgICAgICBwYWdlU2l6ZTogMTAsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrUmFuZ2UgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIGNvdW50OiAwLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrT3JkZXIgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgcmFuZ2U6IG1vY2tSYW5nZSB9KTtcbiAgICAgIGNvbnN0IG1vY2tPciA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBvcmRlcjogbW9ja09yZGVyIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBvcjogbW9ja09yIH0pO1xuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBldmVudFNlcnZpY2Uuc2VhcmNoKG1hbGljaW91c1NlYXJjaCk7XG5cbiAgICAgIC8vIFZlcmlmeSBzYW5pdGl6YXRpb24gd2FzIGNhbGxlZFxuICAgICAgY29uc3QgeyBzYW5pdGl6ZUlucHV0IH0gPSByZXF1aXJlKCcuLi91dGlscy9zYW5pdGl6YXRpb24nKTtcbiAgICAgIGV4cGVjdChzYW5pdGl6ZUlucHV0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChtYWxpY2lvdXNTZWFyY2gucXVlcnkpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gVkFMSURBVElPTl9FUlJPUiB3aGVuIHF1ZXJ5IGlzIGVtcHR5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFNlYXJjaCA9IHsgLi4uc2VhcmNoUGFyYW1zLCBxdWVyeTogJycgfTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV2ZW50U2VydmljZS5zZWFyY2goaW52YWxpZFNlYXJjaCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnVkFMSURBVElPTl9FUlJPUicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnY2hlY2tTY2hlZHVsaW5nQ29uZmxpY3RzJywgKCkgPT4ge1xuICAgIGNvbnN0IGNvbmZsaWN0UGFyYW1zOiBDb25mbGljdENoZWNrRFRPID0ge1xuICAgICAgbG9jYXRpb25JZDogJzEyM2U0NTY3LWU4OWItMTJkMy1hNDU2LTQyNjYxNDE3NDAwMCcsXG4gICAgICBzdGFydERhdGU6ICcyMDI1LTA2LTE1VDE0OjAwOjAwWicsXG4gICAgICBlbmREYXRlOiAnMjAyNS0wNi0xNVQxNTowMDowMFonLFxuICAgIH07XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIHdpdGggbm8gY29uZmxpY3RzIHdoZW4gbm8gb3ZlcmxhcHBpbmcgZXZlbnRzIGV4aXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXEgfSk7XG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV2ZW50U2VydmljZS5jaGVja1NjaGVkdWxpbmdDb25mbGljdHMoY29uZmxpY3RQYXJhbXMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmhhc0NvbmZsaWN0KS50b0JlKGZhbHNlKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmNvbmZsaWN0aW5nRXZlbnRzKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIHdpdGggY29uZmxpY3RzIHdoZW4gb3ZlcmxhcHBpbmcgZXZlbnRzIGV4aXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdFdmVudCA9IHtcbiAgICAgICAgaWQ6ICdleGlzdGluZy1ldmVudCcsXG4gICAgICAgIG5hbWU6ICdFeGlzdGluZyBFdmVudCcsXG4gICAgICAgIHN0YXJ0X2RhdGU6ICcyMDI1LTA2LTE1VDEzOjMwOjAwWicsXG4gICAgICAgIGVuZF9kYXRlOiAnMjAyNS0wNi0xNVQxNDozMDowMFonLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogW292ZXJsYXBwaW5nRXZlbnRdLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxIH0pO1xuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBldmVudFNlcnZpY2UuY2hlY2tTY2hlZHVsaW5nQ29uZmxpY3RzKGNvbmZsaWN0UGFyYW1zKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5oYXNDb25mbGljdCkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmNvbmZsaWN0aW5nRXZlbnRzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5jb25mbGljdGluZ0V2ZW50c1swXS5pZCkudG9CZSgnZXhpc3RpbmctZXZlbnQnKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmNvbmZsaWN0aW5nRXZlbnRzWzBdLm5hbWUpLnRvQmUoJ0V4aXN0aW5nIEV2ZW50Jyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGV4Y2x1ZGUgc3BlY2lmaWVkIGV2ZW50IElEIGZyb20gY29uZmxpY3QgY2hlY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwYXJhbXNXaXRoRXhjbHVzaW9uID0ge1xuICAgICAgICAuLi5jb25mbGljdFBhcmFtcyxcbiAgICAgICAgZXhjbHVkZUV2ZW50SWQ6ICcyMjNlNDU2Ny1lODliLTEyZDMtYTQ1Ni00MjY2MTQxNzQwMDEnLCAvLyBWYWxpZCBVVUlEXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrTmVxID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgbmVxOiBtb2NrTmVxIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxIH0pO1xuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBldmVudFNlcnZpY2UuY2hlY2tTY2hlZHVsaW5nQ29uZmxpY3RzKHBhcmFtc1dpdGhFeGNsdXNpb24pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmhhc0NvbmZsaWN0KS50b0JlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGV2ZW50cyB3aXRob3V0IGVuZCBkYXRlcyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBldmVudFdpdGhvdXRFbmREYXRlID0ge1xuICAgICAgICBpZDogJ3BvaW50LWV2ZW50JyxcbiAgICAgICAgbmFtZTogJ1BvaW50IEV2ZW50JyxcbiAgICAgICAgc3RhcnRfZGF0ZTogJzIwMjUtMDYtMTVUMTQ6MzA6MDBaJyxcbiAgICAgICAgZW5kX2RhdGU6IG51bGwsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBbZXZlbnRXaXRob3V0RW5kRGF0ZV0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXEgfSk7XG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV2ZW50U2VydmljZS5jaGVja1NjaGVkdWxpbmdDb25mbGljdHMoY29uZmxpY3RQYXJhbXMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmhhc0NvbmZsaWN0KS50b0JlKHRydWUpOyAvLyBTaG91bGQgc3RpbGwgZGV0ZWN0IG92ZXJsYXBcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIERBVEFCQVNFX0VSUk9SIHdoZW4gcXVlcnkgZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnQ29ubmVjdGlvbiBmYWlsZWQnIH0sXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcSB9KTtcbiAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZSh7IHNlbGVjdDogbW9ja1NlbGVjdCB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXZlbnRTZXJ2aWNlLmNoZWNrU2NoZWR1bGluZ0NvbmZsaWN0cyhjb25mbGljdFBhcmFtcyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnREFUQUJBU0VfRVJST1InKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIFZBTElEQVRJT05fRVJST1Igd2hlbiBsb2NhdGlvbklkIGlzIGludmFsaWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkUGFyYW1zID0geyAuLi5jb25mbGljdFBhcmFtcywgbG9jYXRpb25JZDogJ2ludmFsaWQtdXVpZCcgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXZlbnRTZXJ2aWNlLmNoZWNrU2NoZWR1bGluZ0NvbmZsaWN0cyhpbnZhbGlkUGFyYW1zKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdWQUxJREFUSU9OX0VSUk9SJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJTVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZIiwiamVzdCIsIm1vY2siLCJzYW5pdGl6ZUlucHV0IiwiZm4iLCJpbnB1dCIsInRyaW0iLCJzYW5pdGl6ZVJpY2hUZXh0IiwibW9ja0Zyb20iLCJtb2NrU3VwYWJhc2VDbGllbnQiLCJmcm9tIiwiY3JlYXRlQ2xpZW50IiwiX19tb2NrRnJvbSIsImV2ZW50U2VydmljZU1vZHVsZSIsInJlcXVpcmUiLCJldmVudFNlcnZpY2UiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwidmFsaWREYXRhIiwibmFtZSIsImV2ZW50VHlwZSIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJsb2NhdGlvbklkIiwiZGVzY3JpcHRpb24iLCJpdCIsIm1vY2tFdmVudCIsImlkIiwiZXZlbnRfdHlwZSIsInN0YXJ0X2RhdGUiLCJlbmRfZGF0ZSIsImxvY2F0aW9uX2lkIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJjYWxsQ291bnQiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJtb2NrRXEiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsImRhdGEiLCJlcnJvciIsIm1vY2tTZWxlY3QiLCJtb2NrUmV0dXJuVmFsdWUiLCJlcSIsInNlbGVjdCIsIm1vY2tTaW5nbGUiLCJzaW5nbGUiLCJtb2NrSW5zZXJ0IiwiaW5zZXJ0IiwicmVzdWx0IiwiY3JlYXRlIiwiZXhwZWN0Iiwic3VjY2VzcyIsInRvQmUiLCJpbnZhbGlkRGF0YSIsImNvZGUiLCJjb25mbGljdGluZ0V2ZW50IiwiZGV0YWlscyIsInRvSGF2ZUxlbmd0aCIsIm1lc3NhZ2UiLCJtYWxpY2lvdXNEYXRhIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJnZXQiLCJ1cGRhdGVEYXRhIiwibW9ja1VwZGF0ZWRFdmVudCIsIm1vY2tVcGRhdGUiLCJ1cGRhdGUiLCJldmVudElkIiwidXBkYXRlV2l0aExvY2F0aW9uIiwibW9ja05lcSIsIm5lcSIsIm1vY2tEZWxldGUiLCJkZWxldGUiLCJkZWxldGVFdmVudCIsIm1vY2tFdmVudHMiLCJtb2NrUmFuZ2UiLCJjb3VudCIsIm1vY2tPcmRlciIsInJhbmdlIiwib3JkZXIiLCJmaWx0ZXJzIiwicGFnZSIsInBhZ2VTaXplIiwibGlzdCIsImV2ZW50cyIsInRvdGFsIiwic3RhcnREYXRlRnJvbSIsInN0YXJ0RGF0ZVRvIiwibW9ja0x0ZSIsIm1vY2tHdGUiLCJsdGUiLCJndGUiLCJzZWFyY2hQYXJhbXMiLCJxdWVyeSIsIm1vY2tSZXN1bHRzIiwibW9ja09yIiwib3IiLCJzZWFyY2giLCJtYWxpY2lvdXNTZWFyY2giLCJpbnZhbGlkU2VhcmNoIiwiY29uZmxpY3RQYXJhbXMiLCJjaGVja1NjaGVkdWxpbmdDb25mbGljdHMiLCJoYXNDb25mbGljdCIsImNvbmZsaWN0aW5nRXZlbnRzIiwib3ZlcmxhcHBpbmdFdmVudCIsInBhcmFtc1dpdGhFeGNsdXNpb24iLCJleGNsdWRlRXZlbnRJZCIsImV2ZW50V2l0aG91dEVuZERhdGUiLCJpbnZhbGlkUGFyYW1zIl0sIm1hcHBpbmdzIjoiOzs7O3lCQUF1RDtBQUd2RCxrQ0FBa0M7QUFDbENBLFFBQVFDLEdBQUcsQ0FBQ0Msd0JB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