0c4dae27d468bcfdfe50a46c35a14f06
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _errors = require("./errors");
const _types = require("../types");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('Error Handling Utilities', ()=>{
    describe('success', ()=>{
        it('should create a success Result with data', ()=>{
            const data = {
                id: '123',
                name: 'Test'
            };
            const result = (0, _errors.success)(data);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data).toEqual(data);
            }
        });
    });
    describe('error', ()=>{
        it('should create an error Result with code and message', ()=>{
            const result = (0, _errors.error)(_types.ERROR_CODES.VALIDATION_ERROR, 'Test error');
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe(_types.ERROR_CODES.VALIDATION_ERROR);
                expect(result.error.message).toBe('Test error');
            }
        });
        it('should include optional details', ()=>{
            const details = {
                field: 'email',
                issue: 'invalid format'
            };
            const result = (0, _errors.error)(_types.ERROR_CODES.VALIDATION_ERROR, 'Test error', details);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.details).toEqual(details);
            }
        });
    });
    describe('validationError', ()=>{
        it('should create a validation error with default message', ()=>{
            const result = (0, _errors.validationError)();
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe(_types.ERROR_CODES.VALIDATION_ERROR);
                expect(result.error.message).toBe('Validation failed');
            }
        });
        it('should create a validation error with custom message', ()=>{
            const result = (0, _errors.validationError)('Custom validation error');
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.message).toBe('Custom validation error');
            }
        });
    });
    describe('HTTP status code mapping', ()=>{
        it('should map error codes to correct HTTP status codes', ()=>{
            expect((0, _errors.getStatusFromErrorCode)(_types.ERROR_CODES.VALIDATION_ERROR)).toBe(400);
            expect((0, _errors.getStatusFromErrorCode)(_types.ERROR_CODES.UNAUTHORIZED)).toBe(401);
            expect((0, _errors.getStatusFromErrorCode)(_types.ERROR_CODES.FORBIDDEN)).toBe(403);
            expect((0, _errors.getStatusFromErrorCode)(_types.ERROR_CODES.NOT_FOUND)).toBe(404);
            expect((0, _errors.getStatusFromErrorCode)(_types.ERROR_CODES.CONFLICT)).toBe(409);
            expect((0, _errors.getStatusFromErrorCode)(_types.ERROR_CODES.EXTERNAL_SERVICE_ERROR)).toBe(503);
        });
        it('should map HTTP status codes to error codes', ()=>{
            expect((0, _errors.getErrorCodeFromStatus)(400)).toBe(_types.ERROR_CODES.VALIDATION_ERROR);
            expect((0, _errors.getErrorCodeFromStatus)(401)).toBe(_types.ERROR_CODES.UNAUTHORIZED);
            expect((0, _errors.getErrorCodeFromStatus)(403)).toBe(_types.ERROR_CODES.FORBIDDEN);
            expect((0, _errors.getErrorCodeFromStatus)(404)).toBe(_types.ERROR_CODES.NOT_FOUND);
            expect((0, _errors.getErrorCodeFromStatus)(409)).toBe(_types.ERROR_CODES.CONFLICT);
            expect((0, _errors.getErrorCodeFromStatus)(503)).toBe(_types.ERROR_CODES.EXTERNAL_SERVICE_ERROR);
        });
    });
});
/**
 * Feature: destination-wedding-platform, Property 6: XSS and Injection Prevention (partial - error handling)
 * Validates: Requirements 4.18, 18.2
 * 
 * This property test ensures that error handling utilities properly handle
 * malicious input without exposing vulnerabilities or breaking the error handling flow.
 */ describe('Property Test: XSS and Injection Prevention in Error Handling', ()=>{
    // Arbitrary for generating malicious strings
    const maliciousInputArbitrary = _fastcheck.oneof(_fastcheck.constant('<script>alert("xss")</script>'), _fastcheck.constant('"; DROP TABLE guests; --'), _fastcheck.constant('<img src=x onerror=alert(1)>'), _fastcheck.constant('javascript:alert(1)'), _fastcheck.constant('<svg onload=alert(1)>'), _fastcheck.constant("' OR '1'='1"), _fastcheck.constant('${alert(1)}'), _fastcheck.constant('{{constructor.constructor("alert(1)")()}}'), _fastcheck.string().map((s)=>`${s}<script>alert(1)</script>`), _fastcheck.string().map((s)=>`${s}'; DROP TABLE users; --`));
    it('should safely handle malicious input in error messages', ()=>{
        _fastcheck.assert(_fastcheck.property(maliciousInputArbitrary, (maliciousInput)=>{
            // Create error with malicious message
            const result = (0, _errors.error)(_types.ERROR_CODES.VALIDATION_ERROR, maliciousInput);
            // Verify error structure is maintained
            expect(result.success).toBe(false);
            if (!result.success) {
                // Error message should be stored as-is (sanitization happens at display time)
                expect(result.error.message).toBe(maliciousInput);
                expect(result.error.code).toBe(_types.ERROR_CODES.VALIDATION_ERROR);
                // Verify the error object is serializable (no code injection)
                const serialized = JSON.stringify(result);
                expect(()=>JSON.parse(serialized)).not.toThrow();
                // Verify serialization produces valid JSON structure
                const parsed = JSON.parse(serialized);
                expect(parsed.success).toBe(false);
                expect(parsed.error).toBeDefined();
                expect(parsed.error.code).toBe(_types.ERROR_CODES.VALIDATION_ERROR);
                // The message is stored as-is - sanitization should happen at display time
                // This is correct behavior for error handling
                expect(parsed.error.message).toBe(maliciousInput);
            }
        }), {
            numRuns: 100
        });
    });
    it('should safely handle malicious input in error details', ()=>{
        _fastcheck.assert(_fastcheck.property(maliciousInputArbitrary, (maliciousInput)=>{
            const details = {
                field: maliciousInput,
                value: maliciousInput,
                nested: {
                    data: maliciousInput
                }
            };
            const result = (0, _errors.error)(_types.ERROR_CODES.VALIDATION_ERROR, 'Test error', details);
            expect(result.success).toBe(false);
            if (!result.success) {
                // Details should be stored as-is
                expect(result.error.details).toEqual(details);
                // Verify serialization safety
                const serialized = JSON.stringify(result);
                expect(()=>JSON.parse(serialized)).not.toThrow();
            }
        }), {
            numRuns: 100
        });
    });
    it('should handle all error types with malicious input', ()=>{
        _fastcheck.assert(_fastcheck.property(maliciousInputArbitrary, (maliciousInput)=>{
            const errorFunctions = [
                ()=>(0, _errors.validationError)(maliciousInput),
                ()=>(0, _errors.databaseError)(maliciousInput),
                ()=>(0, _errors.unauthorizedError)(maliciousInput),
                ()=>(0, _errors.notFoundError)(maliciousInput)
            ];
            errorFunctions.forEach((fn)=>{
                const result = fn();
                expect(result.success).toBe(false);
                if (!result.success) {
                    // Verify error structure is maintained
                    expect(result.error.code).toBeDefined();
                    expect(result.error.message).toBeDefined();
                    // Verify serialization safety
                    expect(()=>JSON.stringify(result)).not.toThrow();
                }
            });
        }), {
            numRuns: 100
        });
    });
    it('should handle unknown errors with malicious Error objects', ()=>{
        _fastcheck.assert(_fastcheck.property(maliciousInputArbitrary, (maliciousInput)=>{
            const maliciousError = new Error(maliciousInput);
            const result = (0, _errors.unknownError)(maliciousError);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe(_types.ERROR_CODES.UNKNOWN_ERROR);
                expect(result.error.message).toBe(maliciousInput);
                // Verify serialization safety
                const serialized = JSON.stringify(result);
                expect(()=>JSON.parse(serialized)).not.toThrow();
            }
        }), {
            numRuns: 100
        });
    });
    it('should maintain type safety with any input', ()=>{
        _fastcheck.assert(_fastcheck.property(_fastcheck.anything(), _fastcheck.string(), (data, message)=>{
            // Success case
            const successResult = (0, _errors.success)(data);
            expect(successResult.success).toBe(true);
            if (successResult.success) {
                expect(successResult.data).toBe(data);
            }
            // Error case
            const errorResult = (0, _errors.error)(_types.ERROR_CODES.VALIDATION_ERROR, message, data);
            expect(errorResult.success).toBe(false);
            if (!errorResult.success) {
                expect(errorResult.error.details).toBe(data);
            }
        }), {
            numRuns: 100
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvdXRpbHMvZXJyb3JzLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZmMgZnJvbSAnZmFzdC1jaGVjayc7XG5pbXBvcnQge1xuICBzdWNjZXNzLFxuICBlcnJvcixcbiAgdmFsaWRhdGlvbkVycm9yLFxuICBkYXRhYmFzZUVycm9yLFxuICB1bmF1dGhvcml6ZWRFcnJvcixcbiAgbm90Rm91bmRFcnJvcixcbiAgdW5rbm93bkVycm9yLFxuICBnZXRFcnJvckNvZGVGcm9tU3RhdHVzLFxuICBnZXRTdGF0dXNGcm9tRXJyb3JDb2RlLFxufSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBFUlJPUl9DT0RFUyB9IGZyb20gJ0AvdHlwZXMnO1xuXG5kZXNjcmliZSgnRXJyb3IgSGFuZGxpbmcgVXRpbGl0aWVzJywgKCkgPT4ge1xuICBkZXNjcmliZSgnc3VjY2VzcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSBhIHN1Y2Nlc3MgUmVzdWx0IHdpdGggZGF0YScsICgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSB7IGlkOiAnMTIzJywgbmFtZTogJ1Rlc3QnIH07XG4gICAgICBjb25zdCByZXN1bHQgPSBzdWNjZXNzKGRhdGEpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhKS50b0VxdWFsKGRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZXJyb3InLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgYW4gZXJyb3IgUmVzdWx0IHdpdGggY29kZSBhbmQgbWVzc2FnZScsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGVycm9yKEVSUk9SX0NPREVTLlZBTElEQVRJT05fRVJST1IsICdUZXN0IGVycm9yJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZShFUlJPUl9DT0RFUy5WQUxJREFUSU9OX0VSUk9SKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0JlKCdUZXN0IGVycm9yJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGluY2x1ZGUgb3B0aW9uYWwgZGV0YWlscycsICgpID0+IHtcbiAgICAgIGNvbnN0IGRldGFpbHMgPSB7IGZpZWxkOiAnZW1haWwnLCBpc3N1ZTogJ2ludmFsaWQgZm9ybWF0JyB9O1xuICAgICAgY29uc3QgcmVzdWx0ID0gZXJyb3IoRVJST1JfQ09ERVMuVkFMSURBVElPTl9FUlJPUiwgJ1Rlc3QgZXJyb3InLCBkZXRhaWxzKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5kZXRhaWxzKS50b0VxdWFsKGRldGFpbHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgndmFsaWRhdGlvbkVycm9yJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY3JlYXRlIGEgdmFsaWRhdGlvbiBlcnJvciB3aXRoIGRlZmF1bHQgbWVzc2FnZScsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRpb25FcnJvcigpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoRVJST1JfQ09ERVMuVkFMSURBVElPTl9FUlJPUik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9CZSgnVmFsaWRhdGlvbiBmYWlsZWQnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY3JlYXRlIGEgdmFsaWRhdGlvbiBlcnJvciB3aXRoIGN1c3RvbSBtZXNzYWdlJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGlvbkVycm9yKCdDdXN0b20gdmFsaWRhdGlvbiBlcnJvcicpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQmUoJ0N1c3RvbSB2YWxpZGF0aW9uIGVycm9yJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdIVFRQIHN0YXR1cyBjb2RlIG1hcHBpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBtYXAgZXJyb3IgY29kZXMgdG8gY29ycmVjdCBIVFRQIHN0YXR1cyBjb2RlcycsICgpID0+IHtcbiAgICAgIGV4cGVjdChnZXRTdGF0dXNGcm9tRXJyb3JDb2RlKEVSUk9SX0NPREVTLlZBTElEQVRJT05fRVJST1IpKS50b0JlKDQwMCk7XG4gICAgICBleHBlY3QoZ2V0U3RhdHVzRnJvbUVycm9yQ29kZShFUlJPUl9DT0RFUy5VTkFVVEhPUklaRUQpKS50b0JlKDQwMSk7XG4gICAgICBleHBlY3QoZ2V0U3RhdHVzRnJvbUVycm9yQ29kZShFUlJPUl9DT0RFUy5GT1JCSURERU4pKS50b0JlKDQwMyk7XG4gICAgICBleHBlY3QoZ2V0U3RhdHVzRnJvbUVycm9yQ29kZShFUlJPUl9DT0RFUy5OT1RfRk9VTkQpKS50b0JlKDQwNCk7XG4gICAgICBleHBlY3QoZ2V0U3RhdHVzRnJvbUVycm9yQ29kZShFUlJPUl9DT0RFUy5DT05GTElDVCkpLnRvQmUoNDA5KTtcbiAgICAgIGV4cGVjdChnZXRTdGF0dXNGcm9tRXJyb3JDb2RlKEVSUk9SX0NPREVTLkVYVEVSTkFMX1NFUlZJQ0VfRVJST1IpKS50b0JlKDUwMyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG1hcCBIVFRQIHN0YXR1cyBjb2RlcyB0byBlcnJvciBjb2RlcycsICgpID0+IHtcbiAgICAgIGV4cGVjdChnZXRFcnJvckNvZGVGcm9tU3RhdHVzKDQwMCkpLnRvQmUoRVJST1JfQ09ERVMuVkFMSURBVElPTl9FUlJPUik7XG4gICAgICBleHBlY3QoZ2V0RXJyb3JDb2RlRnJvbVN0YXR1cyg0MDEpKS50b0JlKEVSUk9SX0NPREVTLlVOQVVUSE9SSVpFRCk7XG4gICAgICBleHBlY3QoZ2V0RXJyb3JDb2RlRnJvbVN0YXR1cyg0MDMpKS50b0JlKEVSUk9SX0NPREVTLkZPUkJJRERFTik7XG4gICAgICBleHBlY3QoZ2V0RXJyb3JDb2RlRnJvbVN0YXR1cyg0MDQpKS50b0JlKEVSUk9SX0NPREVTLk5PVF9GT1VORCk7XG4gICAgICBleHBlY3QoZ2V0RXJyb3JDb2RlRnJvbVN0YXR1cyg0MDkpKS50b0JlKEVSUk9SX0NPREVTLkNPTkZMSUNUKTtcbiAgICAgIGV4cGVjdChnZXRFcnJvckNvZGVGcm9tU3RhdHVzKDUwMykpLnRvQmUoRVJST1JfQ09ERVMuRVhURVJOQUxfU0VSVklDRV9FUlJPUik7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbi8qKlxuICogRmVhdHVyZTogZGVzdGluYXRpb24td2VkZGluZy1wbGF0Zm9ybSwgUHJvcGVydHkgNjogWFNTIGFuZCBJbmplY3Rpb24gUHJldmVudGlvbiAocGFydGlhbCAtIGVycm9yIGhhbmRsaW5nKVxuICogVmFsaWRhdGVzOiBSZXF1aXJlbWVudHMgNC4xOCwgMTguMlxuICogXG4gKiBUaGlzIHByb3BlcnR5IHRlc3QgZW5zdXJlcyB0aGF0IGVycm9yIGhhbmRsaW5nIHV0aWxpdGllcyBwcm9wZXJseSBoYW5kbGVcbiAqIG1hbGljaW91cyBpbnB1dCB3aXRob3V0IGV4cG9zaW5nIHZ1bG5lcmFiaWxpdGllcyBvciBicmVha2luZyB0aGUgZXJyb3IgaGFuZGxpbmcgZmxvdy5cbiAqL1xuZGVzY3JpYmUoJ1Byb3BlcnR5IFRlc3Q6IFhTUyBhbmQgSW5qZWN0aW9uIFByZXZlbnRpb24gaW4gRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gIC8vIEFyYml0cmFyeSBmb3IgZ2VuZXJhdGluZyBtYWxpY2lvdXMgc3RyaW5nc1xuICBjb25zdCBtYWxpY2lvdXNJbnB1dEFyYml0cmFyeSA9IGZjLm9uZW9mKFxuICAgIGZjLmNvbnN0YW50KCc8c2NyaXB0PmFsZXJ0KFwieHNzXCIpPC9zY3JpcHQ+JyksXG4gICAgZmMuY29uc3RhbnQoJ1wiOyBEUk9QIFRBQkxFIGd1ZXN0czsgLS0nKSxcbiAgICBmYy5jb25zdGFudCgnPGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPicpLFxuICAgIGZjLmNvbnN0YW50KCdqYXZhc2NyaXB0OmFsZXJ0KDEpJyksXG4gICAgZmMuY29uc3RhbnQoJzxzdmcgb25sb2FkPWFsZXJ0KDEpPicpLFxuICAgIGZjLmNvbnN0YW50KFwiJyBPUiAnMSc9JzFcIiksXG4gICAgZmMuY29uc3RhbnQoJyR7YWxlcnQoMSl9JyksXG4gICAgZmMuY29uc3RhbnQoJ3t7Y29uc3RydWN0b3IuY29uc3RydWN0b3IoXCJhbGVydCgxKVwiKSgpfX0nKSxcbiAgICBmYy5zdHJpbmcoKS5tYXAocyA9PiBgJHtzfTxzY3JpcHQ+YWxlcnQoMSk8L3NjcmlwdD5gKSxcbiAgICBmYy5zdHJpbmcoKS5tYXAocyA9PiBgJHtzfSc7IERST1AgVEFCTEUgdXNlcnM7IC0tYClcbiAgKTtcblxuICBpdCgnc2hvdWxkIHNhZmVseSBoYW5kbGUgbWFsaWNpb3VzIGlucHV0IGluIGVycm9yIG1lc3NhZ2VzJywgKCkgPT4ge1xuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLnByb3BlcnR5KG1hbGljaW91c0lucHV0QXJiaXRyYXJ5LCAobWFsaWNpb3VzSW5wdXQpID0+IHtcbiAgICAgICAgLy8gQ3JlYXRlIGVycm9yIHdpdGggbWFsaWNpb3VzIG1lc3NhZ2VcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZXJyb3IoRVJST1JfQ09ERVMuVkFMSURBVElPTl9FUlJPUiwgbWFsaWNpb3VzSW5wdXQpO1xuICAgICAgICBcbiAgICAgICAgLy8gVmVyaWZ5IGVycm9yIHN0cnVjdHVyZSBpcyBtYWludGFpbmVkXG4gICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgLy8gRXJyb3IgbWVzc2FnZSBzaG91bGQgYmUgc3RvcmVkIGFzLWlzIChzYW5pdGl6YXRpb24gaGFwcGVucyBhdCBkaXNwbGF5IHRpbWUpXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0JlKG1hbGljaW91c0lucHV0KTtcbiAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoRVJST1JfQ09ERVMuVkFMSURBVElPTl9FUlJPUik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVmVyaWZ5IHRoZSBlcnJvciBvYmplY3QgaXMgc2VyaWFsaXphYmxlIChubyBjb2RlIGluamVjdGlvbilcbiAgICAgICAgICBjb25zdCBzZXJpYWxpemVkID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgICBleHBlY3QoKCkgPT4gSlNPTi5wYXJzZShzZXJpYWxpemVkKSkubm90LnRvVGhyb3coKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBWZXJpZnkgc2VyaWFsaXphdGlvbiBwcm9kdWNlcyB2YWxpZCBKU09OIHN0cnVjdHVyZVxuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICAgICAgZXhwZWN0KHBhcnNlZC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICBleHBlY3QocGFyc2VkLmVycm9yKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgIGV4cGVjdChwYXJzZWQuZXJyb3IuY29kZSkudG9CZShFUlJPUl9DT0RFUy5WQUxJREFUSU9OX0VSUk9SKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUaGUgbWVzc2FnZSBpcyBzdG9yZWQgYXMtaXMgLSBzYW5pdGl6YXRpb24gc2hvdWxkIGhhcHBlbiBhdCBkaXNwbGF5IHRpbWVcbiAgICAgICAgICAvLyBUaGlzIGlzIGNvcnJlY3QgYmVoYXZpb3IgZm9yIGVycm9yIGhhbmRsaW5nXG4gICAgICAgICAgZXhwZWN0KHBhcnNlZC5lcnJvci5tZXNzYWdlKS50b0JlKG1hbGljaW91c0lucHV0KTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBzYWZlbHkgaGFuZGxlIG1hbGljaW91cyBpbnB1dCBpbiBlcnJvciBkZXRhaWxzJywgKCkgPT4ge1xuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLnByb3BlcnR5KG1hbGljaW91c0lucHV0QXJiaXRyYXJ5LCAobWFsaWNpb3VzSW5wdXQpID0+IHtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IHtcbiAgICAgICAgICBmaWVsZDogbWFsaWNpb3VzSW5wdXQsXG4gICAgICAgICAgdmFsdWU6IG1hbGljaW91c0lucHV0LFxuICAgICAgICAgIG5lc3RlZDogeyBkYXRhOiBtYWxpY2lvdXNJbnB1dCB9LFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZXJyb3IoRVJST1JfQ09ERVMuVkFMSURBVElPTl9FUlJPUiwgJ1Rlc3QgZXJyb3InLCBkZXRhaWxzKTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgLy8gRGV0YWlscyBzaG91bGQgYmUgc3RvcmVkIGFzLWlzXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5kZXRhaWxzKS50b0VxdWFsKGRldGFpbHMpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFZlcmlmeSBzZXJpYWxpemF0aW9uIHNhZmV0eVxuICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICAgIGV4cGVjdCgoKSA9PiBKU09OLnBhcnNlKHNlcmlhbGl6ZWQpKS5ub3QudG9UaHJvdygpO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGhhbmRsZSBhbGwgZXJyb3IgdHlwZXMgd2l0aCBtYWxpY2lvdXMgaW5wdXQnLCAoKSA9PiB7XG4gICAgZmMuYXNzZXJ0KFxuICAgICAgZmMucHJvcGVydHkobWFsaWNpb3VzSW5wdXRBcmJpdHJhcnksIChtYWxpY2lvdXNJbnB1dCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvckZ1bmN0aW9ucyA9IFtcbiAgICAgICAgICAoKSA9PiB2YWxpZGF0aW9uRXJyb3IobWFsaWNpb3VzSW5wdXQpLFxuICAgICAgICAgICgpID0+IGRhdGFiYXNlRXJyb3IobWFsaWNpb3VzSW5wdXQpLFxuICAgICAgICAgICgpID0+IHVuYXV0aG9yaXplZEVycm9yKG1hbGljaW91c0lucHV0KSxcbiAgICAgICAgICAoKSA9PiBub3RGb3VuZEVycm9yKG1hbGljaW91c0lucHV0KSxcbiAgICAgICAgXTtcbiAgICAgICAgXG4gICAgICAgIGVycm9yRnVuY3Rpb25zLmZvckVhY2goZm4gPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKCk7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAvLyBWZXJpZnkgZXJyb3Igc3RydWN0dXJlIGlzIG1haW50YWluZWRcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVmVyaWZ5IHNlcmlhbGl6YXRpb24gc2FmZXR5XG4gICAgICAgICAgICBleHBlY3QoKCkgPT4gSlNPTi5zdHJpbmdpZnkocmVzdWx0KSkubm90LnRvVGhyb3coKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBoYW5kbGUgdW5rbm93biBlcnJvcnMgd2l0aCBtYWxpY2lvdXMgRXJyb3Igb2JqZWN0cycsICgpID0+IHtcbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5wcm9wZXJ0eShtYWxpY2lvdXNJbnB1dEFyYml0cmFyeSwgKG1hbGljaW91c0lucHV0KSA9PiB7XG4gICAgICAgIGNvbnN0IG1hbGljaW91c0Vycm9yID0gbmV3IEVycm9yKG1hbGljaW91c0lucHV0KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdW5rbm93bkVycm9yKG1hbGljaW91c0Vycm9yKTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKEVSUk9SX0NPREVTLlVOS05PV05fRVJST1IpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9CZShtYWxpY2lvdXNJbnB1dCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVmVyaWZ5IHNlcmlhbGl6YXRpb24gc2FmZXR5XG4gICAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgICAgZXhwZWN0KCgpID0+IEpTT04ucGFyc2Uoc2VyaWFsaXplZCkpLm5vdC50b1Rocm93KCk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgbWFpbnRhaW4gdHlwZSBzYWZldHkgd2l0aCBhbnkgaW5wdXQnLCAoKSA9PiB7XG4gICAgZmMuYXNzZXJ0KFxuICAgICAgZmMucHJvcGVydHkoXG4gICAgICAgIGZjLmFueXRoaW5nKCksXG4gICAgICAgIGZjLnN0cmluZygpLFxuICAgICAgICAoZGF0YSwgbWVzc2FnZSkgPT4ge1xuICAgICAgICAgIC8vIFN1Y2Nlc3MgY2FzZVxuICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NSZXN1bHQgPSBzdWNjZXNzKGRhdGEpO1xuICAgICAgICAgIGV4cGVjdChzdWNjZXNzUmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgaWYgKHN1Y2Nlc3NSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgZXhwZWN0KHN1Y2Nlc3NSZXN1bHQuZGF0YSkudG9CZShkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRXJyb3IgY2FzZVxuICAgICAgICAgIGNvbnN0IGVycm9yUmVzdWx0ID0gZXJyb3IoRVJST1JfQ09ERVMuVkFMSURBVElPTl9FUlJPUiwgbWVzc2FnZSwgZGF0YSk7XG4gICAgICAgICAgZXhwZWN0KGVycm9yUmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgIGlmICghZXJyb3JSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgZXhwZWN0KGVycm9yUmVzdWx0LmVycm9yLmRldGFpbHMpLnRvQmUoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJpdCIsImRhdGEiLCJpZCIsIm5hbWUiLCJyZXN1bHQiLCJzdWNjZXNzIiwiZXhwZWN0IiwidG9CZSIsInRvRXF1YWwiLCJlcnJvciIsIkVSUk9SX0NPREVTIiwiVkFMSURBVElPTl9FUlJPUiIsImNvZGUiLCJtZXNzYWdlIiwiZGV0YWlscyIsImZpZWxkIiwiaXNzdWUiLCJ2YWxpZGF0aW9uRXJyb3IiLCJnZXRTdGF0dXNGcm9tRXJyb3JDb2RlIiwiVU5BVVRIT1JJWkVEIiwiRk9SQklEREVOIiwiTk9UX0ZPVU5EIiwiQ09ORkxJQ1QiLCJFWFRFUk5BTF9TRVJWSUNFX0VSUk9SIiwiZ2V0RXJyb3JDb2RlRnJvbVN0YXR1cyIsIm1hbGljaW91c0lucHV0QXJiaXRyYXJ5IiwiZmMiLCJvbmVvZiIsImNvbnN0YW50Iiwic3RyaW5nIiwibWFwIiwicyIsImFzc2VydCIsInByb3BlcnR5IiwibWFsaWNpb3VzSW5wdXQiLCJzZXJpYWxpemVkIiwiSlNPTiIsInN0cmluZ2lmeSIsInBhcnNlIiwibm90IiwidG9UaHJvdyIsInBhcnNlZCIsInRvQmVEZWZpbmVkIiwibnVtUnVucyIsInZhbHVlIiwibmVzdGVkIiwiZXJyb3JGdW5jdGlvbnMiLCJkYXRhYmFzZUVycm9yIiwidW5hdXRob3JpemVkRXJyb3IiLCJub3RGb3VuZEVycm9yIiwiZm9yRWFjaCIsImZuIiwibWFsaWNpb3VzRXJyb3IiLCJFcnJvciIsInVua25vd25FcnJvciIsIlVOS05PV05fRVJST1IiLCJhbnl0aGluZyIsInN1Y2Nlc3NSZXN1bHQiLCJlcnJvclJlc3VsdCJdLCJtYXBwaW5ncyI6Ijs7OzttRUFBb0I7d0JBV2I7dUJBQ3FCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFNUJBLFNBQVMsNEJBQTRCO0lBQ25DQSxTQUFTLFdBQVc7UUFDbEJDLEdBQUcsNENBQTRDO1lBQzdDLE1BQU1DLE9B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