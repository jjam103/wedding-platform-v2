0c18d7622e3da873a461610074b6f48a
/**
 * Test Tagging System
 * 
 * Provides utilities for tagging tests with metadata for selective execution.
 * 
 * Usage:
 * ```typescript
 * import { describeWithTags, itWithTags } from '@/__tests__/helpers/testTags';
 * 
 * describeWithTags('Guest Service', ['unit', 'fast', 'critical'], () => {
 *   itWithTags('should create guest', ['database'], async () => {
 *     // Test implementation
 *   });
 * });
 * ```
 * 
 * Run tests by tag:
 * ```bash
 * npm test -- --testNamePattern="@tag:unit"
 * npm test -- --testNamePattern="@tag:critical"
 * npm test -- --testNamePattern="@tag:fast"
 * ```
 */ /**
 * Available test tags
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get describeCritical () {
        return describeCritical;
    },
    get describeFast () {
        return describeFast;
    },
    get describeIntegration () {
        return describeIntegration;
    },
    get describeSlow () {
        return describeSlow;
    },
    get describeUnit () {
        return describeUnit;
    },
    get describeWithTags () {
        return describeWithTags;
    },
    get getTagsFromTestName () {
        return getTagsFromTestName;
    },
    get hasAllTags () {
        return hasAllTags;
    },
    get hasAnyTag () {
        return hasAnyTag;
    },
    get hasTag () {
        return hasTag;
    },
    get itOnlyWithTags () {
        return itOnlyWithTags;
    },
    get itSkipWithTags () {
        return itSkipWithTags;
    },
    get itWithTags () {
        return itWithTags;
    },
    get testMetadata () {
        return testMetadata;
    }
});
/**
 * Format tags for test name
 */ function formatTags(tags) {
    return tags.map((tag)=>`@tag:${tag}`).join(' ');
}
function describeWithTags(name, tags, fn) {
    const tagString = formatTags(tags);
    describe(`${name} ${tagString}`, fn);
}
function itWithTags(name, tags, fn, timeout) {
    const tagString = formatTags(tags);
    it(`${name} ${tagString}`, fn, timeout);
}
function itSkipWithTags(name, tags, fn) {
    const tagString = formatTags(tags);
    it.skip(`${name} ${tagString}`, fn);
}
function itOnlyWithTags(name, tags, fn, timeout) {
    const tagString = formatTags(tags);
    it.only(`${name} ${tagString}`, fn, timeout);
}
function testMetadata(metadata) {
    // Store metadata for reporting
    // This can be used by custom reporters
    if (typeof expect !== 'undefined' && expect.getState) {
        const state = expect.getState();
        if (state.testPath) {
            // Store metadata in global registry
            if (!global.__TEST_METADATA__) {
                global.__TEST_METADATA__ = new Map();
            }
            global.__TEST_METADATA__.set(state.testPath, metadata);
        }
    }
}
const describeFast = (name, fn)=>describeWithTags(name, [
        'fast'
    ], fn);
const describeSlow = (name, fn)=>describeWithTags(name, [
        'slow'
    ], fn);
const describeCritical = (name, fn)=>describeWithTags(name, [
        'critical'
    ], fn);
const describeUnit = (name, fn)=>describeWithTags(name, [
        'unit'
    ], fn);
const describeIntegration = (name, fn)=>describeWithTags(name, [
        'integration'
    ], fn);
function getTagsFromTestName(testName) {
    const tagRegex = /@tag:(\w+)/g;
    const tags = [];
    let match;
    while((match = tagRegex.exec(testName)) !== null){
        tags.push(match[1]);
    }
    return tags;
}
function hasTag(testName, tag) {
    return getTagsFromTestName(testName).includes(tag);
}
function hasAnyTag(testName, tags) {
    const testTags = getTagsFromTestName(testName);
    return tags.some((tag)=>testTags.includes(tag));
}
function hasAllTags(testName, tags) {
    const testTags = getTagsFromTestName(testName);
    return tags.every((tag)=>testTags.includes(tag));
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvX190ZXN0c19fL2hlbHBlcnMvdGVzdFRhZ3MudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUZXN0IFRhZ2dpbmcgU3lzdGVtXG4gKiBcbiAqIFByb3ZpZGVzIHV0aWxpdGllcyBmb3IgdGFnZ2luZyB0ZXN0cyB3aXRoIG1ldGFkYXRhIGZvciBzZWxlY3RpdmUgZXhlY3V0aW9uLlxuICogXG4gKiBVc2FnZTpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IGRlc2NyaWJlV2l0aFRhZ3MsIGl0V2l0aFRhZ3MgfSBmcm9tICdAL19fdGVzdHNfXy9oZWxwZXJzL3Rlc3RUYWdzJztcbiAqIFxuICogZGVzY3JpYmVXaXRoVGFncygnR3Vlc3QgU2VydmljZScsIFsndW5pdCcsICdmYXN0JywgJ2NyaXRpY2FsJ10sICgpID0+IHtcbiAqICAgaXRXaXRoVGFncygnc2hvdWxkIGNyZWF0ZSBndWVzdCcsIFsnZGF0YWJhc2UnXSwgYXN5bmMgKCkgPT4ge1xuICogICAgIC8vIFRlc3QgaW1wbGVtZW50YXRpb25cbiAqICAgfSk7XG4gKiB9KTtcbiAqIGBgYFxuICogXG4gKiBSdW4gdGVzdHMgYnkgdGFnOlxuICogYGBgYmFzaFxuICogbnBtIHRlc3QgLS0gLS10ZXN0TmFtZVBhdHRlcm49XCJAdGFnOnVuaXRcIlxuICogbnBtIHRlc3QgLS0gLS10ZXN0TmFtZVBhdHRlcm49XCJAdGFnOmNyaXRpY2FsXCJcbiAqIG5wbSB0ZXN0IC0tIC0tdGVzdE5hbWVQYXR0ZXJuPVwiQHRhZzpmYXN0XCJcbiAqIGBgYFxuICovXG5cbi8qKlxuICogQXZhaWxhYmxlIHRlc3QgdGFnc1xuICovXG5leHBvcnQgdHlwZSBUZXN0VGFnID1cbiAgLy8gU3BlZWQgdGFnc1xuICB8ICdmYXN0JyAgICAgICAgLy8gPDEwMG1zIGV4ZWN1dGlvblxuICB8ICdtZWRpdW0nICAgICAgLy8gMTAwbXMtMXMgZXhlY3V0aW9uXG4gIHwgJ3Nsb3cnICAgICAgICAvLyA+MXMgZXhlY3V0aW9uXG4gIFxuICAvLyBUeXBlIHRhZ3NcbiAgfCAndW5pdCcgICAgICAgIC8vIFVuaXQgdGVzdFxuICB8ICdpbnRlZ3JhdGlvbicgLy8gSW50ZWdyYXRpb24gdGVzdFxuICB8ICdlMmUnICAgICAgICAgLy8gRW5kLXRvLWVuZCB0ZXN0XG4gIHwgJ3Byb3BlcnR5JyAgICAvLyBQcm9wZXJ0eS1iYXNlZCB0ZXN0XG4gIHwgJ3JlZ3Jlc3Npb24nICAvLyBSZWdyZXNzaW9uIHRlc3RcbiAgXG4gIC8vIFByaW9yaXR5IHRhZ3NcbiAgfCAnY3JpdGljYWwnICAgIC8vIENyaXRpY2FsIHBhdGggKGF1dGgsIHBheW1lbnRzLCBSTFMpXG4gIHwgJ2ltcG9ydGFudCcgICAvLyBJbXBvcnRhbnQgYnV0IG5vdCBjcml0aWNhbFxuICB8ICdvcHRpb25hbCcgICAgLy8gTmljZSB0byBoYXZlXG4gIFxuICAvLyBGZWF0dXJlIHRhZ3NcbiAgfCAnYXV0aCcgICAgICAgIC8vIEF1dGhlbnRpY2F0aW9uXG4gIHwgJ3JscycgICAgICAgICAvLyBSb3cgTGV2ZWwgU2VjdXJpdHlcbiAgfCAnYXBpJyAgICAgICAgIC8vIEFQSSByb3V0ZXNcbiAgfCAnZGF0YWJhc2UnICAgIC8vIERhdGFiYXNlIG9wZXJhdGlvbnNcbiAgfCAndWknICAgICAgICAgIC8vIFVJIGNvbXBvbmVudHNcbiAgfCAnZW1haWwnICAgICAgIC8vIEVtYWlsIGZ1bmN0aW9uYWxpdHlcbiAgfCAncGhvdG9zJyAgICAgIC8vIFBob3RvIG1hbmFnZW1lbnRcbiAgfCAncnN2cCcgICAgICAgIC8vIFJTVlAgZnVuY3Rpb25hbGl0eVxuICB8ICdidWRnZXQnICAgICAgLy8gQnVkZ2V0IHRyYWNraW5nXG4gIHwgJ2NtcycgICAgICAgICAvLyBDb250ZW50IG1hbmFnZW1lbnRcbiAgXG4gIC8vIEVudmlyb25tZW50IHRhZ3NcbiAgfCAncmVxdWlyZXMtZGInIC8vIFJlcXVpcmVzIGRhdGFiYXNlIGNvbm5lY3Rpb25cbiAgfCAncmVxdWlyZXMtYXV0aCcgLy8gUmVxdWlyZXMgYXV0aGVudGljYXRpb25cbiAgfCAncmVxdWlyZXMtc2VydmVyJyAvLyBSZXF1aXJlcyBydW5uaW5nIHNlcnZlclxuICB8ICdyZXF1aXJlcy1icm93c2VyJyAvLyBSZXF1aXJlcyBicm93c2VyIChFMkUpXG4gIFxuICAvLyBTdGFiaWxpdHkgdGFnc1xuICB8ICdzdGFibGUnICAgICAgLy8gU3RhYmxlLCByZWxpYWJsZSB0ZXN0XG4gIHwgJ2ZsYWt5JyAgICAgICAvLyBLbm93biB0byBiZSBmbGFreVxuICB8ICd3aXAnICAgICAgICAgLy8gV29yayBpbiBwcm9ncmVzc1xuICB8ICdza2lwJyAgICAgICAgLy8gU2tpcCB0aGlzIHRlc3RcbiAgO1xuXG4vKipcbiAqIFRlc3QgdGFnIG1ldGFkYXRhXG4gKi9cbmludGVyZmFjZSBUZXN0VGFnTWV0YWRhdGEge1xuICB0YWdzOiBUZXN0VGFnW107XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBqaXJhVGlja2V0Pzogc3RyaW5nO1xuICBhdXRob3I/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogRm9ybWF0IHRhZ3MgZm9yIHRlc3QgbmFtZVxuICovXG5mdW5jdGlvbiBmb3JtYXRUYWdzKHRhZ3M6IFRlc3RUYWdbXSk6IHN0cmluZyB7XG4gIHJldHVybiB0YWdzLm1hcCh0YWcgPT4gYEB0YWc6JHt0YWd9YCkuam9pbignICcpO1xufVxuXG4vKipcbiAqIERlc2NyaWJlIGJsb2NrIHdpdGggdGFnc1xuICogXG4gKiBAZXhhbXBsZVxuICogZGVzY3JpYmVXaXRoVGFncygnR3Vlc3QgU2VydmljZScsIFsndW5pdCcsICdmYXN0JywgJ2NyaXRpY2FsJ10sICgpID0+IHtcbiAqICAgLy8gVGVzdHNcbiAqIH0pO1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzY3JpYmVXaXRoVGFncyhcbiAgbmFtZTogc3RyaW5nLFxuICB0YWdzOiBUZXN0VGFnW10sXG4gIGZuOiAoKSA9PiB2b2lkXG4pOiB2b2lkIHtcbiAgY29uc3QgdGFnU3RyaW5nID0gZm9ybWF0VGFncyh0YWdzKTtcbiAgZGVzY3JpYmUoYCR7bmFtZX0gJHt0YWdTdHJpbmd9YCwgZm4pO1xufVxuXG4vKipcbiAqIFRlc3QgY2FzZSB3aXRoIHRhZ3NcbiAqIFxuICogQGV4YW1wbGVcbiAqIGl0V2l0aFRhZ3MoJ3Nob3VsZCBjcmVhdGUgZ3Vlc3QnLCBbJ2RhdGFiYXNlJywgJ2Zhc3QnXSwgYXN5bmMgKCkgPT4ge1xuICogICAvLyBUZXN0IGltcGxlbWVudGF0aW9uXG4gKiB9KTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGl0V2l0aFRhZ3MoXG4gIG5hbWU6IHN0cmluZyxcbiAgdGFnczogVGVzdFRhZ1tdLFxuICBmbjogKCkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD4sXG4gIHRpbWVvdXQ/OiBudW1iZXJcbik6IHZvaWQge1xuICBjb25zdCB0YWdTdHJpbmcgPSBmb3JtYXRUYWdzKHRhZ3MpO1xuICBpdChgJHtuYW1lfSAke3RhZ1N0cmluZ31gLCBmbiwgdGltZW91dCk7XG59XG5cbi8qKlxuICogU2tpcCB0ZXN0IHdpdGggdGFnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXRTa2lwV2l0aFRhZ3MoXG4gIG5hbWU6IHN0cmluZyxcbiAgdGFnczogVGVzdFRhZ1tdLFxuICBmbjogKCkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD5cbik6IHZvaWQge1xuICBjb25zdCB0YWdTdHJpbmcgPSBmb3JtYXRUYWdzKHRhZ3MpO1xuICBpdC5za2lwKGAke25hbWV9ICR7dGFnU3RyaW5nfWAsIGZuKTtcbn1cblxuLyoqXG4gKiBPbmx5IHJ1biB0aGlzIHRlc3Qgd2l0aCB0YWdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpdE9ubHlXaXRoVGFncyhcbiAgbmFtZTogc3RyaW5nLFxuICB0YWdzOiBUZXN0VGFnW10sXG4gIGZuOiAoKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPixcbiAgdGltZW91dD86IG51bWJlclxuKTogdm9pZCB7XG4gIGNvbnN0IHRhZ1N0cmluZyA9IGZvcm1hdFRhZ3ModGFncyk7XG4gIGl0Lm9ubHkoYCR7bmFtZX0gJHt0YWdTdHJpbmd9YCwgZm4sIHRpbWVvdXQpO1xufVxuXG4vKipcbiAqIFRlc3QgbWV0YWRhdGEgZGVjb3JhdG9yXG4gKiBcbiAqIEBleGFtcGxlXG4gKiB0ZXN0TWV0YWRhdGEoe1xuICogICB0YWdzOiBbJ3VuaXQnLCAnY3JpdGljYWwnXSxcbiAqICAgZGVzY3JpcHRpb246ICdUZXN0cyBndWVzdCBjcmVhdGlvbiB3aXRoIFJMUycsXG4gKiAgIGppcmFUaWNrZXQ6ICdQUk9KLTEyMycsXG4gKiAgIGF1dGhvcjogJ2pvaG5AZXhhbXBsZS5jb20nXG4gKiB9KTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRlc3RNZXRhZGF0YShtZXRhZGF0YTogVGVzdFRhZ01ldGFkYXRhKTogdm9pZCB7XG4gIC8vIFN0b3JlIG1ldGFkYXRhIGZvciByZXBvcnRpbmdcbiAgLy8gVGhpcyBjYW4gYmUgdXNlZCBieSBjdXN0b20gcmVwb3J0ZXJzXG4gIGlmICh0eXBlb2YgZXhwZWN0ICE9PSAndW5kZWZpbmVkJyAmJiAoZXhwZWN0IGFzIGFueSkuZ2V0U3RhdGUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IChleHBlY3QgYXMgYW55KS5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZS50ZXN0UGF0aCkge1xuICAgICAgLy8gU3RvcmUgbWV0YWRhdGEgaW4gZ2xvYmFsIHJlZ2lzdHJ5XG4gICAgICBpZiAoIShnbG9iYWwgYXMgYW55KS5fX1RFU1RfTUVUQURBVEFfXykge1xuICAgICAgICAoZ2xvYmFsIGFzIGFueSkuX19URVNUX01FVEFEQVRBX18gPSBuZXcgTWFwKCk7XG4gICAgICB9XG4gICAgICAoZ2xvYmFsIGFzIGFueSkuX19URVNUX01FVEFEQVRBX18uc2V0KHN0YXRlLnRlc3RQYXRoLCBtZXRhZGF0YSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSGVscGVyIHRvIHJ1biBvbmx5IGZhc3QgdGVzdHNcbiAqL1xuZXhwb3J0IGNvbnN0IGRlc2NyaWJlRmFzdCA9IChuYW1lOiBzdHJpbmcsIGZuOiAoKSA9PiB2b2lkKSA9PlxuICBkZXNjcmliZVdpdGhUYWdzKG5hbWUsIFsnZmFzdCddLCBmbik7XG5cbi8qKlxuICogSGVscGVyIHRvIHJ1biBvbmx5IHNsb3cgdGVzdHNcbiAqL1xuZXhwb3J0IGNvbnN0IGRlc2NyaWJlU2xvdyA9IChuYW1lOiBzdHJpbmcsIGZuOiAoKSA9PiB2b2lkKSA9PlxuICBkZXNjcmliZVdpdGhUYWdzKG5hbWUsIFsnc2xvdyddLCBmbik7XG5cbi8qKlxuICogSGVscGVyIHRvIHJ1biBvbmx5IGNyaXRpY2FsIHRlc3RzXG4gKi9cbmV4cG9ydCBjb25zdCBkZXNjcmliZUNyaXRpY2FsID0gKG5hbWU6IHN0cmluZywgZm46ICgpID0+IHZvaWQpID0+XG4gIGRlc2NyaWJlV2l0aFRhZ3MobmFtZSwgWydjcml0aWNhbCddLCBmbik7XG5cbi8qKlxuICogSGVscGVyIHRvIHJ1biBvbmx5IHVuaXQgdGVzdHNcbiAqL1xuZXhwb3J0IGNvbnN0IGRlc2NyaWJlVW5pdCA9IChuYW1lOiBzdHJpbmcsIGZuOiAoKSA9PiB2b2lkKSA9PlxuICBkZXNjcmliZVdpdGhUYWdzKG5hbWUsIFsndW5pdCddLCBmbik7XG5cbi8qKlxuICogSGVscGVyIHRvIHJ1biBvbmx5IGludGVncmF0aW9uIHRlc3RzXG4gKi9cbmV4cG9ydCBjb25zdCBkZXNjcmliZUludGVncmF0aW9uID0gKG5hbWU6IHN0cmluZywgZm46ICgpID0+IHZvaWQpID0+XG4gIGRlc2NyaWJlV2l0aFRhZ3MobmFtZSwgWydpbnRlZ3JhdGlvbiddLCBmbik7XG5cbi8qKlxuICogR2V0IGFsbCB0YWdzIGZyb20gdGVzdCBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUYWdzRnJvbVRlc3ROYW1lKHRlc3ROYW1lOiBzdHJpbmcpOiBUZXN0VGFnW10ge1xuICBjb25zdCB0YWdSZWdleCA9IC9AdGFnOihcXHcrKS9nO1xuICBjb25zdCB0YWdzOiBUZXN0VGFnW10gPSBbXTtcbiAgbGV0IG1hdGNoO1xuICBcbiAgd2hpbGUgKChtYXRjaCA9IHRhZ1JlZ2V4LmV4ZWModGVzdE5hbWUpKSAhPT0gbnVsbCkge1xuICAgIHRhZ3MucHVzaChtYXRjaFsxXSBhcyBUZXN0VGFnKTtcbiAgfVxuICBcbiAgcmV0dXJuIHRhZ3M7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGVzdCBoYXMgc3BlY2lmaWMgdGFnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNUYWcodGVzdE5hbWU6IHN0cmluZywgdGFnOiBUZXN0VGFnKTogYm9vbGVhbiB7XG4gIHJldHVybiBnZXRUYWdzRnJvbVRlc3ROYW1lKHRlc3ROYW1lKS5pbmNsdWRlcyh0YWcpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRlc3QgaGFzIGFueSBvZiB0aGUgc3BlY2lmaWVkIHRhZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0FueVRhZyh0ZXN0TmFtZTogc3RyaW5nLCB0YWdzOiBUZXN0VGFnW10pOiBib29sZWFuIHtcbiAgY29uc3QgdGVzdFRhZ3MgPSBnZXRUYWdzRnJvbVRlc3ROYW1lKHRlc3ROYW1lKTtcbiAgcmV0dXJuIHRhZ3Muc29tZSh0YWcgPT4gdGVzdFRhZ3MuaW5jbHVkZXModGFnKSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGVzdCBoYXMgYWxsIG9mIHRoZSBzcGVjaWZpZWQgdGFnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzQWxsVGFncyh0ZXN0TmFtZTogc3RyaW5nLCB0YWdzOiBUZXN0VGFnW10pOiBib29sZWFuIHtcbiAgY29uc3QgdGVzdFRhZ3MgPSBnZXRUYWdzRnJvbVRlc3ROYW1lKHRlc3ROYW1lKTtcbiAgcmV0dXJuIHRhZ3MuZXZlcnkodGFnID0+IHRlc3RUYWdzLmluY2x1ZGVzKHRhZykpO1xufVxuIl0sIm5hbWVzIjpbImRlc2NyaWJlQ3JpdGljYWwiLCJkZXNjcmliZUZhc3QiLCJkZXNjcmliZUludGVncmF0aW9uIiwiZGVzY3JpYmVTbG93IiwiZGVzY3JpYmVVbml0IiwiZGVzY3JpYmVXaXRoVGFncyIsImdldFRhZ3NGcm9tVGVzdE5hbWUiLCJoYXNBbGxUYWdzIiwiaGFzQW55VGFnIiwiaGFzVGFnIiwiaXRPbmx5V2l0aFRhZ3MiLCJpdFNraXBXaXRoVGFncyIsIml0V2l0aFRhZ3MiLCJ0ZXN0TWV0YWRhdGEiLCJmb3JtYXRUYWdzIiwidGFncyIsIm1hcCIsInRhZyIsImpvaW4iLCJuYW1lIiwiZm4iLCJ0YWdTdHJpbmciLCJkZXNjcmliZSIsInRpbWVvdXQiLCJpdCIsInNraXAiLCJvbmx5IiwibWV0YWRhdGEiLCJleHBlY3QiLCJnZXRTdGF0ZSIsInN0YXRlIiwidGVzdFBhdGgiLCJnbG9iYWwiLCJfX1RFU1RfTUVUQURBVEFfXyIsIk1hcCIsInNldCIsInRlc3ROYW1lIiwidGFnUmVnZXgiLCJtYXRjaCIsImV4ZWMiLCJwdXNoIiwiaW5jbHVkZXMiLCJ0ZXN0VGFncyIsInNvbWUiLCJldmVyeSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzQkMsR0FFRDs7Q0FFQzs7Ozs7Ozs7Ozs7UUFrS1lBO2VBQUFBOztRQVpBQztlQUFBQTs7UUF3QkFDO2VBQUFBOztRQWxCQUM7ZUFBQUE7O1FBWUFDO2VBQUFBOztRQW5HR0M7ZUFBQUE7O1FBK0dBQztlQUFBQTs7UUE4QkFDO2VBQUFBOztRQVJBQztlQUFBQTs7UUFQQUM7ZUFBQUE7O1FBcEZBQztlQUFBQTs7UUFaQUM7ZUFBQUE7O1FBYkFDO2VBQUFBOztRQThDQUM7ZUFBQUE7OztBQTlFaEI7O0NBRUMsR0FDRCxTQUFTQyxXQUFXQyxJQUFlO0lBQ2pDLE9BQU9BLEtBQUtDLEdBQUcsQ0FBQ0MsQ0FBQUEsTUFBTyxDQUFDLEtBQUssRUFBRUEsS0FBSyxFQUFFQyxJQUFJLENBQUM7QUFDN0M7QUFVTyxTQUFTYixpQkFDZGMsSUFBWSxFQUNaSixJQUFlLEVBQ2ZLLEVBQWM7SUFFZCxNQUFNQyxZQUFZUCxXQUFXQztJQUM3Qk8sU0FBUyxHQUFHSCxLQUFLLENBQUMsRUFBRUUsV0FBVyxFQUFFRDtBQUNuQztBQVVPLFNBQVNSLFdBQ2RPLElBQVksRUFDWkosSUFBZSxFQUNmSyxFQUE4QixFQUM5QkcsT0FBZ0I7SUFFaEIsTUFBTUYsWUFBWVAsV0FBV0M7SUFDN0JTLEdBQUcsR0FBR0wsS0FBSyxDQUFDLEVBQUVFLFdBQVcsRUFBRUQsSUFBSUc7QUFDakM7QUFLTyxTQUFTWixlQUNkUSxJQUFZLEVBQ1pKLElBQWUsRUFDZkssRUFBOEI7SUFFOUIsTUFBTUMsWUFBWVAsV0FBV0M7SUFDN0JTLEdBQUdDLElBQUksQ0FBQyxHQUFHTixLQUFLLENBQUMsRUFBRUUsV0FBVyxFQUFFRDtBQUNsQztBQUtPLFNBQVNWLGVBQ2RTLElBQVksRUFDWkosSUFBZSxFQUNmSyxFQUE4QixFQUM5QkcsT0FBZ0I7SUFFaEIsTUFBTUYsWUFBWVAsV0FBV0M7SUFDN0JTLEdBQUdFLElBQUksQ0FBQyxHQUFHUCxLQUFLLENBQUMsRUFBRUUsV0FBVyxFQUFFRCxJQUFJRztBQUN0QztBQWFPLFNBQVNWLGFBQWFjLFFBQXlCO0lBQ3BELCtCQUErQjtJQUMvQix1Q0FBdUM7SUFDdkMsSUFBSSxPQUFPQyxXQUFXLGVBQWUsQUFBQ0EsT0FBZUMsUUFBUSxFQUFFO1FBQzdELE1BQU1DLFFBQVEsQUFBQ0YsT0FBZUMsUUFBUTtRQUN0QyxJQUFJQyxNQUFNQyxRQUFRLEVBQUU7WUFDbEIsb0NBQW9DO1lBQ3BDLElBQUksQ0FBQyxBQUFDQyxPQUFlQyxpQkFBaUIsRUFBRTtnQkFDckNELE9BQWVDLGlCQUFpQixHQUFHLElBQUlDO1lBQzFDO1lBQ0NGLE9BQWVDLGlCQUFpQixDQUFDRSxHQUFHLENBQUNMLE1BQU1DLFFBQVEsRUFBRUo7UUFDeEQ7SUFDRjtBQUNGO0FBS08sTUFBTTFCLGVBQWUsQ0FBQ2tCLE1BQWNDLEtBQ3pDZixpQkFBaUJjLE1BQU07UUFBQztLQUFPLEVBQUVDO0FBSzVCLE1BQU1qQixlQUFlLENBQUNnQixNQUFjQyxLQUN6Q2YsaUJBQWlCYyxNQUFNO1FBQUM7S0FBTyxFQUFFQztBQUs1QixNQUFNcEIsbUJBQW1CLENBQUNtQixNQUFjQyxLQUM3Q2YsaUJBQWlCYyxNQUFNO1FBQUM7S0FBVyxFQUFFQztBQUtoQyxNQUFNaEIsZUFBZSxDQUFDZSxNQUFjQyxLQUN6Q2YsaUJBQWlCYyxNQUFNO1FBQUM7S0FBTyxFQUFFQztBQUs1QixNQUFNbEIsc0JBQXNCLENBQUNpQixNQUFjQyxLQUNoRGYsaUJBQWlCYyxNQUFNO1FBQUM7S0FBYyxFQUFFQztBQUtuQyxTQUFTZCxvQkFBb0I4QixRQUFnQjtJQUNsRCxNQUFNQyxXQUFXO0lBQ2pCLE1BQU10QixPQUFrQixFQUFFO0lBQzFCLElBQUl1QjtJQUVKLE1BQU8sQUFBQ0EsQ0FBQUEsUUFBUUQsU0FBU0UsSUFBSSxDQUFDSCxTQUFRLE1BQU8sS0FBTTtRQUNqRHJCLEtBQUt5QixJQUFJLENBQUNGLEtBQUssQ0FBQyxFQUFFO0lBQ3BCO0lBRUEsT0FBT3ZCO0FBQ1Q7QUFLTyxTQUFTTixPQUFPMkIsUUFBZ0IsRUFBRW5CLEdBQVk7SUFDbkQsT0FBT1gsb0JBQW9COEIsVUFBVUssUUFBUSxDQUFDeEI7QUFDaEQ7QUFLTyxTQUFTVCxVQUFVNEIsUUFBZ0IsRUFBRXJCLElBQWU7SUFDekQsTUFBTTJCLFdBQVdwQyxvQkFBb0I4QjtJQUNyQyxPQUFPckIsS0FBSzRCLElBQUksQ0FBQzFCLENBQUFBLE1BQU95QixTQUFTRCxRQUFRLENBQUN4QjtBQUM1QztBQUtPLFNBQVNWLFdBQVc2QixRQUFnQixFQUFFckIsSUFBZTtJQUMxRCxNQUFNMkIsV0FBV3BDLG9CQUFvQjhCO0lBQ3JDLE9BQU9yQixLQUFLNkIsS0FBSyxDQUFDM0IsQ0FBQUEsTUFBT3lCLFNBQVNELFFBQVEsQ0FBQ3hCO0FBQzdDIn0=