410398ec99450aeb50a37ac965d67356
/**
 * Property-Based Test: RSVP Status Toggle Cycle
 * 
 * Feature: guest-portal-and-admin-enhancements
 * Property 4: RSVP Status Toggle Cycle
 * 
 * Description:
 * For any RSVP status control, clicking SHALL cycle through states in order:
 * pending → attending → maybe → declined → pending
 * 
 * Validates: Requirements 2.4
 * 
 * Test Strategy:
 * - Generate random starting status
 * - Apply toggle operation multiple times
 * - Verify cycle order is maintained
 * - Verify cycle completes after 4 toggles
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('Feature: guest-portal-and-admin-enhancements, Property 4: RSVP Status Toggle Cycle', ()=>{
    // Define the expected cycle order
    const CYCLE_ORDER = [
        'pending',
        'attending',
        'maybe',
        'declined'
    ];
    /**
   * Get the next status in the cycle
   */ function getNextStatus(currentStatus) {
        const currentIndex = CYCLE_ORDER.indexOf(currentStatus);
        const nextIndex = (currentIndex + 1) % CYCLE_ORDER.length;
        return CYCLE_ORDER[nextIndex];
    }
    /**
   * Arbitrary for RSVP status
   */ const rsvpStatusArbitrary = _fastcheck.constantFrom('pending', 'attending', 'maybe', 'declined');
    it('should cycle through statuses in correct order: pending → attending → maybe → declined → pending', ()=>{
        _fastcheck.assert(_fastcheck.property(rsvpStatusArbitrary, (startingStatus)=>{
            let currentStatus = startingStatus;
            const visitedStatuses = [
                currentStatus
            ];
            // Toggle 4 times to complete one full cycle
            for(let i = 0; i < 4; i++){
                const nextStatus = getNextStatus(currentStatus);
                visitedStatuses.push(nextStatus);
                currentStatus = nextStatus;
            }
            // After 4 toggles, should return to starting status
            expect(currentStatus).toBe(startingStatus);
            // Verify each transition follows the cycle order
            for(let i = 0; i < visitedStatuses.length - 1; i++){
                const current = visitedStatuses[i];
                const next = visitedStatuses[i + 1];
                const expectedNext = getNextStatus(current);
                expect(next).toBe(expectedNext);
            }
        }), {
            numRuns: 100
        });
    });
    it('should always transition to the next status in cycle order', ()=>{
        _fastcheck.assert(_fastcheck.property(rsvpStatusArbitrary, (currentStatus)=>{
            const nextStatus = getNextStatus(currentStatus);
            const currentIndex = CYCLE_ORDER.indexOf(currentStatus);
            const nextIndex = CYCLE_ORDER.indexOf(nextStatus);
            // Next index should be current + 1 (mod 4)
            expect(nextIndex).toBe((currentIndex + 1) % 4);
        }), {
            numRuns: 100
        });
    });
    it('should visit all 4 statuses exactly once in a complete cycle', ()=>{
        _fastcheck.assert(_fastcheck.property(rsvpStatusArbitrary, (startingStatus)=>{
            let currentStatus = startingStatus;
            const visitedStatuses = new Set([
                currentStatus
            ]);
            // Toggle until we return to starting status
            for(let i = 0; i < 4; i++){
                currentStatus = getNextStatus(currentStatus);
                if (currentStatus === startingStatus && i < 3) {
                    // Should not return to start before completing cycle
                    return false;
                }
                visitedStatuses.add(currentStatus);
            }
            // Should have visited all 4 statuses
            expect(visitedStatuses.size).toBe(4);
            expect(visitedStatuses.has('pending')).toBe(true);
            expect(visitedStatuses.has('attending')).toBe(true);
            expect(visitedStatuses.has('maybe')).toBe(true);
            expect(visitedStatuses.has('declined')).toBe(true);
            // Should return to starting status after 4 toggles
            expect(currentStatus).toBe(startingStatus);
        }), {
            numRuns: 100
        });
    });
    it('should maintain cycle order regardless of starting position', ()=>{
        _fastcheck.assert(_fastcheck.property(rsvpStatusArbitrary, _fastcheck.integer({
            min: 1,
            max: 10
        }), (startingStatus, numToggles)=>{
            let currentStatus = startingStatus;
            const startIndex = CYCLE_ORDER.indexOf(startingStatus);
            // Apply toggles
            for(let i = 0; i < numToggles; i++){
                currentStatus = getNextStatus(currentStatus);
            }
            // Calculate expected final position
            const expectedIndex = (startIndex + numToggles) % 4;
            const expectedStatus = CYCLE_ORDER[expectedIndex];
            expect(currentStatus).toBe(expectedStatus);
        }), {
            numRuns: 100
        });
    });
    it('should be deterministic - same starting status and toggles always produce same result', ()=>{
        _fastcheck.assert(_fastcheck.property(rsvpStatusArbitrary, _fastcheck.integer({
            min: 0,
            max: 20
        }), (startingStatus, numToggles)=>{
            // First run
            let status1 = startingStatus;
            for(let i = 0; i < numToggles; i++){
                status1 = getNextStatus(status1);
            }
            // Second run with same inputs
            let status2 = startingStatus;
            for(let i = 0; i < numToggles; i++){
                status2 = getNextStatus(status2);
            }
            // Results should be identical
            expect(status1).toBe(status2);
        }), {
            numRuns: 100
        });
    });
    it('should never skip a status in the cycle', ()=>{
        _fastcheck.assert(_fastcheck.property(rsvpStatusArbitrary, (currentStatus)=>{
            const nextStatus = getNextStatus(currentStatus);
            const currentIndex = CYCLE_ORDER.indexOf(currentStatus);
            const nextIndex = CYCLE_ORDER.indexOf(nextStatus);
            // Should move exactly one position forward (with wraparound)
            const expectedNextIndex = (currentIndex + 1) % 4;
            expect(nextIndex).toBe(expectedNextIndex);
            // Should not skip any status
            const skippedCount = (nextIndex - currentIndex + 4) % 4;
            expect(skippedCount).toBe(1);
        }), {
            numRuns: 100
        });
    });
    it('should handle rapid successive toggles correctly', ()=>{
        _fastcheck.assert(_fastcheck.property(rsvpStatusArbitrary, _fastcheck.integer({
            min: 1,
            max: 100
        }), (startingStatus, rapidToggles)=>{
            let currentStatus = startingStatus;
            // Apply rapid toggles
            for(let i = 0; i < rapidToggles; i++){
                currentStatus = getNextStatus(currentStatus);
            }
            // Calculate expected position
            const startIndex = CYCLE_ORDER.indexOf(startingStatus);
            const expectedIndex = (startIndex + rapidToggles) % 4;
            const expectedStatus = CYCLE_ORDER[expectedIndex];
            expect(currentStatus).toBe(expectedStatus);
        }), {
            numRuns: 100
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvX190ZXN0c19fL3Byb3BlcnR5L3JzdnBTdGF0dXNUb2dnbGVDeWNsZS5wcm9wZXJ0eS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUHJvcGVydHktQmFzZWQgVGVzdDogUlNWUCBTdGF0dXMgVG9nZ2xlIEN5Y2xlXG4gKiBcbiAqIEZlYXR1cmU6IGd1ZXN0LXBvcnRhbC1hbmQtYWRtaW4tZW5oYW5jZW1lbnRzXG4gKiBQcm9wZXJ0eSA0OiBSU1ZQIFN0YXR1cyBUb2dnbGUgQ3ljbGVcbiAqIFxuICogRGVzY3JpcHRpb246XG4gKiBGb3IgYW55IFJTVlAgc3RhdHVzIGNvbnRyb2wsIGNsaWNraW5nIFNIQUxMIGN5Y2xlIHRocm91Z2ggc3RhdGVzIGluIG9yZGVyOlxuICogcGVuZGluZyDihpIgYXR0ZW5kaW5nIOKGkiBtYXliZSDihpIgZGVjbGluZWQg4oaSIHBlbmRpbmdcbiAqIFxuICogVmFsaWRhdGVzOiBSZXF1aXJlbWVudHMgMi40XG4gKiBcbiAqIFRlc3QgU3RyYXRlZ3k6XG4gKiAtIEdlbmVyYXRlIHJhbmRvbSBzdGFydGluZyBzdGF0dXNcbiAqIC0gQXBwbHkgdG9nZ2xlIG9wZXJhdGlvbiBtdWx0aXBsZSB0aW1lc1xuICogLSBWZXJpZnkgY3ljbGUgb3JkZXIgaXMgbWFpbnRhaW5lZFxuICogLSBWZXJpZnkgY3ljbGUgY29tcGxldGVzIGFmdGVyIDQgdG9nZ2xlc1xuICovXG5cbmltcG9ydCAqIGFzIGZjIGZyb20gJ2Zhc3QtY2hlY2snO1xuXG5kZXNjcmliZSgnRmVhdHVyZTogZ3Vlc3QtcG9ydGFsLWFuZC1hZG1pbi1lbmhhbmNlbWVudHMsIFByb3BlcnR5IDQ6IFJTVlAgU3RhdHVzIFRvZ2dsZSBDeWNsZScsICgpID0+IHtcbiAgLy8gRGVmaW5lIHRoZSBleHBlY3RlZCBjeWNsZSBvcmRlclxuICBjb25zdCBDWUNMRV9PUkRFUjogQXJyYXk8J3BlbmRpbmcnIHwgJ2F0dGVuZGluZycgfCAnbWF5YmUnIHwgJ2RlY2xpbmVkJz4gPSBbXG4gICAgJ3BlbmRpbmcnLFxuICAgICdhdHRlbmRpbmcnLFxuICAgICdtYXliZScsXG4gICAgJ2RlY2xpbmVkJyxcbiAgXTtcblxuICAvKipcbiAgICogR2V0IHRoZSBuZXh0IHN0YXR1cyBpbiB0aGUgY3ljbGVcbiAgICovXG4gIGZ1bmN0aW9uIGdldE5leHRTdGF0dXMoXG4gICAgY3VycmVudFN0YXR1czogJ3BlbmRpbmcnIHwgJ2F0dGVuZGluZycgfCAnbWF5YmUnIHwgJ2RlY2xpbmVkJ1xuICApOiAncGVuZGluZycgfCAnYXR0ZW5kaW5nJyB8ICdtYXliZScgfCAnZGVjbGluZWQnIHtcbiAgICBjb25zdCBjdXJyZW50SW5kZXggPSBDWUNMRV9PUkRFUi5pbmRleE9mKGN1cnJlbnRTdGF0dXMpO1xuICAgIGNvbnN0IG5leHRJbmRleCA9IChjdXJyZW50SW5kZXggKyAxKSAlIENZQ0xFX09SREVSLmxlbmd0aDtcbiAgICByZXR1cm4gQ1lDTEVfT1JERVJbbmV4dEluZGV4XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcmJpdHJhcnkgZm9yIFJTVlAgc3RhdHVzXG4gICAqL1xuICBjb25zdCByc3ZwU3RhdHVzQXJiaXRyYXJ5ID0gZmMuY29uc3RhbnRGcm9tPCdwZW5kaW5nJyB8ICdhdHRlbmRpbmcnIHwgJ21heWJlJyB8ICdkZWNsaW5lZCc+KFxuICAgICdwZW5kaW5nJyxcbiAgICAnYXR0ZW5kaW5nJyxcbiAgICAnbWF5YmUnLFxuICAgICdkZWNsaW5lZCdcbiAgKTtcblxuICBpdCgnc2hvdWxkIGN5Y2xlIHRocm91Z2ggc3RhdHVzZXMgaW4gY29ycmVjdCBvcmRlcjogcGVuZGluZyDihpIgYXR0ZW5kaW5nIOKGkiBtYXliZSDihpIgZGVjbGluZWQg4oaSIHBlbmRpbmcnLCAoKSA9PiB7XG4gICAgZmMuYXNzZXJ0KFxuICAgICAgZmMucHJvcGVydHkocnN2cFN0YXR1c0FyYml0cmFyeSwgKHN0YXJ0aW5nU3RhdHVzKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50U3RhdHVzID0gc3RhcnRpbmdTdGF0dXM7XG4gICAgICAgIGNvbnN0IHZpc2l0ZWRTdGF0dXNlczogQXJyYXk8J3BlbmRpbmcnIHwgJ2F0dGVuZGluZycgfCAnbWF5YmUnIHwgJ2RlY2xpbmVkJz4gPSBbY3VycmVudFN0YXR1c107XG5cbiAgICAgICAgLy8gVG9nZ2xlIDQgdGltZXMgdG8gY29tcGxldGUgb25lIGZ1bGwgY3ljbGVcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICBjb25zdCBuZXh0U3RhdHVzID0gZ2V0TmV4dFN0YXR1cyhjdXJyZW50U3RhdHVzKTtcbiAgICAgICAgICB2aXNpdGVkU3RhdHVzZXMucHVzaChuZXh0U3RhdHVzKTtcbiAgICAgICAgICBjdXJyZW50U3RhdHVzID0gbmV4dFN0YXR1cztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFmdGVyIDQgdG9nZ2xlcywgc2hvdWxkIHJldHVybiB0byBzdGFydGluZyBzdGF0dXNcbiAgICAgICAgZXhwZWN0KGN1cnJlbnRTdGF0dXMpLnRvQmUoc3RhcnRpbmdTdGF0dXMpO1xuXG4gICAgICAgIC8vIFZlcmlmeSBlYWNoIHRyYW5zaXRpb24gZm9sbG93cyB0aGUgY3ljbGUgb3JkZXJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aXNpdGVkU3RhdHVzZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudCA9IHZpc2l0ZWRTdGF0dXNlc1tpXTtcbiAgICAgICAgICBjb25zdCBuZXh0ID0gdmlzaXRlZFN0YXR1c2VzW2kgKyAxXTtcbiAgICAgICAgICBjb25zdCBleHBlY3RlZE5leHQgPSBnZXROZXh0U3RhdHVzKGN1cnJlbnQpO1xuICAgICAgICAgIGV4cGVjdChuZXh0KS50b0JlKGV4cGVjdGVkTmV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgYWx3YXlzIHRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdHVzIGluIGN5Y2xlIG9yZGVyJywgKCkgPT4ge1xuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLnByb3BlcnR5KHJzdnBTdGF0dXNBcmJpdHJhcnksIChjdXJyZW50U3RhdHVzKSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHRTdGF0dXMgPSBnZXROZXh0U3RhdHVzKGN1cnJlbnRTdGF0dXMpO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBDWUNMRV9PUkRFUi5pbmRleE9mKGN1cnJlbnRTdGF0dXMpO1xuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSBDWUNMRV9PUkRFUi5pbmRleE9mKG5leHRTdGF0dXMpO1xuXG4gICAgICAgIC8vIE5leHQgaW5kZXggc2hvdWxkIGJlIGN1cnJlbnQgKyAxIChtb2QgNClcbiAgICAgICAgZXhwZWN0KG5leHRJbmRleCkudG9CZSgoY3VycmVudEluZGV4ICsgMSkgJSA0KTtcbiAgICAgIH0pLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgdmlzaXQgYWxsIDQgc3RhdHVzZXMgZXhhY3RseSBvbmNlIGluIGEgY29tcGxldGUgY3ljbGUnLCAoKSA9PiB7XG4gICAgZmMuYXNzZXJ0KFxuICAgICAgZmMucHJvcGVydHkocnN2cFN0YXR1c0FyYml0cmFyeSwgKHN0YXJ0aW5nU3RhdHVzKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50U3RhdHVzID0gc3RhcnRpbmdTdGF0dXM7XG4gICAgICAgIGNvbnN0IHZpc2l0ZWRTdGF0dXNlcyA9IG5ldyBTZXQ8J3BlbmRpbmcnIHwgJ2F0dGVuZGluZycgfCAnbWF5YmUnIHwgJ2RlY2xpbmVkJz4oW2N1cnJlbnRTdGF0dXNdKTtcblxuICAgICAgICAvLyBUb2dnbGUgdW50aWwgd2UgcmV0dXJuIHRvIHN0YXJ0aW5nIHN0YXR1c1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgIGN1cnJlbnRTdGF0dXMgPSBnZXROZXh0U3RhdHVzKGN1cnJlbnRTdGF0dXMpO1xuICAgICAgICAgIGlmIChjdXJyZW50U3RhdHVzID09PSBzdGFydGluZ1N0YXR1cyAmJiBpIDwgMykge1xuICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCByZXR1cm4gdG8gc3RhcnQgYmVmb3JlIGNvbXBsZXRpbmcgY3ljbGVcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmlzaXRlZFN0YXR1c2VzLmFkZChjdXJyZW50U3RhdHVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNob3VsZCBoYXZlIHZpc2l0ZWQgYWxsIDQgc3RhdHVzZXNcbiAgICAgICAgZXhwZWN0KHZpc2l0ZWRTdGF0dXNlcy5zaXplKS50b0JlKDQpO1xuICAgICAgICBleHBlY3QodmlzaXRlZFN0YXR1c2VzLmhhcygncGVuZGluZycpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QodmlzaXRlZFN0YXR1c2VzLmhhcygnYXR0ZW5kaW5nJykpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdCh2aXNpdGVkU3RhdHVzZXMuaGFzKCdtYXliZScpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QodmlzaXRlZFN0YXR1c2VzLmhhcygnZGVjbGluZWQnKSkudG9CZSh0cnVlKTtcblxuICAgICAgICAvLyBTaG91bGQgcmV0dXJuIHRvIHN0YXJ0aW5nIHN0YXR1cyBhZnRlciA0IHRvZ2dsZXNcbiAgICAgICAgZXhwZWN0KGN1cnJlbnRTdGF0dXMpLnRvQmUoc3RhcnRpbmdTdGF0dXMpO1xuICAgICAgfSksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBtYWludGFpbiBjeWNsZSBvcmRlciByZWdhcmRsZXNzIG9mIHN0YXJ0aW5nIHBvc2l0aW9uJywgKCkgPT4ge1xuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLnByb3BlcnR5KHJzdnBTdGF0dXNBcmJpdHJhcnksIGZjLmludGVnZXIoeyBtaW46IDEsIG1heDogMTAgfSksIChzdGFydGluZ1N0YXR1cywgbnVtVG9nZ2xlcykgPT4ge1xuICAgICAgICBsZXQgY3VycmVudFN0YXR1cyA9IHN0YXJ0aW5nU3RhdHVzO1xuICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gQ1lDTEVfT1JERVIuaW5kZXhPZihzdGFydGluZ1N0YXR1cyk7XG5cbiAgICAgICAgLy8gQXBwbHkgdG9nZ2xlc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVRvZ2dsZXM7IGkrKykge1xuICAgICAgICAgIGN1cnJlbnRTdGF0dXMgPSBnZXROZXh0U3RhdHVzKGN1cnJlbnRTdGF0dXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGV4cGVjdGVkIGZpbmFsIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkSW5kZXggPSAoc3RhcnRJbmRleCArIG51bVRvZ2dsZXMpICUgNDtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRTdGF0dXMgPSBDWUNMRV9PUkRFUltleHBlY3RlZEluZGV4XTtcblxuICAgICAgICBleHBlY3QoY3VycmVudFN0YXR1cykudG9CZShleHBlY3RlZFN0YXR1cyk7XG4gICAgICB9KSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGJlIGRldGVybWluaXN0aWMgLSBzYW1lIHN0YXJ0aW5nIHN0YXR1cyBhbmQgdG9nZ2xlcyBhbHdheXMgcHJvZHVjZSBzYW1lIHJlc3VsdCcsICgpID0+IHtcbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5wcm9wZXJ0eShyc3ZwU3RhdHVzQXJiaXRyYXJ5LCBmYy5pbnRlZ2VyKHsgbWluOiAwLCBtYXg6IDIwIH0pLCAoc3RhcnRpbmdTdGF0dXMsIG51bVRvZ2dsZXMpID0+IHtcbiAgICAgICAgLy8gRmlyc3QgcnVuXG4gICAgICAgIGxldCBzdGF0dXMxID0gc3RhcnRpbmdTdGF0dXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVG9nZ2xlczsgaSsrKSB7XG4gICAgICAgICAgc3RhdHVzMSA9IGdldE5leHRTdGF0dXMoc3RhdHVzMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZWNvbmQgcnVuIHdpdGggc2FtZSBpbnB1dHNcbiAgICAgICAgbGV0IHN0YXR1czIgPSBzdGFydGluZ1N0YXR1cztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Ub2dnbGVzOyBpKyspIHtcbiAgICAgICAgICBzdGF0dXMyID0gZ2V0TmV4dFN0YXR1cyhzdGF0dXMyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc3VsdHMgc2hvdWxkIGJlIGlkZW50aWNhbFxuICAgICAgICBleHBlY3Qoc3RhdHVzMSkudG9CZShzdGF0dXMyKTtcbiAgICAgIH0pLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgbmV2ZXIgc2tpcCBhIHN0YXR1cyBpbiB0aGUgY3ljbGUnLCAoKSA9PiB7XG4gICAgZmMuYXNzZXJ0KFxuICAgICAgZmMucHJvcGVydHkocnN2cFN0YXR1c0FyYml0cmFyeSwgKGN1cnJlbnRTdGF0dXMpID0+IHtcbiAgICAgICAgY29uc3QgbmV4dFN0YXR1cyA9IGdldE5leHRTdGF0dXMoY3VycmVudFN0YXR1cyk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IENZQ0xFX09SREVSLmluZGV4T2YoY3VycmVudFN0YXR1cyk7XG4gICAgICAgIGNvbnN0IG5leHRJbmRleCA9IENZQ0xFX09SREVSLmluZGV4T2YobmV4dFN0YXR1cyk7XG5cbiAgICAgICAgLy8gU2hvdWxkIG1vdmUgZXhhY3RseSBvbmUgcG9zaXRpb24gZm9yd2FyZCAod2l0aCB3cmFwYXJvdW5kKVxuICAgICAgICBjb25zdCBleHBlY3RlZE5leHRJbmRleCA9IChjdXJyZW50SW5kZXggKyAxKSAlIDQ7XG4gICAgICAgIGV4cGVjdChuZXh0SW5kZXgpLnRvQmUoZXhwZWN0ZWROZXh0SW5kZXgpO1xuXG4gICAgICAgIC8vIFNob3VsZCBub3Qgc2tpcCBhbnkgc3RhdHVzXG4gICAgICAgIGNvbnN0IHNraXBwZWRDb3VudCA9IChuZXh0SW5kZXggLSBjdXJyZW50SW5kZXggKyA0KSAlIDQ7XG4gICAgICAgIGV4cGVjdChza2lwcGVkQ291bnQpLnRvQmUoMSk7XG4gICAgICB9KSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGhhbmRsZSByYXBpZCBzdWNjZXNzaXZlIHRvZ2dsZXMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLnByb3BlcnR5KHJzdnBTdGF0dXNBcmJpdHJhcnksIGZjLmludGVnZXIoeyBtaW46IDEsIG1heDogMTAwIH0pLCAoc3RhcnRpbmdTdGF0dXMsIHJhcGlkVG9nZ2xlcykgPT4ge1xuICAgICAgICBsZXQgY3VycmVudFN0YXR1cyA9IHN0YXJ0aW5nU3RhdHVzO1xuXG4gICAgICAgIC8vIEFwcGx5IHJhcGlkIHRvZ2dsZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXBpZFRvZ2dsZXM7IGkrKykge1xuICAgICAgICAgIGN1cnJlbnRTdGF0dXMgPSBnZXROZXh0U3RhdHVzKGN1cnJlbnRTdGF0dXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGV4cGVjdGVkIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBDWUNMRV9PUkRFUi5pbmRleE9mKHN0YXJ0aW5nU3RhdHVzKTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRJbmRleCA9IChzdGFydEluZGV4ICsgcmFwaWRUb2dnbGVzKSAlIDQ7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkU3RhdHVzID0gQ1lDTEVfT1JERVJbZXhwZWN0ZWRJbmRleF07XG5cbiAgICAgICAgZXhwZWN0KGN1cnJlbnRTdGF0dXMpLnRvQmUoZXhwZWN0ZWRTdGF0dXMpO1xuICAgICAgfSksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJkZXNjcmliZSIsIkNZQ0xFX09SREVSIiwiZ2V0TmV4dFN0YXR1cyIsImN1cnJlbnRTdGF0dXMiLCJjdXJyZW50SW5kZXgiLCJpbmRleE9mIiwibmV4dEluZGV4IiwibGVuZ3RoIiwicnN2cFN0YXR1c0FyYml0cmFyeSIsImZjIiwiY29uc3RhbnRGcm9tIiwiaXQiLCJhc3NlcnQiLCJwcm9wZXJ0eSIsInN0YXJ0aW5nU3RhdHVzIiwidmlzaXRlZFN0YXR1c2VzIiwiaSIsIm5leHRTdGF0dXMiLCJwdXNoIiwiZXhwZWN0IiwidG9CZSIsImN1cnJlbnQiLCJuZXh0IiwiZXhwZWN0ZWROZXh0IiwibnVtUnVucyIsIlNldCIsImFkZCIsInNpemUiLCJoYXMiLCJpbnRlZ2VyIiwibWluIiwibWF4IiwibnVtVG9nZ2xlcyIsInN0YXJ0SW5kZXgiLCJleHBlY3RlZEluZGV4IiwiZXhwZWN0ZWRTdGF0dXMiLCJzdGF0dXMxIiwic3RhdHVzMiIsImV4cGVjdGVkTmV4dEluZGV4Iiwic2tpcHBlZENvdW50IiwicmFwaWRUb2dnbGVzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkM7Ozs7bUVBRW1COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFcEJBLFNBQVMsc0ZBQXNGO0lBQzdGLGtDQUFrQztJQUNsQyxNQUFNQyxjQUFxRTtRQUN6RTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBRUQ7O0dBRUMsR0FDRCxTQUFTQyxjQUNQQyxhQUE2RDtRQUU3RCxNQUFNQyxlQUFlSCxZQUFZSSxPQUFPLENBQUNGO1FBQ3pDLE1BQU1HLFlBQVksQUFBQ0YsQ0FBQUEsZUFBZSxDQUFBLElBQUtILFlBQVlNLE1BQU07UUFDekQsT0FBT04sV0FBVyxDQUFDSyxVQUFVO0lBQy9CO0lBRUE7O0dBRUMsR0FDRCxNQUFNRSxzQkFBc0JD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