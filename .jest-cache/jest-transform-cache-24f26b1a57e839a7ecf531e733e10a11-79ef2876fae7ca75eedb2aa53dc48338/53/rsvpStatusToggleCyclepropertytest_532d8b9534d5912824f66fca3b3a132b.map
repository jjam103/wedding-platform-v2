{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/__tests__/property/rsvpStatusToggleCycle.property.test.ts"],"sourcesContent":["/**\n * Property-Based Test: RSVP Status Toggle Cycle\n * \n * Feature: guest-portal-and-admin-enhancements\n * Property 4: RSVP Status Toggle Cycle\n * \n * Description:\n * For any RSVP status control, clicking SHALL cycle through states in order:\n * pending → attending → maybe → declined → pending\n * \n * Validates: Requirements 2.4\n * \n * Test Strategy:\n * - Generate random starting status\n * - Apply toggle operation multiple times\n * - Verify cycle order is maintained\n * - Verify cycle completes after 4 toggles\n */\n\nimport * as fc from 'fast-check';\n\ndescribe('Feature: guest-portal-and-admin-enhancements, Property 4: RSVP Status Toggle Cycle', () => {\n  // Define the expected cycle order\n  const CYCLE_ORDER: Array<'pending' | 'attending' | 'maybe' | 'declined'> = [\n    'pending',\n    'attending',\n    'maybe',\n    'declined',\n  ];\n\n  /**\n   * Get the next status in the cycle\n   */\n  function getNextStatus(\n    currentStatus: 'pending' | 'attending' | 'maybe' | 'declined'\n  ): 'pending' | 'attending' | 'maybe' | 'declined' {\n    const currentIndex = CYCLE_ORDER.indexOf(currentStatus);\n    const nextIndex = (currentIndex + 1) % CYCLE_ORDER.length;\n    return CYCLE_ORDER[nextIndex];\n  }\n\n  /**\n   * Arbitrary for RSVP status\n   */\n  const rsvpStatusArbitrary = fc.constantFrom<'pending' | 'attending' | 'maybe' | 'declined'>(\n    'pending',\n    'attending',\n    'maybe',\n    'declined'\n  );\n\n  it('should cycle through statuses in correct order: pending → attending → maybe → declined → pending', () => {\n    fc.assert(\n      fc.property(rsvpStatusArbitrary, (startingStatus) => {\n        let currentStatus = startingStatus;\n        const visitedStatuses: Array<'pending' | 'attending' | 'maybe' | 'declined'> = [currentStatus];\n\n        // Toggle 4 times to complete one full cycle\n        for (let i = 0; i < 4; i++) {\n          const nextStatus = getNextStatus(currentStatus);\n          visitedStatuses.push(nextStatus);\n          currentStatus = nextStatus;\n        }\n\n        // After 4 toggles, should return to starting status\n        expect(currentStatus).toBe(startingStatus);\n\n        // Verify each transition follows the cycle order\n        for (let i = 0; i < visitedStatuses.length - 1; i++) {\n          const current = visitedStatuses[i];\n          const next = visitedStatuses[i + 1];\n          const expectedNext = getNextStatus(current);\n          expect(next).toBe(expectedNext);\n        }\n      }),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should always transition to the next status in cycle order', () => {\n    fc.assert(\n      fc.property(rsvpStatusArbitrary, (currentStatus) => {\n        const nextStatus = getNextStatus(currentStatus);\n        const currentIndex = CYCLE_ORDER.indexOf(currentStatus);\n        const nextIndex = CYCLE_ORDER.indexOf(nextStatus);\n\n        // Next index should be current + 1 (mod 4)\n        expect(nextIndex).toBe((currentIndex + 1) % 4);\n      }),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should visit all 4 statuses exactly once in a complete cycle', () => {\n    fc.assert(\n      fc.property(rsvpStatusArbitrary, (startingStatus) => {\n        let currentStatus = startingStatus;\n        const visitedStatuses = new Set<'pending' | 'attending' | 'maybe' | 'declined'>([currentStatus]);\n\n        // Toggle until we return to starting status\n        for (let i = 0; i < 4; i++) {\n          currentStatus = getNextStatus(currentStatus);\n          if (currentStatus === startingStatus && i < 3) {\n            // Should not return to start before completing cycle\n            return false;\n          }\n          visitedStatuses.add(currentStatus);\n        }\n\n        // Should have visited all 4 statuses\n        expect(visitedStatuses.size).toBe(4);\n        expect(visitedStatuses.has('pending')).toBe(true);\n        expect(visitedStatuses.has('attending')).toBe(true);\n        expect(visitedStatuses.has('maybe')).toBe(true);\n        expect(visitedStatuses.has('declined')).toBe(true);\n\n        // Should return to starting status after 4 toggles\n        expect(currentStatus).toBe(startingStatus);\n      }),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should maintain cycle order regardless of starting position', () => {\n    fc.assert(\n      fc.property(rsvpStatusArbitrary, fc.integer({ min: 1, max: 10 }), (startingStatus, numToggles) => {\n        let currentStatus = startingStatus;\n        const startIndex = CYCLE_ORDER.indexOf(startingStatus);\n\n        // Apply toggles\n        for (let i = 0; i < numToggles; i++) {\n          currentStatus = getNextStatus(currentStatus);\n        }\n\n        // Calculate expected final position\n        const expectedIndex = (startIndex + numToggles) % 4;\n        const expectedStatus = CYCLE_ORDER[expectedIndex];\n\n        expect(currentStatus).toBe(expectedStatus);\n      }),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should be deterministic - same starting status and toggles always produce same result', () => {\n    fc.assert(\n      fc.property(rsvpStatusArbitrary, fc.integer({ min: 0, max: 20 }), (startingStatus, numToggles) => {\n        // First run\n        let status1 = startingStatus;\n        for (let i = 0; i < numToggles; i++) {\n          status1 = getNextStatus(status1);\n        }\n\n        // Second run with same inputs\n        let status2 = startingStatus;\n        for (let i = 0; i < numToggles; i++) {\n          status2 = getNextStatus(status2);\n        }\n\n        // Results should be identical\n        expect(status1).toBe(status2);\n      }),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should never skip a status in the cycle', () => {\n    fc.assert(\n      fc.property(rsvpStatusArbitrary, (currentStatus) => {\n        const nextStatus = getNextStatus(currentStatus);\n        const currentIndex = CYCLE_ORDER.indexOf(currentStatus);\n        const nextIndex = CYCLE_ORDER.indexOf(nextStatus);\n\n        // Should move exactly one position forward (with wraparound)\n        const expectedNextIndex = (currentIndex + 1) % 4;\n        expect(nextIndex).toBe(expectedNextIndex);\n\n        // Should not skip any status\n        const skippedCount = (nextIndex - currentIndex + 4) % 4;\n        expect(skippedCount).toBe(1);\n      }),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should handle rapid successive toggles correctly', () => {\n    fc.assert(\n      fc.property(rsvpStatusArbitrary, fc.integer({ min: 1, max: 100 }), (startingStatus, rapidToggles) => {\n        let currentStatus = startingStatus;\n\n        // Apply rapid toggles\n        for (let i = 0; i < rapidToggles; i++) {\n          currentStatus = getNextStatus(currentStatus);\n        }\n\n        // Calculate expected position\n        const startIndex = CYCLE_ORDER.indexOf(startingStatus);\n        const expectedIndex = (startIndex + rapidToggles) % 4;\n        const expectedStatus = CYCLE_ORDER[expectedIndex];\n\n        expect(currentStatus).toBe(expectedStatus);\n      }),\n      { numRuns: 100 }\n    );\n  });\n});\n"],"names":["describe","CYCLE_ORDER","getNextStatus","currentStatus","currentIndex","indexOf","nextIndex","length","rsvpStatusArbitrary","fc","constantFrom","it","assert","property","startingStatus","visitedStatuses","i","nextStatus","push","expect","toBe","current","next","expectedNext","numRuns","Set","add","size","has","integer","min","max","numToggles","startIndex","expectedIndex","expectedStatus","status1","status2","expectedNextIndex","skippedCount","rapidToggles"],"mappings":"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"}