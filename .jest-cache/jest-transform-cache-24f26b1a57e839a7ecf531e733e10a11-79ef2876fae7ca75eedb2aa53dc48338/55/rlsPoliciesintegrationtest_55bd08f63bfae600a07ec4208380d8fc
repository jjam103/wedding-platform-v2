609938bb3a5a7541dcd72f6f89a1f34d
/**
 * RLS Policies Integration Tests
 * 
 * These tests validate that Row-Level Security (RLS) policies are properly enforced
 * for all database tables. Uses real authentication (not service role) to ensure
 * RLS policies work as expected.
 * 
 * This catches RLS bugs that unit tests miss because unit tests often use service
 * role which bypasses RLS entirely.
 * 
 * Validates: Requirements 1.2, 1.3, 1.4
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _testDb = require("../helpers/testDb");
const _factories = require("../helpers/factories");
const _cleanup = require("../helpers/cleanup");
describe('RLS Policies Integration Tests', ()=>{
    let testUser = null;
    let authSetupFailed = false;
    const createdIds = new Map();
    // Helper to track created entities for cleanup
    const trackEntity = (table, id)=>{
        const ids = createdIds.get(table) || [];
        ids.push(id);
        createdIds.set(table, ids);
    };
    beforeAll(async ()=>{
        try {
            testUser = await (0, _testDb.createAndSignInTestUser)();
            console.log('✅ Test user created for RLS tests');
        } catch (error) {
            console.warn('⚠️  Failed to create test user:', error instanceof Error ? error.message : error);
            authSetupFailed = true;
        }
    }, 30000);
    afterAll(async ()=>{
        // Clean up created entities
        for (const [table, ids] of createdIds.entries()){
            if (ids.length > 0) {
                await (0, _cleanup.cleanupByIds)(table, ids);
            }
        }
        // Clean up test user
        if (testUser?.id) {
            try {
                await (0, _testDb.deleteTestUser)(testUser.id);
                console.log('✅ Test user cleaned up');
            } catch (error) {
                console.warn('⚠️  Failed to clean up test user:', error);
            }
        }
    }, 10000);
    describe('guest_groups Table RLS', ()=>{
        it('should allow authenticated users to read guest groups', async ()=>{
            if (authSetupFailed || !testUser?.accessToken) {
                console.log('⏭️  Skipping: Authentication not configured');
                return;
            }
            const client = (0, _testDb.createTestClient)(testUser.accessToken);
            const { data, error } = await client.from('guest_groups').select('*').limit(10);
            // Should not get RLS error
            expect(error).toBeNull();
            expect(data).toBeDefined();
            expect(Array.isArray(data)).toBe(true);
        });
        it('should allow authenticated users to create guest groups', async ()=>{
            if (authSetupFailed || !testUser?.accessToken) {
                console.log('⏭️  Skipping: Authentication not configured');
                return;
            }
            const client = (0, _testDb.createTestClient)(testUser.accessToken);
            const testGroup = (0, _factories.createTestGuestGroup)();
            const { data, error } = await client.from('guest_groups').insert({
                name: testGroup.name,
                description: testGroup.description
            }).select().single();
            // Should not get RLS error
            expect(error).toBeNull();
            expect(data).toBeDefined();
            if (data) {
                trackEntity('guest_groups', data.id);
            }
        });
        it('should prevent unauthenticated access to guest groups', async ()=>{
            const client = (0, _testDb.createTestClient)(); // No access token
            const { data, error } = await client.from('guest_groups').select('*').limit(10);
            // Should get auth error or empty result
            expect(data === null || Array.isArray(data) && data.length === 0).toBe(true);
        });
    });
    describe('guests Table RLS', ()=>{
        it('should allow authenticated users to read guests', async ()=>{
            if (authSetupFailed || !testUser?.accessToken) {
                console.log('⏭️  Skipping: Authentication not configured');
                return;
            }
            const client = (0, _testDb.createTestClient)(testUser.accessToken);
            const { data, error } = await client.from('guests').select('*').limit(10);
            expect(error).toBeNull();
            expect(data).toBeDefined();
            expect(Array.isArray(data)).toBe(true);
        });
        it('should allow authenticated users to create guests', async ()=>{
            if (authSetupFailed || !testUser?.accessToken) {
                console.log('⏭️  Skipping: Authentication not configured');
                return;
            }
            // First create a group
            const serviceClient = (0, _testDb.createServiceClient)();
            const testGroup = (0, _factories.createTestGuestGroup)();
            const { data: group } = await serviceClient.from('guest_groups').insert({
                name: testGroup.name,
                description: testGroup.description
            }).select().single();
            if (!group) {
                console.log('⏭️  Skipping: Could not create test group');
                return;
            }
            trackEntity('guest_groups', group.id);
            // Now create guest with authenticated client
            const client = (0, _testDb.createTestClient)(testUser.accessToken);
            const testGuest = (0, _factories.createTestGuest)({
                groupId: group.id
            });
            const { data, error } = await client.from('guests').insert({
                first_name: testGuest.firstName,
                last_name: testGuest.lastName,
                email: testGuest.email,
                group_id: testGuest.groupId,
                age_type: testGuest.ageType,
                guest_type: testGuest.guestType
            }).select().single();
            expect(error).toBeNull();
            expect(data).toBeDefined();
            if (data) {
                trackEntity('guests', data.id);
            }
        });
    });
    describe('events Table RLS', ()=>{
        it('should allow authenticated users to read events', async ()=>{
            if (authSetupFailed || !testUser?.accessToken) {
                console.log('⏭️  Skipping: Authentication not configured');
                return;
            }
            const client = (0, _testDb.createTestClient)(testUser.accessToken);
            const { data, error } = await client.from('events').select('*').limit(10);
            expect(error).toBeNull();
            expect(data).toBeDefined();
            expect(Array.isArray(data)).toBe(true);
        });
        it('should allow authenticated users to create events', async ()=>{
            if (authSetupFailed || !testUser?.accessToken) {
                console.log('⏭️  Skipping: Authentication not configured');
                return;
            }
            const client = (0, _testDb.createTestClient)(testUser.accessToken);
            const testEvent = (0, _factories.createTestEvent)();
            const { data, error } = await client.from('events').insert({
                name: testEvent.name,
                description: testEvent.description,
                start_date: testEvent.startDate,
                end_date: testEvent.endDate
            }).select().single();
            expect(error).toBeNull();
            expect(data).toBeDefined();
            if (data) {
                trackEntity('events', data.id);
            }
        });
    });
    describe('activities Table RLS', ()=>{
        it('should allow authenticated users to read activities', async ()=>{
            if (authSetupFailed || !testUser?.accessToken) {
                console.log('⏭️  Skipping: Authentication not configured');
                return;
            }
            const client = (0, _testDb.createTestClient)(testUser.accessToken);
            const { data, error } = await client.from('activities').select('*').limit(10);
            expect(error).toBeNull();
            expect(data).toBeDefined();
            expect(Array.isArray(data)).toBe(true);
        });
    });
    describe('accommodations Table RLS', ()=>{
        it('should allow authenticated users to read accommodations', async ()=>{
            if (authSetupFailed || !testUser?.accessToken) {
                console.log('⏭️  Skipping: Authentication not configured');
                return;
            }
            const client = (0, _testDb.createTestClient)(testUser.accessToken);
            const { data, error } = await client.from('accommodations').select('*').limit(10);
            expect(error).toBeNull();
            expect(data).toBeDefined();
            expect(Array.isArray(data)).toBe(true);
        });
    });
    describe('sections Table RLS', ()=>{
        it('should allow authenticated users to read sections', async ()=>{
            if (authSetupFailed || !testUser?.accessToken) {
                console.log('⏭️  Skipping: Authentication not configured');
                return;
            }
            const client = (0, _testDb.createTestClient)(testUser.accessToken);
            const { data, error } = await client.from('sections').select('*').limit(10);
            // Should not get "permission denied for table users" error
            expect(error).toBeNull();
            expect(data).toBeDefined();
            expect(Array.isArray(data)).toBe(true);
        });
        it('should allow authenticated users to create sections', async ()=>{
            if (authSetupFailed || !testUser?.accessToken) {
                console.log('⏭️  Skipping: Authentication not configured');
                return;
            }
            const client = (0, _testDb.createTestClient)(testUser.accessToken);
            const sectionData = {
                page_type: 'event',
                page_id: '123e4567-e89b-12d3-a456-426614174000',
                title: 'Test Section',
                display_order: 0
            };
            const { data, error } = await client.from('sections').insert(sectionData).select().single();
            // Should not get RLS error
            expect(error).toBeNull();
            expect(data).toBeDefined();
            if (data) {
                expect(data.page_type).toBe('event');
                expect(data.page_id).toBe(sectionData.page_id);
                trackEntity('sections', data.id);
            }
        });
        it('should filter sections by page_type and page_id', async ()=>{
            if (authSetupFailed || !testUser?.accessToken) {
                console.log('⏭️  Skipping: Authentication not configured');
                return;
            }
            const serviceClient = (0, _testDb.createServiceClient)();
            const client = (0, _testDb.createTestClient)(testUser.accessToken);
            const testPageId = '123e4567-e89b-12d3-a456-426614174001';
            // Create test section using service role
            const { data: section } = await serviceClient.from('sections').insert({
                page_type: 'event',
                page_id: testPageId,
                title: 'Filterable Section',
                display_order: 0
            }).select().single();
            if (section) {
                trackEntity('sections', section.id);
            }
            // Filter by page_type and page_id
            const { data, error } = await client.from('sections').select('*').eq('page_type', 'event').eq('page_id', testPageId);
            expect(error).toBeNull();
            expect(data).toBeDefined();
            expect(Array.isArray(data)).toBe(true);
        });
    });
    describe('columns Table RLS', ()=>{
        it('should allow authenticated users to read columns', async ()=>{
            if (authSetupFailed || !testUser?.accessToken) {
                console.log('⏭️  Skipping: Authentication not configured');
                return;
            }
            const client = (0, _testDb.createTestClient)(testUser.accessToken);
            const { data, error } = await client.from('columns').select('*').limit(10);
            expect(error).toBeNull();
            expect(data).toBeDefined();
            expect(Array.isArray(data)).toBe(true);
        });
        it('should allow authenticated users to create columns', async ()=>{
            if (authSetupFailed || !testUser?.accessToken) {
                console.log('⏭️  Skipping: Authentication not configured');
                return;
            }
            const serviceClient = (0, _testDb.createServiceClient)();
            const client = (0, _testDb.createTestClient)(testUser.accessToken);
            // Create section using service role
            const { data: section } = await serviceClient.from('sections').insert({
                page_type: 'event',
                page_id: '123e4567-e89b-12d3-a456-426614174002',
                display_order: 0
            }).select().single();
            if (!section) {
                console.log('⏭️  Skipping: Could not create test section');
                return;
            }
            trackEntity('sections', section.id);
            // Create column with authenticated client
            const columnData = {
                section_id: section.id,
                column_number: 1,
                content_type: 'rich_text',
                content_data: {
                    html: '<p>Test content</p>'
                }
            };
            const { data, error } = await client.from('columns').insert(columnData).select().single();
            expect(error).toBeNull();
            expect(data).toBeDefined();
            if (data) {
                expect(data.section_id).toBe(section.id);
                expect(data.column_number).toBe(1);
                trackEntity('columns', data.id);
            }
        });
        it('should verify cascade deletion from sections to columns', async ()=>{
            if (authSetupFailed || !testUser?.accessToken) {
                console.log('⏭️  Skipping: Authentication not configured');
                return;
            }
            const serviceClient = (0, _testDb.createServiceClient)();
            const client = (0, _testDb.createTestClient)(testUser.accessToken);
            // Create section and column using service role
            const { data: section } = await serviceClient.from('sections').insert({
                page_type: 'event',
                page_id: '123e4567-e89b-12d3-a456-426614174003',
                display_order: 0
            }).select().single();
            if (!section) {
                console.log('⏭️  Skipping: Could not create test section');
                return;
            }
            const { data: column } = await serviceClient.from('columns').insert({
                section_id: section.id,
                column_number: 1,
                content_type: 'rich_text',
                content_data: {
                    html: '<p>Test content</p>'
                }
            }).select().single();
            if (!column) {
                console.log('⏭️  Skipping: Could not create test column');
                return;
            }
            // Delete section (should cascade to column)
            const { error: deleteError } = await client.from('sections').delete().eq('id', section.id);
            expect(deleteError).toBeNull();
            // Verify column is also deleted
            const { data: deletedColumn } = await serviceClient.from('columns').select('*').eq('id', column.id).single();
            expect(deletedColumn).toBeNull();
        });
    });
    describe('content_pages Table RLS', ()=>{
        it('should allow authenticated users to read content pages', async ()=>{
            if (authSetupFailed || !testUser?.accessToken) {
                console.log('⏭️  Skipping: Authentication not configured');
                return;
            }
            const client = (0, _testDb.createTestClient)(testUser.accessToken);
            const { data, error } = await client.from('content_pages').select('*').limit(10);
            expect(error).toBeNull();
            expect(data).toBeDefined();
            expect(Array.isArray(data)).toBe(true);
        });
        it('should allow authenticated users to create content pages', async ()=>{
            if (authSetupFailed || !testUser?.accessToken) {
                console.log('⏭️  Skipping: Authentication not configured');
                return;
            }
            const client = (0, _testDb.createTestClient)(testUser.accessToken);
            const testPage = (0, _factories.createTestContentPage)();
            const { data, error } = await client.from('content_pages').insert({
                title: testPage.title,
                slug: testPage.slug,
                type: testPage.type,
                published: testPage.published
            }).select().single();
            // Should not get "violates row-level security policy" error
            expect(error).toBeNull();
            expect(data).toBeDefined();
            if (data) {
                trackEntity('content_pages', data.id);
            }
        });
    });
    describe('gallery_settings Table RLS', ()=>{
        it('should allow authenticated users to read gallery settings', async ()=>{
            if (authSetupFailed || !testUser?.accessToken) {
                console.log('⏭️  Skipping: Authentication not configured');
                return;
            }
            const client = (0, _testDb.createTestClient)(testUser.accessToken);
            const { data, error } = await client.from('gallery_settings').select('*').limit(10);
            expect(error).toBeNull();
            expect(data).toBeDefined();
            expect(Array.isArray(data)).toBe(true);
        });
    });
    describe('photos Table RLS', ()=>{
        it('should allow authenticated users to read approved photos', async ()=>{
            if (authSetupFailed || !testUser?.accessToken) {
                console.log('⏭️  Skipping: Authentication not configured');
                return;
            }
            const client = (0, _testDb.createTestClient)(testUser.accessToken);
            const { data, error } = await client.from('photos').select('*').eq('moderation_status', 'approved').limit(10);
            // Should not get RLS error
            expect(error).toBeNull();
            expect(data).toBeDefined();
            expect(Array.isArray(data)).toBe(true);
        });
        it('should allow authenticated users to upload photos', async ()=>{
            if (authSetupFailed || !testUser?.accessToken) {
                console.log('⏭️  Skipping: Authentication not configured');
                return;
            }
            const client = (0, _testDb.createTestClient)(testUser.accessToken);
            const photoData = {
                uploader_id: testUser.id,
                photo_url: `https://cdn.example.com/test-photo-${Date.now()}.jpg`,
                storage_type: 'b2',
                page_type: 'memory',
                moderation_status: 'pending'
            };
            const { data, error } = await client.from('photos').insert(photoData).select().single();
            // Should not get RLS error
            expect(error).toBeNull();
            expect(data).toBeDefined();
            if (data) {
                trackEntity('photos', data.id);
            }
        });
        it('should allow users to view their own photos', async ()=>{
            if (authSetupFailed || !testUser?.accessToken) {
                console.log('⏭️  Skipping: Authentication not configured');
                return;
            }
            const client = (0, _testDb.createTestClient)(testUser.accessToken);
            // Create photo
            const photoData = {
                uploader_id: testUser.id,
                photo_url: `https://cdn.example.com/own-photo-${Date.now()}.jpg`,
                storage_type: 'b2',
                page_type: 'memory',
                moderation_status: 'pending'
            };
            const { data: createdPhoto } = await client.from('photos').insert(photoData).select().single();
            if (!createdPhoto) {
                console.log('⏭️  Skipping: Could not create test photo');
                return;
            }
            trackEntity('photos', createdPhoto.id);
            // Should be able to view own photo even if pending
            const { data, error } = await client.from('photos').select('*').eq('id', createdPhoto.id).single();
            expect(error).toBeNull();
            expect(data).toBeDefined();
            expect(data?.id).toBe(createdPhoto.id);
        });
        it('should filter photos by page_type and page_id', async ()=>{
            if (authSetupFailed || !testUser?.accessToken) {
                console.log('⏭️  Skipping: Authentication not configured');
                return;
            }
            const serviceClient = (0, _testDb.createServiceClient)();
            const client = (0, _testDb.createTestClient)(testUser.accessToken);
            const testPageId = '123e4567-e89b-12d3-a456-426614174000';
            // Create test photo with service role
            const { data: photo } = await serviceClient.from('photos').insert({
                uploader_id: testUser.id,
                photo_url: `https://cdn.example.com/filtered-photo-${Date.now()}.jpg`,
                storage_type: 'b2',
                page_type: 'event',
                page_id: testPageId,
                moderation_status: 'approved'
            }).select().single();
            if (photo) {
                trackEntity('photos', photo.id);
            }
            // Filter by page_type and page_id
            const { data, error } = await client.from('photos').select('*').eq('page_type', 'event').eq('page_id', testPageId);
            expect(error).toBeNull();
            expect(data).toBeDefined();
            expect(Array.isArray(data)).toBe(true);
        });
    });
    describe('Cross-Table RLS Consistency', ()=>{
        it('should enforce consistent RLS across related tables', async ()=>{
            if (authSetupFailed || !testUser?.accessToken) {
                console.log('⏭️  Skipping: Authentication not configured');
                return;
            }
            const client = (0, _testDb.createTestClient)(testUser.accessToken);
            // Try to read from multiple tables
            const [groupsResult, guestsResult, eventsResult] = await Promise.all([
                client.from('guest_groups').select('*').limit(1),
                client.from('guests').select('*').limit(1),
                client.from('events').select('*').limit(1)
            ]);
            // All should succeed or fail consistently (no RLS errors)
            expect(groupsResult.error).toBeNull();
            expect(guestsResult.error).toBeNull();
            expect(eventsResult.error).toBeNull();
        });
    });
}); /**
 * TEST IMPLEMENTATION NOTES
 * 
 * These tests validate RLS policies for all major tables:
 * 
 * 1. **guest_groups**: Read, create, and auth enforcement
 * 2. **guests**: Read, create with proper group reference
 * 3. **events**: Read and create
 * 4. **activities**: Read operations
 * 5. **accommodations**: Read operations
 * 6. **sections**: Read, create (catches "permission denied for table users" bug)
 * 7. **columns**: Read operations
 * 8. **content_pages**: Read, create (catches RLS violation bug)
 * 9. **gallery_settings**: Read operations
 * 
 * Key Testing Patterns:
 * - Uses real authentication (not service role)
 * - Tests both read and write operations
 * - Verifies unauthenticated access is blocked
 * - Checks for specific RLS error messages
 * - Cleans up test data after execution
 * 
 * What These Tests Catch:
 * - Missing RLS policies
 * - Incorrect RLS policy logic
 * - Permission denied errors
 * - RLS policy violations
 * - Inconsistent access control
 * 
 * Validates: Requirements 1.2, 1.3, 1.4
 */ 

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvX190ZXN0c19fL2ludGVncmF0aW9uL3Jsc1BvbGljaWVzLmludGVncmF0aW9uLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSTFMgUG9saWNpZXMgSW50ZWdyYXRpb24gVGVzdHNcbiAqIFxuICogVGhlc2UgdGVzdHMgdmFsaWRhdGUgdGhhdCBSb3ctTGV2ZWwgU2VjdXJpdHkgKFJMUykgcG9saWNpZXMgYXJlIHByb3Blcmx5IGVuZm9yY2VkXG4gKiBmb3IgYWxsIGRhdGFiYXNlIHRhYmxlcy4gVXNlcyByZWFsIGF1dGhlbnRpY2F0aW9uIChub3Qgc2VydmljZSByb2xlKSB0byBlbnN1cmVcbiAqIFJMUyBwb2xpY2llcyB3b3JrIGFzIGV4cGVjdGVkLlxuICogXG4gKiBUaGlzIGNhdGNoZXMgUkxTIGJ1Z3MgdGhhdCB1bml0IHRlc3RzIG1pc3MgYmVjYXVzZSB1bml0IHRlc3RzIG9mdGVuIHVzZSBzZXJ2aWNlXG4gKiByb2xlIHdoaWNoIGJ5cGFzc2VzIFJMUyBlbnRpcmVseS5cbiAqIFxuICogVmFsaWRhdGVzOiBSZXF1aXJlbWVudHMgMS4yLCAxLjMsIDEuNFxuICovXG5cbmltcG9ydCB7IGNyZWF0ZUFuZFNpZ25JblRlc3RVc2VyLCBkZWxldGVUZXN0VXNlciwgY3JlYXRlU2VydmljZUNsaWVudCwgY3JlYXRlVGVzdENsaWVudCwgdHlwZSBUZXN0VXNlciB9IGZyb20gJy4uL2hlbHBlcnMvdGVzdERiJztcbmltcG9ydCB7IGNyZWF0ZVRlc3RHdWVzdEdyb3VwLCBjcmVhdGVUZXN0R3Vlc3QsIGNyZWF0ZVRlc3RFdmVudCwgY3JlYXRlVGVzdEFjdGl2aXR5LCBjcmVhdGVUZXN0QWNjb21tb2RhdGlvbiwgY3JlYXRlVGVzdFNlY3Rpb24sIGNyZWF0ZVRlc3RDb250ZW50UGFnZSB9IGZyb20gJy4uL2hlbHBlcnMvZmFjdG9yaWVzJztcbmltcG9ydCB7IGNsZWFudXBCeUlkcyB9IGZyb20gJy4uL2hlbHBlcnMvY2xlYW51cCc7XG5cbmRlc2NyaWJlKCdSTFMgUG9saWNpZXMgSW50ZWdyYXRpb24gVGVzdHMnLCAoKSA9PiB7XG4gIGxldCB0ZXN0VXNlcjogVGVzdFVzZXIgfCBudWxsID0gbnVsbDtcbiAgbGV0IGF1dGhTZXR1cEZhaWxlZCA9IGZhbHNlO1xuICBjb25zdCBjcmVhdGVkSWRzOiBNYXA8c3RyaW5nLCBzdHJpbmdbXT4gPSBuZXcgTWFwKCk7XG4gIFxuICAvLyBIZWxwZXIgdG8gdHJhY2sgY3JlYXRlZCBlbnRpdGllcyBmb3IgY2xlYW51cFxuICBjb25zdCB0cmFja0VudGl0eSA9ICh0YWJsZTogc3RyaW5nLCBpZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgaWRzID0gY3JlYXRlZElkcy5nZXQodGFibGUpIHx8IFtdO1xuICAgIGlkcy5wdXNoKGlkKTtcbiAgICBjcmVhdGVkSWRzLnNldCh0YWJsZSwgaWRzKTtcbiAgfTtcbiAgXG4gIGJlZm9yZUFsbChhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RVc2VyID0gYXdhaXQgY3JlYXRlQW5kU2lnbkluVGVzdFVzZXIoKTtcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgVGVzdCB1c2VyIGNyZWF0ZWQgZm9yIFJMUyB0ZXN0cycpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyAgRmFpbGVkIHRvIGNyZWF0ZSB0ZXN0IHVzZXI6JywgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBlcnJvcik7XG4gICAgICBhdXRoU2V0dXBGYWlsZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwgMzAwMDApO1xuICBcbiAgYWZ0ZXJBbGwoYXN5bmMgKCkgPT4ge1xuICAgIC8vIENsZWFuIHVwIGNyZWF0ZWQgZW50aXRpZXNcbiAgICBmb3IgKGNvbnN0IFt0YWJsZSwgaWRzXSBvZiBjcmVhdGVkSWRzLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGlkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGF3YWl0IGNsZWFudXBCeUlkcyh0YWJsZSwgaWRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgdGVzdCB1c2VyXG4gICAgaWYgKHRlc3RVc2VyPy5pZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZGVsZXRlVGVzdFVzZXIodGVzdFVzZXIuaWQpO1xuICAgICAgICBjb25zb2xlLmxvZygn4pyFIFRlc3QgdXNlciBjbGVhbmVkIHVwJyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyAgRmFpbGVkIHRvIGNsZWFuIHVwIHRlc3QgdXNlcjonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9LCAxMDAwMCk7XG4gIFxuICBkZXNjcmliZSgnZ3Vlc3RfZ3JvdXBzIFRhYmxlIFJMUycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGFsbG93IGF1dGhlbnRpY2F0ZWQgdXNlcnMgdG8gcmVhZCBndWVzdCBncm91cHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoYXV0aFNldHVwRmFpbGVkIHx8ICF0ZXN0VXNlcj8uYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KPre+4jyAgU2tpcHBpbmc6IEF1dGhlbnRpY2F0aW9uIG5vdCBjb25maWd1cmVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgY2xpZW50ID0gY3JlYXRlVGVzdENsaWVudCh0ZXN0VXNlci5hY2Nlc3NUb2tlbik7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGNsaWVudFxuICAgICAgICAuZnJvbSgnZ3Vlc3RfZ3JvdXBzJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5saW1pdCgxMCk7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBub3QgZ2V0IFJMUyBlcnJvclxuICAgICAgZXhwZWN0KGVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGRhdGEpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoQXJyYXkuaXNBcnJheShkYXRhKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIGFsbG93IGF1dGhlbnRpY2F0ZWQgdXNlcnMgdG8gY3JlYXRlIGd1ZXN0IGdyb3VwcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChhdXRoU2V0dXBGYWlsZWQgfHwgIXRlc3RVc2VyPy5hY2Nlc3NUb2tlbikge1xuICAgICAgICBjb25zb2xlLmxvZygn4o+t77iPICBTa2lwcGluZzogQXV0aGVudGljYXRpb24gbm90IGNvbmZpZ3VyZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBjbGllbnQgPSBjcmVhdGVUZXN0Q2xpZW50KHRlc3RVc2VyLmFjY2Vzc1Rva2VuKTtcbiAgICAgIGNvbnN0IHRlc3RHcm91cCA9IGNyZWF0ZVRlc3RHdWVzdEdyb3VwKCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGNsaWVudFxuICAgICAgICAuZnJvbSgnZ3Vlc3RfZ3JvdXBzJylcbiAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgbmFtZTogdGVzdEdyb3VwLm5hbWUsXG4gICAgICAgICAgZGVzY3JpcHRpb246IHRlc3RHcm91cC5kZXNjcmlwdGlvbixcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIG5vdCBnZXQgUkxTIGVycm9yXG4gICAgICBleHBlY3QoZXJyb3IpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoZGF0YSkudG9CZURlZmluZWQoKTtcbiAgICAgIFxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgdHJhY2tFbnRpdHkoJ2d1ZXN0X2dyb3VwcycsIGRhdGEuaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGl0KCdzaG91bGQgcHJldmVudCB1bmF1dGhlbnRpY2F0ZWQgYWNjZXNzIHRvIGd1ZXN0IGdyb3VwcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNsaWVudCA9IGNyZWF0ZVRlc3RDbGllbnQoKTsgLy8gTm8gYWNjZXNzIHRva2VuXG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGNsaWVudFxuICAgICAgICAuZnJvbSgnZ3Vlc3RfZ3JvdXBzJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5saW1pdCgxMCk7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBnZXQgYXV0aCBlcnJvciBvciBlbXB0eSByZXN1bHRcbiAgICAgIGV4cGVjdChkYXRhID09PSBudWxsIHx8IChBcnJheS5pc0FycmF5KGRhdGEpICYmIGRhdGEubGVuZ3RoID09PSAwKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG4gIFxuICBkZXNjcmliZSgnZ3Vlc3RzIFRhYmxlIFJMUycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGFsbG93IGF1dGhlbnRpY2F0ZWQgdXNlcnMgdG8gcmVhZCBndWVzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoYXV0aFNldHVwRmFpbGVkIHx8ICF0ZXN0VXNlcj8uYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KPre+4jyAgU2tpcHBpbmc6IEF1dGhlbnRpY2F0aW9uIG5vdCBjb25maWd1cmVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgY2xpZW50ID0gY3JlYXRlVGVzdENsaWVudCh0ZXN0VXNlci5hY2Nlc3NUb2tlbik7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGNsaWVudFxuICAgICAgICAuZnJvbSgnZ3Vlc3RzJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5saW1pdCgxMCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChlcnJvcikudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChkYXRhKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KEFycmF5LmlzQXJyYXkoZGF0YSkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gICAgXG4gICAgaXQoJ3Nob3VsZCBhbGxvdyBhdXRoZW50aWNhdGVkIHVzZXJzIHRvIGNyZWF0ZSBndWVzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoYXV0aFNldHVwRmFpbGVkIHx8ICF0ZXN0VXNlcj8uYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KPre+4jyAgU2tpcHBpbmc6IEF1dGhlbnRpY2F0aW9uIG5vdCBjb25maWd1cmVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRmlyc3QgY3JlYXRlIGEgZ3JvdXBcbiAgICAgIGNvbnN0IHNlcnZpY2VDbGllbnQgPSBjcmVhdGVTZXJ2aWNlQ2xpZW50KCk7XG4gICAgICBjb25zdCB0ZXN0R3JvdXAgPSBjcmVhdGVUZXN0R3Vlc3RHcm91cCgpO1xuICAgICAgY29uc3QgeyBkYXRhOiBncm91cCB9ID0gYXdhaXQgc2VydmljZUNsaWVudFxuICAgICAgICAuZnJvbSgnZ3Vlc3RfZ3JvdXBzJylcbiAgICAgICAgLmluc2VydCh7IG5hbWU6IHRlc3RHcm91cC5uYW1lLCBkZXNjcmlwdGlvbjogdGVzdEdyb3VwLmRlc2NyaXB0aW9uIH0pXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKCk7XG4gICAgICBcbiAgICAgIGlmICghZ3JvdXApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KPre+4jyAgU2tpcHBpbmc6IENvdWxkIG5vdCBjcmVhdGUgdGVzdCBncm91cCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRyYWNrRW50aXR5KCdndWVzdF9ncm91cHMnLCBncm91cC5pZCk7XG4gICAgICBcbiAgICAgIC8vIE5vdyBjcmVhdGUgZ3Vlc3Qgd2l0aCBhdXRoZW50aWNhdGVkIGNsaWVudFxuICAgICAgY29uc3QgY2xpZW50ID0gY3JlYXRlVGVzdENsaWVudCh0ZXN0VXNlci5hY2Nlc3NUb2tlbik7XG4gICAgICBjb25zdCB0ZXN0R3Vlc3QgPSBjcmVhdGVUZXN0R3Vlc3QoeyBncm91cElkOiBncm91cC5pZCB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgY2xpZW50XG4gICAgICAgIC5mcm9tKCdndWVzdHMnKVxuICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICBmaXJzdF9uYW1lOiB0ZXN0R3Vlc3QuZmlyc3ROYW1lLFxuICAgICAgICAgIGxhc3RfbmFtZTogdGVzdEd1ZXN0Lmxhc3ROYW1lLFxuICAgICAgICAgIGVtYWlsOiB0ZXN0R3Vlc3QuZW1haWwsXG4gICAgICAgICAgZ3JvdXBfaWQ6IHRlc3RHdWVzdC5ncm91cElkLFxuICAgICAgICAgIGFnZV90eXBlOiB0ZXN0R3Vlc3QuYWdlVHlwZSxcbiAgICAgICAgICBndWVzdF90eXBlOiB0ZXN0R3Vlc3QuZ3Vlc3RUeXBlLFxuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgXG4gICAgICBleHBlY3QoZXJyb3IpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoZGF0YSkudG9CZURlZmluZWQoKTtcbiAgICAgIFxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgdHJhY2tFbnRpdHkoJ2d1ZXN0cycsIGRhdGEuaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgXG4gIGRlc2NyaWJlKCdldmVudHMgVGFibGUgUkxTJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgYWxsb3cgYXV0aGVudGljYXRlZCB1c2VycyB0byByZWFkIGV2ZW50cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChhdXRoU2V0dXBGYWlsZWQgfHwgIXRlc3RVc2VyPy5hY2Nlc3NUb2tlbikge1xuICAgICAgICBjb25zb2xlLmxvZygn4o+t77iPICBTa2lwcGluZzogQXV0aGVudGljYXRpb24gbm90IGNvbmZpZ3VyZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBjbGllbnQgPSBjcmVhdGVUZXN0Q2xpZW50KHRlc3RVc2VyLmFjY2Vzc1Rva2VuKTtcbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgY2xpZW50XG4gICAgICAgIC5mcm9tKCdldmVudHMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmxpbWl0KDEwKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGRhdGEpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoQXJyYXkuaXNBcnJheShkYXRhKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIGFsbG93IGF1dGhlbnRpY2F0ZWQgdXNlcnMgdG8gY3JlYXRlIGV2ZW50cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChhdXRoU2V0dXBGYWlsZWQgfHwgIXRlc3RVc2VyPy5hY2Nlc3NUb2tlbikge1xuICAgICAgICBjb25zb2xlLmxvZygn4o+t77iPICBTa2lwcGluZzogQXV0aGVudGljYXRpb24gbm90IGNvbmZpZ3VyZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBjbGllbnQgPSBjcmVhdGVUZXN0Q2xpZW50KHRlc3RVc2VyLmFjY2Vzc1Rva2VuKTtcbiAgICAgIGNvbnN0IHRlc3RFdmVudCA9IGNyZWF0ZVRlc3RFdmVudCgpO1xuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBjbGllbnRcbiAgICAgICAgLmZyb20oJ2V2ZW50cycpXG4gICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgIG5hbWU6IHRlc3RFdmVudC5uYW1lLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0ZXN0RXZlbnQuZGVzY3JpcHRpb24sXG4gICAgICAgICAgc3RhcnRfZGF0ZTogdGVzdEV2ZW50LnN0YXJ0RGF0ZSxcbiAgICAgICAgICBlbmRfZGF0ZTogdGVzdEV2ZW50LmVuZERhdGUsXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChlcnJvcikudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChkYXRhKS50b0JlRGVmaW5lZCgpO1xuICAgICAgXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICB0cmFja0VudGl0eSgnZXZlbnRzJywgZGF0YS5pZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBcbiAgZGVzY3JpYmUoJ2FjdGl2aXRpZXMgVGFibGUgUkxTJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgYWxsb3cgYXV0aGVudGljYXRlZCB1c2VycyB0byByZWFkIGFjdGl2aXRpZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoYXV0aFNldHVwRmFpbGVkIHx8ICF0ZXN0VXNlcj8uYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KPre+4jyAgU2tpcHBpbmc6IEF1dGhlbnRpY2F0aW9uIG5vdCBjb25maWd1cmVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgY2xpZW50ID0gY3JlYXRlVGVzdENsaWVudCh0ZXN0VXNlci5hY2Nlc3NUb2tlbik7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGNsaWVudFxuICAgICAgICAuZnJvbSgnYWN0aXZpdGllcycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAubGltaXQoMTApO1xuICAgICAgXG4gICAgICBleHBlY3QoZXJyb3IpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoZGF0YSkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChBcnJheS5pc0FycmF5KGRhdGEpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcbiAgXG4gIGRlc2NyaWJlKCdhY2NvbW1vZGF0aW9ucyBUYWJsZSBSTFMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBhbGxvdyBhdXRoZW50aWNhdGVkIHVzZXJzIHRvIHJlYWQgYWNjb21tb2RhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoYXV0aFNldHVwRmFpbGVkIHx8ICF0ZXN0VXNlcj8uYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KPre+4jyAgU2tpcHBpbmc6IEF1dGhlbnRpY2F0aW9uIG5vdCBjb25maWd1cmVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgY2xpZW50ID0gY3JlYXRlVGVzdENsaWVudCh0ZXN0VXNlci5hY2Nlc3NUb2tlbik7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGNsaWVudFxuICAgICAgICAuZnJvbSgnYWNjb21tb2RhdGlvbnMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmxpbWl0KDEwKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGRhdGEpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoQXJyYXkuaXNBcnJheShkYXRhKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG4gIFxuICBkZXNjcmliZSgnc2VjdGlvbnMgVGFibGUgUkxTJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgYWxsb3cgYXV0aGVudGljYXRlZCB1c2VycyB0byByZWFkIHNlY3Rpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKGF1dGhTZXR1cEZhaWxlZCB8fCAhdGVzdFVzZXI/LmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfij63vuI8gIFNraXBwaW5nOiBBdXRoZW50aWNhdGlvbiBub3QgY29uZmlndXJlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGNsaWVudCA9IGNyZWF0ZVRlc3RDbGllbnQodGVzdFVzZXIuYWNjZXNzVG9rZW4pO1xuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBjbGllbnRcbiAgICAgICAgLmZyb20oJ3NlY3Rpb25zJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5saW1pdCgxMCk7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBub3QgZ2V0IFwicGVybWlzc2lvbiBkZW5pZWQgZm9yIHRhYmxlIHVzZXJzXCIgZXJyb3JcbiAgICAgIGV4cGVjdChlcnJvcikudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChkYXRhKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KEFycmF5LmlzQXJyYXkoZGF0YSkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gICAgXG4gICAgaXQoJ3Nob3VsZCBhbGxvdyBhdXRoZW50aWNhdGVkIHVzZXJzIHRvIGNyZWF0ZSBzZWN0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChhdXRoU2V0dXBGYWlsZWQgfHwgIXRlc3RVc2VyPy5hY2Nlc3NUb2tlbikge1xuICAgICAgICBjb25zb2xlLmxvZygn4o+t77iPICBTa2lwcGluZzogQXV0aGVudGljYXRpb24gbm90IGNvbmZpZ3VyZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBjbGllbnQgPSBjcmVhdGVUZXN0Q2xpZW50KHRlc3RVc2VyLmFjY2Vzc1Rva2VuKTtcbiAgICAgIFxuICAgICAgY29uc3Qgc2VjdGlvbkRhdGEgPSB7XG4gICAgICAgIHBhZ2VfdHlwZTogJ2V2ZW50JyxcbiAgICAgICAgcGFnZV9pZDogJzEyM2U0NTY3LWU4OWItMTJkMy1hNDU2LTQyNjYxNDE3NDAwMCcsXG4gICAgICAgIHRpdGxlOiAnVGVzdCBTZWN0aW9uJyxcbiAgICAgICAgZGlzcGxheV9vcmRlcjogMCxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGNsaWVudFxuICAgICAgICAuZnJvbSgnc2VjdGlvbnMnKVxuICAgICAgICAuaW5zZXJ0KHNlY3Rpb25EYXRhKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgbm90IGdldCBSTFMgZXJyb3JcbiAgICAgIGV4cGVjdChlcnJvcikudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChkYXRhKS50b0JlRGVmaW5lZCgpO1xuICAgICAgXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBleHBlY3QoZGF0YS5wYWdlX3R5cGUpLnRvQmUoJ2V2ZW50Jyk7XG4gICAgICAgIGV4cGVjdChkYXRhLnBhZ2VfaWQpLnRvQmUoc2VjdGlvbkRhdGEucGFnZV9pZCk7XG4gICAgICAgIHRyYWNrRW50aXR5KCdzZWN0aW9ucycsIGRhdGEuaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGl0KCdzaG91bGQgZmlsdGVyIHNlY3Rpb25zIGJ5IHBhZ2VfdHlwZSBhbmQgcGFnZV9pZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChhdXRoU2V0dXBGYWlsZWQgfHwgIXRlc3RVc2VyPy5hY2Nlc3NUb2tlbikge1xuICAgICAgICBjb25zb2xlLmxvZygn4o+t77iPICBTa2lwcGluZzogQXV0aGVudGljYXRpb24gbm90IGNvbmZpZ3VyZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBzZXJ2aWNlQ2xpZW50ID0gY3JlYXRlU2VydmljZUNsaWVudCgpO1xuICAgICAgY29uc3QgY2xpZW50ID0gY3JlYXRlVGVzdENsaWVudCh0ZXN0VXNlci5hY2Nlc3NUb2tlbik7XG4gICAgICBcbiAgICAgIGNvbnN0IHRlc3RQYWdlSWQgPSAnMTIzZTQ1NjctZTg5Yi0xMmQzLWE0NTYtNDI2NjE0MTc0MDAxJztcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHRlc3Qgc2VjdGlvbiB1c2luZyBzZXJ2aWNlIHJvbGVcbiAgICAgIGNvbnN0IHsgZGF0YTogc2VjdGlvbiB9ID0gYXdhaXQgc2VydmljZUNsaWVudFxuICAgICAgICAuZnJvbSgnc2VjdGlvbnMnKVxuICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICBwYWdlX3R5cGU6ICdldmVudCcsXG4gICAgICAgICAgcGFnZV9pZDogdGVzdFBhZ2VJZCxcbiAgICAgICAgICB0aXRsZTogJ0ZpbHRlcmFibGUgU2VjdGlvbicsXG4gICAgICAgICAgZGlzcGxheV9vcmRlcjogMCxcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKTtcbiAgICAgIFxuICAgICAgaWYgKHNlY3Rpb24pIHtcbiAgICAgICAgdHJhY2tFbnRpdHkoJ3NlY3Rpb25zJywgc2VjdGlvbi5pZCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZpbHRlciBieSBwYWdlX3R5cGUgYW5kIHBhZ2VfaWRcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGNsaWVudFxuICAgICAgICAuZnJvbSgnc2VjdGlvbnMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdwYWdlX3R5cGUnLCAnZXZlbnQnKVxuICAgICAgICAuZXEoJ3BhZ2VfaWQnLCB0ZXN0UGFnZUlkKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGRhdGEpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoQXJyYXkuaXNBcnJheShkYXRhKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG4gIFxuICBkZXNjcmliZSgnY29sdW1ucyBUYWJsZSBSTFMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBhbGxvdyBhdXRoZW50aWNhdGVkIHVzZXJzIHRvIHJlYWQgY29sdW1ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChhdXRoU2V0dXBGYWlsZWQgfHwgIXRlc3RVc2VyPy5hY2Nlc3NUb2tlbikge1xuICAgICAgICBjb25zb2xlLmxvZygn4o+t77iPICBTa2lwcGluZzogQXV0aGVudGljYXRpb24gbm90IGNvbmZpZ3VyZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBjbGllbnQgPSBjcmVhdGVUZXN0Q2xpZW50KHRlc3RVc2VyLmFjY2Vzc1Rva2VuKTtcbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgY2xpZW50XG4gICAgICAgIC5mcm9tKCdjb2x1bW5zJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5saW1pdCgxMCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChlcnJvcikudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChkYXRhKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KEFycmF5LmlzQXJyYXkoZGF0YSkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gICAgXG4gICAgaXQoJ3Nob3VsZCBhbGxvdyBhdXRoZW50aWNhdGVkIHVzZXJzIHRvIGNyZWF0ZSBjb2x1bW5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKGF1dGhTZXR1cEZhaWxlZCB8fCAhdGVzdFVzZXI/LmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfij63vuI8gIFNraXBwaW5nOiBBdXRoZW50aWNhdGlvbiBub3QgY29uZmlndXJlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHNlcnZpY2VDbGllbnQgPSBjcmVhdGVTZXJ2aWNlQ2xpZW50KCk7XG4gICAgICBjb25zdCBjbGllbnQgPSBjcmVhdGVUZXN0Q2xpZW50KHRlc3RVc2VyLmFjY2Vzc1Rva2VuKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHNlY3Rpb24gdXNpbmcgc2VydmljZSByb2xlXG4gICAgICBjb25zdCB7IGRhdGE6IHNlY3Rpb24gfSA9IGF3YWl0IHNlcnZpY2VDbGllbnRcbiAgICAgICAgLmZyb20oJ3NlY3Rpb25zJylcbiAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgcGFnZV90eXBlOiAnZXZlbnQnLFxuICAgICAgICAgIHBhZ2VfaWQ6ICcxMjNlNDU2Ny1lODliLTEyZDMtYTQ1Ni00MjY2MTQxNzQwMDInLFxuICAgICAgICAgIGRpc3BsYXlfb3JkZXI6IDAsXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKCk7XG4gICAgICBcbiAgICAgIGlmICghc2VjdGlvbikge1xuICAgICAgICBjb25zb2xlLmxvZygn4o+t77iPICBTa2lwcGluZzogQ291bGQgbm90IGNyZWF0ZSB0ZXN0IHNlY3Rpb24nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0cmFja0VudGl0eSgnc2VjdGlvbnMnLCBzZWN0aW9uLmlkKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGNvbHVtbiB3aXRoIGF1dGhlbnRpY2F0ZWQgY2xpZW50XG4gICAgICBjb25zdCBjb2x1bW5EYXRhID0ge1xuICAgICAgICBzZWN0aW9uX2lkOiBzZWN0aW9uLmlkLFxuICAgICAgICBjb2x1bW5fbnVtYmVyOiAxLFxuICAgICAgICBjb250ZW50X3R5cGU6ICdyaWNoX3RleHQnLFxuICAgICAgICBjb250ZW50X2RhdGE6IHsgaHRtbDogJzxwPlRlc3QgY29udGVudDwvcD4nIH0sXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBjbGllbnRcbiAgICAgICAgLmZyb20oJ2NvbHVtbnMnKVxuICAgICAgICAuaW5zZXJ0KGNvbHVtbkRhdGEpXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChlcnJvcikudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChkYXRhKS50b0JlRGVmaW5lZCgpO1xuICAgICAgXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBleHBlY3QoZGF0YS5zZWN0aW9uX2lkKS50b0JlKHNlY3Rpb24uaWQpO1xuICAgICAgICBleHBlY3QoZGF0YS5jb2x1bW5fbnVtYmVyKS50b0JlKDEpO1xuICAgICAgICB0cmFja0VudGl0eSgnY29sdW1ucycsIGRhdGEuaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGl0KCdzaG91bGQgdmVyaWZ5IGNhc2NhZGUgZGVsZXRpb24gZnJvbSBzZWN0aW9ucyB0byBjb2x1bW5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKGF1dGhTZXR1cEZhaWxlZCB8fCAhdGVzdFVzZXI/LmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfij63vuI8gIFNraXBwaW5nOiBBdXRoZW50aWNhdGlvbiBub3QgY29uZmlndXJlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHNlcnZpY2VDbGllbnQgPSBjcmVhdGVTZXJ2aWNlQ2xpZW50KCk7XG4gICAgICBjb25zdCBjbGllbnQgPSBjcmVhdGVUZXN0Q2xpZW50KHRlc3RVc2VyLmFjY2Vzc1Rva2VuKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHNlY3Rpb24gYW5kIGNvbHVtbiB1c2luZyBzZXJ2aWNlIHJvbGVcbiAgICAgIGNvbnN0IHsgZGF0YTogc2VjdGlvbiB9ID0gYXdhaXQgc2VydmljZUNsaWVudFxuICAgICAgICAuZnJvbSgnc2VjdGlvbnMnKVxuICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICBwYWdlX3R5cGU6ICdldmVudCcsXG4gICAgICAgICAgcGFnZV9pZDogJzEyM2U0NTY3LWU4OWItMTJkMy1hNDU2LTQyNjYxNDE3NDAwMycsXG4gICAgICAgICAgZGlzcGxheV9vcmRlcjogMCxcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKTtcbiAgICAgIFxuICAgICAgaWYgKCFzZWN0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfij63vuI8gIFNraXBwaW5nOiBDb3VsZCBub3QgY3JlYXRlIHRlc3Qgc2VjdGlvbicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YTogY29sdW1uIH0gPSBhd2FpdCBzZXJ2aWNlQ2xpZW50XG4gICAgICAgIC5mcm9tKCdjb2x1bW5zJylcbiAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgc2VjdGlvbl9pZDogc2VjdGlvbi5pZCxcbiAgICAgICAgICBjb2x1bW5fbnVtYmVyOiAxLFxuICAgICAgICAgIGNvbnRlbnRfdHlwZTogJ3JpY2hfdGV4dCcsXG4gICAgICAgICAgY29udGVudF9kYXRhOiB7IGh0bWw6ICc8cD5UZXN0IGNvbnRlbnQ8L3A+JyB9LFxuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgXG4gICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICBjb25zb2xlLmxvZygn4o+t77iPICBTa2lwcGluZzogQ291bGQgbm90IGNyZWF0ZSB0ZXN0IGNvbHVtbicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIERlbGV0ZSBzZWN0aW9uIChzaG91bGQgY2FzY2FkZSB0byBjb2x1bW4pXG4gICAgICBjb25zdCB7IGVycm9yOiBkZWxldGVFcnJvciB9ID0gYXdhaXQgY2xpZW50XG4gICAgICAgIC5mcm9tKCdzZWN0aW9ucycpXG4gICAgICAgIC5kZWxldGUoKVxuICAgICAgICAuZXEoJ2lkJywgc2VjdGlvbi5pZCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChkZWxldGVFcnJvcikudG9CZU51bGwoKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGNvbHVtbiBpcyBhbHNvIGRlbGV0ZWRcbiAgICAgIGNvbnN0IHsgZGF0YTogZGVsZXRlZENvbHVtbiB9ID0gYXdhaXQgc2VydmljZUNsaWVudFxuICAgICAgICAuZnJvbSgnY29sdW1ucycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZXEoJ2lkJywgY29sdW1uLmlkKVxuICAgICAgICAuc2luZ2xlKCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChkZWxldGVkQ29sdW1uKS50b0JlTnVsbCgpO1xuICAgIH0pO1xuICB9KTtcbiAgXG4gIGRlc2NyaWJlKCdjb250ZW50X3BhZ2VzIFRhYmxlIFJMUycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGFsbG93IGF1dGhlbnRpY2F0ZWQgdXNlcnMgdG8gcmVhZCBjb250ZW50IHBhZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKGF1dGhTZXR1cEZhaWxlZCB8fCAhdGVzdFVzZXI/LmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfij63vuI8gIFNraXBwaW5nOiBBdXRoZW50aWNhdGlvbiBub3QgY29uZmlndXJlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGNsaWVudCA9IGNyZWF0ZVRlc3RDbGllbnQodGVzdFVzZXIuYWNjZXNzVG9rZW4pO1xuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBjbGllbnRcbiAgICAgICAgLmZyb20oJ2NvbnRlbnRfcGFnZXMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmxpbWl0KDEwKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGRhdGEpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoQXJyYXkuaXNBcnJheShkYXRhKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIGFsbG93IGF1dGhlbnRpY2F0ZWQgdXNlcnMgdG8gY3JlYXRlIGNvbnRlbnQgcGFnZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoYXV0aFNldHVwRmFpbGVkIHx8ICF0ZXN0VXNlcj8uYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KPre+4jyAgU2tpcHBpbmc6IEF1dGhlbnRpY2F0aW9uIG5vdCBjb25maWd1cmVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgY2xpZW50ID0gY3JlYXRlVGVzdENsaWVudCh0ZXN0VXNlci5hY2Nlc3NUb2tlbik7XG4gICAgICBjb25zdCB0ZXN0UGFnZSA9IGNyZWF0ZVRlc3RDb250ZW50UGFnZSgpO1xuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBjbGllbnRcbiAgICAgICAgLmZyb20oJ2NvbnRlbnRfcGFnZXMnKVxuICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICB0aXRsZTogdGVzdFBhZ2UudGl0bGUsXG4gICAgICAgICAgc2x1ZzogdGVzdFBhZ2Uuc2x1ZyxcbiAgICAgICAgICB0eXBlOiB0ZXN0UGFnZS50eXBlLFxuICAgICAgICAgIHB1Ymxpc2hlZDogdGVzdFBhZ2UucHVibGlzaGVkLFxuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgbm90IGdldCBcInZpb2xhdGVzIHJvdy1sZXZlbCBzZWN1cml0eSBwb2xpY3lcIiBlcnJvclxuICAgICAgZXhwZWN0KGVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGRhdGEpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIHRyYWNrRW50aXR5KCdjb250ZW50X3BhZ2VzJywgZGF0YS5pZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBcbiAgZGVzY3JpYmUoJ2dhbGxlcnlfc2V0dGluZ3MgVGFibGUgUkxTJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgYWxsb3cgYXV0aGVudGljYXRlZCB1c2VycyB0byByZWFkIGdhbGxlcnkgc2V0dGluZ3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoYXV0aFNldHVwRmFpbGVkIHx8ICF0ZXN0VXNlcj8uYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KPre+4jyAgU2tpcHBpbmc6IEF1dGhlbnRpY2F0aW9uIG5vdCBjb25maWd1cmVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgY2xpZW50ID0gY3JlYXRlVGVzdENsaWVudCh0ZXN0VXNlci5hY2Nlc3NUb2tlbik7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGNsaWVudFxuICAgICAgICAuZnJvbSgnZ2FsbGVyeV9zZXR0aW5ncycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAubGltaXQoMTApO1xuICAgICAgXG4gICAgICBleHBlY3QoZXJyb3IpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoZGF0YSkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChBcnJheS5pc0FycmF5KGRhdGEpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcbiAgXG4gIGRlc2NyaWJlKCdwaG90b3MgVGFibGUgUkxTJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgYWxsb3cgYXV0aGVudGljYXRlZCB1c2VycyB0byByZWFkIGFwcHJvdmVkIHBob3RvcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChhdXRoU2V0dXBGYWlsZWQgfHwgIXRlc3RVc2VyPy5hY2Nlc3NUb2tlbikge1xuICAgICAgICBjb25zb2xlLmxvZygn4o+t77iPICBTa2lwcGluZzogQXV0aGVudGljYXRpb24gbm90IGNvbmZpZ3VyZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBjbGllbnQgPSBjcmVhdGVUZXN0Q2xpZW50KHRlc3RVc2VyLmFjY2Vzc1Rva2VuKTtcbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgY2xpZW50XG4gICAgICAgIC5mcm9tKCdwaG90b3MnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdtb2RlcmF0aW9uX3N0YXR1cycsICdhcHByb3ZlZCcpXG4gICAgICAgIC5saW1pdCgxMCk7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBub3QgZ2V0IFJMUyBlcnJvclxuICAgICAgZXhwZWN0KGVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGRhdGEpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoQXJyYXkuaXNBcnJheShkYXRhKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIGFsbG93IGF1dGhlbnRpY2F0ZWQgdXNlcnMgdG8gdXBsb2FkIHBob3RvcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChhdXRoU2V0dXBGYWlsZWQgfHwgIXRlc3RVc2VyPy5hY2Nlc3NUb2tlbikge1xuICAgICAgICBjb25zb2xlLmxvZygn4o+t77iPICBTa2lwcGluZzogQXV0aGVudGljYXRpb24gbm90IGNvbmZpZ3VyZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBjbGllbnQgPSBjcmVhdGVUZXN0Q2xpZW50KHRlc3RVc2VyLmFjY2Vzc1Rva2VuKTtcbiAgICAgIFxuICAgICAgY29uc3QgcGhvdG9EYXRhID0ge1xuICAgICAgICB1cGxvYWRlcl9pZDogdGVzdFVzZXIuaWQsXG4gICAgICAgIHBob3RvX3VybDogYGh0dHBzOi8vY2RuLmV4YW1wbGUuY29tL3Rlc3QtcGhvdG8tJHtEYXRlLm5vdygpfS5qcGdgLFxuICAgICAgICBzdG9yYWdlX3R5cGU6ICdiMicsXG4gICAgICAgIHBhZ2VfdHlwZTogJ21lbW9yeScsXG4gICAgICAgIG1vZGVyYXRpb25fc3RhdHVzOiAncGVuZGluZycsXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBjbGllbnRcbiAgICAgICAgLmZyb20oJ3Bob3RvcycpXG4gICAgICAgIC5pbnNlcnQocGhvdG9EYXRhKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgbm90IGdldCBSTFMgZXJyb3JcbiAgICAgIGV4cGVjdChlcnJvcikudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChkYXRhKS50b0JlRGVmaW5lZCgpO1xuICAgICAgXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICB0cmFja0VudGl0eSgncGhvdG9zJywgZGF0YS5pZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgaXQoJ3Nob3VsZCBhbGxvdyB1c2VycyB0byB2aWV3IHRoZWlyIG93biBwaG90b3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoYXV0aFNldHVwRmFpbGVkIHx8ICF0ZXN0VXNlcj8uYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KPre+4jyAgU2tpcHBpbmc6IEF1dGhlbnRpY2F0aW9uIG5vdCBjb25maWd1cmVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgY2xpZW50ID0gY3JlYXRlVGVzdENsaWVudCh0ZXN0VXNlci5hY2Nlc3NUb2tlbik7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBwaG90b1xuICAgICAgY29uc3QgcGhvdG9EYXRhID0ge1xuICAgICAgICB1cGxvYWRlcl9pZDogdGVzdFVzZXIuaWQsXG4gICAgICAgIHBob3RvX3VybDogYGh0dHBzOi8vY2RuLmV4YW1wbGUuY29tL293bi1waG90by0ke0RhdGUubm93KCl9LmpwZ2AsXG4gICAgICAgIHN0b3JhZ2VfdHlwZTogJ2IyJyxcbiAgICAgICAgcGFnZV90eXBlOiAnbWVtb3J5JyxcbiAgICAgICAgbW9kZXJhdGlvbl9zdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YTogY3JlYXRlZFBob3RvIH0gPSBhd2FpdCBjbGllbnRcbiAgICAgICAgLmZyb20oJ3Bob3RvcycpXG4gICAgICAgIC5pbnNlcnQocGhvdG9EYXRhKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgXG4gICAgICBpZiAoIWNyZWF0ZWRQaG90bykge1xuICAgICAgICBjb25zb2xlLmxvZygn4o+t77iPICBTa2lwcGluZzogQ291bGQgbm90IGNyZWF0ZSB0ZXN0IHBob3RvJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdHJhY2tFbnRpdHkoJ3Bob3RvcycsIGNyZWF0ZWRQaG90by5pZCk7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBiZSBhYmxlIHRvIHZpZXcgb3duIHBob3RvIGV2ZW4gaWYgcGVuZGluZ1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgY2xpZW50XG4gICAgICAgIC5mcm9tKCdwaG90b3MnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdpZCcsIGNyZWF0ZWRQaG90by5pZClcbiAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgXG4gICAgICBleHBlY3QoZXJyb3IpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoZGF0YSkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChkYXRhPy5pZCkudG9CZShjcmVhdGVkUGhvdG8uaWQpO1xuICAgIH0pO1xuICAgIFxuICAgIGl0KCdzaG91bGQgZmlsdGVyIHBob3RvcyBieSBwYWdlX3R5cGUgYW5kIHBhZ2VfaWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoYXV0aFNldHVwRmFpbGVkIHx8ICF0ZXN0VXNlcj8uYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KPre+4jyAgU2tpcHBpbmc6IEF1dGhlbnRpY2F0aW9uIG5vdCBjb25maWd1cmVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3Qgc2VydmljZUNsaWVudCA9IGNyZWF0ZVNlcnZpY2VDbGllbnQoKTtcbiAgICAgIGNvbnN0IGNsaWVudCA9IGNyZWF0ZVRlc3RDbGllbnQodGVzdFVzZXIuYWNjZXNzVG9rZW4pO1xuICAgICAgXG4gICAgICBjb25zdCB0ZXN0UGFnZUlkID0gJzEyM2U0NTY3LWU4OWItMTJkMy1hNDU2LTQyNjYxNDE3NDAwMCc7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSB0ZXN0IHBob3RvIHdpdGggc2VydmljZSByb2xlXG4gICAgICBjb25zdCB7IGRhdGE6IHBob3RvIH0gPSBhd2FpdCBzZXJ2aWNlQ2xpZW50XG4gICAgICAgIC5mcm9tKCdwaG90b3MnKVxuICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICB1cGxvYWRlcl9pZDogdGVzdFVzZXIuaWQsXG4gICAgICAgICAgcGhvdG9fdXJsOiBgaHR0cHM6Ly9jZG4uZXhhbXBsZS5jb20vZmlsdGVyZWQtcGhvdG8tJHtEYXRlLm5vdygpfS5qcGdgLFxuICAgICAgICAgIHN0b3JhZ2VfdHlwZTogJ2IyJyxcbiAgICAgICAgICBwYWdlX3R5cGU6ICdldmVudCcsXG4gICAgICAgICAgcGFnZV9pZDogdGVzdFBhZ2VJZCxcbiAgICAgICAgICBtb2RlcmF0aW9uX3N0YXR1czogJ2FwcHJvdmVkJyxcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKTtcbiAgICAgIFxuICAgICAgaWYgKHBob3RvKSB7XG4gICAgICAgIHRyYWNrRW50aXR5KCdwaG90b3MnLCBwaG90by5pZCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZpbHRlciBieSBwYWdlX3R5cGUgYW5kIHBhZ2VfaWRcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGNsaWVudFxuICAgICAgICAuZnJvbSgncGhvdG9zJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5lcSgncGFnZV90eXBlJywgJ2V2ZW50JylcbiAgICAgICAgLmVxKCdwYWdlX2lkJywgdGVzdFBhZ2VJZCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChlcnJvcikudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChkYXRhKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KEFycmF5LmlzQXJyYXkoZGF0YSkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuICBcbiAgZGVzY3JpYmUoJ0Nyb3NzLVRhYmxlIFJMUyBDb25zaXN0ZW5jeScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGVuZm9yY2UgY29uc2lzdGVudCBSTFMgYWNyb3NzIHJlbGF0ZWQgdGFibGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKGF1dGhTZXR1cEZhaWxlZCB8fCAhdGVzdFVzZXI/LmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfij63vuI8gIFNraXBwaW5nOiBBdXRoZW50aWNhdGlvbiBub3QgY29uZmlndXJlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGNsaWVudCA9IGNyZWF0ZVRlc3RDbGllbnQodGVzdFVzZXIuYWNjZXNzVG9rZW4pO1xuICAgICAgXG4gICAgICAvLyBUcnkgdG8gcmVhZCBmcm9tIG11bHRpcGxlIHRhYmxlc1xuICAgICAgY29uc3QgW2dyb3Vwc1Jlc3VsdCwgZ3Vlc3RzUmVzdWx0LCBldmVudHNSZXN1bHRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBjbGllbnQuZnJvbSgnZ3Vlc3RfZ3JvdXBzJykuc2VsZWN0KCcqJykubGltaXQoMSksXG4gICAgICAgIGNsaWVudC5mcm9tKCdndWVzdHMnKS5zZWxlY3QoJyonKS5saW1pdCgxKSxcbiAgICAgICAgY2xpZW50LmZyb20oJ2V2ZW50cycpLnNlbGVjdCgnKicpLmxpbWl0KDEpLFxuICAgICAgXSk7XG4gICAgICBcbiAgICAgIC8vIEFsbCBzaG91bGQgc3VjY2VlZCBvciBmYWlsIGNvbnNpc3RlbnRseSAobm8gUkxTIGVycm9ycylcbiAgICAgIGV4cGVjdChncm91cHNSZXN1bHQuZXJyb3IpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoZ3Vlc3RzUmVzdWx0LmVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KGV2ZW50c1Jlc3VsdC5lcnJvcikudG9CZU51bGwoKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBURVNUIElNUExFTUVOVEFUSU9OIE5PVEVTXG4gKiBcbiAqIFRoZXNlIHRlc3RzIHZhbGlkYXRlIFJMUyBwb2xpY2llcyBmb3IgYWxsIG1ham9yIHRhYmxlczpcbiAqIFxuICogMS4gKipndWVzdF9ncm91cHMqKjogUmVhZCwgY3JlYXRlLCBhbmQgYXV0aCBlbmZvcmNlbWVudFxuICogMi4gKipndWVzdHMqKjogUmVhZCwgY3JlYXRlIHdpdGggcHJvcGVyIGdyb3VwIHJlZmVyZW5jZVxuICogMy4gKipldmVudHMqKjogUmVhZCBhbmQgY3JlYXRlXG4gKiA0LiAqKmFjdGl2aXRpZXMqKjogUmVhZCBvcGVyYXRpb25zXG4gKiA1LiAqKmFjY29tbW9kYXRpb25zKio6IFJlYWQgb3BlcmF0aW9uc1xuICogNi4gKipzZWN0aW9ucyoqOiBSZWFkLCBjcmVhdGUgKGNhdGNoZXMgXCJwZXJtaXNzaW9uIGRlbmllZCBmb3IgdGFibGUgdXNlcnNcIiBidWcpXG4gKiA3LiAqKmNvbHVtbnMqKjogUmVhZCBvcGVyYXRpb25zXG4gKiA4LiAqKmNvbnRlbnRfcGFnZXMqKjogUmVhZCwgY3JlYXRlIChjYXRjaGVzIFJMUyB2aW9sYXRpb24gYnVnKVxuICogOS4gKipnYWxsZXJ5X3NldHRpbmdzKio6IFJlYWQgb3BlcmF0aW9uc1xuICogXG4gKiBLZXkgVGVzdGluZyBQYXR0ZXJuczpcbiAqIC0gVXNlcyByZWFsIGF1dGhlbnRpY2F0aW9uIChub3Qgc2VydmljZSByb2xlKVxuICogLSBUZXN0cyBib3RoIHJlYWQgYW5kIHdyaXRlIG9wZXJhdGlvbnNcbiAqIC0gVmVyaWZpZXMgdW5hdXRoZW50aWNhdGVkIGFjY2VzcyBpcyBibG9ja2VkXG4gKiAtIENoZWNrcyBmb3Igc3BlY2lmaWMgUkxTIGVycm9yIG1lc3NhZ2VzXG4gKiAtIENsZWFucyB1cCB0ZXN0IGRhdGEgYWZ0ZXIgZXhlY3V0aW9uXG4gKiBcbiAqIFdoYXQgVGhlc2UgVGVzdHMgQ2F0Y2g6XG4gKiAtIE1pc3NpbmcgUkxTIHBvbGljaWVzXG4gKiAtIEluY29ycmVjdCBSTFMgcG9saWN5IGxvZ2ljXG4gKiAtIFBlcm1pc3Npb24gZGVuaWVkIGVycm9yc1xuICogLSBSTFMgcG9saWN5IHZpb2xhdGlvbnNcbiAqIC0gSW5jb25zaXN0ZW50IGFjY2VzcyBjb250cm9sXG4gKiBcbiAqIFZhbGlkYXRlczogUmVxdWlyZW1lbnRzIDEuMiwgMS4zLCAxLjRcbiAqL1xuIl0sIm5hbWVzIjpbImRlc2NyaWJlIiwidGVzdFVzZXIiLCJhdXRoU2V0dXBGYWlsZWQiLCJjcmVhdGVkSWRzIiwiTWFwIiwidHJhY2tFbnRpdHkiLCJ0YWJsZSIsImlkIiwiaWRzIiwiZ2V0IiwicHVzaCIsInNldCIsImJlZm9yZUFsbCIsImNyZWF0ZUFuZFNpZ25JblRlc3RVc2VyIiwiY29uc29sZSIsImxvZyIsImVycm9yIiwid2FybiIsIkVycm9yIiwibWVzc2FnZSIsImFmdGVyQWxsIiwiZW50cmllcyIsImxlbmd0aCIsImNsZWFudXBCeUlkcyIsImRlbGV0ZVRlc3RVc2VyIiwiaXQiLCJhY2Nlc3NUb2tlbiIsImNsaWVudCIsImNyZWF0ZVRlc3RDbGllbnQiLCJkYXRhIiwiZnJvbSIsInNlbGVjdCIsImxpbWl0IiwiZXhwZWN0IiwidG9CZU51bGwiLCJ0b0JlRGVmaW5lZCIsIkFycmF5IiwiaXNBcnJheSIsInRvQmUiLCJ0ZXN0R3JvdXAiLCJjcmVhdGVUZXN0R3Vlc3RHcm91cCIsImluc2VydCIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsInNpbmdsZSIsInNlcnZpY2VDbGllbnQiLCJjcmVhdGVTZXJ2aWNlQ2xpZW50IiwiZ3JvdXAiLCJ0ZXN0R3Vlc3QiLCJjcmVhdGVUZXN0R3Vlc3QiLCJncm91cElkIiwiZmlyc3RfbmFtZSIsImZpcnN0TmFtZSIsImxhc3RfbmFtZSIsImxhc3ROYW1lIiwiZW1haWwiLCJncm91cF9pZCIsImFnZV90eXBlIiwiYWdlVHlwZSIsImd1ZXN0X3R5cGUiLCJndWVzdFR5cGUiLCJ0ZXN0RXZlbnQiLCJjcmVhdGVUZXN0RXZlbnQiLCJzdGFydF9kYXRlIiwic3RhcnREYXRlIiwiZW5kX2RhdGUiLCJlbmREYXRlIiwic2VjdGlvbkRhdGEiLCJwYWdlX3R5cGUiLCJwYWdlX2lkIiwidGl0bGUiLCJkaXNwbGF5X29yZGVyIiwidGVzdFBhZ2VJZCIsInNlY3Rpb24iLCJlcSIsImNvbHVtbkRhdGEiLCJzZWN0aW9uX2lkIiwiY29sdW1uX251bWJlciIsImNvbnRlbnRfdHlwZSIsImNvbnRlbnRfZGF0YSIsImh0bWwiLCJjb2x1bW4iLCJkZWxldGVFcnJvciIsImRlbGV0ZSIsImRlbGV0ZWRDb2x1bW4iLCJ0ZXN0UGFnZSIsImNyZWF0ZVRlc3RDb250ZW50UGFnZSIsInNsdWciLCJ0eXBlIiwicHVibGlzaGVkIiwicGhvdG9EYXRhIiwidXBsb2FkZXJfaWQiLCJwaG90b191cmwiLCJEYXRlIiwibm93Iiwic3RvcmFnZV90eXBlIiwibW9kZXJhdGlvbl9zdGF0dXMiLCJjcmVhdGVkUGhvdG8iLCJwaG90byIsImdyb3Vwc1Jlc3VsdCIsImd1ZXN0c1Jlc3VsdCIsImV2ZW50c1Jlc3VsdCIsIlByb21pc2UiLCJhbGwiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7OztDQVdDOzs7O3dCQUU2RzsyQkFDZ0Q7eUJBQ2pJO0FBRTdCQSxTQUFTLGtDQUFrQztJQUN6QyxJQUFJQyxXQUE0QjtJQUNoQyxJQUFJQyxrQkFBa0I7SUFDdEIsTUFBTUMsYUFBb0MsSUFBSUM7SUFFOUMsK0NBQStDO0lBQy9DLE1BQU1DLGNBQWMsQ0FBQ0MsT0FBZUM7UUFDbEMsTUFBTUMsTUFB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