{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/services/eventSchedulingConflict.property.test.ts"],"sourcesContent":["import * as fc from 'fast-check';\nimport { checkSchedulingConflicts } from './eventService';\nimport { createClient } from '@supabase/supabase-js';\n\n/**\n * Property-Based Test: Event Scheduling Conflict Detection\n * \n * Feature: destination-wedding-platform\n * Property 8: Event Scheduling Conflict Detection\n * Validates: Requirements 6.3\n * \n * This test validates that the system correctly detects scheduling conflicts\n * when events overlap at the same location.\n * \n * Property: For any two events at the same location, if their time ranges overlap,\n * the system SHALL detect a conflict.\n * \n * Overlap condition: (StartA <= EndB) AND (EndA >= StartB)\n */\n\n// Mock Supabase\njest.mock('@supabase/supabase-js', () => ({\n  createClient: jest.fn(),\n}));\n\ndescribe('Feature: destination-wedding-platform, Property 8: Event Scheduling Conflict Detection', () => {\n  let mockSupabase: any;\n\n  beforeEach(() => {\n    mockSupabase = {\n      from: jest.fn().mockReturnThis(),\n      select: jest.fn().mockReturnThis(),\n      eq: jest.fn().mockReturnThis(),\n      neq: jest.fn().mockReturnThis(),\n    };\n    (createClient as jest.Mock).mockReturnValue(mockSupabase);\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  /**\n   * Arbitrary for generating valid date ranges\n   */\n  const dateRangeArbitrary = fc.record({\n    startDate: fc.date({ min: new Date('2025-01-01'), max: new Date('2025-12-31') }),\n    durationHours: fc.integer({ min: 1, max: 8 }),\n  }).map(({ startDate, durationHours }) => {\n    const endDate = new Date(startDate.getTime() + durationHours * 60 * 60 * 1000);\n    return {\n      startDate: startDate.toISOString(),\n      endDate: endDate.toISOString(),\n    };\n  });\n\n  /**\n   * Arbitrary for generating overlapping events\n   * Two events overlap if: (StartA <= EndB) AND (EndA >= StartB)\n   */\n  const overlappingEventsArbitrary = fc.tuple(\n    dateRangeArbitrary,\n    fc.integer({ min: 1, max: 4 }) // Overlap duration in hours\n  ).map(([event1, overlapHours]) => {\n    const event1Start = new Date(event1.startDate);\n    const event1End = new Date(event1.endDate);\n    const event1Duration = (event1End.getTime() - event1Start.getTime()) / (60 * 60 * 1000);\n    \n    // Create event2 that starts before event1 ends (ensuring overlap)\n    // Start event2 somewhere in the middle of event1\n    const offsetHours = Math.min(overlapHours, event1Duration - 0.5);\n    const event2Start = new Date(event1Start.getTime() + offsetHours * 60 * 60 * 1000);\n    \n    // Event2 ends after it starts, ensuring it overlaps with event1\n    const event2End = new Date(event2Start.getTime() + overlapHours * 60 * 60 * 1000);\n    \n    return {\n      event1: {\n        startDate: event1.startDate,\n        endDate: event1.endDate,\n      },\n      event2: {\n        startDate: event2Start.toISOString(),\n        endDate: event2End.toISOString(),\n      },\n    };\n  });\n\n  /**\n   * Arbitrary for generating non-overlapping events\n   */\n  const nonOverlappingEventsArbitrary = fc.tuple(\n    dateRangeArbitrary,\n    fc.integer({ min: 9, max: 24 }) // Gap in hours (at least 9 hours apart)\n  ).map(([event1, gapHours]) => {\n    const event1End = new Date(event1.endDate);\n    \n    // Create event2 that starts after event1 ends\n    const event2Start = new Date(event1End.getTime() + gapHours * 60 * 60 * 1000);\n    const event2End = new Date(event2Start.getTime() + 2 * 60 * 60 * 1000); // 2 hour duration\n    \n    return {\n      event1: {\n        startDate: event1.startDate,\n        endDate: event1.endDate,\n      },\n      event2: {\n        startDate: event2Start.toISOString(),\n        endDate: event2End.toISOString(),\n      },\n    };\n  });\n\n  it('should detect conflicts when events overlap at the same location', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        overlappingEventsArbitrary,\n        fc.uuid(),\n        async ({ event1, event2 }, locationId) => {\n          // Setup: Mock existing event at location\n          mockSupabase.from.mockReturnValue({\n            select: jest.fn().mockReturnValue({\n              eq: jest.fn().mockReturnValue({\n                data: [\n                  {\n                    id: 'existing-event-id',\n                    name: 'Existing Event',\n                    start_date: event1.startDate,\n                    end_date: event1.endDate,\n                  },\n                ],\n                error: null,\n              }),\n            }),\n          });\n\n          // Act: Check for conflicts with overlapping event\n          const result = await checkSchedulingConflicts({\n            locationId,\n            startDate: event2.startDate,\n            endDate: event2.endDate,\n          });\n\n          // Assert: Should detect conflict\n          expect(result.success).toBe(true);\n          if (result.success) {\n            expect(result.data.hasConflict).toBe(true);\n            expect(result.data.conflictingEvents).toHaveLength(1);\n            expect(result.data.conflictingEvents[0].id).toBe('existing-event-id');\n          }\n        }\n      ),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should not detect conflicts when events do not overlap at the same location', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        nonOverlappingEventsArbitrary,\n        fc.uuid(),\n        async ({ event1, event2 }, locationId) => {\n          // Setup: Mock existing event at location\n          mockSupabase.from.mockReturnValue({\n            select: jest.fn().mockReturnValue({\n              eq: jest.fn().mockReturnValue({\n                data: [\n                  {\n                    id: 'existing-event-id',\n                    name: 'Existing Event',\n                    start_date: event1.startDate,\n                    end_date: event1.endDate,\n                  },\n                ],\n                error: null,\n              }),\n            }),\n          });\n\n          // Act: Check for conflicts with non-overlapping event\n          const result = await checkSchedulingConflicts({\n            locationId,\n            startDate: event2.startDate,\n            endDate: event2.endDate,\n          });\n\n          // Assert: Should not detect conflict\n          expect(result.success).toBe(true);\n          if (result.success) {\n            expect(result.data.hasConflict).toBe(false);\n            expect(result.data.conflictingEvents).toHaveLength(0);\n          }\n        }\n      ),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should not detect conflicts at different locations even if times overlap', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        overlappingEventsArbitrary,\n        fc.uuid(),\n        fc.uuid(),\n        async ({ event1, event2 }, locationId1, locationId2) => {\n          // Ensure different locations\n          fc.pre(locationId1 !== locationId2);\n\n          // Setup: Mock that returns empty array for location2 (no events at that location)\n          mockSupabase.from.mockReturnValue({\n            select: jest.fn().mockReturnValue({\n              eq: jest.fn().mockImplementation((field, value) => {\n                // Only return events if querying for locationId1\n                if (field === 'location_id' && value === locationId1) {\n                  return {\n                    data: [\n                      {\n                        id: 'existing-event-id',\n                        name: 'Existing Event',\n                        start_date: event1.startDate,\n                        end_date: event1.endDate,\n                      },\n                    ],\n                    error: null,\n                  };\n                }\n                // Return empty for locationId2\n                return {\n                  data: [],\n                  error: null,\n                };\n              }),\n            }),\n          });\n\n          // Act: Check for conflicts at location2 (different location)\n          const result = await checkSchedulingConflicts({\n            locationId: locationId2,\n            startDate: event2.startDate,\n            endDate: event2.endDate,\n          });\n\n          // Assert: Should not detect conflict (different location)\n          expect(result.success).toBe(true);\n          if (result.success) {\n            expect(result.data.hasConflict).toBe(false);\n          }\n        }\n      ),\n      { numRuns: 50 }\n    );\n  });\n\n  it('should exclude specified event when checking conflicts (for updates)', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        overlappingEventsArbitrary,\n        fc.uuid(),\n        fc.uuid(),\n        async ({ event1, event2 }, locationId, excludeEventId) => {\n          // Setup: Mock existing event at location (the one being updated)\n          mockSupabase.from.mockReturnValue({\n            select: jest.fn().mockReturnValue({\n              eq: jest.fn().mockReturnValue({\n                neq: jest.fn().mockReturnValue({\n                  data: [], // No other events after excluding this one\n                  error: null,\n                }),\n              }),\n            }),\n          });\n\n          // Act: Check for conflicts excluding the event being updated\n          const result = await checkSchedulingConflicts({\n            locationId,\n            startDate: event2.startDate,\n            endDate: event2.endDate,\n            excludeEventId,\n          });\n\n          // Assert: Should not detect conflict (excluded event)\n          expect(result.success).toBe(true);\n          if (result.success) {\n            expect(result.data.hasConflict).toBe(false);\n            expect(result.data.conflictingEvents).toHaveLength(0);\n          }\n        }\n      ),\n      { numRuns: 50 }\n    );\n  });\n\n  it('should handle events without end dates (single-point events)', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.date({ min: new Date('2025-01-01'), max: new Date('2025-12-31') }),\n        fc.uuid(),\n        async (eventDate, locationId) => {\n          const eventDateStr = eventDate.toISOString();\n\n          // Setup: Mock existing single-point event\n          mockSupabase.from.mockReturnValue({\n            select: jest.fn().mockReturnValue({\n              eq: jest.fn().mockReturnValue({\n                data: [\n                  {\n                    id: 'existing-event-id',\n                    name: 'Existing Event',\n                    start_date: eventDateStr,\n                    end_date: null, // Single-point event\n                  },\n                ],\n                error: null,\n              }),\n            }),\n          });\n\n          // Act: Check for conflicts with same time\n          const result = await checkSchedulingConflicts({\n            locationId,\n            startDate: eventDateStr,\n            endDate: null,\n          });\n\n          // Assert: Should detect conflict (same time)\n          expect(result.success).toBe(true);\n          if (result.success) {\n            expect(result.data.hasConflict).toBe(true);\n            expect(result.data.conflictingEvents).toHaveLength(1);\n          }\n        }\n      ),\n      { numRuns: 50 }\n    );\n  });\n\n  it('should detect conflicts when new event spans multiple existing events', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.date({ min: new Date('2025-01-01'), max: new Date('2025-12-31') }),\n        fc.uuid(),\n        async (baseDate, locationId) => {\n          const baseDateStr = baseDate.toISOString();\n          const event1End = new Date(baseDate.getTime() + 2 * 60 * 60 * 1000); // +2 hours\n          const event2Start = new Date(baseDate.getTime() + 4 * 60 * 60 * 1000); // +4 hours\n          const event2End = new Date(baseDate.getTime() + 6 * 60 * 60 * 1000); // +6 hours\n          \n          // New event spans from base to +7 hours (covers both events)\n          const newEventEnd = new Date(baseDate.getTime() + 7 * 60 * 60 * 1000);\n\n          // Setup: Mock two existing events\n          mockSupabase.from.mockReturnValue({\n            select: jest.fn().mockReturnValue({\n              eq: jest.fn().mockReturnValue({\n                data: [\n                  {\n                    id: 'event-1',\n                    name: 'Event 1',\n                    start_date: baseDateStr,\n                    end_date: event1End.toISOString(),\n                  },\n                  {\n                    id: 'event-2',\n                    name: 'Event 2',\n                    start_date: event2Start.toISOString(),\n                    end_date: event2End.toISOString(),\n                  },\n                ],\n                error: null,\n              }),\n            }),\n          });\n\n          // Act: Check for conflicts with spanning event\n          const result = await checkSchedulingConflicts({\n            locationId,\n            startDate: baseDateStr,\n            endDate: newEventEnd.toISOString(),\n          });\n\n          // Assert: Should detect conflicts with both events\n          expect(result.success).toBe(true);\n          if (result.success) {\n            expect(result.data.hasConflict).toBe(true);\n            expect(result.data.conflictingEvents.length).toBeGreaterThanOrEqual(1);\n          }\n        }\n      ),\n      { numRuns: 50 }\n    );\n  });\n});\n"],"names":["jest","mock","createClient","fn","describe","mockSupabase","beforeEach","from","mockReturnThis","select","eq","neq","mockReturnValue","afterEach","clearAllMocks","dateRangeArbitrary","fc","record","startDate","date","min","Date","max","durationHours","integer","map","endDate","getTime","toISOString","overlappingEventsArbitrary","tuple","event1","overlapHours","event1Start","event1End","event1Duration","offsetHours","Math","event2Start","event2End","event2","nonOverlappingEventsArbitrary","gapHours","it","assert","asyncProperty","uuid","locationId","data","id","name","start_date","end_date","error","result","checkSchedulingConflicts","expect","success","toBe","hasConflict","conflictingEvents","toHaveLength","numRuns","locationId1","locationId2","pre","mockImplementation","field","value","excludeEventId","eventDate","eventDateStr","baseDate","baseDateStr","newEventEnd","length","toBeGreaterThanOrEqual"],"mappings":"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"}