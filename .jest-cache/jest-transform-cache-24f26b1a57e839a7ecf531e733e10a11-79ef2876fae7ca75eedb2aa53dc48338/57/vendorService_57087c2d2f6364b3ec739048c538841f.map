{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/services/vendorService.ts"],"sourcesContent":["/**\n * Vendor Service\n * \n * Handles vendor management including CRUD operations, pricing models,\n * and payment tracking for wedding service providers.\n * \n * Requirements: 7.1, 7.3, 7.6, 8.1, 8.3\n */\n\nimport { createClient } from '@supabase/supabase-js';\nimport {\n  createVendorSchema,\n  updateVendorSchema,\n  vendorFilterSchema,\n  vendorSearchSchema,\n  recordPaymentSchema,\n  type CreateVendorDTO,\n  type UpdateVendorDTO,\n  type VendorFilterDTO,\n  type VendorSearchDTO,\n  type RecordPaymentDTO,\n  type Vendor,\n  type PaginatedVendors,\n  type VendorPaymentInfo,\n} from '../schemas/vendorSchemas';\nimport { sanitizeInput } from '../utils/sanitization';\n\n// Result type for consistent error handling\ntype Result<T> =\n  | { success: true; data: T }\n  | { success: false; error: { code: string; message: string; details?: unknown } };\n\n// Initialize Supabase client\nconst supabase = createClient(\n  process.env.NEXT_PUBLIC_SUPABASE_URL!,\n  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n);\n\n/**\n * Creates a new vendor in the system.\n * \n * @param data - Vendor data including name, category, pricing model, and contact info\n * @returns Result containing the created vendor or error details\n * \n * @example\n * const result = await vendorService.create({\n *   name: 'Costa Rica Photography',\n *   category: 'photography',\n *   pricingModel: 'flat_rate',\n *   baseCost: 2500,\n *   email: 'contact@crphoto.com',\n * });\n */\nexport async function create(data: CreateVendorDTO): Promise<Result<Vendor>> {\n  try {\n    // 1. Validate\n    const validation = createVendorSchema.safeParse(data);\n    if (!validation.success) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Validation failed',\n          details: validation.error.issues,\n        },\n      };\n    }\n\n    // 2. Sanitize user input\n    const sanitized = {\n      ...validation.data,\n      name: sanitizeInput(validation.data.name),\n      contactName: validation.data.contactName ? sanitizeInput(validation.data.contactName) : null,\n      notes: validation.data.notes ? sanitizeInput(validation.data.notes) : null,\n    };\n\n    // 3. Database operation\n    const { data: vendor, error } = await supabase\n      .from('vendors')\n      .insert({\n        name: sanitized.name,\n        category: sanitized.category,\n        contact_name: sanitized.contactName,\n        email: sanitized.email,\n        phone: sanitized.phone,\n        pricing_model: sanitized.pricingModel,\n        base_cost: sanitized.baseCost,\n        payment_status: sanitized.paymentStatus || 'unpaid',\n        amount_paid: sanitized.amountPaid || 0,\n        notes: sanitized.notes,\n      })\n      .select()\n      .single();\n\n    if (error) {\n      return {\n        success: false,\n        error: {\n          code: 'DATABASE_ERROR',\n          message: error.message,\n          details: error,\n        },\n      };\n    }\n\n    return {\n      success: true,\n      data: mapVendorFromDb(vendor),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error occurred',\n      },\n    };\n  }\n}\n\n/**\n * Retrieves a vendor by ID.\n * \n * @param id - Vendor UUID\n * @returns Result containing the vendor or error details\n */\nexport async function get(id: string): Promise<Result<Vendor>> {\n  try {\n    const { data: vendor, error } = await supabase\n      .from('vendors')\n      .select('*')\n      .eq('id', id)\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return {\n          success: false,\n          error: {\n            code: 'NOT_FOUND',\n            message: 'Vendor not found',\n          },\n        };\n      }\n      return {\n        success: false,\n        error: {\n          code: 'DATABASE_ERROR',\n          message: error.message,\n          details: error,\n        },\n      };\n    }\n\n    return {\n      success: true,\n      data: mapVendorFromDb(vendor),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error occurred',\n      },\n    };\n  }\n}\n\n/**\n * Updates an existing vendor.\n * \n * @param id - Vendor UUID\n * @param data - Partial vendor data to update\n * @returns Result containing the updated vendor or error details\n */\nexport async function update(id: string, data: UpdateVendorDTO): Promise<Result<Vendor>> {\n  try {\n    // 1. Validate\n    const validation = updateVendorSchema.safeParse(data);\n    if (!validation.success) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Validation failed',\n          details: validation.error.issues,\n        },\n      };\n    }\n\n    // 2. Sanitize user input\n    const sanitized: Record<string, unknown> = {};\n    if (validation.data.name !== undefined) {\n      sanitized.name = sanitizeInput(validation.data.name);\n    }\n    if (validation.data.contactName !== undefined) {\n      sanitized.contact_name = validation.data.contactName ? sanitizeInput(validation.data.contactName) : null;\n    }\n    if (validation.data.notes !== undefined) {\n      sanitized.notes = validation.data.notes ? sanitizeInput(validation.data.notes) : null;\n    }\n    if (validation.data.category !== undefined) {\n      sanitized.category = validation.data.category;\n    }\n    if (validation.data.email !== undefined) {\n      sanitized.email = validation.data.email;\n    }\n    if (validation.data.phone !== undefined) {\n      sanitized.phone = validation.data.phone;\n    }\n    if (validation.data.pricingModel !== undefined) {\n      sanitized.pricing_model = validation.data.pricingModel;\n    }\n    if (validation.data.baseCost !== undefined) {\n      sanitized.base_cost = validation.data.baseCost;\n    }\n    if (validation.data.paymentStatus !== undefined) {\n      sanitized.payment_status = validation.data.paymentStatus;\n    }\n    if (validation.data.amountPaid !== undefined) {\n      sanitized.amount_paid = validation.data.amountPaid;\n    }\n\n    // 3. Database operation\n    const { data: vendor, error } = await supabase\n      .from('vendors')\n      .update(sanitized)\n      .eq('id', id)\n      .select()\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return {\n          success: false,\n          error: {\n            code: 'NOT_FOUND',\n            message: 'Vendor not found',\n          },\n        };\n      }\n      return {\n        success: false,\n        error: {\n          code: 'DATABASE_ERROR',\n          message: error.message,\n          details: error,\n        },\n      };\n    }\n\n    return {\n      success: true,\n      data: mapVendorFromDb(vendor),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error occurred',\n      },\n    };\n  }\n}\n\n/**\n * Deletes a vendor from the system.\n * \n * @param id - Vendor UUID\n * @returns Result indicating success or error details\n */\nexport async function deleteVendor(id: string): Promise<Result<void>> {\n  try {\n    const { error } = await supabase\n      .from('vendors')\n      .delete()\n      .eq('id', id);\n\n    if (error) {\n      return {\n        success: false,\n        error: {\n          code: 'DATABASE_ERROR',\n          message: error.message,\n          details: error,\n        },\n      };\n    }\n\n    return { success: true, data: undefined };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error occurred',\n      },\n    };\n  }\n}\n\n/**\n * Lists vendors with optional filtering and pagination.\n * \n * @param filters - Optional filters for category, pricing model, payment status, and pagination\n * @returns Result containing paginated vendor list or error details\n */\nexport async function list(filters: VendorFilterDTO = {}): Promise<Result<PaginatedVendors>> {\n  try {\n    // Validate filters\n    const validation = vendorFilterSchema.safeParse(filters);\n    if (!validation.success) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Invalid filters',\n          details: validation.error.issues,\n        },\n      };\n    }\n\n    const { category, pricingModel, paymentStatus, page = 1, pageSize = 50 } = validation.data;\n\n    // Build query\n    let query = supabase.from('vendors').select('*', { count: 'exact' });\n\n    if (category) {\n      query = query.eq('category', category);\n    }\n    if (pricingModel) {\n      query = query.eq('pricing_model', pricingModel);\n    }\n    if (paymentStatus) {\n      query = query.eq('payment_status', paymentStatus);\n    }\n\n    // Apply pagination\n    const from = (page - 1) * pageSize;\n    const to = from + pageSize - 1;\n    query = query.range(from, to).order('name', { ascending: true });\n\n    const { data: vendors, error, count } = await query;\n\n    if (error) {\n      return {\n        success: false,\n        error: {\n          code: 'DATABASE_ERROR',\n          message: error.message,\n          details: error,\n        },\n      };\n    }\n\n    const total = count || 0;\n    const totalPages = Math.ceil(total / pageSize);\n\n    return {\n      success: true,\n      data: {\n        vendors: vendors.map(mapVendorFromDb),\n        total,\n        page,\n        pageSize,\n        totalPages,\n      },\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error occurred',\n      },\n    };\n  }\n}\n\n/**\n * Searches vendors by name or contact name.\n * \n * @param searchParams - Search query and pagination parameters\n * @returns Result containing paginated search results or error details\n */\nexport async function search(searchParams: VendorSearchDTO): Promise<Result<PaginatedVendors>> {\n  try {\n    // Validate search parameters\n    const validation = vendorSearchSchema.safeParse(searchParams);\n    if (!validation.success) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Invalid search parameters',\n          details: validation.error.issues,\n        },\n      };\n    }\n\n    const { query, page = 1, pageSize = 50 } = validation.data;\n\n    // Search in name and contact_name fields\n    const { data: vendors, error, count } = await supabase\n      .from('vendors')\n      .select('*', { count: 'exact' })\n      .or(`name.ilike.%${query}%,contact_name.ilike.%${query}%`)\n      .range((page - 1) * pageSize, page * pageSize - 1)\n      .order('name', { ascending: true });\n\n    if (error) {\n      return {\n        success: false,\n        error: {\n          code: 'DATABASE_ERROR',\n          message: error.message,\n          details: error,\n        },\n      };\n    }\n\n    const total = count || 0;\n    const totalPages = Math.ceil(total / pageSize);\n\n    return {\n      success: true,\n      data: {\n        vendors: vendors.map(mapVendorFromDb),\n        total,\n        page,\n        pageSize,\n        totalPages,\n      },\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error occurred',\n      },\n    };\n  }\n}\n\n/**\n * Records a payment for a vendor and updates payment status.\n * \n * @param paymentData - Vendor ID, payment amount, and optional notes\n * @returns Result containing updated vendor payment info or error details\n */\nexport async function recordPayment(paymentData: RecordPaymentDTO): Promise<Result<VendorPaymentInfo>> {\n  try {\n    // 1. Validate\n    const validation = recordPaymentSchema.safeParse(paymentData);\n    if (!validation.success) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Validation failed',\n          details: validation.error.issues,\n        },\n      };\n    }\n\n    const { vendorId, amount } = validation.data;\n\n    // 2. Get current vendor\n    const vendorResult = await get(vendorId);\n    if (!vendorResult.success) {\n      return vendorResult as Result<VendorPaymentInfo>;\n    }\n\n    const vendor = vendorResult.data;\n    const newAmountPaid = vendor.amountPaid + amount;\n\n    // Check if payment exceeds base cost (with floating point tolerance)\n    if (newAmountPaid - vendor.baseCost > 0.01) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Payment amount exceeds vendor base cost',\n          details: {\n            baseCost: vendor.baseCost,\n            currentPaid: vendor.amountPaid,\n            attemptedPayment: amount,\n            wouldTotal: newAmountPaid,\n          },\n        },\n      };\n    }\n\n    // 3. Calculate new payment status\n    let newPaymentStatus: 'unpaid' | 'partial' | 'paid';\n    if (newAmountPaid === 0) {\n      newPaymentStatus = 'unpaid';\n    } else if (newAmountPaid >= vendor.baseCost) {\n      newPaymentStatus = 'paid';\n    } else {\n      newPaymentStatus = 'partial';\n    }\n\n    // 4. Update vendor\n    const updateResult = await update(vendorId, {\n      amountPaid: newAmountPaid,\n      paymentStatus: newPaymentStatus,\n    });\n\n    if (!updateResult.success) {\n      return updateResult as Result<VendorPaymentInfo>;\n    }\n\n    const updatedVendor = updateResult.data;\n\n    return {\n      success: true,\n      data: {\n        vendorId: updatedVendor.id,\n        vendorName: updatedVendor.name,\n        baseCost: updatedVendor.baseCost,\n        amountPaid: updatedVendor.amountPaid,\n        balanceDue: updatedVendor.baseCost - updatedVendor.amountPaid,\n        paymentStatus: updatedVendor.paymentStatus,\n      },\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error occurred',\n      },\n    };\n  }\n}\n\n/**\n * Gets payment information for a vendor.\n * \n * @param vendorId - Vendor UUID\n * @returns Result containing vendor payment info or error details\n */\nexport async function getPaymentInfo(vendorId: string): Promise<Result<VendorPaymentInfo>> {\n  try {\n    const vendorResult = await get(vendorId);\n    if (!vendorResult.success) {\n      return vendorResult as Result<VendorPaymentInfo>;\n    }\n\n    const vendor = vendorResult.data;\n\n    return {\n      success: true,\n      data: {\n        vendorId: vendor.id,\n        vendorName: vendor.name,\n        baseCost: vendor.baseCost,\n        amountPaid: vendor.amountPaid,\n        balanceDue: vendor.baseCost - vendor.amountPaid,\n        paymentStatus: vendor.paymentStatus,\n      },\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error occurred',\n      },\n    };\n  }\n}\n\n/**\n * Maps database vendor record to Vendor type.\n */\nfunction mapVendorFromDb(dbVendor: any): Vendor {\n  return {\n    id: dbVendor.id,\n    name: dbVendor.name,\n    category: dbVendor.category,\n    contactName: dbVendor.contact_name,\n    email: dbVendor.email,\n    phone: dbVendor.phone,\n    pricingModel: dbVendor.pricing_model,\n    baseCost: parseFloat(dbVendor.base_cost),\n    paymentStatus: dbVendor.payment_status,\n    amountPaid: parseFloat(dbVendor.amount_paid),\n    notes: dbVendor.notes,\n    createdAt: dbVendor.created_at,\n    updatedAt: dbVendor.updated_at,\n  };\n}\n"],"names":["create","deleteVendor","get","getPaymentInfo","list","recordPayment","search","update","supabase","createClient","process","env","NEXT_PUBLIC_SUPABASE_URL","NEXT_PUBLIC_SUPABASE_ANON_KEY","data","validation","createVendorSchema","safeParse","success","error","code","message","details","issues","sanitized","name","sanitizeInput","contactName","notes","vendor","from","insert","category","contact_name","email","phone","pricing_model","pricingModel","base_cost","baseCost","payment_status","paymentStatus","amount_paid","amountPaid","select","single","mapVendorFromDb","Error","id","eq","updateVendorSchema","undefined","delete","filters","vendorFilterSchema","page","pageSize","query","count","to","range","order","ascending","vendors","total","totalPages","Math","ceil","map","searchParams","vendorSearchSchema","or","paymentData","recordPaymentSchema","vendorId","amount","vendorResult","newAmountPaid","currentPaid","attemptedPayment","wouldTotal","newPaymentStatus","updateResult","updatedVendor","vendorName","balanceDue","dbVendor","parseFloat","createdAt","created_at","updatedAt","updated_at"],"mappings":"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"}