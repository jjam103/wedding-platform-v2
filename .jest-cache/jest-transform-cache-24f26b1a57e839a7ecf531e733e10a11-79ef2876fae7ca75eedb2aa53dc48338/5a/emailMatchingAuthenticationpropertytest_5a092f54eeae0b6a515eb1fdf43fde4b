cf74b1c3e60dff9223f04a361ae7d8ba
"use strict";
/**
 * Property-Based Tests for Email Matching Authentication
 * 
 * Feature: destination-wedding-platform
 * Property 14: Email Matching Authentication
 * Validates: Requirements 5.2, 22.4
 * Task: 5.2
 */ // Mock dependencies
jest.mock('@/lib/supabase');
jest.mock('next/headers', ()=>({
        cookies: jest.fn().mockResolvedValue({
            set: jest.fn()
        })
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _route = require("../../app/api/auth/guest/email-match/route");
const _supabase = require("../../lib/supabase");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const mockSupabase = {
    from: jest.fn().mockReturnThis(),
    select: jest.fn().mockReturnThis(),
    eq: jest.fn().mockReturnThis(),
    single: jest.fn(),
    insert: jest.fn().mockReturnThis()
};
describe('Feature: destination-wedding-platform, Property 14: Email Matching Authentication', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        _supabase.createSupabaseClient.mockReturnValue(mockSupabase);
    });
    it('should authenticate any valid email that exists in guest database with email_matching auth method', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.emailAddress(), _fastcheck.uuid(), _fastcheck.uuid(), _fastcheck.string({
            minLength: 1,
            maxLength: 50
        }), _fastcheck.string({
            minLength: 1,
            maxLength: 50
        }), async (email, guestId, groupId, firstName, lastName)=>{
            // Arrange
            const mockGuest = {
                id: guestId,
                email: email.toLowerCase(),
                group_id: groupId,
                first_name: firstName,
                last_name: lastName,
                auth_method: 'email_matching'
            };
            mockSupabase.single.mockResolvedValueOnce({
                data: mockGuest,
                error: null
            }).mockResolvedValueOnce({
                data: {
                    id: 'session-id',
                    token: 'token'
                },
                error: null
            });
            mockSupabase.insert.mockResolvedValueOnce({
                data: null,
                error: null
            });
            const request = new Request('http://localhost:3000/api/auth/guest/email-match', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email
                })
            });
            // Act
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            // Assert
            expect(response.status).toBe(200);
            expect(data.success).toBe(true);
            expect(data.data.guestId).toBe(guestId);
            expect(data.data.groupId).toBe(groupId);
        }), {
            numRuns: 20
        } // Fewer runs for async tests
        );
    });
    it('should reject any email that does not exist in guest database', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.emailAddress(), async (email)=>{
            // Arrange
            mockSupabase.single.mockResolvedValueOnce({
                data: null,
                error: {
                    message: 'Not found'
                }
            });
            const request = new Request('http://localhost:3000/api/auth/guest/email-match', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email
                })
            });
            // Act
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            // Assert
            expect(response.status).toBe(404);
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('NOT_FOUND');
        }), {
            numRuns: 20
        });
    });
    it('should normalize email case before lookup', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.emailAddress(), _fastcheck.uuid(), async (email, guestId)=>{
            // Arrange
            const mockGuest = {
                id: guestId,
                email: email.toLowerCase(),
                group_id: 'group-id',
                first_name: 'Test',
                last_name: 'User',
                auth_method: 'email_matching'
            };
            mockSupabase.single.mockResolvedValueOnce({
                data: mockGuest,
                error: null
            }).mockResolvedValueOnce({
                data: {
                    id: 'session-id',
                    token: 'token'
                },
                error: null
            });
            mockSupabase.insert.mockResolvedValueOnce({
                data: null,
                error: null
            });
            // Test with various case combinations
            const emailVariations = [
                email.toLowerCase(),
                email.toUpperCase(),
                email.charAt(0).toUpperCase() + email.slice(1).toLowerCase()
            ];
            for (const emailVariation of emailVariations){
                const request = new Request('http://localhost:3000/api/auth/guest/email-match', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        email: emailVariation
                    })
                });
                // Act
                const response = await (0, _route.POST)(request);
                const data = await response.json();
                // Assert - All variations should work
                expect(response.status).toBe(200);
                expect(data.success).toBe(true);
            }
        }), {
            numRuns: 10
        });
    });
    it('should reject invalid email formats', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.oneof(_fastcheck.constant('not-an-email'), _fastcheck.constant('missing@domain'), _fastcheck.constant('@nodomain.com'), _fastcheck.constant('spaces in@email.com'), _fastcheck.constant(''), _fastcheck.string({
            minLength: 1,
            maxLength: 20
        }).filter((s)=>!s.includes('@'))), async (invalidEmail)=>{
            // Arrange
            const request = new Request('http://localhost:3000/api/auth/guest/email-match', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: invalidEmail
                })
            });
            // Act
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            // Assert
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('VALIDATION_ERROR');
        }), {
            numRuns: 20
        });
    });
    it('should create unique session tokens for each authentication', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.emailAddress(), _fastcheck.uuid(), async (email, guestId)=>{
            // Arrange
            const mockGuest = {
                id: guestId,
                email: email.toLowerCase(),
                group_id: 'group-id',
                first_name: 'Test',
                last_name: 'User',
                auth_method: 'email_matching'
            };
            const sessionTokens = new Set();
            // Authenticate multiple times
            for(let i = 0; i < 5; i++){
                mockSupabase.single.mockResolvedValueOnce({
                    data: mockGuest,
                    error: null
                }).mockResolvedValueOnce({
                    data: {
                        id: `session-${i}`,
                        token: `token-${i}`
                    },
                    error: null
                });
                mockSupabase.insert.mockResolvedValueOnce({
                    data: null,
                    error: null
                });
                const request = new Request('http://localhost:3000/api/auth/guest/email-match', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        email
                    })
                });
                await (0, _route.POST)(request);
                // Extract token from insert call
                const insertCall = mockSupabase.insert.mock.calls.find((call)=>mockSupabase.from.mock.calls.some((fromCall)=>fromCall[0] === 'guest_sessions'));
                if (insertCall && insertCall[0]?.token) {
                    sessionTokens.add(insertCall[0].token);
                }
            }
            // Assert - All tokens should be unique
            expect(sessionTokens.size).toBe(5);
        }), {
            numRuns: 5
        } // Fewer runs since we do 5 authentications per run
        );
    });
    it('should only authenticate guests with email_matching auth method', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.emailAddress(), _fastcheck.uuid(), _fastcheck.constantFrom('email_matching', 'magic_link'), async (email, guestId, authMethod)=>{
            // Arrange
            if (authMethod === 'email_matching') {
                const mockGuest = {
                    id: guestId,
                    email: email.toLowerCase(),
                    group_id: 'group-id',
                    first_name: 'Test',
                    last_name: 'User',
                    auth_method: 'email_matching'
                };
                mockSupabase.single.mockResolvedValueOnce({
                    data: mockGuest,
                    error: null
                }).mockResolvedValueOnce({
                    data: {
                        id: 'session-id',
                        token: 'token'
                    },
                    error: null
                });
                mockSupabase.insert.mockResolvedValueOnce({
                    data: null,
                    error: null
                });
            } else {
                // Guest with magic_link auth method should not be found
                mockSupabase.single.mockResolvedValueOnce({
                    data: null,
                    error: {
                        message: 'Not found'
                    }
                });
            }
            const request = new Request('http://localhost:3000/api/auth/guest/email-match', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email
                })
            });
            // Act
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            // Assert
            if (authMethod === 'email_matching') {
                expect(response.status).toBe(200);
                expect(data.success).toBe(true);
            } else {
                expect(response.status).toBe(404);
                expect(data.success).toBe(false);
                expect(data.error.code).toBe('NOT_FOUND');
            }
        }), {
            numRuns: 20
        });
    });
    it('should sanitize malicious email input', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.oneof(_fastcheck.constant('<script>alert("xss")</script>test@example.com'), _fastcheck.constant('test@example.com<img src=x onerror=alert(1)>'), _fastcheck.constant('javascript:alert(1)@example.com'), _fastcheck.constant('test@example.com"; DROP TABLE guests; --')), async (maliciousEmail)=>{
            // Arrange
            mockSupabase.single.mockResolvedValueOnce({
                data: null,
                error: {
                    message: 'Not found'
                }
            });
            const request = new Request('http://localhost:3000/api/auth/guest/email-match', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: maliciousEmail
                })
            });
            // Act
            await (0, _route.POST)(request);
            // Assert - Email should be sanitized before database query
            const emailArg = mockSupabase.eq.mock.calls.find((call)=>call[0] === 'email')?.[1];
            if (emailArg) {
                expect(emailArg).not.toContain('<script>');
                expect(emailArg).not.toContain('javascript:');
                expect(emailArg).not.toContain('DROP TABLE');
                expect(emailArg).not.toContain('onerror=');
            }
        }), {
            numRuns: 20
        });
    });
    it('should set session expiration to 24 hours from creation', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.emailAddress(), _fastcheck.uuid(), async (email, guestId)=>{
            // Arrange
            const mockGuest = {
                id: guestId,
                email: email.toLowerCase(),
                group_id: 'group-id',
                first_name: 'Test',
                last_name: 'User',
                auth_method: 'email_matching'
            };
            mockSupabase.single.mockResolvedValueOnce({
                data: mockGuest,
                error: null
            }).mockResolvedValueOnce({
                data: {
                    id: 'session-id',
                    token: 'token'
                },
                error: null
            });
            mockSupabase.insert.mockResolvedValueOnce({
                data: null,
                error: null
            });
            const beforeRequest = Date.now();
            const request = new Request('http://localhost:3000/api/auth/guest/email-match', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email
                })
            });
            // Act
            await (0, _route.POST)(request);
            const afterRequest = Date.now();
            // Assert - Session should expire 24 hours from now
            const insertCall = mockSupabase.insert.mock.calls.find((call)=>mockSupabase.from.mock.calls.some((fromCall)=>fromCall[0] === 'guest_sessions'));
            if (insertCall && insertCall[0]?.expires_at) {
                const expiresAt = new Date(insertCall[0].expires_at).getTime();
                const expectedMin = beforeRequest + 24 * 60 * 60 * 1000;
                const expectedMax = afterRequest + 24 * 60 * 60 * 1000;
                expect(expiresAt).toBeGreaterThanOrEqual(expectedMin);
                expect(expiresAt).toBeLessThanOrEqual(expectedMax);
            }
        }), {
            numRuns: 10
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvX190ZXN0c19fL3Byb3BlcnR5L2VtYWlsTWF0Y2hpbmdBdXRoZW50aWNhdGlvbi5wcm9wZXJ0eS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGZjIGZyb20gJ2Zhc3QtY2hlY2snO1xuaW1wb3J0IHsgUE9TVCB9IGZyb20gJ0AvYXBwL2FwaS9hdXRoL2d1ZXN0L2VtYWlsLW1hdGNoL3JvdXRlJztcbmltcG9ydCB7IGNyZWF0ZVN1cGFiYXNlQ2xpZW50IH0gZnJvbSAnQC9saWIvc3VwYWJhc2UnO1xuXG4vKipcbiAqIFByb3BlcnR5LUJhc2VkIFRlc3RzIGZvciBFbWFpbCBNYXRjaGluZyBBdXRoZW50aWNhdGlvblxuICogXG4gKiBGZWF0dXJlOiBkZXN0aW5hdGlvbi13ZWRkaW5nLXBsYXRmb3JtXG4gKiBQcm9wZXJ0eSAxNDogRW1haWwgTWF0Y2hpbmcgQXV0aGVudGljYXRpb25cbiAqIFZhbGlkYXRlczogUmVxdWlyZW1lbnRzIDUuMiwgMjIuNFxuICogVGFzazogNS4yXG4gKi9cblxuLy8gTW9jayBkZXBlbmRlbmNpZXNcbmplc3QubW9jaygnQC9saWIvc3VwYWJhc2UnKTtcbmplc3QubW9jaygnbmV4dC9oZWFkZXJzJywgKCkgPT4gKHtcbiAgY29va2llczogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICBzZXQ6IGplc3QuZm4oKSxcbiAgfSksXG59KSk7XG5cbmNvbnN0IG1vY2tTdXBhYmFzZSA9IHtcbiAgZnJvbTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgc2luZ2xlOiBqZXN0LmZuKCksXG4gIGluc2VydDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG59O1xuXG5kZXNjcmliZSgnRmVhdHVyZTogZGVzdGluYXRpb24td2VkZGluZy1wbGF0Zm9ybSwgUHJvcGVydHkgMTQ6IEVtYWlsIE1hdGNoaW5nIEF1dGhlbnRpY2F0aW9uJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICAoY3JlYXRlU3VwYWJhc2VDbGllbnQgYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBhdXRoZW50aWNhdGUgYW55IHZhbGlkIGVtYWlsIHRoYXQgZXhpc3RzIGluIGd1ZXN0IGRhdGFiYXNlIHdpdGggZW1haWxfbWF0Y2hpbmcgYXV0aCBtZXRob2QnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMuZW1haWxBZGRyZXNzKCksXG4gICAgICAgIGZjLnV1aWQoKSxcbiAgICAgICAgZmMudXVpZCgpLFxuICAgICAgICBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogNTAgfSksXG4gICAgICAgIGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1MCB9KSxcbiAgICAgICAgYXN5bmMgKGVtYWlsLCBndWVzdElkLCBncm91cElkLCBmaXJzdE5hbWUsIGxhc3ROYW1lKSA9PiB7XG4gICAgICAgICAgLy8gQXJyYW5nZVxuICAgICAgICAgIGNvbnN0IG1vY2tHdWVzdCA9IHtcbiAgICAgICAgICAgIGlkOiBndWVzdElkLFxuICAgICAgICAgICAgZW1haWw6IGVtYWlsLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBncm91cF9pZDogZ3JvdXBJZCxcbiAgICAgICAgICAgIGZpcnN0X25hbWU6IGZpcnN0TmFtZSxcbiAgICAgICAgICAgIGxhc3RfbmFtZTogbGFzdE5hbWUsXG4gICAgICAgICAgICBhdXRoX21ldGhvZDogJ2VtYWlsX21hdGNoaW5nJyxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgbW9ja1N1cGFiYXNlLnNpbmdsZVxuICAgICAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGRhdGE6IG1vY2tHdWVzdCwgZXJyb3I6IG51bGwgfSlcbiAgICAgICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBkYXRhOiB7IGlkOiAnc2Vzc2lvbi1pZCcsIHRva2VuOiAndG9rZW4nIH0sIGVycm9yOiBudWxsIH0pO1xuICAgICAgICAgIG1vY2tTdXBhYmFzZS5pbnNlcnQubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgZGF0YTogbnVsbCwgZXJyb3I6IG51bGwgfSk7XG5cbiAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYXV0aC9ndWVzdC9lbWFpbC1tYXRjaCcsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVtYWlsIH0pLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gQWN0XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgICAvLyBBc3NlcnRcbiAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgICAgICBleHBlY3QoZGF0YS5kYXRhLmd1ZXN0SWQpLnRvQmUoZ3Vlc3RJZCk7XG4gICAgICAgICAgZXhwZWN0KGRhdGEuZGF0YS5ncm91cElkKS50b0JlKGdyb3VwSWQpO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAyMCB9IC8vIEZld2VyIHJ1bnMgZm9yIGFzeW5jIHRlc3RzXG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCByZWplY3QgYW55IGVtYWlsIHRoYXQgZG9lcyBub3QgZXhpc3QgaW4gZ3Vlc3QgZGF0YWJhc2UnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShmYy5lbWFpbEFkZHJlc3MoKSwgYXN5bmMgKGVtYWlsKSA9PiB7XG4gICAgICAgIC8vIEFycmFuZ2VcbiAgICAgICAgbW9ja1N1cGFiYXNlLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBkYXRhOiBudWxsLCBlcnJvcjogeyBtZXNzYWdlOiAnTm90IGZvdW5kJyB9IH0pO1xuXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2d1ZXN0L2VtYWlsLW1hdGNoJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWwgfSksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFjdFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgLy8gQXNzZXJ0XG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDA0KTtcbiAgICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChkYXRhLmVycm9yLmNvZGUpLnRvQmUoJ05PVF9GT1VORCcpO1xuICAgICAgfSksXG4gICAgICB7IG51bVJ1bnM6IDIwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIG5vcm1hbGl6ZSBlbWFpbCBjYXNlIGJlZm9yZSBsb29rdXAnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMuZW1haWxBZGRyZXNzKCksXG4gICAgICAgIGZjLnV1aWQoKSxcbiAgICAgICAgYXN5bmMgKGVtYWlsLCBndWVzdElkKSA9PiB7XG4gICAgICAgICAgLy8gQXJyYW5nZVxuICAgICAgICAgIGNvbnN0IG1vY2tHdWVzdCA9IHtcbiAgICAgICAgICAgIGlkOiBndWVzdElkLFxuICAgICAgICAgICAgZW1haWw6IGVtYWlsLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBncm91cF9pZDogJ2dyb3VwLWlkJyxcbiAgICAgICAgICAgIGZpcnN0X25hbWU6ICdUZXN0JyxcbiAgICAgICAgICAgIGxhc3RfbmFtZTogJ1VzZXInLFxuICAgICAgICAgICAgYXV0aF9tZXRob2Q6ICdlbWFpbF9tYXRjaGluZycsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIG1vY2tTdXBhYmFzZS5zaW5nbGVcbiAgICAgICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBkYXRhOiBtb2NrR3Vlc3QsIGVycm9yOiBudWxsIH0pXG4gICAgICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgZGF0YTogeyBpZDogJ3Nlc3Npb24taWQnLCB0b2tlbjogJ3Rva2VuJyB9LCBlcnJvcjogbnVsbCB9KTtcbiAgICAgICAgICBtb2NrU3VwYWJhc2UuaW5zZXJ0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH0pO1xuXG4gICAgICAgICAgLy8gVGVzdCB3aXRoIHZhcmlvdXMgY2FzZSBjb21iaW5hdGlvbnNcbiAgICAgICAgICBjb25zdCBlbWFpbFZhcmlhdGlvbnMgPSBbXG4gICAgICAgICAgICBlbWFpbC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgZW1haWwudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgIGVtYWlsLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgZW1haWwuc2xpY2UoMSkudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICBdO1xuXG4gICAgICAgICAgZm9yIChjb25zdCBlbWFpbFZhcmlhdGlvbiBvZiBlbWFpbFZhcmlhdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2d1ZXN0L2VtYWlsLW1hdGNoJywge1xuICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWw6IGVtYWlsVmFyaWF0aW9uIH0pLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEFjdFxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgICAgLy8gQXNzZXJ0IC0gQWxsIHZhcmlhdGlvbnMgc2hvdWxkIHdvcmtcbiAgICAgICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgICAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCByZWplY3QgaW52YWxpZCBlbWFpbCBmb3JtYXRzJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGZjLm9uZW9mKFxuICAgICAgICAgIGZjLmNvbnN0YW50KCdub3QtYW4tZW1haWwnKSxcbiAgICAgICAgICBmYy5jb25zdGFudCgnbWlzc2luZ0Bkb21haW4nKSxcbiAgICAgICAgICBmYy5jb25zdGFudCgnQG5vZG9tYWluLmNvbScpLFxuICAgICAgICAgIGZjLmNvbnN0YW50KCdzcGFjZXMgaW5AZW1haWwuY29tJyksXG4gICAgICAgICAgZmMuY29uc3RhbnQoJycpLFxuICAgICAgICAgIGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAyMCB9KS5maWx0ZXIocyA9PiAhcy5pbmNsdWRlcygnQCcpKVxuICAgICAgICApLFxuICAgICAgICBhc3luYyAoaW52YWxpZEVtYWlsKSA9PiB7XG4gICAgICAgICAgLy8gQXJyYW5nZVxuICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2d1ZXN0L2VtYWlsLW1hdGNoJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWw6IGludmFsaWRFbWFpbCB9KSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIEFjdFxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcbiAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgLy8gQXNzZXJ0XG4gICAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgIGV4cGVjdChkYXRhLmVycm9yLmNvZGUpLnRvQmUoJ1ZBTElEQVRJT05fRVJST1InKTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMjAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgY3JlYXRlIHVuaXF1ZSBzZXNzaW9uIHRva2VucyBmb3IgZWFjaCBhdXRoZW50aWNhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBmYy5lbWFpbEFkZHJlc3MoKSxcbiAgICAgICAgZmMudXVpZCgpLFxuICAgICAgICBhc3luYyAoZW1haWwsIGd1ZXN0SWQpID0+IHtcbiAgICAgICAgICAvLyBBcnJhbmdlXG4gICAgICAgICAgY29uc3QgbW9ja0d1ZXN0ID0ge1xuICAgICAgICAgICAgaWQ6IGd1ZXN0SWQsXG4gICAgICAgICAgICBlbWFpbDogZW1haWwudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIGdyb3VwX2lkOiAnZ3JvdXAtaWQnLFxuICAgICAgICAgICAgZmlyc3RfbmFtZTogJ1Rlc3QnLFxuICAgICAgICAgICAgbGFzdF9uYW1lOiAnVXNlcicsXG4gICAgICAgICAgICBhdXRoX21ldGhvZDogJ2VtYWlsX21hdGNoaW5nJyxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3Qgc2Vzc2lvblRva2VucyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgICAgICAgLy8gQXV0aGVudGljYXRlIG11bHRpcGxlIHRpbWVzXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgIG1vY2tTdXBhYmFzZS5zaW5nbGVcbiAgICAgICAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGRhdGE6IG1vY2tHdWVzdCwgZXJyb3I6IG51bGwgfSlcbiAgICAgICAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGRhdGE6IHsgaWQ6IGBzZXNzaW9uLSR7aX1gLCB0b2tlbjogYHRva2VuLSR7aX1gIH0sIGVycm9yOiBudWxsIH0pO1xuICAgICAgICAgICAgbW9ja1N1cGFiYXNlLmluc2VydC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBkYXRhOiBudWxsLCBlcnJvcjogbnVsbCB9KTtcblxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvZ3Vlc3QvZW1haWwtbWF0Y2gnLCB7XG4gICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbWFpbCB9KSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuXG4gICAgICAgICAgICAvLyBFeHRyYWN0IHRva2VuIGZyb20gaW5zZXJ0IGNhbGxcbiAgICAgICAgICAgIGNvbnN0IGluc2VydENhbGwgPSBtb2NrU3VwYWJhc2UuaW5zZXJ0Lm1vY2suY2FsbHMuZmluZChcbiAgICAgICAgICAgICAgY2FsbCA9PiBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrLmNhbGxzLnNvbWUoZnJvbUNhbGwgPT4gZnJvbUNhbGxbMF0gPT09ICdndWVzdF9zZXNzaW9ucycpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGluc2VydENhbGwgJiYgaW5zZXJ0Q2FsbFswXT8udG9rZW4pIHtcbiAgICAgICAgICAgICAgc2Vzc2lvblRva2Vucy5hZGQoaW5zZXJ0Q2FsbFswXS50b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQXNzZXJ0IC0gQWxsIHRva2VucyBzaG91bGQgYmUgdW5pcXVlXG4gICAgICAgICAgZXhwZWN0KHNlc3Npb25Ub2tlbnMuc2l6ZSkudG9CZSg1KTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogNSB9IC8vIEZld2VyIHJ1bnMgc2luY2Ugd2UgZG8gNSBhdXRoZW50aWNhdGlvbnMgcGVyIHJ1blxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgb25seSBhdXRoZW50aWNhdGUgZ3Vlc3RzIHdpdGggZW1haWxfbWF0Y2hpbmcgYXV0aCBtZXRob2QnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMuZW1haWxBZGRyZXNzKCksXG4gICAgICAgIGZjLnV1aWQoKSxcbiAgICAgICAgZmMuY29uc3RhbnRGcm9tKCdlbWFpbF9tYXRjaGluZycsICdtYWdpY19saW5rJyksXG4gICAgICAgIGFzeW5jIChlbWFpbCwgZ3Vlc3RJZCwgYXV0aE1ldGhvZCkgPT4ge1xuICAgICAgICAgIC8vIEFycmFuZ2VcbiAgICAgICAgICBpZiAoYXV0aE1ldGhvZCA9PT0gJ2VtYWlsX21hdGNoaW5nJykge1xuICAgICAgICAgICAgY29uc3QgbW9ja0d1ZXN0ID0ge1xuICAgICAgICAgICAgICBpZDogZ3Vlc3RJZCxcbiAgICAgICAgICAgICAgZW1haWw6IGVtYWlsLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgIGdyb3VwX2lkOiAnZ3JvdXAtaWQnLFxuICAgICAgICAgICAgICBmaXJzdF9uYW1lOiAnVGVzdCcsXG4gICAgICAgICAgICAgIGxhc3RfbmFtZTogJ1VzZXInLFxuICAgICAgICAgICAgICBhdXRoX21ldGhvZDogJ2VtYWlsX21hdGNoaW5nJyxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG1vY2tTdXBhYmFzZS5zaW5nbGVcbiAgICAgICAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGRhdGE6IG1vY2tHdWVzdCwgZXJyb3I6IG51bGwgfSlcbiAgICAgICAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGRhdGE6IHsgaWQ6ICdzZXNzaW9uLWlkJywgdG9rZW46ICd0b2tlbicgfSwgZXJyb3I6IG51bGwgfSk7XG4gICAgICAgICAgICBtb2NrU3VwYWJhc2UuaW5zZXJ0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBHdWVzdCB3aXRoIG1hZ2ljX2xpbmsgYXV0aCBtZXRob2Qgc2hvdWxkIG5vdCBiZSBmb3VuZFxuICAgICAgICAgICAgbW9ja1N1cGFiYXNlLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBkYXRhOiBudWxsLCBlcnJvcjogeyBtZXNzYWdlOiAnTm90IGZvdW5kJyB9IH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2d1ZXN0L2VtYWlsLW1hdGNoJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWwgfSksXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBBY3RcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgIC8vIEFzc2VydFxuICAgICAgICAgIGlmIChhdXRoTWV0aG9kID09PSAnZW1haWxfbWF0Y2hpbmcnKSB7XG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwNCk7XG4gICAgICAgICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICAgIGV4cGVjdChkYXRhLmVycm9yLmNvZGUpLnRvQmUoJ05PVF9GT1VORCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMjAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgc2FuaXRpemUgbWFsaWNpb3VzIGVtYWlsIGlucHV0JywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGZjLm9uZW9mKFxuICAgICAgICAgIGZjLmNvbnN0YW50KCc8c2NyaXB0PmFsZXJ0KFwieHNzXCIpPC9zY3JpcHQ+dGVzdEBleGFtcGxlLmNvbScpLFxuICAgICAgICAgIGZjLmNvbnN0YW50KCd0ZXN0QGV4YW1wbGUuY29tPGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPicpLFxuICAgICAgICAgIGZjLmNvbnN0YW50KCdqYXZhc2NyaXB0OmFsZXJ0KDEpQGV4YW1wbGUuY29tJyksXG4gICAgICAgICAgZmMuY29uc3RhbnQoJ3Rlc3RAZXhhbXBsZS5jb21cIjsgRFJPUCBUQUJMRSBndWVzdHM7IC0tJylcbiAgICAgICAgKSxcbiAgICAgICAgYXN5bmMgKG1hbGljaW91c0VtYWlsKSA9PiB7XG4gICAgICAgICAgLy8gQXJyYW5nZVxuICAgICAgICAgIG1vY2tTdXBhYmFzZS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgZGF0YTogbnVsbCwgZXJyb3I6IHsgbWVzc2FnZTogJ05vdCBmb3VuZCcgfSB9KTtcblxuICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2d1ZXN0L2VtYWlsLW1hdGNoJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWw6IG1hbGljaW91c0VtYWlsIH0pLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gQWN0XG4gICAgICAgICAgYXdhaXQgUE9TVChyZXF1ZXN0KTtcblxuICAgICAgICAgIC8vIEFzc2VydCAtIEVtYWlsIHNob3VsZCBiZSBzYW5pdGl6ZWQgYmVmb3JlIGRhdGFiYXNlIHF1ZXJ5XG4gICAgICAgICAgY29uc3QgZW1haWxBcmcgPSBtb2NrU3VwYWJhc2UuZXEubW9jay5jYWxscy5maW5kKGNhbGwgPT4gY2FsbFswXSA9PT0gJ2VtYWlsJyk/LlsxXTtcbiAgICAgICAgICBpZiAoZW1haWxBcmcpIHtcbiAgICAgICAgICAgIGV4cGVjdChlbWFpbEFyZykubm90LnRvQ29udGFpbignPHNjcmlwdD4nKTtcbiAgICAgICAgICAgIGV4cGVjdChlbWFpbEFyZykubm90LnRvQ29udGFpbignamF2YXNjcmlwdDonKTtcbiAgICAgICAgICAgIGV4cGVjdChlbWFpbEFyZykubm90LnRvQ29udGFpbignRFJPUCBUQUJMRScpO1xuICAgICAgICAgICAgZXhwZWN0KGVtYWlsQXJnKS5ub3QudG9Db250YWluKCdvbmVycm9yPScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMjAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgc2V0IHNlc3Npb24gZXhwaXJhdGlvbiB0byAyNCBob3VycyBmcm9tIGNyZWF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGZjLmVtYWlsQWRkcmVzcygpLFxuICAgICAgICBmYy51dWlkKCksXG4gICAgICAgIGFzeW5jIChlbWFpbCwgZ3Vlc3RJZCkgPT4ge1xuICAgICAgICAgIC8vIEFycmFuZ2VcbiAgICAgICAgICBjb25zdCBtb2NrR3Vlc3QgPSB7XG4gICAgICAgICAgICBpZDogZ3Vlc3RJZCxcbiAgICAgICAgICAgIGVtYWlsOiBlbWFpbC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgZ3JvdXBfaWQ6ICdncm91cC1pZCcsXG4gICAgICAgICAgICBmaXJzdF9uYW1lOiAnVGVzdCcsXG4gICAgICAgICAgICBsYXN0X25hbWU6ICdVc2VyJyxcbiAgICAgICAgICAgIGF1dGhfbWV0aG9kOiAnZW1haWxfbWF0Y2hpbmcnLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBtb2NrU3VwYWJhc2Uuc2luZ2xlXG4gICAgICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgZGF0YTogbW9ja0d1ZXN0LCBlcnJvcjogbnVsbCB9KVxuICAgICAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGRhdGE6IHsgaWQ6ICdzZXNzaW9uLWlkJywgdG9rZW46ICd0b2tlbicgfSwgZXJyb3I6IG51bGwgfSk7XG4gICAgICAgICAgbW9ja1N1cGFiYXNlLmluc2VydC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBkYXRhOiBudWxsLCBlcnJvcjogbnVsbCB9KTtcblxuICAgICAgICAgIGNvbnN0IGJlZm9yZVJlcXVlc3QgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvZ3Vlc3QvZW1haWwtbWF0Y2gnLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbWFpbCB9KSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIEFjdFxuICAgICAgICAgIGF3YWl0IFBPU1QocmVxdWVzdCk7XG5cbiAgICAgICAgICBjb25zdCBhZnRlclJlcXVlc3QgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgICAgLy8gQXNzZXJ0IC0gU2Vzc2lvbiBzaG91bGQgZXhwaXJlIDI0IGhvdXJzIGZyb20gbm93XG4gICAgICAgICAgY29uc3QgaW5zZXJ0Q2FsbCA9IG1vY2tTdXBhYmFzZS5pbnNlcnQubW9jay5jYWxscy5maW5kKFxuICAgICAgICAgICAgY2FsbCA9PiBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrLmNhbGxzLnNvbWUoZnJvbUNhbGwgPT4gZnJvbUNhbGxbMF0gPT09ICdndWVzdF9zZXNzaW9ucycpXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChpbnNlcnRDYWxsICYmIGluc2VydENhbGxbMF0/LmV4cGlyZXNfYXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IG5ldyBEYXRlKGluc2VydENhbGxbMF0uZXhwaXJlc19hdCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRNaW4gPSBiZWZvcmVSZXF1ZXN0ICsgMjQgKiA2MCAqIDYwICogMTAwMDtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkTWF4ID0gYWZ0ZXJSZXF1ZXN0ICsgMjQgKiA2MCAqIDYwICogMTAwMDtcblxuICAgICAgICAgICAgZXhwZWN0KGV4cGlyZXNBdCkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbChleHBlY3RlZE1pbik7XG4gICAgICAgICAgICBleHBlY3QoZXhwaXJlc0F0KS50b0JlTGVzc1RoYW5PckVxdWFsKGV4cGVjdGVkTWF4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwIH1cbiAgICApO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiY29va2llcyIsImZuIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJzZXQiLCJtb2NrU3VwYWJhc2UiLCJmcm9tIiwibW9ja1JldHVyblRoaXMiLCJzZWxlY3QiLCJlcSIsInNpbmdsZSIsImluc2VydCIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJjcmVhdGVTdXBhYmFzZUNsaWVudCIsIm1vY2tSZXR1cm5WYWx1ZSIsIml0IiwiZmMiLCJhc3NlcnQiLCJhc3luY1Byb3BlcnR5IiwiZW1haWxBZGRyZXNzIiwidXVpZCIsInN0cmluZyIsIm1pbkxlbmd0aCIsIm1heExlbmd0aCIsImVtYWlsIiwiZ3Vlc3RJZCIsImdyb3VwSWQiLCJmaXJzdE5hbWUiLCJsYXN0TmFtZSIsIm1vY2tHdWVzdCIsImlkIiwidG9Mb3dlckNhc2UiLCJncm91cF9pZCIsImZpcnN0X25hbWUiLCJsYXN0X25hbWUiLCJhdXRoX21ldGhvZCIsIm1vY2tSZXNvbHZlZFZhbHVlT25jZSIsImRhdGEiLCJlcnJvciIsInRva2VuIiwicmVxdWVzdCIsIlJlcXVlc3QiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXNwb25zZSIsIlBPU1QiLCJqc29uIiwiZXhwZWN0Iiwic3RhdHVzIiwidG9CZSIsInN1Y2Nlc3MiLCJudW1SdW5zIiwibWVzc2FnZSIsImNvZGUiLCJlbWFpbFZhcmlhdGlvbnMiLCJ0b1VwcGVyQ2FzZSIsImNoYXJBdCIsInNsaWNlIiwiZW1haWxWYXJpYXRpb24iLCJvbmVvZiIsImNvbnN0YW50IiwiZmlsdGVyIiwicyIsImluY2x1ZGVzIiwiaW52YWxpZEVtYWlsIiwic2Vzc2lvblRva2VucyIsIlNldCIsImkiLCJpbnNlcnRDYWxsIiwiY2FsbHMiLCJmaW5kIiwiY2FsbCIsInNvbWUiLCJmcm9tQ2FsbCIsImFkZCIsInNpemUiLCJjb25zdGFudEZyb20iLCJhdXRoTWV0aG9kIiwibWFsaWNpb3VzRW1haWwiLCJlbWFpbEFyZyIsIm5vdCIsInRvQ29udGFpbiIsImJlZm9yZVJlcXVlc3QiLCJEYXRlIiwibm93IiwiYWZ0ZXJSZXF1ZXN0IiwiZXhwaXJlc19hdCIsImV4cGlyZXNBdCIsImdldFRpbWUiLCJleHBlY3RlZE1pbiIsImV4cGVjdGVkTWF4IiwidG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCIsInRvQmVMZXNzVGhhbk9yRXF1YWwiXSwibWFwcGluZ3MiOiI7QUFJQTs7Ozs7OztDQU9DLEdBRUQsb0JBQW9CO0FBQ3BCQSxLQUFLQyxJQUFJLENBQUM7QUFDVkQsS0FBS0MsSUFBSSxDQUFDLGdCQUFnQixJQUFPLENBQUE7UUFDL0JDLFNBQVNGLEtBQUtHLEVBQUUsR0FBR0MsaUJBQWlCLENBQUM7WUFDbkNDLEtBQUtMLEtBQUtHLEVBQUU7UUFDZDtJQUNGLENBQUE7Ozs7bUVBbkJvQjt1QkFDQzswQkFDZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CckMsTUFBTUcsZUFBZTtJQUNuQkMsTUFBTVAsS0FBS0csRUFBRSxHQUFHSyxjQUFjO0lBQzlCQyxRQUFRVCxLQUFLRyxFQUFFLEdBQUdLLGNBQWM7SUFDaENFLElBQUlWLEtBQUtHLEVBQUUsR0FBR0ssY0FBYztJQUM1QkcsUUFBUVgsS0FBS0csRUFBRTtJQUNmUyxRQUFRWixLQUFLRyxFQUFFLEdBQUdLLGNBQWM7QUFDbEM7QUFFQUssU0FBUyxxRkFBcUY7SUFDNUZDLFdBQVc7UUFDVGQsS0FBS2UsYUFBYTtRQUNqQkMsOEJBQW9CLENBQWVDLGVBQWUsQ0FBQ1g7SUFDdEQ7SUFFQVksR0FBRyxxR0FBcUc7UUFDdEcsTUFBTUMsV0FBR0MsTUFBTSxDQUNiRCxXQUFHRSxhQUFhLENBQ2RGLFdBQUdHLFlBQVksSUFDZkgsV0FBR0ksSUFBSSxJQUNQSixXQUFHSSxJQUFJLElBQ1BKLFdBQUdLLE1BQU0sQ0FBQztZQUFFQyxXQUFXO1lBQUdDLFdBQVc7UUFBRyxJQUN4Q1AsV0FBR0ssTUFBTSxDQUFDO1lBQUVDLFdBQVc7WUFBR0MsV0FBVztRQUFHLElBQ3hDLE9BQU9DLE9BQU9DLFNBQVNDLFNBQVNDLFdBQVdDO1lBQ3pDLFVBQVU7WUFDVixNQUFNQyxZQUFZO2dCQUNoQkMsSUFBSUw7Z0JBQ0pELE9BQU9BLE1B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