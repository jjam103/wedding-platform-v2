979a0b174d14f3816cc422b3175f2e01
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get executeCronJob () {
        return executeCronJob;
    },
    get getJobLogs () {
        return getJobLogs;
    },
    get getJobStats () {
        return getJobStats;
    },
    get isJobRunning () {
        return isJobRunning;
    }
});
const _types = require("../types");
const _supabase = require("../lib/supabase");
/**
 * Creates a cron job log entry at the start of execution.
 * 
 * @param jobType - Type of cron job being executed
 * @returns Result containing the log entry ID
 */ async function startJobLog(jobType) {
    try {
        const { data, error } = await _supabase.supabase.from('cron_job_logs').insert({
            job_type: jobType,
            status: 'running',
            started_at: new Date().toISOString(),
            items_processed: 0,
            items_failed: 0
        }).select('id').single();
        if (error) {
            return {
                success: false,
                error: {
                    code: _types.ERROR_CODES.DATABASE_ERROR,
                    message: 'Failed to create job log',
                    details: error
                }
            };
        }
        return {
            success: true,
            data: data.id
        };
    } catch (error) {
        return {
            success: false,
            error: {
                code: _types.ERROR_CODES.UNKNOWN_ERROR,
                message: error instanceof Error ? error.message : 'Unknown error'
            }
        };
    }
}
/**
 * Updates a cron job log entry at the end of execution.
 * 
 * @param logId - Log entry ID
 * @param result - Job execution result
 * @returns Result indicating success or error
 */ async function completeJobLog(logId, result) {
    try {
        const { error } = await _supabase.supabase.from('cron_job_logs').update({
            status: result.status,
            completed_at: new Date().toISOString(),
            duration_ms: result.durationMs,
            items_processed: result.itemsProcessed,
            items_failed: result.itemsFailed,
            error_message: result.errors.length > 0 ? result.errors.join('; ') : null
        }).eq('id', logId);
        if (error) {
            return {
                success: false,
                error: {
                    code: _types.ERROR_CODES.DATABASE_ERROR,
                    message: 'Failed to update job log',
                    details: error
                }
            };
        }
        return {
            success: true,
            data: undefined
        };
    } catch (error) {
        return {
            success: false,
            error: {
                code: _types.ERROR_CODES.UNKNOWN_ERROR,
                message: error instanceof Error ? error.message : 'Unknown error'
            }
        };
    }
}
async function executeCronJob(jobType, jobFunction) {
    const startTime = Date.now();
    const errors = [];
    // Start job log
    const logResult = await startJobLog(jobType);
    if (!logResult.success) {
        return {
            success: false,
            error: logResult.error
        };
    }
    const logId = logResult.data;
    try {
        // Execute the job function
        const { itemsProcessed, itemsFailed } = await jobFunction();
        const durationMs = Date.now() - startTime;
        const status = itemsFailed > 0 ? 'completed' : 'completed';
        const result = {
            jobType,
            status,
            itemsProcessed,
            itemsFailed,
            durationMs,
            errors
        };
        // Update job log
        await completeJobLog(logId, result);
        return {
            success: true,
            data: result
        };
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        errors.push(errorMessage);
        const durationMs = Date.now() - startTime;
        const result = {
            jobType,
            status: 'failed',
            itemsProcessed: 0,
            itemsFailed: 0,
            durationMs,
            errors
        };
        // Update job log with failure
        await completeJobLog(logId, result);
        return {
            success: false,
            error: {
                code: _types.ERROR_CODES.CRON_JOB_ERROR,
                message: `Cron job ${jobType} failed: ${errorMessage}`,
                details: error
            }
        };
    }
}
async function getJobLogs(jobType, limit = 100) {
    try {
        let query = _supabase.supabase.from('cron_job_logs').select('*').order('started_at', {
            ascending: false
        }).limit(limit);
        if (jobType) {
            query = query.eq('job_type', jobType);
        }
        const { data, error } = await query;
        if (error) {
            return {
                success: false,
                error: {
                    code: _types.ERROR_CODES.DATABASE_ERROR,
                    message: 'Failed to fetch job logs',
                    details: error
                }
            };
        }
        return {
            success: true,
            data: data || []
        };
    } catch (error) {
        return {
            success: false,
            error: {
                code: _types.ERROR_CODES.UNKNOWN_ERROR,
                message: error instanceof Error ? error.message : 'Unknown error'
            }
        };
    }
}
async function getJobStats(jobType, since) {
    try {
        let query = _supabase.supabase.from('cron_job_logs').select('*');
        if (jobType) {
            query = query.eq('job_type', jobType);
        }
        if (since) {
            query = query.gte('started_at', since);
        }
        const { data: logs, error } = await query;
        if (error) {
            return {
                success: false,
                error: {
                    code: _types.ERROR_CODES.DATABASE_ERROR,
                    message: 'Failed to fetch job statistics',
                    details: error
                }
            };
        }
        const stats = {
            totalExecutions: logs.length,
            successfulExecutions: logs.filter((l)=>l.status === 'completed').length,
            failedExecutions: logs.filter((l)=>l.status === 'failed').length,
            averageDurationMs: logs.length > 0 ? logs.reduce((sum, l)=>sum + (l.duration_ms || 0), 0) / logs.length : 0,
            totalItemsProcessed: logs.reduce((sum, l)=>sum + (l.items_processed || 0), 0),
            totalItemsFailed: logs.reduce((sum, l)=>sum + (l.items_failed || 0), 0)
        };
        return {
            success: true,
            data: stats
        };
    } catch (error) {
        return {
            success: false,
            error: {
                code: _types.ERROR_CODES.UNKNOWN_ERROR,
                message: error instanceof Error ? error.message : 'Unknown error'
            }
        };
    }
}
async function isJobRunning(jobType) {
    try {
        const { data, error } = await _supabase.supabase.from('cron_job_logs').select('id').eq('job_type', jobType).eq('status', 'running').limit(1);
        if (error) {
            return {
                success: false,
                error: {
                    code: _types.ERROR_CODES.DATABASE_ERROR,
                    message: 'Failed to check job status',
                    details: error
                }
            };
        }
        return {
            success: true,
            data: (data || []).length > 0
        };
    } catch (error) {
        return {
            success: false,
            error: {
                code: _types.ERROR_CODES.UNKNOWN_ERROR,
                message: error instanceof Error ? error.message : 'Unknown error'
            }
        };
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvY3JvblNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBSZXN1bHQgfSBmcm9tICdAL3R5cGVzJztcbmltcG9ydCB7IEVSUk9SX0NPREVTIH0gZnJvbSAnQC90eXBlcyc7XG5pbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gJ0AvbGliL3N1cGFiYXNlJztcblxuLyoqXG4gKiBDcm9uIGpvYiBzdGF0dXMgdHlwZXMuXG4gKi9cbmV4cG9ydCB0eXBlIENyb25Kb2JTdGF0dXMgPSAncGVuZGluZycgfCAncnVubmluZycgfCAnY29tcGxldGVkJyB8ICdmYWlsZWQnO1xuXG4vKipcbiAqIENyb24gam9iIHR5cGVzIHN1cHBvcnRlZCBieSB0aGUgc3lzdGVtLlxuICovXG5leHBvcnQgdHlwZSBDcm9uSm9iVHlwZSA9XG4gIHwgJ3JzdnBfZGVhZGxpbmVfcmVtaW5kZXJzJ1xuICB8ICdzY2hlZHVsZWRfZW1haWxfcHJvY2Vzc2luZydcbiAgfCAnd2ViaG9va19yZXRyeSdcbiAgfCAndGVtcF9maWxlX2NsZWFudXAnXG4gIHwgJ2V4cGlyZWRfc2Vzc2lvbl9jbGVhbnVwJztcblxuLyoqXG4gKiBDcm9uIGpvYiBleGVjdXRpb24gbG9nIGVudHJ5LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENyb25Kb2JMb2cge1xuICBpZDogc3RyaW5nO1xuICBqb2JfdHlwZTogQ3JvbkpvYlR5cGU7XG4gIHN0YXR1czogQ3JvbkpvYlN0YXR1cztcbiAgc3RhcnRlZF9hdDogc3RyaW5nO1xuICBjb21wbGV0ZWRfYXQ6IHN0cmluZyB8IG51bGw7XG4gIGR1cmF0aW9uX21zOiBudW1iZXIgfCBudWxsO1xuICBpdGVtc19wcm9jZXNzZWQ6IG51bWJlcjtcbiAgaXRlbXNfZmFpbGVkOiBudW1iZXI7XG4gIGVycm9yX21lc3NhZ2U6IHN0cmluZyB8IG51bGw7XG4gIG1ldGFkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IG51bGw7XG59XG5cbi8qKlxuICogQ3JvbiBqb2IgZXhlY3V0aW9uIHJlc3VsdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDcm9uSm9iUmVzdWx0IHtcbiAgam9iVHlwZTogQ3JvbkpvYlR5cGU7XG4gIHN0YXR1czogQ3JvbkpvYlN0YXR1cztcbiAgaXRlbXNQcm9jZXNzZWQ6IG51bWJlcjtcbiAgaXRlbXNGYWlsZWQ6IG51bWJlcjtcbiAgZHVyYXRpb25NczogbnVtYmVyO1xuICBlcnJvcnM6IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjcm9uIGpvYiBsb2cgZW50cnkgYXQgdGhlIHN0YXJ0IG9mIGV4ZWN1dGlvbi5cbiAqIFxuICogQHBhcmFtIGpvYlR5cGUgLSBUeXBlIG9mIGNyb24gam9iIGJlaW5nIGV4ZWN1dGVkXG4gKiBAcmV0dXJucyBSZXN1bHQgY29udGFpbmluZyB0aGUgbG9nIGVudHJ5IElEXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN0YXJ0Sm9iTG9nKGpvYlR5cGU6IENyb25Kb2JUeXBlKTogUHJvbWlzZTxSZXN1bHQ8c3RyaW5nPj4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY3Jvbl9qb2JfbG9ncycpXG4gICAgICAuaW5zZXJ0KHtcbiAgICAgICAgam9iX3R5cGU6IGpvYlR5cGUsXG4gICAgICAgIHN0YXR1czogJ3J1bm5pbmcnLFxuICAgICAgICBzdGFydGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGl0ZW1zX3Byb2Nlc3NlZDogMCxcbiAgICAgICAgaXRlbXNfZmFpbGVkOiAwLFxuICAgICAgfSlcbiAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgY29kZTogRVJST1JfQ09ERVMuREFUQUJBU0VfRVJST1IsXG4gICAgICAgICAgbWVzc2FnZTogJ0ZhaWxlZCB0byBjcmVhdGUgam9iIGxvZycsXG4gICAgICAgICAgZGV0YWlsczogZXJyb3IsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IGRhdGEuaWQgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjoge1xuICAgICAgICBjb2RlOiBFUlJPUl9DT0RFUy5VTktOT1dOX0VSUk9SLFxuICAgICAgICBtZXNzYWdlOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBjcm9uIGpvYiBsb2cgZW50cnkgYXQgdGhlIGVuZCBvZiBleGVjdXRpb24uXG4gKiBcbiAqIEBwYXJhbSBsb2dJZCAtIExvZyBlbnRyeSBJRFxuICogQHBhcmFtIHJlc3VsdCAtIEpvYiBleGVjdXRpb24gcmVzdWx0XG4gKiBAcmV0dXJucyBSZXN1bHQgaW5kaWNhdGluZyBzdWNjZXNzIG9yIGVycm9yXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNvbXBsZXRlSm9iTG9nKFxuICBsb2dJZDogc3RyaW5nLFxuICByZXN1bHQ6IE9taXQ8Q3JvbkpvYlJlc3VsdCwgJ2pvYlR5cGUnPlxuKTogUHJvbWlzZTxSZXN1bHQ8dm9pZD4+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2Nyb25fam9iX2xvZ3MnKVxuICAgICAgLnVwZGF0ZSh7XG4gICAgICAgIHN0YXR1czogcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgY29tcGxldGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGR1cmF0aW9uX21zOiByZXN1bHQuZHVyYXRpb25NcyxcbiAgICAgICAgaXRlbXNfcHJvY2Vzc2VkOiByZXN1bHQuaXRlbXNQcm9jZXNzZWQsXG4gICAgICAgIGl0ZW1zX2ZhaWxlZDogcmVzdWx0Lml0ZW1zRmFpbGVkLFxuICAgICAgICBlcnJvcl9tZXNzYWdlOiByZXN1bHQuZXJyb3JzLmxlbmd0aCA+IDAgPyByZXN1bHQuZXJyb3JzLmpvaW4oJzsgJykgOiBudWxsLFxuICAgICAgfSlcbiAgICAgIC5lcSgnaWQnLCBsb2dJZCk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgIGNvZGU6IEVSUk9SX0NPREVTLkRBVEFCQVNFX0VSUk9SLFxuICAgICAgICAgIG1lc3NhZ2U6ICdGYWlsZWQgdG8gdXBkYXRlIGpvYiBsb2cnLFxuICAgICAgICAgIGRldGFpbHM6IGVycm9yLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiB1bmRlZmluZWQgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjoge1xuICAgICAgICBjb2RlOiBFUlJPUl9DT0RFUy5VTktOT1dOX0VSUk9SLFxuICAgICAgICBtZXNzYWdlOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEV4ZWN1dGVzIGEgY3JvbiBqb2Igd2l0aCBhdXRvbWF0aWMgbG9nZ2luZyBhbmQgZXJyb3IgaGFuZGxpbmcuXG4gKiBcbiAqIEBwYXJhbSBqb2JUeXBlIC0gVHlwZSBvZiBjcm9uIGpvYiB0byBleGVjdXRlXG4gKiBAcGFyYW0gam9iRnVuY3Rpb24gLSBGdW5jdGlvbiB0aGF0IHBlcmZvcm1zIHRoZSBqb2JcbiAqIEByZXR1cm5zIFJlc3VsdCBjb250YWluaW5nIGpvYiBleGVjdXRpb24gZGV0YWlsc1xuICogXG4gKiBAZXhhbXBsZVxuICogYXdhaXQgZXhlY3V0ZUNyb25Kb2IoJ3JzdnBfZGVhZGxpbmVfcmVtaW5kZXJzJywgYXN5bmMgKCkgPT4ge1xuICogICAvLyBKb2IgaW1wbGVtZW50YXRpb25cbiAqICAgcmV0dXJuIHsgaXRlbXNQcm9jZXNzZWQ6IDEwLCBpdGVtc0ZhaWxlZDogMCB9O1xuICogfSk7XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleGVjdXRlQ3JvbkpvYihcbiAgam9iVHlwZTogQ3JvbkpvYlR5cGUsXG4gIGpvYkZ1bmN0aW9uOiAoKSA9PiBQcm9taXNlPHsgaXRlbXNQcm9jZXNzZWQ6IG51bWJlcjsgaXRlbXNGYWlsZWQ6IG51bWJlciB9PlxuKTogUHJvbWlzZTxSZXN1bHQ8Q3JvbkpvYlJlc3VsdD4+IHtcbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8vIFN0YXJ0IGpvYiBsb2dcbiAgY29uc3QgbG9nUmVzdWx0ID0gYXdhaXQgc3RhcnRKb2JMb2coam9iVHlwZSk7XG4gIGlmICghbG9nUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogbG9nUmVzdWx0LmVycm9yLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBsb2dJZCA9IGxvZ1Jlc3VsdC5kYXRhO1xuXG4gIHRyeSB7XG4gICAgLy8gRXhlY3V0ZSB0aGUgam9iIGZ1bmN0aW9uXG4gICAgY29uc3QgeyBpdGVtc1Byb2Nlc3NlZCwgaXRlbXNGYWlsZWQgfSA9IGF3YWl0IGpvYkZ1bmN0aW9uKCk7XG5cbiAgICBjb25zdCBkdXJhdGlvbk1zID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICBjb25zdCBzdGF0dXM6IENyb25Kb2JTdGF0dXMgPSBpdGVtc0ZhaWxlZCA+IDAgPyAnY29tcGxldGVkJyA6ICdjb21wbGV0ZWQnO1xuXG4gICAgY29uc3QgcmVzdWx0OiBDcm9uSm9iUmVzdWx0ID0ge1xuICAgICAgam9iVHlwZSxcbiAgICAgIHN0YXR1cyxcbiAgICAgIGl0ZW1zUHJvY2Vzc2VkLFxuICAgICAgaXRlbXNGYWlsZWQsXG4gICAgICBkdXJhdGlvbk1zLFxuICAgICAgZXJyb3JzLFxuICAgIH07XG5cbiAgICAvLyBVcGRhdGUgam9iIGxvZ1xuICAgIGF3YWl0IGNvbXBsZXRlSm9iTG9nKGxvZ0lkLCByZXN1bHQpO1xuXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzdWx0IH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcic7XG4gICAgZXJyb3JzLnB1c2goZXJyb3JNZXNzYWdlKTtcblxuICAgIGNvbnN0IGR1cmF0aW9uTXMgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgY29uc3QgcmVzdWx0OiBDcm9uSm9iUmVzdWx0ID0ge1xuICAgICAgam9iVHlwZSxcbiAgICAgIHN0YXR1czogJ2ZhaWxlZCcsXG4gICAgICBpdGVtc1Byb2Nlc3NlZDogMCxcbiAgICAgIGl0ZW1zRmFpbGVkOiAwLFxuICAgICAgZHVyYXRpb25NcyxcbiAgICAgIGVycm9ycyxcbiAgICB9O1xuXG4gICAgLy8gVXBkYXRlIGpvYiBsb2cgd2l0aCBmYWlsdXJlXG4gICAgYXdhaXQgY29tcGxldGVKb2JMb2cobG9nSWQsIHJlc3VsdCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjoge1xuICAgICAgICBjb2RlOiBFUlJPUl9DT0RFUy5DUk9OX0pPQl9FUlJPUixcbiAgICAgICAgbWVzc2FnZTogYENyb24gam9iICR7am9iVHlwZX0gZmFpbGVkOiAke2Vycm9yTWVzc2FnZX1gLFxuICAgICAgICBkZXRhaWxzOiBlcnJvcixcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgcmVjZW50IGNyb24gam9iIGV4ZWN1dGlvbiBsb2dzLlxuICogXG4gKiBAcGFyYW0gam9iVHlwZSAtIE9wdGlvbmFsIGZpbHRlciBieSBqb2IgdHlwZVxuICogQHBhcmFtIGxpbWl0IC0gTWF4aW11bSBudW1iZXIgb2YgbG9ncyB0byByZXR1cm4gKGRlZmF1bHQ6IDEwMClcbiAqIEByZXR1cm5zIFJlc3VsdCBjb250YWluaW5nIGFycmF5IG9mIGpvYiBsb2dzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRKb2JMb2dzKFxuICBqb2JUeXBlPzogQ3JvbkpvYlR5cGUsXG4gIGxpbWl0OiBudW1iZXIgPSAxMDBcbik6IFByb21pc2U8UmVzdWx0PENyb25Kb2JMb2dbXT4+IHtcbiAgdHJ5IHtcbiAgICBsZXQgcXVlcnkgPSBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2Nyb25fam9iX2xvZ3MnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAub3JkZXIoJ3N0YXJ0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICAgIC5saW1pdChsaW1pdCk7XG5cbiAgICBpZiAoam9iVHlwZSkge1xuICAgICAgcXVlcnkgPSBxdWVyeS5lcSgnam9iX3R5cGUnLCBqb2JUeXBlKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBxdWVyeTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgY29kZTogRVJST1JfQ09ERVMuREFUQUJBU0VfRVJST1IsXG4gICAgICAgICAgbWVzc2FnZTogJ0ZhaWxlZCB0byBmZXRjaCBqb2IgbG9ncycsXG4gICAgICAgICAgZGV0YWlsczogZXJyb3IsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IGRhdGEgfHwgW10gfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjoge1xuICAgICAgICBjb2RlOiBFUlJPUl9DT0RFUy5VTktOT1dOX0VSUk9SLFxuICAgICAgICBtZXNzYWdlOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgY3JvbiBqb2IgZXhlY3V0aW9uIHN0YXRpc3RpY3MuXG4gKiBcbiAqIEBwYXJhbSBqb2JUeXBlIC0gT3B0aW9uYWwgZmlsdGVyIGJ5IGpvYiB0eXBlXG4gKiBAcGFyYW0gc2luY2UgLSBPcHRpb25hbCBzdGFydCBkYXRlIGZvciBzdGF0aXN0aWNzIChJU08gc3RyaW5nKVxuICogQHJldHVybnMgUmVzdWx0IGNvbnRhaW5pbmcgam9iIHN0YXRpc3RpY3NcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEpvYlN0YXRzKFxuICBqb2JUeXBlPzogQ3JvbkpvYlR5cGUsXG4gIHNpbmNlPzogc3RyaW5nXG4pOiBQcm9taXNlPFxuICBSZXN1bHQ8e1xuICAgIHRvdGFsRXhlY3V0aW9uczogbnVtYmVyO1xuICAgIHN1Y2Nlc3NmdWxFeGVjdXRpb25zOiBudW1iZXI7XG4gICAgZmFpbGVkRXhlY3V0aW9uczogbnVtYmVyO1xuICAgIGF2ZXJhZ2VEdXJhdGlvbk1zOiBudW1iZXI7XG4gICAgdG90YWxJdGVtc1Byb2Nlc3NlZDogbnVtYmVyO1xuICAgIHRvdGFsSXRlbXNGYWlsZWQ6IG51bWJlcjtcbiAgfT5cbj4ge1xuICB0cnkge1xuICAgIGxldCBxdWVyeSA9IHN1cGFiYXNlLmZyb20oJ2Nyb25fam9iX2xvZ3MnKS5zZWxlY3QoJyonKTtcblxuICAgIGlmIChqb2JUeXBlKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdqb2JfdHlwZScsIGpvYlR5cGUpO1xuICAgIH1cblxuICAgIGlmIChzaW5jZSkge1xuICAgICAgcXVlcnkgPSBxdWVyeS5ndGUoJ3N0YXJ0ZWRfYXQnLCBzaW5jZSk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBkYXRhOiBsb2dzLCBlcnJvciB9ID0gYXdhaXQgcXVlcnk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgIGNvZGU6IEVSUk9SX0NPREVTLkRBVEFCQVNFX0VSUk9SLFxuICAgICAgICAgIG1lc3NhZ2U6ICdGYWlsZWQgdG8gZmV0Y2ggam9iIHN0YXRpc3RpY3MnLFxuICAgICAgICAgIGRldGFpbHM6IGVycm9yLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0cyA9IHtcbiAgICAgIHRvdGFsRXhlY3V0aW9uczogbG9ncy5sZW5ndGgsXG4gICAgICBzdWNjZXNzZnVsRXhlY3V0aW9uczogbG9ncy5maWx0ZXIoKGwpID0+IGwuc3RhdHVzID09PSAnY29tcGxldGVkJykubGVuZ3RoLFxuICAgICAgZmFpbGVkRXhlY3V0aW9uczogbG9ncy5maWx0ZXIoKGwpID0+IGwuc3RhdHVzID09PSAnZmFpbGVkJykubGVuZ3RoLFxuICAgICAgYXZlcmFnZUR1cmF0aW9uTXM6XG4gICAgICAgIGxvZ3MubGVuZ3RoID4gMFxuICAgICAgICAgID8gbG9ncy5yZWR1Y2UoKHN1bSwgbCkgPT4gc3VtICsgKGwuZHVyYXRpb25fbXMgfHwgMCksIDApIC8gbG9ncy5sZW5ndGhcbiAgICAgICAgICA6IDAsXG4gICAgICB0b3RhbEl0ZW1zUHJvY2Vzc2VkOiBsb2dzLnJlZHVjZSgoc3VtLCBsKSA9PiBzdW0gKyAobC5pdGVtc19wcm9jZXNzZWQgfHwgMCksIDApLFxuICAgICAgdG90YWxJdGVtc0ZhaWxlZDogbG9ncy5yZWR1Y2UoKHN1bSwgbCkgPT4gc3VtICsgKGwuaXRlbXNfZmFpbGVkIHx8IDApLCAwKSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogc3RhdHMgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjoge1xuICAgICAgICBjb2RlOiBFUlJPUl9DT0RFUy5VTktOT1dOX0VSUk9SLFxuICAgICAgICBtZXNzYWdlOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGNyb24gam9iIGlzIGN1cnJlbnRseSBydW5uaW5nLlxuICogXG4gKiBAcGFyYW0gam9iVHlwZSAtIFR5cGUgb2YgY3JvbiBqb2IgdG8gY2hlY2tcbiAqIEByZXR1cm5zIFJlc3VsdCBpbmRpY2F0aW5nIGlmIGpvYiBpcyBydW5uaW5nXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpc0pvYlJ1bm5pbmcoam9iVHlwZTogQ3JvbkpvYlR5cGUpOiBQcm9taXNlPFJlc3VsdDxib29sZWFuPj4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY3Jvbl9qb2JfbG9ncycpXG4gICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAuZXEoJ2pvYl90eXBlJywgam9iVHlwZSlcbiAgICAgIC5lcSgnc3RhdHVzJywgJ3J1bm5pbmcnKVxuICAgICAgLmxpbWl0KDEpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICBjb2RlOiBFUlJPUl9DT0RFUy5EQVRBQkFTRV9FUlJPUixcbiAgICAgICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIGNoZWNrIGpvYiBzdGF0dXMnLFxuICAgICAgICAgIGRldGFpbHM6IGVycm9yLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiAoZGF0YSB8fCBbXSkubGVuZ3RoID4gMCB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiB7XG4gICAgICAgIGNvZGU6IEVSUk9SX0NPREVTLlVOS05PV05fRVJST1IsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG59XG5cbiJdLCJuYW1lcyI6WyJleGVjdXRlQ3JvbkpvYiIsImdldEpvYkxvZ3MiLCJnZXRKb2JTdGF0cyIsImlzSm9iUnVubmluZyIsInN0YXJ0Sm9iTG9nIiwiam9iVHlwZSIsImRhdGEiLCJlcnJvciIsInN1cGFiYXNlIiwiZnJvbSIsImluc2VydCIsImpvYl90eXBlIiwic3RhdHVzIiwic3RhcnRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIml0ZW1zX3Byb2Nlc3NlZCIsIml0ZW1zX2ZhaWxlZCIsInNlbGVjdCIsInNpbmdsZSIsInN1Y2Nlc3MiLCJjb2RlIiwiRVJST1JfQ09ERVMiLCJEQVRBQkFTRV9FUlJPUiIsIm1lc3NhZ2UiLCJkZXRhaWxzIiwiaWQiLCJVTktOT1dOX0VSUk9SIiwiRXJyb3IiLCJjb21wbGV0ZUpvYkxvZyIsImxvZ0lkIiwicmVzdWx0IiwidXBkYXRlIiwiY29tcGxldGVkX2F0IiwiZHVyYXRpb25fbXMiLCJkdXJhdGlvbk1zIiwiaXRlbXNQcm9jZXNzZWQiLCJpdGVtc0ZhaWxlZCIsImVycm9yX21lc3NhZ2UiLCJlcnJvcnMiLCJsZW5ndGgiLCJqb2luIiwiZXEiLCJ1bmRlZmluZWQiLCJqb2JGdW5jdGlvbiIsInN0YXJ0VGltZSIsIm5vdyIsImxvZ1Jlc3VsdCIsImVycm9yTWVzc2FnZSIsInB1c2giLCJDUk9OX0pPQl9FUlJPUiIsImxpbWl0IiwicXVlcnkiLCJvcmRlciIsImFzY2VuZGluZyIsInNpbmNlIiwiZ3RlIiwibG9ncyIsInN0YXRzIiwidG90YWxFeGVjdXRpb25zIiwic3VjY2Vzc2Z1bEV4ZWN1dGlvbnMiLCJmaWx0ZXIiLCJsIiwiZmFpbGVkRXhlY3V0aW9ucyIsImF2ZXJhZ2VEdXJhdGlvbk1zIiwicmVkdWNlIiwic3VtIiwidG90YWxJdGVtc1Byb2Nlc3NlZCIsInRvdGFsSXRlbXNGYWlsZWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O1FBc0pzQkE7ZUFBQUE7O1FBMEVBQztlQUFBQTs7UUErQ0FDO2VBQUFBOztRQW1FQUM7ZUFBQUE7Ozt1QkFqVk07MEJBQ0g7QUE2Q3pCOzs7OztDQUtDLEdBQ0QsZUFBZUMsWUFBWUMsT0FBb0I7SUFDN0MsSUFBSTtRQUNGLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNQyxrQkFBUSxDQUNuQ0MsSUFBSSxDQUFDLGlCQUNMQyxNQUFNLENBQUM7WUFDTkMsVUFBVU47WUFDVk8sUUFBUTtZQUNSQyxZQUFZLElBQUlDLE9BQU9DLFdBQVc7WUFDbENDLGlCQUFpQjtZQUNqQkMsY0FBYztRQUNoQixHQUNDQyxNQUFNLENBQUMsTUFDUEMsTUFBTTtRQUVULElBQUlaLE9BQU87WUFDVCxPQUFPO2dCQUNMYSxTQUFTO2dCQUNUYixPQUFPO29CQUNMYyxNQUFNQyxrQkFBVyxDQUFDQyxjQUFjO29CQUNoQ0MsU0FBUztvQkFDVEMsU0FBU2xCO2dCQUNYO1lBQ0Y7UUFDRjtRQUVBLE9BQU87WUFBRWEsU0FBUztZQUFNZCxNQUFNQSxLQUFLb0IsRUFBRTtRQUFDO0lBQ3hDLEVBQUUsT0FBT25CLE9BQU87UUFDZCxPQUFPO1lBQ0xhLFNBQVM7WUFDVGIsT0FBTztnQkFDTGMsTUFBTUMsa0JBQVcs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