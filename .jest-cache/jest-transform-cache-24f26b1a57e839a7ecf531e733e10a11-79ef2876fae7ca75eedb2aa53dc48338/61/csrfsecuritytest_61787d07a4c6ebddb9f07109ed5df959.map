{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/__tests__/security/csrf.security.test.ts"],"sourcesContent":["/**\n * Security Test: CSRF Protection\n * \n * Tests that Cross-Site Request Forgery (CSRF) attacks are prevented\n * through proper authentication and origin validation.\n */\n\nimport { NextRequest } from 'next/server';\n\ndescribe('Security: CSRF Protection', () => {\n  describe('Authentication-based CSRF protection', () => {\n    it('should require authentication for state-changing operations', () => {\n      // Next.js API routes with Supabase Auth require valid session tokens\n      // This prevents CSRF as attackers cannot forge valid session tokens\n      \n      // Example: POST /api/guests requires Authorization header\n      // Without valid session, request is rejected with 401\n      \n      expect(true).toBe(true); // Documentation test\n    });\n\n    it('should validate session tokens on every request', () => {\n      // Supabase Auth validates session tokens server-side\n      // Tokens are stored in HTTP-only cookies (not accessible to JavaScript)\n      // This prevents XSS-based token theft\n      \n      expect(true).toBe(true); // Documentation test\n    });\n\n    it('should use HTTP-only cookies for session storage', () => {\n      // Session tokens stored in HTTP-only cookies cannot be accessed by JavaScript\n      // This prevents XSS attacks from stealing session tokens\n      // Cookies are automatically sent with requests (SameSite protection)\n      \n      expect(true).toBe(true); // Documentation test\n    });\n  });\n\n  describe('Origin validation', () => {\n    it('should validate request origin for API calls', () => {\n      // Next.js middleware can validate Origin and Referer headers\n      // Reject requests from unexpected origins\n      \n      const validOrigins = [\n        'http://localhost:3000',\n        'https://wedding.example.com',\n      ];\n\n      const testOrigin = (origin: string) => {\n        return validOrigins.some(valid => origin.startsWith(valid));\n      };\n\n      expect(testOrigin('http://localhost:3000')).toBe(true);\n      expect(testOrigin('https://wedding.example.com')).toBe(true);\n      expect(testOrigin('https://evil.com')).toBe(false);\n    });\n\n    it('should reject requests without proper origin', () => {\n      // Requests without Origin or Referer headers should be rejected\n      // for state-changing operations (POST, PUT, DELETE)\n      \n      const hasValidOrigin = (request: { origin?: string; referer?: string }) => {\n        return !!(request.origin || request.referer);\n      };\n\n      expect(hasValidOrigin({ origin: 'http://localhost:3000' })).toBe(true);\n      expect(hasValidOrigin({ referer: 'http://localhost:3000' })).toBe(true);\n      expect(hasValidOrigin({})).toBe(false);\n    });\n  });\n\n  describe('SameSite cookie protection', () => {\n    it('should use SameSite=Lax for session cookies', () => {\n      // Supabase Auth cookies should have SameSite=Lax or SameSite=Strict\n      // This prevents cookies from being sent in cross-site requests\n      \n      // SameSite=Lax: Cookies sent with top-level navigation (GET)\n      // SameSite=Strict: Cookies never sent in cross-site requests\n      \n      expect(true).toBe(true); // Documentation test\n    });\n\n    it('should not send cookies in cross-origin POST requests', () => {\n      // With SameSite=Lax, cookies are not sent with cross-origin POST\n      // This prevents CSRF attacks that rely on automatic cookie sending\n      \n      expect(true).toBe(true); // Documentation test\n    });\n  });\n\n  describe('State-changing operation protection', () => {\n    const stateChangingEndpoints = [\n      { method: 'POST', path: '/api/guests' },\n      { method: 'PUT', path: '/api/guests/[id]' },\n      { method: 'DELETE', path: '/api/guests/[id]' },\n      { method: 'POST', path: '/api/rsvp' },\n      { method: 'POST', path: '/api/photos/upload' },\n      { method: 'POST', path: '/api/email/send' },\n      { method: 'PUT', path: '/api/activities/[id]' },\n      { method: 'DELETE', path: '/api/activities/[id]' },\n    ];\n\n    stateChangingEndpoints.forEach(({ method, path }) => {\n      it(`should require authentication for ${method} ${path}`, () => {\n        // All state-changing operations require valid authentication\n        // Unauthenticated requests return 401 Unauthorized\n        \n        expect(true).toBe(true); // Documentation test\n      });\n    });\n\n    it('should allow GET requests without CSRF protection', () => {\n      // GET requests should be idempotent and not change state\n      // CSRF protection not required for read-only operations\n      \n      const readOnlyMethods = ['GET', 'HEAD', 'OPTIONS'];\n      \n      readOnlyMethods.forEach(method => {\n        expect(['GET', 'HEAD', 'OPTIONS']).toContain(method);\n      });\n    });\n  });\n\n  describe('Double-submit cookie pattern (if implemented)', () => {\n    it('should validate CSRF token matches cookie value', () => {\n      // If using double-submit cookie pattern:\n      // 1. Server sets CSRF token in cookie\n      // 2. Client includes token in request header or body\n      // 3. Server validates token matches cookie\n      \n      const validateCSRFToken = (cookieToken: string, requestToken: string) => {\n        return cookieToken === requestToken && cookieToken.length > 0;\n      };\n\n      expect(validateCSRFToken('abc123', 'abc123')).toBe(true);\n      expect(validateCSRFToken('abc123', 'xyz789')).toBe(false);\n      expect(validateCSRFToken('', '')).toBe(false);\n    });\n\n    it('should generate cryptographically secure CSRF tokens', () => {\n      // CSRF tokens should be:\n      // - Cryptographically random\n      // - Unique per session\n      // - Sufficiently long (at least 128 bits)\n      \n      const isValidTokenLength = (token: string) => {\n        return token.length >= 32; // 128 bits in hex = 32 characters\n      };\n\n      expect(isValidTokenLength('a'.repeat(32))).toBe(true);\n      expect(isValidTokenLength('a'.repeat(16))).toBe(false);\n    });\n  });\n\n  describe('Content-Type validation', () => {\n    it('should validate Content-Type for JSON endpoints', () => {\n      // Endpoints expecting JSON should validate Content-Type header\n      // This prevents simple form-based CSRF attacks\n      \n      const isValidContentType = (contentType: string) => {\n        return contentType.includes('application/json');\n      };\n\n      expect(isValidContentType('application/json')).toBe(true);\n      expect(isValidContentType('application/json; charset=utf-8')).toBe(true);\n      expect(isValidContentType('application/x-www-form-urlencoded')).toBe(false);\n      expect(isValidContentType('multipart/form-data')).toBe(false);\n    });\n\n    it('should reject requests with unexpected Content-Type', () => {\n      // Simple forms can only send:\n      // - application/x-www-form-urlencoded\n      // - multipart/form-data\n      // - text/plain\n      // \n      // Requiring application/json prevents simple form-based CSRF\n      \n      const simpleFormContentTypes = [\n        'application/x-www-form-urlencoded',\n        'multipart/form-data',\n        'text/plain',\n      ];\n\n      simpleFormContentTypes.forEach(contentType => {\n        expect(contentType).not.toBe('application/json');\n      });\n    });\n  });\n\n  describe('Custom request headers', () => {\n    it('should require custom headers for API requests', () => {\n      // Custom headers (e.g., X-Requested-With: XMLHttpRequest)\n      // cannot be set by simple forms, providing CSRF protection\n      \n      const hasCustomHeader = (headers: Record<string, string>) => {\n        return !!(headers['X-Requested-With'] || headers['X-CSRF-Token']);\n      };\n\n      expect(hasCustomHeader({ 'X-Requested-With': 'XMLHttpRequest' })).toBe(true);\n      expect(hasCustomHeader({ 'X-CSRF-Token': 'abc123' })).toBe(true);\n      expect(hasCustomHeader({ 'Content-Type': 'application/json' })).toBe(false);\n    });\n  });\n\n  describe('CORS configuration', () => {\n    it('should restrict CORS to trusted origins', () => {\n      // CORS headers should only allow requests from trusted origins\n      // This prevents cross-origin API access from malicious sites\n      \n      const allowedOrigins = [\n        'http://localhost:3000',\n        'https://wedding.example.com',\n      ];\n\n      const isAllowedOrigin = (origin: string) => {\n        return allowedOrigins.includes(origin);\n      };\n\n      expect(isAllowedOrigin('http://localhost:3000')).toBe(true);\n      expect(isAllowedOrigin('https://evil.com')).toBe(false);\n    });\n\n    it('should not use Access-Control-Allow-Origin: *', () => {\n      // Wildcard CORS allows any origin to make requests\n      // This defeats CSRF protection\n      \n      const isWildcardCORS = (origin: string) => {\n        return origin === '*';\n      };\n\n      expect(isWildcardCORS('*')).toBe(true);\n      expect(isWildcardCORS('http://localhost:3000')).toBe(false);\n      \n      // We should NEVER use wildcard CORS for authenticated endpoints\n    });\n\n    it('should include credentials in CORS when needed', () => {\n      // Access-Control-Allow-Credentials: true\n      // Required for cookies to be sent with cross-origin requests\n      \n      expect(true).toBe(true); // Documentation test\n    });\n  });\n\n  describe('Referer validation', () => {\n    it('should validate Referer header for sensitive operations', () => {\n      // Referer header indicates the page that initiated the request\n      // Should match expected origin for sensitive operations\n      \n      const isValidReferer = (referer: string, expectedOrigin: string) => {\n        return referer.startsWith(expectedOrigin);\n      };\n\n      expect(isValidReferer('http://localhost:3000/admin', 'http://localhost:3000')).toBe(true);\n      expect(isValidReferer('https://evil.com/attack', 'http://localhost:3000')).toBe(false);\n    });\n\n    it('should handle missing Referer header appropriately', () => {\n      // Some browsers/privacy tools strip Referer header\n      // Should fall back to other CSRF protections (auth token, origin)\n      \n      const hasCSRFProtection = (request: { referer?: string; origin?: string; auth?: string }) => {\n        return !!(request.referer || request.origin || request.auth);\n      };\n\n      expect(hasCSRFProtection({ referer: 'http://localhost:3000' })).toBe(true);\n      expect(hasCSRFProtection({ origin: 'http://localhost:3000' })).toBe(true);\n      expect(hasCSRFProtection({ auth: 'Bearer token' })).toBe(true);\n      expect(hasCSRFProtection({})).toBe(false);\n    });\n  });\n\n  describe('Integration with Supabase Auth', () => {\n    it('should leverage Supabase session-based authentication', () => {\n      // Supabase Auth provides built-in CSRF protection through:\n      // 1. Session tokens in HTTP-only cookies\n      // 2. Token validation on every request\n      // 3. Short-lived tokens with refresh mechanism\n      \n      expect(true).toBe(true); // Documentation test\n    });\n\n    it('should validate session on server-side for all protected routes', () => {\n      // Every protected API route calls:\n      // const { data: { session } } = await supabase.auth.getSession()\n      // \n      // This validates the session token and prevents CSRF\n      \n      expect(true).toBe(true); // Documentation test\n    });\n\n    it('should use secure session token storage', () => {\n      // Session tokens stored in:\n      // - HTTP-only cookies (not accessible to JavaScript)\n      // - Secure flag (only sent over HTTPS in production)\n      // - SameSite flag (not sent in cross-site requests)\n      \n      expect(true).toBe(true); // Documentation test\n    });\n  });\n\n  describe('CSRF attack scenarios', () => {\n    it('should prevent malicious form submission from external site', () => {\n      // Scenario: Attacker creates form on evil.com that POSTs to our API\n      // Protection: \n      // - Requires authentication (session token in HTTP-only cookie)\n      // - SameSite cookie prevents cookie from being sent\n      // - Origin validation rejects cross-origin requests\n      \n      expect(true).toBe(true); // Documentation test\n    });\n\n    it('should prevent malicious AJAX request from external site', () => {\n      // Scenario: Attacker uses AJAX from evil.com to call our API\n      // Protection:\n      // - CORS policy rejects cross-origin requests\n      // - Even if CORS allowed, authentication required\n      // - Session token not accessible to attacker's JavaScript\n      \n      expect(true).toBe(true); // Documentation test\n    });\n\n    it('should prevent image tag CSRF attack', () => {\n      // Scenario: <img src=\"https://wedding.example.com/api/guests/delete/123\">\n      // Protection:\n      // - GET requests should not change state (idempotent)\n      // - State-changing operations use POST/PUT/DELETE\n      // - Authentication required for all state changes\n      \n      expect(true).toBe(true); // Documentation test\n    });\n\n    it('should prevent iframe-based CSRF attack', () => {\n      // Scenario: Attacker embeds our site in iframe and submits forms\n      // Protection:\n      // - X-Frame-Options or CSP frame-ancestors prevents embedding\n      // - Authentication still required\n      // - SameSite cookies prevent cookie sending in iframe context\n      \n      expect(true).toBe(true); // Documentation test\n    });\n  });\n});\n"],"names":["describe","it","expect","toBe","validOrigins","testOrigin","origin","some","valid","startsWith","hasValidOrigin","request","referer","stateChangingEndpoints","method","path","forEach","readOnlyMethods","toContain","validateCSRFToken","cookieToken","requestToken","length","isValidTokenLength","token","repeat","isValidContentType","contentType","includes","simpleFormContentTypes","not","hasCustomHeader","headers","allowedOrigins","isAllowedOrigin","isWildcardCORS","isValidReferer","expectedOrigin","hasCSRFProtection","auth"],"mappings":"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"}