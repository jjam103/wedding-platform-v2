c18ae30219ffd78d8d634b09b6d5954a
/**
 * Property-Based Tests for Toast Notification System
 * 
 * Feature: admin-ui-modernization
 * Tests universal properties of the Toast notification system across various inputs.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = require("@testing-library/react");
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _ToastContext = require("./ToastContext");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Helper component to test toast functionality
function ToastTestComponent({ onMount }) {
    const { addToast } = (0, _ToastContext.useToast)();
    // Call onMount with addToast function when component mounts
    if (onMount) {
        onMount(addToast);
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
        "data-testid": "toast-test-component",
        children: "Test Component"
    });
}
describe('Toast System Property Tests', ()=>{
    afterEach(()=>{
        (0, _react.cleanup)();
    });
    /**
   * Property 5: Success toast on successful operations
   * Validates: Requirements 3.10, 4.9, 8.7
   * 
   * For any successful CRUD operation (create, update, delete), the system should
   * display a success toast notification with an appropriate message.
   */ describe('Feature: admin-ui-modernization, Property 5: Success toast on successful operations', ()=>{
        it('should display success toast with correct styling and message', async ()=>{
            await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
                message: _fastcheck.string({
                    minLength: 5,
                    maxLength: 200
                }).filter((s)=>{
                    const trimmed = s.trim();
                    return trimmed.length >= 5 && /[a-zA-Z0-9]/.test(trimmed);
                }),
                operation: _fastcheck.constantFrom('create', 'update', 'delete')
            }), async ({ message, operation })=>{
                let addToastFn = null;
                const { unmount } = (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ToastContext.ToastProvider, {
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(ToastTestComponent, {
                        onMount: (addToast)=>{
                            addToastFn = addToast;
                        }
                    })
                }));
                try {
                    // Add success toast
                    (0, _react.act)(()=>{
                        addToastFn({
                            type: 'success',
                            message
                        });
                    });
                    // Wait for toast to appear
                    await (0, _react.waitFor)(()=>{
                        const toast = _react.screen.getByTestId('toast-success');
                        expect(toast).toBeInTheDocument();
                    });
                    // Verify success styling (jungle green colors)
                    const toast = _react.screen.getByTestId('toast-success');
                    expect(toast).toHaveClass('bg-jungle-50');
                    expect(toast).toHaveClass('border-jungle-500');
                    expect(toast).toHaveClass('text-jungle-900');
                    // Verify message is displayed (use flexible text matcher)
                    const messageElement = toast.querySelector('p');
                    expect(messageElement?.textContent).toBe(message);
                    // Verify success icon is present (checkmark)
                    const icon = toast.querySelector('svg');
                    expect(icon).toBeInTheDocument();
                } finally{
                    unmount();
                }
            }), {
                numRuns: 50
            });
        });
        it('should auto-dismiss success toast after specified duration', async ()=>{
            await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
                message: _fastcheck.string({
                    minLength: 5,
                    maxLength: 100
                }).filter((s)=>{
                    const trimmed = s.trim();
                    return trimmed.length >= 5 && /[a-zA-Z0-9]/.test(trimmed);
                }),
                duration: _fastcheck.integer({
                    min: 100,
                    max: 1000
                })
            }), async ({ message, duration })=>{
                let addToastFn = null;
                const { unmount } = (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ToastContext.ToastProvider, {
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(ToastTestComponent, {
                        onMount: (addToast)=>{
                            addToastFn = addToast;
                        }
                    })
                }));
                try {
                    // Add success toast with custom duration
                    (0, _react.act)(()=>{
                        addToastFn({
                            type: 'success',
                            message,
                            duration
                        });
                    });
                    // Wait for toast to appear
                    await (0, _react.waitFor)(()=>{
                        expect(_react.screen.getByTestId('toast-success')).toBeInTheDocument();
                    });
                    // Wait for toast to auto-dismiss (duration + buffer)
                    await (0, _react.waitFor)(()=>{
                        expect(_react.screen.queryByTestId('toast-success')).not.toBeInTheDocument();
                    }, {
                        timeout: duration + 500
                    });
                } finally{
                    unmount();
                }
            }), {
                numRuns: 20
            } // Fewer runs due to timing-based test
            );
        }, 30000); // Increased timeout for timing-based tests
    });
    /**
   * Property 6: Error toast on failed operations
   * Validates: Requirements 3.11, 12.1
   * 
   * For any failed CRUD operation, the system should display an error toast
   * notification with a user-friendly error message.
   */ describe('Feature: admin-ui-modernization, Property 6: Error toast on failed operations', ()=>{
        it('should display error toast with correct styling and message', async ()=>{
            await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
                message: _fastcheck.string({
                    minLength: 5,
                    maxLength: 200
                }).filter((s)=>{
                    const trimmed = s.trim();
                    return trimmed.length >= 5 && /[a-zA-Z0-9]/.test(trimmed);
                }),
                errorType: _fastcheck.constantFrom('VALIDATION_ERROR', 'DATABASE_ERROR', 'UNAUTHORIZED', 'NOT_FOUND')
            }), async ({ message, errorType })=>{
                let addToastFn = null;
                const { unmount } = (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ToastContext.ToastProvider, {
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(ToastTestComponent, {
                        onMount: (addToast)=>{
                            addToastFn = addToast;
                        }
                    })
                }));
                try {
                    // Add error toast
                    (0, _react.act)(()=>{
                        addToastFn({
                            type: 'error',
                            message
                        });
                    });
                    // Wait for toast to appear
                    await (0, _react.waitFor)(()=>{
                        const toast = _react.screen.getByTestId('toast-error');
                        expect(toast).toBeInTheDocument();
                    });
                    // Verify error styling (volcano red colors)
                    const toast = _react.screen.getByTestId('toast-error');
                    expect(toast).toHaveClass('bg-volcano-50');
                    expect(toast).toHaveClass('border-volcano-500');
                    expect(toast).toHaveClass('text-volcano-900');
                    // Verify message is displayed (use flexible text matcher)
                    const messageElement = toast.querySelector('p');
                    expect(messageElement?.textContent).toBe(message);
                    // Verify error icon is present (X mark)
                    const icon = toast.querySelector('svg');
                    expect(icon).toBeInTheDocument();
                } finally{
                    unmount();
                }
            }), {
                numRuns: 50
            });
        });
        it('should display warning toast with correct styling', async ()=>{
            await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
                message: _fastcheck.string({
                    minLength: 5,
                    maxLength: 200
                }).filter((s)=>{
                    const trimmed = s.trim();
                    return trimmed.length >= 5 && /[a-zA-Z0-9]/.test(trimmed);
                })
            }), async ({ message })=>{
                let addToastFn = null;
                const { unmount } = (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ToastContext.ToastProvider, {
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(ToastTestComponent, {
                        onMount: (addToast)=>{
                            addToastFn = addToast;
                        }
                    })
                }));
                try {
                    // Add warning toast
                    (0, _react.act)(()=>{
                        addToastFn({
                            type: 'warning',
                            message
                        });
                    });
                    // Wait for toast to appear
                    await (0, _react.waitFor)(()=>{
                        const toast = _react.screen.getByTestId('toast-warning');
                        expect(toast).toBeInTheDocument();
                    });
                    // Verify warning styling (sunset orange colors)
                    const toast = _react.screen.getByTestId('toast-warning');
                    expect(toast).toHaveClass('bg-sunset-50');
                    expect(toast).toHaveClass('border-sunset-500');
                    expect(toast).toHaveClass('text-sunset-900');
                    // Verify message is displayed (use flexible text matcher)
                    const messageElement = toast.querySelector('p');
                    expect(messageElement?.textContent).toBe(message);
                } finally{
                    unmount();
                }
            }), {
                numRuns: 50
            });
        });
        it('should display info toast with correct styling', async ()=>{
            await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
                message: _fastcheck.string({
                    minLength: 5,
                    maxLength: 200
                }).filter((s)=>{
                    const trimmed = s.trim();
                    return trimmed.length >= 5 && /[a-zA-Z0-9]/.test(trimmed);
                })
            }), async ({ message })=>{
                let addToastFn = null;
                const { unmount } = (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ToastContext.ToastProvider, {
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(ToastTestComponent, {
                        onMount: (addToast)=>{
                            addToastFn = addToast;
                        }
                    })
                }));
                try {
                    // Add info toast
                    (0, _react.act)(()=>{
                        addToastFn({
                            type: 'info',
                            message
                        });
                    });
                    // Wait for toast to appear
                    await (0, _react.waitFor)(()=>{
                        const toast = _react.screen.getByTestId('toast-info');
                        expect(toast).toBeInTheDocument();
                    });
                    // Verify info styling (ocean blue colors)
                    const toast = _react.screen.getByTestId('toast-info');
                    expect(toast).toHaveClass('bg-ocean-50');
                    expect(toast).toHaveClass('border-ocean-500');
                    expect(toast).toHaveClass('text-ocean-900');
                    // Verify message is displayed (use flexible text matcher)
                    const messageElement = toast.querySelector('p');
                    expect(messageElement?.textContent).toBe(message);
                } finally{
                    unmount();
                }
            }), {
                numRuns: 50
            });
        });
    });
    /**
   * Additional property: Multiple toasts stack vertically
   * 
   * For any number of toasts displayed simultaneously, they should stack
   * vertically without overlapping.
   */ describe('Feature: admin-ui-modernization, Multiple toasts stack vertically', ()=>{
        it('should stack multiple toasts vertically', async ()=>{
            await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.array(_fastcheck.record({
                message: _fastcheck.string({
                    minLength: 5,
                    maxLength: 50
                }).filter((s)=>{
                    const trimmed = s.trim();
                    return trimmed.length >= 5 && /[a-zA-Z0-9]/.test(trimmed);
                }),
                type: _fastcheck.constantFrom('success', 'error', 'warning', 'info')
            }), {
                minLength: 2,
                maxLength: 3
            } // Reduced to 3 for faster tests
            ), async (toasts)=>{
                let addToastFn = null;
                const { unmount } = (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ToastContext.ToastProvider, {
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(ToastTestComponent, {
                        onMount: (addToast)=>{
                            addToastFn = addToast;
                        }
                    })
                }));
                try {
                    // Add all toasts
                    (0, _react.act)(()=>{
                        toasts.forEach((toast)=>{
                            addToastFn({
                                type: toast.type,
                                message: toast.message,
                                duration: 10000
                            });
                        });
                    });
                    // Wait for all toasts to appear
                    await (0, _react.waitFor)(()=>{
                        const displayedToasts = _react.screen.getAllByRole('alert');
                        expect(displayedToasts.length).toBe(toasts.length);
                    }, {
                        timeout: 2000
                    });
                    // Verify each toast message is displayed by checking all alerts
                    const displayedToasts = _react.screen.getAllByRole('alert');
                    toasts.forEach((toast, index)=>{
                        const toastElement = displayedToasts[index];
                        const messageElement = toastElement.querySelector('p');
                        expect(messageElement?.textContent).toBe(toast.message);
                    });
                } finally{
                    unmount();
                }
            }), {
                numRuns: 20
            } // Reduced runs for performance
            );
        }, 15000); // Increased timeout
    });
    /**
   * Additional property: Toast close button functionality
   * 
   * For any toast, clicking the close button should immediately remove the toast.
   */ describe('Feature: admin-ui-modernization, Toast close button functionality', ()=>{
        it('should remove toast when close button is clicked', async ()=>{
            await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
                message: _fastcheck.string({
                    minLength: 5,
                    maxLength: 100
                }).filter((s)=>{
                    const trimmed = s.trim();
                    return trimmed.length >= 5 && /[a-zA-Z0-9]/.test(trimmed);
                }),
                type: _fastcheck.constantFrom('success', 'error', 'warning', 'info')
            }), async ({ message, type })=>{
                let addToastFn = null;
                const { unmount } = (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ToastContext.ToastProvider, {
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(ToastTestComponent, {
                        onMount: (addToast)=>{
                            addToastFn = addToast;
                        }
                    })
                }));
                try {
                    // Add toast with long duration so it doesn't auto-dismiss
                    (0, _react.act)(()=>{
                        addToastFn({
                            type: type,
                            message,
                            duration: 10000
                        });
                    });
                    // Wait for toast to appear
                    await (0, _react.waitFor)(()=>{
                        expect(_react.screen.getByTestId(`toast-${type}`)).toBeInTheDocument();
                    });
                    // Get the toast element and find its close button
                    const toast = _react.screen.getByTestId(`toast-${type}`);
                    const closeButton = toast.querySelector('button[aria-label="Close notification"]');
                    expect(closeButton).toBeInTheDocument();
                    // Click close button
                    (0, _react.act)(()=>{
                        closeButton.click();
                    });
                    // Verify toast is removed
                    await (0, _react.waitFor)(()=>{
                        expect(_react.screen.queryByTestId(`toast-${type}`)).not.toBeInTheDocument();
                    });
                } finally{
                    unmount();
                }
            }), {
                numRuns: 50
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvY29tcG9uZW50cy91aS9Ub2FzdC5wcm9wZXJ0eS50ZXN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFByb3BlcnR5LUJhc2VkIFRlc3RzIGZvciBUb2FzdCBOb3RpZmljYXRpb24gU3lzdGVtXG4gKiBcbiAqIEZlYXR1cmU6IGFkbWluLXVpLW1vZGVybml6YXRpb25cbiAqIFRlc3RzIHVuaXZlcnNhbCBwcm9wZXJ0aWVzIG9mIHRoZSBUb2FzdCBub3RpZmljYXRpb24gc3lzdGVtIGFjcm9zcyB2YXJpb3VzIGlucHV0cy5cbiAqL1xuXG5pbXBvcnQgeyByZW5kZXIsIHNjcmVlbiwgd2FpdEZvciwgY2xlYW51cCwgYWN0IH0gZnJvbSAnQHRlc3RpbmctbGlicmFyeS9yZWFjdCc7XG5pbXBvcnQgKiBhcyBmYyBmcm9tICdmYXN0LWNoZWNrJztcbmltcG9ydCB7IFRvYXN0UHJvdmlkZXIsIHVzZVRvYXN0IH0gZnJvbSAnLi9Ub2FzdENvbnRleHQnO1xuaW1wb3J0IHR5cGUgeyBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5cbi8vIEhlbHBlciBjb21wb25lbnQgdG8gdGVzdCB0b2FzdCBmdW5jdGlvbmFsaXR5XG5mdW5jdGlvbiBUb2FzdFRlc3RDb21wb25lbnQoeyBcbiAgb25Nb3VudCBcbn06IHsgXG4gIG9uTW91bnQ6IChhZGRUb2FzdDogUmV0dXJuVHlwZTx0eXBlb2YgdXNlVG9hc3Q+WydhZGRUb2FzdCddKSA9PiB2b2lkIFxufSkge1xuICBjb25zdCB7IGFkZFRvYXN0IH0gPSB1c2VUb2FzdCgpO1xuICBcbiAgLy8gQ2FsbCBvbk1vdW50IHdpdGggYWRkVG9hc3QgZnVuY3Rpb24gd2hlbiBjb21wb25lbnQgbW91bnRzXG4gIGlmIChvbk1vdW50KSB7XG4gICAgb25Nb3VudChhZGRUb2FzdCk7XG4gIH1cbiAgXG4gIHJldHVybiA8ZGl2IGRhdGEtdGVzdGlkPVwidG9hc3QtdGVzdC1jb21wb25lbnRcIj5UZXN0IENvbXBvbmVudDwvZGl2Pjtcbn1cblxuZGVzY3JpYmUoJ1RvYXN0IFN5c3RlbSBQcm9wZXJ0eSBUZXN0cycsICgpID0+IHtcbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBjbGVhbnVwKCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQcm9wZXJ0eSA1OiBTdWNjZXNzIHRvYXN0IG9uIHN1Y2Nlc3NmdWwgb3BlcmF0aW9uc1xuICAgKiBWYWxpZGF0ZXM6IFJlcXVpcmVtZW50cyAzLjEwLCA0LjksIDguN1xuICAgKiBcbiAgICogRm9yIGFueSBzdWNjZXNzZnVsIENSVUQgb3BlcmF0aW9uIChjcmVhdGUsIHVwZGF0ZSwgZGVsZXRlKSwgdGhlIHN5c3RlbSBzaG91bGRcbiAgICogZGlzcGxheSBhIHN1Y2Nlc3MgdG9hc3Qgbm90aWZpY2F0aW9uIHdpdGggYW4gYXBwcm9wcmlhdGUgbWVzc2FnZS5cbiAgICovXG4gIGRlc2NyaWJlKCdGZWF0dXJlOiBhZG1pbi11aS1tb2Rlcm5pemF0aW9uLCBQcm9wZXJ0eSA1OiBTdWNjZXNzIHRvYXN0IG9uIHN1Y2Nlc3NmdWwgb3BlcmF0aW9ucycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGRpc3BsYXkgc3VjY2VzcyB0b2FzdCB3aXRoIGNvcnJlY3Qgc3R5bGluZyBhbmQgbWVzc2FnZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgICAgbWVzc2FnZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiA1LCBtYXhMZW5ndGg6IDIwMCB9KS5maWx0ZXIocyA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWQgPSBzLnRyaW0oKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRyaW1tZWQubGVuZ3RoID49IDUgJiYgL1thLXpBLVowLTldLy50ZXN0KHRyaW1tZWQpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvcGVyYXRpb246IGZjLmNvbnN0YW50RnJvbSgnY3JlYXRlJywgJ3VwZGF0ZScsICdkZWxldGUnKSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBhc3luYyAoeyBtZXNzYWdlLCBvcGVyYXRpb24gfSkgPT4ge1xuICAgICAgICAgICAgbGV0IGFkZFRvYXN0Rm46IFJldHVyblR5cGU8dHlwZW9mIHVzZVRvYXN0PlsnYWRkVG9hc3QnXSB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgICAgICBjb25zdCB7IHVubW91bnQgfSA9IHJlbmRlcihcbiAgICAgICAgICAgICAgPFRvYXN0UHJvdmlkZXI+XG4gICAgICAgICAgICAgICAgPFRvYXN0VGVzdENvbXBvbmVudCBcbiAgICAgICAgICAgICAgICAgIG9uTW91bnQ9eyhhZGRUb2FzdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhZGRUb2FzdEZuID0gYWRkVG9hc3Q7XG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvVG9hc3RQcm92aWRlcj5cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIEFkZCBzdWNjZXNzIHRvYXN0XG4gICAgICAgICAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgYWRkVG9hc3RGbiEoeyB0eXBlOiAnc3VjY2VzcycsIG1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRvYXN0IHRvIGFwcGVhclxuICAgICAgICAgICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2FzdCA9IHNjcmVlbi5nZXRCeVRlc3RJZCgndG9hc3Qtc3VjY2VzcycpO1xuICAgICAgICAgICAgICAgIGV4cGVjdCh0b2FzdCkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgLy8gVmVyaWZ5IHN1Y2Nlc3Mgc3R5bGluZyAoanVuZ2xlIGdyZWVuIGNvbG9ycylcbiAgICAgICAgICAgICAgY29uc3QgdG9hc3QgPSBzY3JlZW4uZ2V0QnlUZXN0SWQoJ3RvYXN0LXN1Y2Nlc3MnKTtcbiAgICAgICAgICAgICAgZXhwZWN0KHRvYXN0KS50b0hhdmVDbGFzcygnYmctanVuZ2xlLTUwJyk7XG4gICAgICAgICAgICAgIGV4cGVjdCh0b2FzdCkudG9IYXZlQ2xhc3MoJ2JvcmRlci1qdW5nbGUtNTAwJyk7XG4gICAgICAgICAgICAgIGV4cGVjdCh0b2FzdCkudG9IYXZlQ2xhc3MoJ3RleHQtanVuZ2xlLTkwMCcpO1xuXG4gICAgICAgICAgICAgIC8vIFZlcmlmeSBtZXNzYWdlIGlzIGRpc3BsYXllZCAodXNlIGZsZXhpYmxlIHRleHQgbWF0Y2hlcilcbiAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZUVsZW1lbnQgPSB0b2FzdC5xdWVyeVNlbGVjdG9yKCdwJyk7XG4gICAgICAgICAgICAgIGV4cGVjdChtZXNzYWdlRWxlbWVudD8udGV4dENvbnRlbnQpLnRvQmUobWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgLy8gVmVyaWZ5IHN1Y2Nlc3MgaWNvbiBpcyBwcmVzZW50IChjaGVja21hcmspXG4gICAgICAgICAgICAgIGNvbnN0IGljb24gPSB0b2FzdC5xdWVyeVNlbGVjdG9yKCdzdmcnKTtcbiAgICAgICAgICAgICAgZXhwZWN0KGljb24pLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB1bm1vdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDUwIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGF1dG8tZGlzbWlzcyBzdWNjZXNzIHRvYXN0IGFmdGVyIHNwZWNpZmllZCBkdXJhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgICAgbWVzc2FnZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiA1LCBtYXhMZW5ndGg6IDEwMCB9KS5maWx0ZXIocyA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWQgPSBzLnRyaW0oKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRyaW1tZWQubGVuZ3RoID49IDUgJiYgL1thLXpBLVowLTldLy50ZXN0KHRyaW1tZWQpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBkdXJhdGlvbjogZmMuaW50ZWdlcih7IG1pbjogMTAwLCBtYXg6IDEwMDAgfSksIC8vIFNob3J0IGR1cmF0aW9ucyBmb3IgdGVzdGluZ1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGFzeW5jICh7IG1lc3NhZ2UsIGR1cmF0aW9uIH0pID0+IHtcbiAgICAgICAgICAgIGxldCBhZGRUb2FzdEZuOiBSZXR1cm5UeXBlPHR5cGVvZiB1c2VUb2FzdD5bJ2FkZFRvYXN0J10gfCBudWxsID0gbnVsbDtcblxuICAgICAgICAgICAgY29uc3QgeyB1bm1vdW50IH0gPSByZW5kZXIoXG4gICAgICAgICAgICAgIDxUb2FzdFByb3ZpZGVyPlxuICAgICAgICAgICAgICAgIDxUb2FzdFRlc3RDb21wb25lbnQgXG4gICAgICAgICAgICAgICAgICBvbk1vdW50PXsoYWRkVG9hc3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYWRkVG9hc3RGbiA9IGFkZFRvYXN0O1xuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L1RvYXN0UHJvdmlkZXI+XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBBZGQgc3VjY2VzcyB0b2FzdCB3aXRoIGN1c3RvbSBkdXJhdGlvblxuICAgICAgICAgICAgICBhY3QoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGFkZFRvYXN0Rm4hKHsgdHlwZTogJ3N1Y2Nlc3MnLCBtZXNzYWdlLCBkdXJhdGlvbiB9KTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgLy8gV2FpdCBmb3IgdG9hc3QgdG8gYXBwZWFyXG4gICAgICAgICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXN0SWQoJ3RvYXN0LXN1Y2Nlc3MnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgLy8gV2FpdCBmb3IgdG9hc3QgdG8gYXV0by1kaXNtaXNzIChkdXJhdGlvbiArIGJ1ZmZlcilcbiAgICAgICAgICAgICAgYXdhaXQgd2FpdEZvcihcbiAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlUZXN0SWQoJ3RvYXN0LXN1Y2Nlc3MnKSkubm90LnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7IHRpbWVvdXQ6IGR1cmF0aW9uICsgNTAwIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHVubW91bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHsgbnVtUnVuczogMjAgfSAvLyBGZXdlciBydW5zIGR1ZSB0byB0aW1pbmctYmFzZWQgdGVzdFxuICAgICAgKTtcbiAgICB9LCAzMDAwMCk7IC8vIEluY3JlYXNlZCB0aW1lb3V0IGZvciB0aW1pbmctYmFzZWQgdGVzdHNcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFByb3BlcnR5IDY6IEVycm9yIHRvYXN0IG9uIGZhaWxlZCBvcGVyYXRpb25zXG4gICAqIFZhbGlkYXRlczogUmVxdWlyZW1lbnRzIDMuMTEsIDEyLjFcbiAgICogXG4gICAqIEZvciBhbnkgZmFpbGVkIENSVUQgb3BlcmF0aW9uLCB0aGUgc3lzdGVtIHNob3VsZCBkaXNwbGF5IGFuIGVycm9yIHRvYXN0XG4gICAqIG5vdGlmaWNhdGlvbiB3aXRoIGEgdXNlci1mcmllbmRseSBlcnJvciBtZXNzYWdlLlxuICAgKi9cbiAgZGVzY3JpYmUoJ0ZlYXR1cmU6IGFkbWluLXVpLW1vZGVybml6YXRpb24sIFByb3BlcnR5IDY6IEVycm9yIHRvYXN0IG9uIGZhaWxlZCBvcGVyYXRpb25zJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZGlzcGxheSBlcnJvciB0b2FzdCB3aXRoIGNvcnJlY3Qgc3R5bGluZyBhbmQgbWVzc2FnZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgICAgbWVzc2FnZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiA1LCBtYXhMZW5ndGg6IDIwMCB9KS5maWx0ZXIocyA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWQgPSBzLnRyaW0oKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRyaW1tZWQubGVuZ3RoID49IDUgJiYgL1thLXpBLVowLTldLy50ZXN0KHRyaW1tZWQpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBlcnJvclR5cGU6IGZjLmNvbnN0YW50RnJvbSgnVkFMSURBVElPTl9FUlJPUicsICdEQVRBQkFTRV9FUlJPUicsICdVTkFVVEhPUklaRUQnLCAnTk9UX0ZPVU5EJyksXG4gICAgICAgICAgfSksXG4gICAgICAgICAgYXN5bmMgKHsgbWVzc2FnZSwgZXJyb3JUeXBlIH0pID0+IHtcbiAgICAgICAgICAgIGxldCBhZGRUb2FzdEZuOiBSZXR1cm5UeXBlPHR5cGVvZiB1c2VUb2FzdD5bJ2FkZFRvYXN0J10gfCBudWxsID0gbnVsbDtcblxuICAgICAgICAgICAgY29uc3QgeyB1bm1vdW50IH0gPSByZW5kZXIoXG4gICAgICAgICAgICAgIDxUb2FzdFByb3ZpZGVyPlxuICAgICAgICAgICAgICAgIDxUb2FzdFRlc3RDb21wb25lbnQgXG4gICAgICAgICAgICAgICAgICBvbk1vdW50PXsoYWRkVG9hc3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYWRkVG9hc3RGbiA9IGFkZFRvYXN0O1xuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L1RvYXN0UHJvdmlkZXI+XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBBZGQgZXJyb3IgdG9hc3RcbiAgICAgICAgICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBhZGRUb2FzdEZuISh7IHR5cGU6ICdlcnJvcicsIG1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRvYXN0IHRvIGFwcGVhclxuICAgICAgICAgICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2FzdCA9IHNjcmVlbi5nZXRCeVRlc3RJZCgndG9hc3QtZXJyb3InKTtcbiAgICAgICAgICAgICAgICBleHBlY3QodG9hc3QpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIC8vIFZlcmlmeSBlcnJvciBzdHlsaW5nICh2b2xjYW5vIHJlZCBjb2xvcnMpXG4gICAgICAgICAgICAgIGNvbnN0IHRvYXN0ID0gc2NyZWVuLmdldEJ5VGVzdElkKCd0b2FzdC1lcnJvcicpO1xuICAgICAgICAgICAgICBleHBlY3QodG9hc3QpLnRvSGF2ZUNsYXNzKCdiZy12b2xjYW5vLTUwJyk7XG4gICAgICAgICAgICAgIGV4cGVjdCh0b2FzdCkudG9IYXZlQ2xhc3MoJ2JvcmRlci12b2xjYW5vLTUwMCcpO1xuICAgICAgICAgICAgICBleHBlY3QodG9hc3QpLnRvSGF2ZUNsYXNzKCd0ZXh0LXZvbGNhbm8tOTAwJyk7XG5cbiAgICAgICAgICAgICAgLy8gVmVyaWZ5IG1lc3NhZ2UgaXMgZGlzcGxheWVkICh1c2UgZmxleGlibGUgdGV4dCBtYXRjaGVyKVxuICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlRWxlbWVudCA9IHRvYXN0LnF1ZXJ5U2VsZWN0b3IoJ3AnKTtcbiAgICAgICAgICAgICAgZXhwZWN0KG1lc3NhZ2VFbGVtZW50Py50ZXh0Q29udGVudCkudG9CZShtZXNzYWdlKTtcblxuICAgICAgICAgICAgICAvLyBWZXJpZnkgZXJyb3IgaWNvbiBpcyBwcmVzZW50IChYIG1hcmspXG4gICAgICAgICAgICAgIGNvbnN0IGljb24gPSB0b2FzdC5xdWVyeVNlbGVjdG9yKCdzdmcnKTtcbiAgICAgICAgICAgICAgZXhwZWN0KGljb24pLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB1bm1vdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDUwIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRpc3BsYXkgd2FybmluZyB0b2FzdCB3aXRoIGNvcnJlY3Qgc3R5bGluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgICAgbWVzc2FnZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiA1LCBtYXhMZW5ndGg6IDIwMCB9KS5maWx0ZXIocyA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWQgPSBzLnRyaW0oKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRyaW1tZWQubGVuZ3RoID49IDUgJiYgL1thLXpBLVowLTldLy50ZXN0KHRyaW1tZWQpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSksXG4gICAgICAgICAgYXN5bmMgKHsgbWVzc2FnZSB9KSA9PiB7XG4gICAgICAgICAgICBsZXQgYWRkVG9hc3RGbjogUmV0dXJuVHlwZTx0eXBlb2YgdXNlVG9hc3Q+WydhZGRUb2FzdCddIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgdW5tb3VudCB9ID0gcmVuZGVyKFxuICAgICAgICAgICAgICA8VG9hc3RQcm92aWRlcj5cbiAgICAgICAgICAgICAgICA8VG9hc3RUZXN0Q29tcG9uZW50IFxuICAgICAgICAgICAgICAgICAgb25Nb3VudD17KGFkZFRvYXN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFRvYXN0Rm4gPSBhZGRUb2FzdDtcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPC9Ub2FzdFByb3ZpZGVyPlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gQWRkIHdhcm5pbmcgdG9hc3RcbiAgICAgICAgICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBhZGRUb2FzdEZuISh7IHR5cGU6ICd3YXJuaW5nJywgbWVzc2FnZSB9KTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgLy8gV2FpdCBmb3IgdG9hc3QgdG8gYXBwZWFyXG4gICAgICAgICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvYXN0ID0gc2NyZWVuLmdldEJ5VGVzdElkKCd0b2FzdC13YXJuaW5nJyk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHRvYXN0KS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAvLyBWZXJpZnkgd2FybmluZyBzdHlsaW5nIChzdW5zZXQgb3JhbmdlIGNvbG9ycylcbiAgICAgICAgICAgICAgY29uc3QgdG9hc3QgPSBzY3JlZW4uZ2V0QnlUZXN0SWQoJ3RvYXN0LXdhcm5pbmcnKTtcbiAgICAgICAgICAgICAgZXhwZWN0KHRvYXN0KS50b0hhdmVDbGFzcygnYmctc3Vuc2V0LTUwJyk7XG4gICAgICAgICAgICAgIGV4cGVjdCh0b2FzdCkudG9IYXZlQ2xhc3MoJ2JvcmRlci1zdW5zZXQtNTAwJyk7XG4gICAgICAgICAgICAgIGV4cGVjdCh0b2FzdCkudG9IYXZlQ2xhc3MoJ3RleHQtc3Vuc2V0LTkwMCcpO1xuXG4gICAgICAgICAgICAgIC8vIFZlcmlmeSBtZXNzYWdlIGlzIGRpc3BsYXllZCAodXNlIGZsZXhpYmxlIHRleHQgbWF0Y2hlcilcbiAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZUVsZW1lbnQgPSB0b2FzdC5xdWVyeVNlbGVjdG9yKCdwJyk7XG4gICAgICAgICAgICAgIGV4cGVjdChtZXNzYWdlRWxlbWVudD8udGV4dENvbnRlbnQpLnRvQmUobWVzc2FnZSk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB1bm1vdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDUwIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRpc3BsYXkgaW5mbyB0b2FzdCB3aXRoIGNvcnJlY3Qgc3R5bGluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgICAgbWVzc2FnZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiA1LCBtYXhMZW5ndGg6IDIwMCB9KS5maWx0ZXIocyA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWQgPSBzLnRyaW0oKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRyaW1tZWQubGVuZ3RoID49IDUgJiYgL1thLXpBLVowLTldLy50ZXN0KHRyaW1tZWQpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSksXG4gICAgICAgICAgYXN5bmMgKHsgbWVzc2FnZSB9KSA9PiB7XG4gICAgICAgICAgICBsZXQgYWRkVG9hc3RGbjogUmV0dXJuVHlwZTx0eXBlb2YgdXNlVG9hc3Q+WydhZGRUb2FzdCddIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgdW5tb3VudCB9ID0gcmVuZGVyKFxuICAgICAgICAgICAgICA8VG9hc3RQcm92aWRlcj5cbiAgICAgICAgICAgICAgICA8VG9hc3RUZXN0Q29tcG9uZW50IFxuICAgICAgICAgICAgICAgICAgb25Nb3VudD17KGFkZFRvYXN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFRvYXN0Rm4gPSBhZGRUb2FzdDtcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPC9Ub2FzdFByb3ZpZGVyPlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gQWRkIGluZm8gdG9hc3RcbiAgICAgICAgICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBhZGRUb2FzdEZuISh7IHR5cGU6ICdpbmZvJywgbWVzc2FnZSB9KTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgLy8gV2FpdCBmb3IgdG9hc3QgdG8gYXBwZWFyXG4gICAgICAgICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvYXN0ID0gc2NyZWVuLmdldEJ5VGVzdElkKCd0b2FzdC1pbmZvJyk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHRvYXN0KS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAvLyBWZXJpZnkgaW5mbyBzdHlsaW5nIChvY2VhbiBibHVlIGNvbG9ycylcbiAgICAgICAgICAgICAgY29uc3QgdG9hc3QgPSBzY3JlZW4uZ2V0QnlUZXN0SWQoJ3RvYXN0LWluZm8nKTtcbiAgICAgICAgICAgICAgZXhwZWN0KHRvYXN0KS50b0hhdmVDbGFzcygnYmctb2NlYW4tNTAnKTtcbiAgICAgICAgICAgICAgZXhwZWN0KHRvYXN0KS50b0hhdmVDbGFzcygnYm9yZGVyLW9jZWFuLTUwMCcpO1xuICAgICAgICAgICAgICBleHBlY3QodG9hc3QpLnRvSGF2ZUNsYXNzKCd0ZXh0LW9jZWFuLTkwMCcpO1xuXG4gICAgICAgICAgICAgIC8vIFZlcmlmeSBtZXNzYWdlIGlzIGRpc3BsYXllZCAodXNlIGZsZXhpYmxlIHRleHQgbWF0Y2hlcilcbiAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZUVsZW1lbnQgPSB0b2FzdC5xdWVyeVNlbGVjdG9yKCdwJyk7XG4gICAgICAgICAgICAgIGV4cGVjdChtZXNzYWdlRWxlbWVudD8udGV4dENvbnRlbnQpLnRvQmUobWVzc2FnZSk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB1bm1vdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDUwIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBZGRpdGlvbmFsIHByb3BlcnR5OiBNdWx0aXBsZSB0b2FzdHMgc3RhY2sgdmVydGljYWxseVxuICAgKiBcbiAgICogRm9yIGFueSBudW1iZXIgb2YgdG9hc3RzIGRpc3BsYXllZCBzaW11bHRhbmVvdXNseSwgdGhleSBzaG91bGQgc3RhY2tcbiAgICogdmVydGljYWxseSB3aXRob3V0IG92ZXJsYXBwaW5nLlxuICAgKi9cbiAgZGVzY3JpYmUoJ0ZlYXR1cmU6IGFkbWluLXVpLW1vZGVybml6YXRpb24sIE11bHRpcGxlIHRvYXN0cyBzdGFjayB2ZXJ0aWNhbGx5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgc3RhY2sgbXVsdGlwbGUgdG9hc3RzIHZlcnRpY2FsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgICAgZmMuYXJyYXkoXG4gICAgICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgICAgICBtZXNzYWdlOiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDUsIG1heExlbmd0aDogNTAgfSkuZmlsdGVyKHMgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWQgPSBzLnRyaW0oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJpbW1lZC5sZW5ndGggPj0gNSAmJiAvW2EtekEtWjAtOV0vLnRlc3QodHJpbW1lZCk7XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB0eXBlOiBmYy5jb25zdGFudEZyb20oJ3N1Y2Nlc3MnLCAnZXJyb3InLCAnd2FybmluZycsICdpbmZvJyksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHsgbWluTGVuZ3RoOiAyLCBtYXhMZW5ndGg6IDMgfSAvLyBSZWR1Y2VkIHRvIDMgZm9yIGZhc3RlciB0ZXN0c1xuICAgICAgICAgICksXG4gICAgICAgICAgYXN5bmMgKHRvYXN0cykgPT4ge1xuICAgICAgICAgICAgbGV0IGFkZFRvYXN0Rm46IFJldHVyblR5cGU8dHlwZW9mIHVzZVRvYXN0PlsnYWRkVG9hc3QnXSB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgICAgICBjb25zdCB7IHVubW91bnQgfSA9IHJlbmRlcihcbiAgICAgICAgICAgICAgPFRvYXN0UHJvdmlkZXI+XG4gICAgICAgICAgICAgICAgPFRvYXN0VGVzdENvbXBvbmVudCBcbiAgICAgICAgICAgICAgICAgIG9uTW91bnQ9eyhhZGRUb2FzdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhZGRUb2FzdEZuID0gYWRkVG9hc3Q7XG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvVG9hc3RQcm92aWRlcj5cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIEFkZCBhbGwgdG9hc3RzXG4gICAgICAgICAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdG9hc3RzLmZvckVhY2godG9hc3QgPT4ge1xuICAgICAgICAgICAgICAgICAgYWRkVG9hc3RGbiEoeyB0eXBlOiB0b2FzdC50eXBlIGFzIGFueSwgbWVzc2FnZTogdG9hc3QubWVzc2FnZSwgZHVyYXRpb246IDEwMDAwIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAvLyBXYWl0IGZvciBhbGwgdG9hc3RzIHRvIGFwcGVhclxuICAgICAgICAgICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNwbGF5ZWRUb2FzdHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCdhbGVydCcpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChkaXNwbGF5ZWRUb2FzdHMubGVuZ3RoKS50b0JlKHRvYXN0cy5sZW5ndGgpO1xuICAgICAgICAgICAgICB9LCB7IHRpbWVvdXQ6IDIwMDAgfSk7XG5cbiAgICAgICAgICAgICAgLy8gVmVyaWZ5IGVhY2ggdG9hc3QgbWVzc2FnZSBpcyBkaXNwbGF5ZWQgYnkgY2hlY2tpbmcgYWxsIGFsZXJ0c1xuICAgICAgICAgICAgICBjb25zdCBkaXNwbGF5ZWRUb2FzdHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCdhbGVydCcpO1xuICAgICAgICAgICAgICB0b2FzdHMuZm9yRWFjaCgodG9hc3QsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9hc3RFbGVtZW50ID0gZGlzcGxheWVkVG9hc3RzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlRWxlbWVudCA9IHRvYXN0RWxlbWVudC5xdWVyeVNlbGVjdG9yKCdwJyk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KG1lc3NhZ2VFbGVtZW50Py50ZXh0Q29udGVudCkudG9CZSh0b2FzdC5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB1bm1vdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDIwIH0gLy8gUmVkdWNlZCBydW5zIGZvciBwZXJmb3JtYW5jZVxuICAgICAgKTtcbiAgICB9LCAxNTAwMCk7IC8vIEluY3JlYXNlZCB0aW1lb3V0XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBZGRpdGlvbmFsIHByb3BlcnR5OiBUb2FzdCBjbG9zZSBidXR0b24gZnVuY3Rpb25hbGl0eVxuICAgKiBcbiAgICogRm9yIGFueSB0b2FzdCwgY2xpY2tpbmcgdGhlIGNsb3NlIGJ1dHRvbiBzaG91bGQgaW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSB0b2FzdC5cbiAgICovXG4gIGRlc2NyaWJlKCdGZWF0dXJlOiBhZG1pbi11aS1tb2Rlcm5pemF0aW9uLCBUb2FzdCBjbG9zZSBidXR0b24gZnVuY3Rpb25hbGl0eScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJlbW92ZSB0b2FzdCB3aGVuIGNsb3NlIGJ1dHRvbiBpcyBjbGlja2VkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICAgIGZjLnJlY29yZCh7XG4gICAgICAgICAgICBtZXNzYWdlOiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDUsIG1heExlbmd0aDogMTAwIH0pLmZpbHRlcihzID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZCA9IHMudHJpbSgpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJpbW1lZC5sZW5ndGggPj0gNSAmJiAvW2EtekEtWjAtOV0vLnRlc3QodHJpbW1lZCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHR5cGU6IGZjLmNvbnN0YW50RnJvbSgnc3VjY2VzcycsICdlcnJvcicsICd3YXJuaW5nJywgJ2luZm8nKSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBhc3luYyAoeyBtZXNzYWdlLCB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgIGxldCBhZGRUb2FzdEZuOiBSZXR1cm5UeXBlPHR5cGVvZiB1c2VUb2FzdD5bJ2FkZFRvYXN0J10gfCBudWxsID0gbnVsbDtcblxuICAgICAgICAgICAgY29uc3QgeyB1bm1vdW50IH0gPSByZW5kZXIoXG4gICAgICAgICAgICAgIDxUb2FzdFByb3ZpZGVyPlxuICAgICAgICAgICAgICAgIDxUb2FzdFRlc3RDb21wb25lbnQgXG4gICAgICAgICAgICAgICAgICBvbk1vdW50PXsoYWRkVG9hc3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYWRkVG9hc3RGbiA9IGFkZFRvYXN0O1xuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L1RvYXN0UHJvdmlkZXI+XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBBZGQgdG9hc3Qgd2l0aCBsb25nIGR1cmF0aW9uIHNvIGl0IGRvZXNuJ3QgYXV0by1kaXNtaXNzXG4gICAgICAgICAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgYWRkVG9hc3RGbiEoeyB0eXBlOiB0eXBlIGFzIGFueSwgbWVzc2FnZSwgZHVyYXRpb246IDEwMDAwIH0pO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAvLyBXYWl0IGZvciB0b2FzdCB0byBhcHBlYXJcbiAgICAgICAgICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRlc3RJZChgdG9hc3QtJHt0eXBlfWApKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRvYXN0IGVsZW1lbnQgYW5kIGZpbmQgaXRzIGNsb3NlIGJ1dHRvblxuICAgICAgICAgICAgICBjb25zdCB0b2FzdCA9IHNjcmVlbi5nZXRCeVRlc3RJZChgdG9hc3QtJHt0eXBlfWApO1xuICAgICAgICAgICAgICBjb25zdCBjbG9zZUJ1dHRvbiA9IHRvYXN0LnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvblthcmlhLWxhYmVsPVwiQ2xvc2Ugbm90aWZpY2F0aW9uXCJdJyk7XG4gICAgICAgICAgICAgIGV4cGVjdChjbG9zZUJ1dHRvbikudG9CZUluVGhlRG9jdW1lbnQoKTtcblxuICAgICAgICAgICAgICAvLyBDbGljayBjbG9zZSBidXR0b25cbiAgICAgICAgICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAoY2xvc2VCdXR0b24gYXMgSFRNTEJ1dHRvbkVsZW1lbnQpLmNsaWNrKCk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIC8vIFZlcmlmeSB0b2FzdCBpcyByZW1vdmVkXG4gICAgICAgICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGV4cGVjdChzY3JlZW4ucXVlcnlCeVRlc3RJZChgdG9hc3QtJHt0eXBlfWApKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB1bm1vdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDUwIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiVG9hc3RUZXN0Q29tcG9uZW50Iiwib25Nb3VudCIsImFkZFRvYXN0IiwidXNlVG9hc3QiLCJkaXYiLCJkYXRhLXRlc3RpZCIsImRlc2NyaWJlIiwiYWZ0ZXJFYWNoIiwiY2xlYW51cCIsIml0IiwiZmMiLCJhc3NlcnQiLCJhc3luY1Byb3BlcnR5IiwicmVjb3JkIiwibWVzc2FnZSIsInN0cmluZyIsIm1pbkxlbmd0aCIsIm1heExlbmd0aCIsImZpbHRlciIsInMiLCJ0cmltbWVkIiwidHJpbSIsImxlbmd0aCIsInRlc3QiLCJvcGVyYXRpb24iLCJjb25zdGFudEZyb20iLCJhZGRUb2FzdEZuIiwidW5tb3VudCIsInJlbmRlciIsIlRvYXN0UHJvdmlkZXIiLCJhY3QiLCJ0eXBlIiwid2FpdEZvciIsInRvYXN0Iiwic2NyZWVuIiwiZ2V0QnlUZXN0SWQiLCJleHBlY3QiLCJ0b0JlSW5UaGVEb2N1bWVudCIsInRvSGF2ZUNsYXNzIiwibWVzc2FnZUVsZW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwidGV4dENvbnRlbnQiLCJ0b0JlIiwiaWNvbiIsIm51bVJ1bnMiLCJkdXJhdGlvbiIsImludGVnZXIiLCJtaW4iLCJtYXgiLCJxdWVyeUJ5VGVzdElkIiwibm90IiwidGltZW91dCIsImVycm9yVHlwZSIsImFycmF5IiwidG9hc3RzIiwiZm9yRWFjaCIsImRpc3BsYXllZFRvYXN0cyIsImdldEFsbEJ5Um9sZSIsImluZGV4IiwidG9hc3RFbGVtZW50IiwiY2xvc2VCdXR0b24iLCJjbGljayJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0M7Ozs7O3VCQUVxRDttRUFDbEM7OEJBQ29COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHeEMsK0NBQStDO0FBQy9DLFNBQVNBLG1CQUFtQixFQUMxQkMsT0FBTyxFQUdSO0lBQ0MsTUFBTSxFQUFFQyxRQUFRLEVBQUUsR0FBR0MsSUFBQUEsc0JBQVE7SUFFN0IsNERBQTREO0lBQzVELElBQUlGLFNBQVM7UUFDWEEsUUFBUUM7SUFDVjtJQUVBLHFCQUFPLHFCQUFDRTtRQUFJQyxlQUFZO2tCQUF1Qjs7QUFDakQ7QUFFQUMsU0FBUywrQkFB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