caae04f44001a163b273826ed8123690
"use strict";
// Mock the Supabase module with simpler per-call mocking
jest.mock('@/lib/supabase', ()=>{
    const mockChain = {
        select: jest.fn(),
        update: jest.fn(),
        eq: jest.fn(),
        single: jest.fn()
    };
    return {
        supabase: {
            from: jest.fn(()=>mockChain)
        },
        __mockChain: mockChain
    };
});
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _transportationService = require("./transportationService");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
/**
 * Feature: destination-wedding-platform, Property 30: Manifest Assignment Updates
 * 
 * For any guest with flight information changes, when the flight time is updated,
 * the system should automatically reassign the guest to the appropriate manifest
 * based on the new time window.
 * 
 * Validates: Requirements 20.8
 */ describe('Feature: destination-wedding-platform, Property 30: Manifest Assignment Updates', ()=>{
    let mockChain;
    beforeEach(()=>{
        jest.clearAllMocks();
        // Get mock chain for configuration
        const { __mockChain } = require('@/lib/supabase');
        mockChain = __mockChain;
    });
    it('should successfully update flight information for any valid guest', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(// Generate guest ID
        _fastcheck.uuid(), // Generate flight info with undefined for optional fields (not null)
        _fastcheck.record({
            guest_id: _fastcheck.uuid(),
            airport_code: _fastcheck.constantFrom('SJO', 'LIR', 'Other'),
            flight_number: _fastcheck.option(_fastcheck.string({
                minLength: 4,
                maxLength: 10
            }), {
                nil: undefined
            }),
            airline: _fastcheck.option(_fastcheck.string({
                minLength: 2,
                maxLength: 50
            }), {
                nil: undefined
            }),
            arrival_time: _fastcheck.option(_fastcheck.date({
                min: new Date('2025-01-01'),
                max: new Date('2025-12-31')
            }).map((d)=>d.toISOString()), {
                nil: undefined
            }),
            departure_time: _fastcheck.option(_fastcheck.date({
                min: new Date('2025-01-01'),
                max: new Date('2025-12-31')
            }).map((d)=>d.toISOString()), {
                nil: undefined
            })
        }), async (guestId, flightInfo)=>{
            // Configure mocks for this iteration using mockReturnValueOnce
            mockChain.select.mockReturnValueOnce(mockChain);
            mockChain.update.mockReturnValueOnce(mockChain);
            mockChain.eq.mockResolvedValueOnce({
                data: null,
                error: null
            });
            const result = await (0, _transportationService.updateFlightInfo)(guestId, {
                ...flightInfo,
                guest_id: guestId,
                airport_code: flightInfo.airport_code
            });
            // Property: Update should succeed for valid input
            expect(result.success).toBe(true);
            // Property: Update should be called with sanitized data
            expect(mockChain.update).toHaveBeenCalled();
            expect(mockChain.eq).toHaveBeenCalledWith('id', guestId);
        }), {
            numRuns: 100
        });
    });
    it('should assign guests to shuttle manifests without duplicates', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(// Generate manifest ID
        _fastcheck.uuid(), // Generate array of guest IDs
        _fastcheck.array(_fastcheck.uuid(), {
            minLength: 1,
            maxLength: 20
        }), async (manifestId, guestIds)=>{
            // Mock current manifest with some existing guests
            const existingGuestIds = _fastcheck.sample(_fastcheck.array(_fastcheck.uuid(), {
                minLength: 0,
                maxLength: 5
            }), 1)[0];
            // Configure mocks for this iteration
            mockChain.select.mockReturnValueOnce(mockChain);
            mockChain.eq.mockReturnValueOnce(mockChain);
            mockChain.single.mockResolvedValueOnce({
                data: {
                    guest_ids: existingGuestIds
                },
                error: null
            });
            mockChain.update.mockReturnValueOnce(mockChain);
            mockChain.eq.mockResolvedValueOnce({
                data: null,
                error: null
            });
            const result = await (0, _transportationService.assignGuestsToShuttle)(manifestId, guestIds);
            // Property: Assignment should succeed
            expect(result.success).toBe(true);
            // Property: Update should be called
            expect(mockChain.update).toHaveBeenCalled();
            // Verify the update was called with merged guest IDs
            const updateCall = mockChain.update.mock.calls[mockChain.update.mock.calls.length - 1][0];
            if (updateCall && updateCall.guest_ids) {
                // Property: No duplicate guest IDs
                const uniqueIds = new Set(updateCall.guest_ids);
                expect(updateCall.guest_ids.length).toBe(uniqueIds.size);
                // Property: All new guests should be included
                for (const guestId of guestIds){
                    expect(updateCall.guest_ids).toContain(guestId);
                }
                // Property: All existing guests should be preserved
                for (const existingId of existingGuestIds){
                    expect(updateCall.guest_ids).toContain(existingId);
                }
            }
        }), {
            numRuns: 100
        });
    });
    it('should handle empty guest assignment gracefully', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.uuid(), async (manifestId)=>{
            // Configure mocks for this iteration
            mockChain.select.mockReturnValueOnce(mockChain);
            mockChain.eq.mockReturnValueOnce(mockChain);
            mockChain.single.mockResolvedValueOnce({
                data: {
                    guest_ids: []
                },
                error: null
            });
            mockChain.update.mockReturnValueOnce(mockChain);
            mockChain.eq.mockResolvedValueOnce({
                data: null,
                error: null
            });
            const result = await (0, _transportationService.assignGuestsToShuttle)(manifestId, []);
            // Property: Should succeed even with empty array
            expect(result.success).toBe(true);
        }), {
            numRuns: 50
        });
    });
    it('should preserve existing assignments when adding new guests', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.uuid(), _fastcheck.array(_fastcheck.uuid(), {
            minLength: 1,
            maxLength: 10
        }), _fastcheck.array(_fastcheck.uuid(), {
            minLength: 1,
            maxLength: 10
        }), async (manifestId, existingGuests, newGuests)=>{
            // Ensure no overlap for this test
            const uniqueExisting = Array.from(new Set(existingGuests));
            const uniqueNew = Array.from(new Set(newGuests.filter((id)=>!uniqueExisting.includes(id))));
            // Skip if no new guests to add (all were filtered out)
            if (uniqueNew.length === 0) {
                return; // Property doesn't apply when there are no new guests
            }
            // Configure mocks for this iteration
            mockChain.select.mockReturnValueOnce(mockChain);
            mockChain.eq.mockReturnValueOnce(mockChain);
            mockChain.single.mockResolvedValueOnce({
                data: {
                    guest_ids: uniqueExisting
                },
                error: null
            });
            mockChain.update.mockReturnValueOnce(mockChain);
            mockChain.eq.mockResolvedValueOnce({
                data: null,
                error: null
            });
            const result = await (0, _transportationService.assignGuestsToShuttle)(manifestId, uniqueNew);
            expect(result.success).toBe(true);
            if (mockChain.update.mock.calls.length > 0) {
                const updateCall = mockChain.update.mock.calls[mockChain.update.mock.calls.length - 1][0];
                if (updateCall && updateCall.guest_ids) {
                    // Property: All existing guests should still be present
                    for (const existingId of uniqueExisting){
                        expect(updateCall.guest_ids).toContain(existingId);
                    }
                    // Property: All new guests should be added
                    for (const newId of uniqueNew){
                        expect(updateCall.guest_ids).toContain(newId);
                    }
                    // Property: Total count should be sum of unique guests
                    const expectedCount = new Set([
                        ...uniqueExisting,
                        ...uniqueNew
                    ]).size;
                    expect(updateCall.guest_ids.length).toBe(expectedCount);
                }
            }
        }), {
            numRuns: 100
        });
    });
    it('should handle database errors gracefully', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.uuid(), _fastcheck.array(_fastcheck.uuid(), {
            minLength: 1,
            maxLength: 5
        }), async (manifestId, guestIds)=>{
            // Configure mocks for this iteration - simulate database error
            mockChain.select.mockReturnValueOnce(mockChain);
            mockChain.eq.mockReturnValueOnce(mockChain);
            mockChain.single.mockResolvedValueOnce({
                data: null,
                error: {
                    message: 'Database connection failed'
                }
            });
            const result = await (0, _transportationService.assignGuestsToShuttle)(manifestId, guestIds);
            // Property: Should return error result
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('DATABASE_ERROR');
            }
        }), {
            numRuns: 50
        });
    });
    it('should sanitize flight information before updating', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.uuid(), _fastcheck.record({
            guest_id: _fastcheck.uuid(),
            airport_code: _fastcheck.constantFrom('SJO', 'LIR', 'Other'),
            // Generate short alphanumeric strings so total length with payload stays under max(20)
            flight_number: _fastcheck.option(_fastcheck.hexaString({
                minLength: 4,
                maxLength: 8
            }), {
                nil: undefined
            }),
            airline: _fastcheck.option(_fastcheck.string({
                minLength: 2,
                maxLength: 20
            }).filter((s)=>/^[A-Za-z ]+$/.test(s)).map((s)=>`${s}<img src=x onerror=alert(1)>`), {
                nil: undefined
            }),
            arrival_time: _fastcheck.option(_fastcheck.date({
                min: new Date('2025-01-01'),
                max: new Date('2025-12-31')
            }).map((d)=>d.toISOString()), {
                nil: undefined
            }),
            departure_time: _fastcheck.option(_fastcheck.date({
                min: new Date('2025-01-01'),
                max: new Date('2025-12-31')
            }).map((d)=>d.toISOString()), {
                nil: undefined
            })
        }), async (guestId, flightInfo)=>{
            // Configure mocks for this iteration
            mockChain.select.mockReturnValueOnce(mockChain);
            mockChain.update.mockReturnValueOnce(mockChain);
            mockChain.eq.mockResolvedValueOnce({
                data: null,
                error: null
            });
            const result = await (0, _transportationService.updateFlightInfo)(guestId, {
                ...flightInfo,
                guest_id: guestId,
                airport_code: flightInfo.airport_code
            });
            expect(result.success).toBe(true);
            // Property: Malicious content should be sanitized
            if (mockChain.update.mock.calls.length > 0) {
                const updateCall = mockChain.update.mock.calls[mockChain.update.mock.calls.length - 1][0];
                if (updateCall.airline) {
                    expect(updateCall.airline).not.toContain('<img');
                    expect(updateCall.airline).not.toContain('onerror');
                    expect(updateCall.airline).not.toContain('alert');
                }
            }
        }), {
            numRuns: 100
        });
    });
    it('should maintain idempotency when assigning same guests multiple times', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.uuid(), _fastcheck.array(_fastcheck.uuid(), {
            minLength: 1,
            maxLength: 10
        }), async (manifestId, guestIds)=>{
            const uniqueGuestIds = Array.from(new Set(guestIds));
            // First assignment - empty manifest
            mockChain.select.mockReturnValueOnce(mockChain);
            mockChain.eq.mockReturnValueOnce(mockChain);
            mockChain.single.mockResolvedValueOnce({
                data: {
                    guest_ids: []
                },
                error: null
            });
            mockChain.update.mockReturnValueOnce(mockChain);
            mockChain.eq.mockResolvedValueOnce({
                data: null,
                error: null
            });
            const result1 = await (0, _transportationService.assignGuestsToShuttle)(manifestId, uniqueGuestIds);
            expect(result1.success).toBe(true);
            // Second assignment with same guests - manifest now has those guests
            mockChain.select.mockReturnValueOnce(mockChain);
            mockChain.eq.mockReturnValueOnce(mockChain);
            mockChain.single.mockResolvedValueOnce({
                data: {
                    guest_ids: uniqueGuestIds
                },
                error: null
            });
            mockChain.update.mockReturnValueOnce(mockChain);
            mockChain.eq.mockResolvedValueOnce({
                data: null,
                error: null
            });
            const result2 = await (0, _transportationService.assignGuestsToShuttle)(manifestId, uniqueGuestIds);
            expect(result2.success).toBe(true);
            // Property: Assigning same guests twice should not duplicate
            if (mockChain.update.mock.calls.length > 1) {
                const lastUpdateCall = mockChain.update.mock.calls[mockChain.update.mock.calls.length - 1][0];
                if (lastUpdateCall && lastUpdateCall.guest_ids) {
                    const uniqueCount = new Set(lastUpdateCall.guest_ids).size;
                    expect(lastUpdateCall.guest_ids.length).toBe(uniqueCount);
                }
            }
        }), {
            numRuns: 100
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvbWFuaWZlc3RBc3NpZ25tZW50VXBkYXRlcy5wcm9wZXJ0eS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGZjIGZyb20gJ2Zhc3QtY2hlY2snO1xuaW1wb3J0IHsgYXNzaWduR3Vlc3RzVG9TaHV0dGxlLCB1cGRhdGVGbGlnaHRJbmZvIH0gZnJvbSAnLi90cmFuc3BvcnRhdGlvblNlcnZpY2UnO1xuXG4vLyBNb2NrIHRoZSBTdXBhYmFzZSBtb2R1bGUgd2l0aCBzaW1wbGVyIHBlci1jYWxsIG1vY2tpbmdcbmplc3QubW9jaygnQC9saWIvc3VwYWJhc2UnLCAoKSA9PiB7XG4gIGNvbnN0IG1vY2tDaGFpbiA9IHtcbiAgICBzZWxlY3Q6IGplc3QuZm4oKSxcbiAgICB1cGRhdGU6IGplc3QuZm4oKSxcbiAgICBlcTogamVzdC5mbigpLFxuICAgIHNpbmdsZTogamVzdC5mbigpLFxuICB9O1xuICBcbiAgcmV0dXJuIHtcbiAgICBzdXBhYmFzZToge1xuICAgICAgZnJvbTogamVzdC5mbigoKSA9PiBtb2NrQ2hhaW4pLFxuICAgIH0sXG4gICAgX19tb2NrQ2hhaW46IG1vY2tDaGFpbixcbiAgfTtcbn0pO1xuXG4vKipcbiAqIEZlYXR1cmU6IGRlc3RpbmF0aW9uLXdlZGRpbmctcGxhdGZvcm0sIFByb3BlcnR5IDMwOiBNYW5pZmVzdCBBc3NpZ25tZW50IFVwZGF0ZXNcbiAqIFxuICogRm9yIGFueSBndWVzdCB3aXRoIGZsaWdodCBpbmZvcm1hdGlvbiBjaGFuZ2VzLCB3aGVuIHRoZSBmbGlnaHQgdGltZSBpcyB1cGRhdGVkLFxuICogdGhlIHN5c3RlbSBzaG91bGQgYXV0b21hdGljYWxseSByZWFzc2lnbiB0aGUgZ3Vlc3QgdG8gdGhlIGFwcHJvcHJpYXRlIG1hbmlmZXN0XG4gKiBiYXNlZCBvbiB0aGUgbmV3IHRpbWUgd2luZG93LlxuICogXG4gKiBWYWxpZGF0ZXM6IFJlcXVpcmVtZW50cyAyMC44XG4gKi9cbmRlc2NyaWJlKCdGZWF0dXJlOiBkZXN0aW5hdGlvbi13ZWRkaW5nLXBsYXRmb3JtLCBQcm9wZXJ0eSAzMDogTWFuaWZlc3QgQXNzaWdubWVudCBVcGRhdGVzJywgKCkgPT4ge1xuICBsZXQgbW9ja0NoYWluOiBhbnk7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgLy8gR2V0IG1vY2sgY2hhaW4gZm9yIGNvbmZpZ3VyYXRpb25cbiAgICBjb25zdCB7IF9fbW9ja0NoYWluIH0gPSByZXF1aXJlKCdAL2xpYi9zdXBhYmFzZScpO1xuICAgIG1vY2tDaGFpbiA9IF9fbW9ja0NoYWluO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHN1Y2Nlc3NmdWxseSB1cGRhdGUgZmxpZ2h0IGluZm9ybWF0aW9uIGZvciBhbnkgdmFsaWQgZ3Vlc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgLy8gR2VuZXJhdGUgZ3Vlc3QgSURcbiAgICAgICAgZmMudXVpZCgpLFxuICAgICAgICAvLyBHZW5lcmF0ZSBmbGlnaHQgaW5mbyB3aXRoIHVuZGVmaW5lZCBmb3Igb3B0aW9uYWwgZmllbGRzIChub3QgbnVsbClcbiAgICAgICAgZmMucmVjb3JkKHtcbiAgICAgICAgICBndWVzdF9pZDogZmMudXVpZCgpLFxuICAgICAgICAgIGFpcnBvcnRfY29kZTogZmMuY29uc3RhbnRGcm9tKCdTSk8nLCAnTElSJywgJ090aGVyJyksXG4gICAgICAgICAgZmxpZ2h0X251bWJlcjogZmMub3B0aW9uKGZjLnN0cmluZyh7IG1pbkxlbmd0aDogNCwgbWF4TGVuZ3RoOiAxMCB9KSwgeyBuaWw6IHVuZGVmaW5lZCB9KSxcbiAgICAgICAgICBhaXJsaW5lOiBmYy5vcHRpb24oZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAyLCBtYXhMZW5ndGg6IDUwIH0pLCB7IG5pbDogdW5kZWZpbmVkIH0pLFxuICAgICAgICAgIGFycml2YWxfdGltZTogZmMub3B0aW9uKGZjLmRhdGUoeyBtaW46IG5ldyBEYXRlKCcyMDI1LTAxLTAxJyksIG1heDogbmV3IERhdGUoJzIwMjUtMTItMzEnKSB9KS5tYXAoZCA9PiBkLnRvSVNPU3RyaW5nKCkpLCB7IG5pbDogdW5kZWZpbmVkIH0pLFxuICAgICAgICAgIGRlcGFydHVyZV90aW1lOiBmYy5vcHRpb24oZmMuZGF0ZSh7IG1pbjogbmV3IERhdGUoJzIwMjUtMDEtMDEnKSwgbWF4OiBuZXcgRGF0ZSgnMjAyNS0xMi0zMScpIH0pLm1hcChkID0+IGQudG9JU09TdHJpbmcoKSksIHsgbmlsOiB1bmRlZmluZWQgfSksXG4gICAgICAgIH0pLFxuICAgICAgICBhc3luYyAoZ3Vlc3RJZCwgZmxpZ2h0SW5mbykgPT4ge1xuICAgICAgICAgIC8vIENvbmZpZ3VyZSBtb2NrcyBmb3IgdGhpcyBpdGVyYXRpb24gdXNpbmcgbW9ja1JldHVyblZhbHVlT25jZVxuICAgICAgICAgIG1vY2tDaGFpbi5zZWxlY3QubW9ja1JldHVyblZhbHVlT25jZShtb2NrQ2hhaW4pO1xuICAgICAgICAgIG1vY2tDaGFpbi51cGRhdGUubW9ja1JldHVyblZhbHVlT25jZShtb2NrQ2hhaW4pO1xuICAgICAgICAgIG1vY2tDaGFpbi5lcS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBkYXRhOiBudWxsLCBlcnJvcjogbnVsbCB9KTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwZGF0ZUZsaWdodEluZm8oZ3Vlc3RJZCwgeyBcbiAgICAgICAgICAgIC4uLmZsaWdodEluZm8sIFxuICAgICAgICAgICAgZ3Vlc3RfaWQ6IGd1ZXN0SWQsXG4gICAgICAgICAgICBhaXJwb3J0X2NvZGU6IGZsaWdodEluZm8uYWlycG9ydF9jb2RlIGFzICdTSk8nIHwgJ0xJUicgfCAnT3RoZXInLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IFVwZGF0ZSBzaG91bGQgc3VjY2VlZCBmb3IgdmFsaWQgaW5wdXRcbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG5cbiAgICAgICAgICAvLyBQcm9wZXJ0eTogVXBkYXRlIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBzYW5pdGl6ZWQgZGF0YVxuICAgICAgICAgIGV4cGVjdChtb2NrQ2hhaW4udXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICAgICAgZXhwZWN0KG1vY2tDaGFpbi5lcSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2lkJywgZ3Vlc3RJZCk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBhc3NpZ24gZ3Vlc3RzIHRvIHNodXR0bGUgbWFuaWZlc3RzIHdpdGhvdXQgZHVwbGljYXRlcycsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICAvLyBHZW5lcmF0ZSBtYW5pZmVzdCBJRFxuICAgICAgICBmYy51dWlkKCksXG4gICAgICAgIC8vIEdlbmVyYXRlIGFycmF5IG9mIGd1ZXN0IElEc1xuICAgICAgICBmYy5hcnJheShmYy51dWlkKCksIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDIwIH0pLFxuICAgICAgICBhc3luYyAobWFuaWZlc3RJZCwgZ3Vlc3RJZHMpID0+IHtcbiAgICAgICAgICAvLyBNb2NrIGN1cnJlbnQgbWFuaWZlc3Qgd2l0aCBzb21lIGV4aXN0aW5nIGd1ZXN0c1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nR3Vlc3RJZHMgPSBmYy5zYW1wbGUoZmMuYXJyYXkoZmMudXVpZCgpLCB7IG1pbkxlbmd0aDogMCwgbWF4TGVuZ3RoOiA1IH0pLCAxKVswXTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDb25maWd1cmUgbW9ja3MgZm9yIHRoaXMgaXRlcmF0aW9uXG4gICAgICAgICAgbW9ja0NoYWluLnNlbGVjdC5tb2NrUmV0dXJuVmFsdWVPbmNlKG1vY2tDaGFpbik7XG4gICAgICAgICAgbW9ja0NoYWluLmVxLm1vY2tSZXR1cm5WYWx1ZU9uY2UobW9ja0NoYWluKTtcbiAgICAgICAgICBtb2NrQ2hhaW4uc2luZ2xlLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgICBkYXRhOiB7IGd1ZXN0X2lkczogZXhpc3RpbmdHdWVzdElkcyB9LFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgbW9ja0NoYWluLnVwZGF0ZS5tb2NrUmV0dXJuVmFsdWVPbmNlKG1vY2tDaGFpbik7XG4gICAgICAgICAgbW9ja0NoYWluLmVxLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH0pO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXNzaWduR3Vlc3RzVG9TaHV0dGxlKG1hbmlmZXN0SWQsIGd1ZXN0SWRzKTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBBc3NpZ25tZW50IHNob3VsZCBzdWNjZWVkXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IFVwZGF0ZSBzaG91bGQgYmUgY2FsbGVkXG4gICAgICAgICAgZXhwZWN0KG1vY2tDaGFpbi51cGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcblxuICAgICAgICAgIC8vIFZlcmlmeSB0aGUgdXBkYXRlIHdhcyBjYWxsZWQgd2l0aCBtZXJnZWQgZ3Vlc3QgSURzXG4gICAgICAgICAgY29uc3QgdXBkYXRlQ2FsbCA9IG1vY2tDaGFpbi51cGRhdGUubW9jay5jYWxsc1ttb2NrQ2hhaW4udXBkYXRlLm1vY2suY2FsbHMubGVuZ3RoIC0gMV1bMF07XG4gICAgICAgICAgaWYgKHVwZGF0ZUNhbGwgJiYgdXBkYXRlQ2FsbC5ndWVzdF9pZHMpIHtcbiAgICAgICAgICAgIC8vIFByb3BlcnR5OiBObyBkdXBsaWNhdGUgZ3Vlc3QgSURzXG4gICAgICAgICAgICBjb25zdCB1bmlxdWVJZHMgPSBuZXcgU2V0KHVwZGF0ZUNhbGwuZ3Vlc3RfaWRzKTtcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVDYWxsLmd1ZXN0X2lkcy5sZW5ndGgpLnRvQmUodW5pcXVlSWRzLnNpemUpO1xuXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eTogQWxsIG5ldyBndWVzdHMgc2hvdWxkIGJlIGluY2x1ZGVkXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGd1ZXN0SWQgb2YgZ3Vlc3RJZHMpIHtcbiAgICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZUNhbGwuZ3Vlc3RfaWRzKS50b0NvbnRhaW4oZ3Vlc3RJZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByb3BlcnR5OiBBbGwgZXhpc3RpbmcgZ3Vlc3RzIHNob3VsZCBiZSBwcmVzZXJ2ZWRcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXhpc3RpbmdJZCBvZiBleGlzdGluZ0d1ZXN0SWRzKSB7XG4gICAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVDYWxsLmd1ZXN0X2lkcykudG9Db250YWluKGV4aXN0aW5nSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGhhbmRsZSBlbXB0eSBndWVzdCBhc3NpZ25tZW50IGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMudXVpZCgpLFxuICAgICAgICBhc3luYyAobWFuaWZlc3RJZCkgPT4ge1xuICAgICAgICAgIC8vIENvbmZpZ3VyZSBtb2NrcyBmb3IgdGhpcyBpdGVyYXRpb25cbiAgICAgICAgICBtb2NrQ2hhaW4uc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZU9uY2UobW9ja0NoYWluKTtcbiAgICAgICAgICBtb2NrQ2hhaW4uZXEubW9ja1JldHVyblZhbHVlT25jZShtb2NrQ2hhaW4pO1xuICAgICAgICAgIG1vY2tDaGFpbi5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICAgIGRhdGE6IHsgZ3Vlc3RfaWRzOiBbXSB9LFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgbW9ja0NoYWluLnVwZGF0ZS5tb2NrUmV0dXJuVmFsdWVPbmNlKG1vY2tDaGFpbik7XG4gICAgICAgICAgbW9ja0NoYWluLmVxLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH0pO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXNzaWduR3Vlc3RzVG9TaHV0dGxlKG1hbmlmZXN0SWQsIFtdKTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBTaG91bGQgc3VjY2VlZCBldmVuIHdpdGggZW1wdHkgYXJyYXlcbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDUwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHByZXNlcnZlIGV4aXN0aW5nIGFzc2lnbm1lbnRzIHdoZW4gYWRkaW5nIG5ldyBndWVzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMudXVpZCgpLFxuICAgICAgICBmYy5hcnJheShmYy51dWlkKCksIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwIH0pLFxuICAgICAgICBmYy5hcnJheShmYy51dWlkKCksIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwIH0pLFxuICAgICAgICBhc3luYyAobWFuaWZlc3RJZCwgZXhpc3RpbmdHdWVzdHMsIG5ld0d1ZXN0cykgPT4ge1xuICAgICAgICAgIC8vIEVuc3VyZSBubyBvdmVybGFwIGZvciB0aGlzIHRlc3RcbiAgICAgICAgICBjb25zdCB1bmlxdWVFeGlzdGluZyA9IEFycmF5LmZyb20obmV3IFNldChleGlzdGluZ0d1ZXN0cykpO1xuICAgICAgICAgIGNvbnN0IHVuaXF1ZU5ldyA9IEFycmF5LmZyb20obmV3IFNldChuZXdHdWVzdHMuZmlsdGVyKGlkID0+ICF1bmlxdWVFeGlzdGluZy5pbmNsdWRlcyhpZCkpKSk7XG5cbiAgICAgICAgICAvLyBTa2lwIGlmIG5vIG5ldyBndWVzdHMgdG8gYWRkIChhbGwgd2VyZSBmaWx0ZXJlZCBvdXQpXG4gICAgICAgICAgaWYgKHVuaXF1ZU5ldy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gUHJvcGVydHkgZG9lc24ndCBhcHBseSB3aGVuIHRoZXJlIGFyZSBubyBuZXcgZ3Vlc3RzXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ29uZmlndXJlIG1vY2tzIGZvciB0aGlzIGl0ZXJhdGlvblxuICAgICAgICAgIG1vY2tDaGFpbi5zZWxlY3QubW9ja1JldHVyblZhbHVlT25jZShtb2NrQ2hhaW4pO1xuICAgICAgICAgIG1vY2tDaGFpbi5lcS5tb2NrUmV0dXJuVmFsdWVPbmNlKG1vY2tDaGFpbik7XG4gICAgICAgICAgbW9ja0NoYWluLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgICAgZGF0YTogeyBndWVzdF9pZHM6IHVuaXF1ZUV4aXN0aW5nIH0sXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBtb2NrQ2hhaW4udXBkYXRlLm1vY2tSZXR1cm5WYWx1ZU9uY2UobW9ja0NoYWluKTtcbiAgICAgICAgICBtb2NrQ2hhaW4uZXEubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgZGF0YTogbnVsbCwgZXJyb3I6IG51bGwgfSk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhc3NpZ25HdWVzdHNUb1NodXR0bGUobWFuaWZlc3RJZCwgdW5pcXVlTmV3KTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcblxuICAgICAgICAgIGlmIChtb2NrQ2hhaW4udXBkYXRlLm1vY2suY2FsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlQ2FsbCA9IG1vY2tDaGFpbi51cGRhdGUubW9jay5jYWxsc1ttb2NrQ2hhaW4udXBkYXRlLm1vY2suY2FsbHMubGVuZ3RoIC0gMV1bMF07XG4gICAgICAgICAgICBpZiAodXBkYXRlQ2FsbCAmJiB1cGRhdGVDYWxsLmd1ZXN0X2lkcykge1xuICAgICAgICAgICAgICAvLyBQcm9wZXJ0eTogQWxsIGV4aXN0aW5nIGd1ZXN0cyBzaG91bGQgc3RpbGwgYmUgcHJlc2VudFxuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV4aXN0aW5nSWQgb2YgdW5pcXVlRXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QodXBkYXRlQ2FsbC5ndWVzdF9pZHMpLnRvQ29udGFpbihleGlzdGluZ0lkKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFByb3BlcnR5OiBBbGwgbmV3IGd1ZXN0cyBzaG91bGQgYmUgYWRkZWRcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBuZXdJZCBvZiB1bmlxdWVOZXcpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QodXBkYXRlQ2FsbC5ndWVzdF9pZHMpLnRvQ29udGFpbihuZXdJZCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBQcm9wZXJ0eTogVG90YWwgY291bnQgc2hvdWxkIGJlIHN1bSBvZiB1bmlxdWUgZ3Vlc3RzXG4gICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkQ291bnQgPSBuZXcgU2V0KFsuLi51bmlxdWVFeGlzdGluZywgLi4udW5pcXVlTmV3XSkuc2l6ZTtcbiAgICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZUNhbGwuZ3Vlc3RfaWRzLmxlbmd0aCkudG9CZShleHBlY3RlZENvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMudXVpZCgpLFxuICAgICAgICBmYy5hcnJheShmYy51dWlkKCksIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUgfSksXG4gICAgICAgIGFzeW5jIChtYW5pZmVzdElkLCBndWVzdElkcykgPT4ge1xuICAgICAgICAgIC8vIENvbmZpZ3VyZSBtb2NrcyBmb3IgdGhpcyBpdGVyYXRpb24gLSBzaW11bGF0ZSBkYXRhYmFzZSBlcnJvclxuICAgICAgICAgIG1vY2tDaGFpbi5zZWxlY3QubW9ja1JldHVyblZhbHVlT25jZShtb2NrQ2hhaW4pO1xuICAgICAgICAgIG1vY2tDaGFpbi5lcS5tb2NrUmV0dXJuVmFsdWVPbmNlKG1vY2tDaGFpbik7XG4gICAgICAgICAgbW9ja0NoYWluLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6ICdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcgfSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFzc2lnbkd1ZXN0c1RvU2h1dHRsZShtYW5pZmVzdElkLCBndWVzdElkcyk7XG5cbiAgICAgICAgICAvLyBQcm9wZXJ0eTogU2hvdWxkIHJldHVybiBlcnJvciByZXN1bHRcbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuXG4gICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdEQVRBQkFTRV9FUlJPUicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogNTAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgc2FuaXRpemUgZmxpZ2h0IGluZm9ybWF0aW9uIGJlZm9yZSB1cGRhdGluZycsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBmYy51dWlkKCksXG4gICAgICAgIGZjLnJlY29yZCh7XG4gICAgICAgICAgZ3Vlc3RfaWQ6IGZjLnV1aWQoKSxcbiAgICAgICAgICBhaXJwb3J0X2NvZGU6IGZjLmNvbnN0YW50RnJvbSgnU0pPJywgJ0xJUicsICdPdGhlcicpLFxuICAgICAgICAgIC8vIEdlbmVyYXRlIHNob3J0IGFscGhhbnVtZXJpYyBzdHJpbmdzIHNvIHRvdGFsIGxlbmd0aCB3aXRoIHBheWxvYWQgc3RheXMgdW5kZXIgbWF4KDIwKVxuICAgICAgICAgIGZsaWdodF9udW1iZXI6IGZjLm9wdGlvbihmYy5oZXhhU3RyaW5nKHsgbWluTGVuZ3RoOiA0LCBtYXhMZW5ndGg6IDggfSksIHsgbmlsOiB1bmRlZmluZWQgfSksXG4gICAgICAgICAgYWlybGluZTogZmMub3B0aW9uKGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMiwgbWF4TGVuZ3RoOiAyMCB9KS5maWx0ZXIocyA9PiAvXltBLVphLXogXSskLy50ZXN0KHMpKS5tYXAocyA9PiBgJHtzfTxpbWcgc3JjPXggb25lcnJvcj1hbGVydCgxKT5gKSwgeyBuaWw6IHVuZGVmaW5lZCB9KSxcbiAgICAgICAgICBhcnJpdmFsX3RpbWU6IGZjLm9wdGlvbihmYy5kYXRlKHsgbWluOiBuZXcgRGF0ZSgnMjAyNS0wMS0wMScpLCBtYXg6IG5ldyBEYXRlKCcyMDI1LTEyLTMxJykgfSkubWFwKGQgPT4gZC50b0lTT1N0cmluZygpKSwgeyBuaWw6IHVuZGVmaW5lZCB9KSxcbiAgICAgICAgICBkZXBhcnR1cmVfdGltZTogZmMub3B0aW9uKGZjLmRhdGUoeyBtaW46IG5ldyBEYXRlKCcyMDI1LTAxLTAxJyksIG1heDogbmV3IERhdGUoJzIwMjUtMTItMzEnKSB9KS5tYXAoZCA9PiBkLnRvSVNPU3RyaW5nKCkpLCB7IG5pbDogdW5kZWZpbmVkIH0pLFxuICAgICAgICB9KSxcbiAgICAgICAgYXN5bmMgKGd1ZXN0SWQsIGZsaWdodEluZm8pID0+IHtcbiAgICAgICAgICAvLyBDb25maWd1cmUgbW9ja3MgZm9yIHRoaXMgaXRlcmF0aW9uXG4gICAgICAgICAgbW9ja0NoYWluLnNlbGVjdC5tb2NrUmV0dXJuVmFsdWVPbmNlKG1vY2tDaGFpbik7XG4gICAgICAgICAgbW9ja0NoYWluLnVwZGF0ZS5tb2NrUmV0dXJuVmFsdWVPbmNlKG1vY2tDaGFpbik7XG4gICAgICAgICAgbW9ja0NoYWluLmVxLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwZGF0ZUZsaWdodEluZm8oZ3Vlc3RJZCwgeyBcbiAgICAgICAgICAgIC4uLmZsaWdodEluZm8sIFxuICAgICAgICAgICAgZ3Vlc3RfaWQ6IGd1ZXN0SWQsXG4gICAgICAgICAgICBhaXJwb3J0X2NvZGU6IGZsaWdodEluZm8uYWlycG9ydF9jb2RlIGFzICdTSk8nIHwgJ0xJUicgfCAnT3RoZXInLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IE1hbGljaW91cyBjb250ZW50IHNob3VsZCBiZSBzYW5pdGl6ZWRcbiAgICAgICAgICBpZiAobW9ja0NoYWluLnVwZGF0ZS5tb2NrLmNhbGxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZUNhbGwgPSBtb2NrQ2hhaW4udXBkYXRlLm1vY2suY2FsbHNbbW9ja0NoYWluLnVwZGF0ZS5tb2NrLmNhbGxzLmxlbmd0aCAtIDFdWzBdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodXBkYXRlQ2FsbC5haXJsaW5lKSB7XG4gICAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVDYWxsLmFpcmxpbmUpLm5vdC50b0NvbnRhaW4oJzxpbWcnKTtcbiAgICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZUNhbGwuYWlybGluZSkubm90LnRvQ29udGFpbignb25lcnJvcicpO1xuICAgICAgICAgICAgICBleHBlY3QodXBkYXRlQ2FsbC5haXJsaW5lKS5ub3QudG9Db250YWluKCdhbGVydCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIG1haW50YWluIGlkZW1wb3RlbmN5IHdoZW4gYXNzaWduaW5nIHNhbWUgZ3Vlc3RzIG11bHRpcGxlIHRpbWVzJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGZjLnV1aWQoKSxcbiAgICAgICAgZmMuYXJyYXkoZmMudXVpZCgpLCB7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxMCB9KSxcbiAgICAgICAgYXN5bmMgKG1hbmlmZXN0SWQsIGd1ZXN0SWRzKSA9PiB7XG4gICAgICAgICAgY29uc3QgdW5pcXVlR3Vlc3RJZHMgPSBBcnJheS5mcm9tKG5ldyBTZXQoZ3Vlc3RJZHMpKTtcblxuICAgICAgICAgIC8vIEZpcnN0IGFzc2lnbm1lbnQgLSBlbXB0eSBtYW5pZmVzdFxuICAgICAgICAgIG1vY2tDaGFpbi5zZWxlY3QubW9ja1JldHVyblZhbHVlT25jZShtb2NrQ2hhaW4pO1xuICAgICAgICAgIG1vY2tDaGFpbi5lcS5tb2NrUmV0dXJuVmFsdWVPbmNlKG1vY2tDaGFpbik7XG4gICAgICAgICAgbW9ja0NoYWluLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgICAgZGF0YTogeyBndWVzdF9pZHM6IFtdIH0sXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtb2NrQ2hhaW4udXBkYXRlLm1vY2tSZXR1cm5WYWx1ZU9uY2UobW9ja0NoYWluKTtcbiAgICAgICAgICBtb2NrQ2hhaW4uZXEubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgZGF0YTogbnVsbCwgZXJyb3I6IG51bGwgfSk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQxID0gYXdhaXQgYXNzaWduR3Vlc3RzVG9TaHV0dGxlKG1hbmlmZXN0SWQsIHVuaXF1ZUd1ZXN0SWRzKTtcbiAgICAgICAgICBleHBlY3QocmVzdWx0MS5zdWNjZXNzKS50b0JlKHRydWUpO1xuXG4gICAgICAgICAgLy8gU2Vjb25kIGFzc2lnbm1lbnQgd2l0aCBzYW1lIGd1ZXN0cyAtIG1hbmlmZXN0IG5vdyBoYXMgdGhvc2UgZ3Vlc3RzXG4gICAgICAgICAgbW9ja0NoYWluLnNlbGVjdC5tb2NrUmV0dXJuVmFsdWVPbmNlKG1vY2tDaGFpbik7XG4gICAgICAgICAgbW9ja0NoYWluLmVxLm1vY2tSZXR1cm5WYWx1ZU9uY2UobW9ja0NoYWluKTtcbiAgICAgICAgICBtb2NrQ2hhaW4uc2luZ2xlLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgICBkYXRhOiB7IGd1ZXN0X2lkczogdW5pcXVlR3Vlc3RJZHMgfSxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1vY2tDaGFpbi51cGRhdGUubW9ja1JldHVyblZhbHVlT25jZShtb2NrQ2hhaW4pO1xuICAgICAgICAgIG1vY2tDaGFpbi5lcS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBkYXRhOiBudWxsLCBlcnJvcjogbnVsbCB9KTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCBhc3NpZ25HdWVzdHNUb1NodXR0bGUobWFuaWZlc3RJZCwgdW5pcXVlR3Vlc3RJZHMpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQyLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG5cbiAgICAgICAgICAvLyBQcm9wZXJ0eTogQXNzaWduaW5nIHNhbWUgZ3Vlc3RzIHR3aWNlIHNob3VsZCBub3QgZHVwbGljYXRlXG4gICAgICAgICAgaWYgKG1vY2tDaGFpbi51cGRhdGUubW9jay5jYWxscy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0VXBkYXRlQ2FsbCA9IG1vY2tDaGFpbi51cGRhdGUubW9jay5jYWxsc1ttb2NrQ2hhaW4udXBkYXRlLm1vY2suY2FsbHMubGVuZ3RoIC0gMV1bMF07XG4gICAgICAgICAgICBpZiAobGFzdFVwZGF0ZUNhbGwgJiYgbGFzdFVwZGF0ZUNhbGwuZ3Vlc3RfaWRzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHVuaXF1ZUNvdW50ID0gbmV3IFNldChsYXN0VXBkYXRlQ2FsbC5ndWVzdF9pZHMpLnNpemU7XG4gICAgICAgICAgICAgIGV4cGVjdChsYXN0VXBkYXRlQ2FsbC5ndWVzdF9pZHMubGVuZ3RoKS50b0JlKHVuaXF1ZUNvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsIm1vY2tDaGFpbiIsInNlbGVjdCIsImZuIiwidXBkYXRlIiwiZXEiLCJzaW5nbGUiLCJzdXBhYmFzZSIsImZyb20iLCJfX21vY2tDaGFpbiIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJyZXF1aXJlIiwiaXQiLCJmYyIsImFzc2VydCIsImFzeW5jUHJvcGVydHkiLCJ1dWlkIiwicmVjb3JkIiwiZ3Vlc3RfaWQiLCJhaXJwb3J0X2NvZGUiLCJjb25zdGFudEZyb20iLCJmbGlnaHRfbnVtYmVyIiwib3B0aW9uIiwic3RyaW5nIiwibWluTGVuZ3RoIiwibWF4TGVuZ3RoIiwibmlsIiwidW5kZWZpbmVkIiwiYWlybGluZSIsImFycml2YWxfdGltZSIsImRhdGUiLCJtaW4iLCJEYXRlIiwibWF4IiwibWFwIiwiZCIsInRvSVNPU3RyaW5nIiwiZGVwYXJ0dXJlX3RpbWUiLCJndWVzdElkIiwiZmxpZ2h0SW5mbyIsIm1vY2tSZXR1cm5WYWx1ZU9uY2UiLCJtb2NrUmVzb2x2ZWRWYWx1ZU9uY2UiLCJkYXRhIiwiZXJyb3IiLCJyZXN1bHQiLCJ1cGRhdGVGbGlnaHRJbmZvIiwiZXhwZWN0Iiwic3VjY2VzcyIsInRvQmUiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJudW1SdW5zIiwiYXJyYXkiLCJtYW5pZmVzdElkIiwiZ3Vlc3RJZHMiLCJleGlzdGluZ0d1ZXN0SWRzIiwic2FtcGxlIiwiZ3Vlc3RfaWRzIiwiYXNzaWduR3Vlc3RzVG9TaHV0dGxlIiwidXBkYXRlQ2FsbCIsImNhbGxzIiwibGVuZ3RoIiwidW5pcXVlSWRzIiwiU2V0Iiwic2l6ZSIsInRvQ29udGFpbiIsImV4aXN0aW5nSWQiLCJleGlzdGluZ0d1ZXN0cyIsIm5ld0d1ZXN0cyIsInVuaXF1ZUV4aXN0aW5nIiwiQXJyYXkiLCJ1bmlxdWVOZXciLCJmaWx0ZXIiLCJpZCIsImluY2x1ZGVzIiwibmV3SWQiLCJleHBlY3RlZENvdW50IiwibWVzc2FnZSIsImNvZGUiLCJoZXhhU3RyaW5nIiwicyIsInRlc3QiLCJub3QiLCJ1bmlxdWVHdWVzdElkcyIsInJlc3VsdDEiLCJyZXN1bHQyIiwibGFzdFVwZGF0ZUNhbGwiLCJ1bmlxdWVD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