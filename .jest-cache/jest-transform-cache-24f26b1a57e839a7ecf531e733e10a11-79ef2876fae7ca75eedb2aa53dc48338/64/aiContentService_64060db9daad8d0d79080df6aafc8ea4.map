{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/services/aiContentService.ts"],"sourcesContent":["import { GoogleGenerativeAI } from '@google/generative-ai';\nimport { sanitizeInput, sanitizeRichText } from \"../utils/sanitization\";\nimport { z } from 'zod';\nimport type { Result } from '../types';\nimport { createActivitySchema, type CreateActivityDTO } from '../schemas/activitySchemas';\nimport { createAccommodationSchema, type CreateAccommodationDTO } from '../schemas/accommodationSchemas';\nimport { createVendorSchema, type CreateVendorDTO } from '../schemas/vendorSchemas';\n\n/**\n * Supported content types for AI extraction.\n */\nexport type ContentType = 'activity' | 'accommodation' | 'vendor';\n\n/**\n * URL validation schema.\n */\nconst urlSchema = z.string().url('Invalid URL format').refine(\n  (url) => {\n    try {\n      const parsed = new URL(url);\n      return parsed.protocol === 'http:' || parsed.protocol === 'https:';\n    } catch {\n      return false;\n    }\n  },\n  { message: 'URL must use HTTP or HTTPS protocol' }\n);\n\n/**\n * AI extraction request schema.\n */\nconst extractionRequestSchema = z.object({\n  url: urlSchema,\n  contentType: z.enum(['activity', 'accommodation', 'vendor']),\n  additionalContext: z.string().max(500).optional(),\n});\n\nexport type ExtractionRequestDTO = z.infer<typeof extractionRequestSchema>;\n\n/**\n * Extracted content with preview data.\n */\nexport interface ExtractedContent<T> {\n  contentType: ContentType;\n  sourceUrl: string;\n  extractedData: T;\n  rawResponse: string;\n  confidence: 'high' | 'medium' | 'low';\n  warnings: string[];\n}\n\n/**\n * Sanitizes extracted text content to prevent XSS and injection attacks.\n * \n * @param input - Raw text input from AI extraction\n * @returns Sanitized text safe for storage\n */\nexport function sanitizeExtractedText(input: string): string {\n  if (!input || typeof input !== 'string') {\n    return '';\n  }\n\n  return sanitizeInput(input);\n}\n\n/**\n * Sanitizes extracted rich text content allowing safe HTML.\n * \n * @param html - Raw HTML input from AI extraction\n * @returns Sanitized HTML safe for storage\n */\nexport function sanitizeExtractedRichText(html: string): string {\n  if (!html || typeof html !== 'string') {\n    return '';\n  }\n\n  return sanitizeRichText(html);\n}\n\n/**\n * Fetches content from a URL with timeout and size limits.\n * \n * @param url - URL to fetch content from\n * @returns Result containing the fetched HTML content\n */\nasync function fetchUrlContent(url: string): Promise<Result<string>> {\n  try {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout\n\n    const response = await fetch(url, {\n      signal: controller.signal,\n      headers: {\n        'User-Agent': 'Mozilla/5.0 (compatible; WeddingPlatform/1.0)',\n      },\n    });\n\n    clearTimeout(timeoutId);\n\n    if (!response.ok) {\n      return {\n        success: false,\n        error: {\n          code: 'FETCH_ERROR',\n          message: `Failed to fetch URL: ${response.status} ${response.statusText}`,\n        },\n      };\n    }\n\n    const contentType = response.headers.get('content-type');\n    if (!contentType || !contentType.includes('text/html')) {\n      return {\n        success: false,\n        error: {\n          code: 'INVALID_CONTENT_TYPE',\n          message: 'URL must return HTML content',\n        },\n      };\n    }\n\n    // Limit content size to 1MB\n    const text = await response.text();\n    if (text.length > 1024 * 1024) {\n      return {\n        success: false,\n        error: {\n          code: 'CONTENT_TOO_LARGE',\n          message: 'Content exceeds 1MB limit',\n        },\n      };\n    }\n\n    return { success: true, data: text };\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      return {\n        success: false,\n        error: {\n          code: 'TIMEOUT',\n          message: 'Request timed out after 30 seconds',\n        },\n      };\n    }\n\n    return {\n      success: false,\n      error: {\n        code: 'FETCH_ERROR',\n        message: error instanceof Error ? error.message : 'Failed to fetch URL',\n      },\n    };\n  }\n}\n\n/**\n * Generates a prompt for the AI model based on content type.\n * \n * @param contentType - Type of content to extract\n * @param htmlContent - HTML content from the URL\n * @param additionalContext - Optional additional context\n * @returns Formatted prompt for the AI model\n */\nfunction generateExtractionPrompt(\n  contentType: ContentType,\n  htmlContent: string,\n  additionalContext?: string\n): string {\n  const basePrompt = `Extract structured data from the following HTML content for a destination wedding management system.\n\nContent Type: ${contentType}\n\n${additionalContext ? `Additional Context: ${additionalContext}\\n\\n` : ''}`;\n\n  const schemas = {\n    activity: `\nExtract the following fields in JSON format:\n{\n  \"name\": \"Activity name (required, max 100 chars)\",\n  \"description\": \"Detailed description (optional, max 2000 chars)\",\n  \"activityType\": \"Type of activity (required)\",\n  \"startTime\": \"ISO 8601 datetime (required)\",\n  \"endTime\": \"ISO 8601 datetime (optional)\",\n  \"capacity\": \"Maximum participants (optional, positive integer)\",\n  \"costPerPerson\": \"Cost per person in USD (optional, non-negative number)\",\n  \"adultsOnly\": \"Boolean indicating if adults only (optional)\",\n  \"plusOneAllowed\": \"Boolean indicating if plus ones allowed (optional)\"\n}`,\n    accommodation: `\nExtract the following fields in JSON format:\n{\n  \"name\": \"Accommodation name (required, max 200 chars)\",\n  \"description\": \"Detailed description (optional, max 5000 chars)\",\n  \"address\": \"Physical address (optional, max 500 chars)\"\n}`,\n    vendor: `\nExtract the following fields in JSON format:\n{\n  \"name\": \"Vendor name (required, max 100 chars)\",\n  \"category\": \"One of: photography, flowers, catering, music, transportation, decoration, other (required)\",\n  \"contactName\": \"Contact person name (optional, max 100 chars)\",\n  \"email\": \"Contact email (optional, valid email format)\",\n  \"phone\": \"Contact phone (optional, max 20 chars)\",\n  \"pricingModel\": \"One of: flat_rate, per_guest, tiered (required)\",\n  \"baseCost\": \"Base cost in USD (required, non-negative number)\",\n  \"notes\": \"Additional notes (optional, max 2000 chars)\"\n}`,\n  };\n\n  return `${basePrompt}${schemas[contentType]}\n\nHTML Content:\n${htmlContent.substring(0, 10000)} ${htmlContent.length > 10000 ? '...(truncated)' : ''}\n\nReturn ONLY valid JSON matching the schema above. Do not include any explanatory text.`;\n}\n\n/**\n * Parses and validates AI response against the appropriate schema.\n * \n * @param contentType - Type of content extracted\n * @param aiResponse - Raw AI response text\n * @returns Result containing validated and sanitized data\n */\nfunction parseAndValidateResponse<T>(\n  contentType: ContentType,\n  aiResponse: string\n): Result<{ data: T; warnings: string[] }> {\n  try {\n    // Extract JSON from response (handle markdown code blocks)\n    let jsonText = aiResponse.trim();\n    if (jsonText.startsWith('```json')) {\n      jsonText = jsonText.replace(/```json\\n?/, '').replace(/\\n?```$/, '');\n    } else if (jsonText.startsWith('```')) {\n      jsonText = jsonText.replace(/```\\n?/, '').replace(/\\n?```$/, '');\n    }\n\n    const parsed = JSON.parse(jsonText);\n    const warnings: string[] = [];\n\n    // Sanitize all string fields\n    const sanitized = sanitizeExtractedData(parsed, warnings);\n\n    // Validate against appropriate schema\n    let validation;\n    switch (contentType) {\n      case 'activity':\n        validation = createActivitySchema.safeParse(sanitized);\n        break;\n      case 'accommodation':\n        validation = createAccommodationSchema.safeParse(sanitized);\n        break;\n      case 'vendor':\n        validation = createVendorSchema.safeParse(sanitized);\n        break;\n      default:\n        return {\n          success: false,\n          error: {\n            code: 'INVALID_CONTENT_TYPE',\n            message: `Unsupported content type: ${contentType}`,\n          },\n        };\n    }\n\n    if (!validation.success) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Extracted data failed schema validation',\n          details: validation.error.issues,\n        },\n      };\n    }\n\n    return {\n      success: true,\n      data: {\n        data: validation.data as T,\n        warnings,\n      },\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'PARSE_ERROR',\n        message: error instanceof Error ? error.message : 'Failed to parse AI response',\n      },\n    };\n  }\n}\n\n/**\n * Recursively sanitizes all string fields in extracted data.\n * \n * @param data - Raw extracted data object\n * @param warnings - Array to collect sanitization warnings\n * @returns Sanitized data object\n */\nfunction sanitizeExtractedData(data: any, warnings: string[]): any {\n  if (typeof data === 'string') {\n    const sanitized = sanitizeExtractedText(data);\n    if (sanitized !== data) {\n      warnings.push('Some content was sanitized to remove potentially dangerous patterns');\n    }\n    return sanitized;\n  }\n\n  if (Array.isArray(data)) {\n    return data.map((item) => sanitizeExtractedData(item, warnings));\n  }\n\n  if (data && typeof data === 'object') {\n    const sanitized: any = {};\n    for (const [key, value] of Object.entries(data)) {\n      sanitized[key] = sanitizeExtractedData(value, warnings);\n    }\n    return sanitized;\n  }\n\n  return data;\n}\n\n/**\n * Determines confidence level based on validation and content quality.\n * \n * @param data - Validated data\n * @param warnings - Validation warnings\n * @returns Confidence level\n */\nfunction determineConfidence(data: any, warnings: string[]): 'high' | 'medium' | 'low' {\n  if (warnings.length > 2) {\n    return 'low';\n  }\n\n  // Check for required fields completeness\n  const hasRequiredFields = data.name && data.name.length > 0;\n  const hasOptionalFields = Object.keys(data).length > 3;\n\n  if (hasRequiredFields && hasOptionalFields && warnings.length === 0) {\n    return 'high';\n  }\n\n  if (hasRequiredFields) {\n    return 'medium';\n  }\n\n  return 'low';\n}\n\n/**\n * Extracts structured content from a URL using Google Gemini AI.\n * \n * @param request - Extraction request with URL and content type\n * @returns Result containing extracted and validated content with preview\n * \n * @example\n * const result = await extractContentFromUrl({\n *   url: 'https://example.com/venue',\n *   contentType: 'accommodation',\n * });\n * \n * if (result.success) {\n *   console.log('Extracted:', result.data.extractedData);\n *   console.log('Confidence:', result.data.confidence);\n * }\n */\nexport async function extractContentFromUrl<T = CreateActivityDTO | CreateAccommodationDTO | CreateVendorDTO>(\n  request: ExtractionRequestDTO\n): Promise<Result<ExtractedContent<T>>> {\n  try {\n    // 1. Validate request\n    const validation = extractionRequestSchema.safeParse(request);\n    if (!validation.success) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Invalid extraction request',\n          details: validation.error.issues,\n        },\n      };\n    }\n\n    const { url, contentType, additionalContext } = validation.data;\n\n    // 2. Fetch URL content\n    const fetchResult = await fetchUrlContent(url);\n    if (!fetchResult.success) {\n      return fetchResult as Result<ExtractedContent<T>>;\n    }\n\n    // 3. Initialize Gemini AI\n    const apiKey = process.env.GEMINI_API_KEY;\n    if (!apiKey) {\n      return {\n        success: false,\n        error: {\n          code: 'CONFIGURATION_ERROR',\n          message: 'GEMINI_API_KEY environment variable is not set',\n        },\n      };\n    }\n\n    const genAI = new GoogleGenerativeAI(apiKey);\n    const model = genAI.getGenerativeModel({ model: 'gemini-pro' });\n\n    // 4. Generate prompt and extract content\n    const prompt = generateExtractionPrompt(contentType, fetchResult.data, additionalContext);\n\n    const result = await model.generateContent(prompt);\n    const response = await result.response;\n    const aiResponse = response.text();\n\n    // 5. Parse and validate response\n    const parseResult = parseAndValidateResponse<T>(contentType, aiResponse);\n    if (!parseResult.success) {\n      return parseResult as Result<ExtractedContent<T>>;\n    }\n\n    const { data: extractedData, warnings } = parseResult.data;\n\n    // 6. Determine confidence level\n    const confidence = determineConfidence(extractedData, warnings);\n\n    return {\n      success: true,\n      data: {\n        contentType,\n        sourceUrl: url,\n        extractedData,\n        rawResponse: aiResponse,\n        confidence,\n        warnings,\n      },\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'EXTERNAL_SERVICE_ERROR',\n        message: error instanceof Error ? error.message : 'AI extraction failed',\n        details: error,\n      },\n    };\n  }\n}\n\n/**\n * Validates extracted content against the appropriate schema without importing.\n * Useful for preview before import.\n * \n * @param contentType - Type of content\n * @param data - Data to validate\n * @returns Result indicating if data is valid\n */\nexport function validateExtractedContent(\n  contentType: ContentType,\n  data: unknown\n): Result<void> {\n  try {\n    let validation;\n    switch (contentType) {\n      case 'activity':\n        validation = createActivitySchema.safeParse(data);\n        break;\n      case 'accommodation':\n        validation = createAccommodationSchema.safeParse(data);\n        break;\n      case 'vendor':\n        validation = createVendorSchema.safeParse(data);\n        break;\n      default:\n        return {\n          success: false,\n          error: {\n            code: 'INVALID_CONTENT_TYPE',\n            message: `Unsupported content type: ${contentType}`,\n          },\n        };\n    }\n\n    if (!validation.success) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Content validation failed',\n          details: validation.error.issues,\n        },\n      };\n    }\n\n    return { success: true, data: undefined };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'VALIDATION_ERROR',\n        message: error instanceof Error ? error.message : 'Validation failed',\n      },\n    };\n  }\n}\n"],"names":["extractContentFromUrl","sanitizeExtractedRichText","sanitizeExtractedText","validateExtractedContent","urlSchema","z","string","url","refine","parsed","URL","protocol","message","extractionRequestSchema","object","contentType","enum","additionalContext","max","optional","input","sanitizeInput","html","sanitizeRichText","fetchUrlContent","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","signal","headers","clearTimeout","ok","success","error","code","status","statusText","get","includes","text","length","data","Error","name","generateExtractionPrompt","htmlContent","basePrompt","schemas","activity","accommodation","vendor","substring","parseAndValidateResponse","aiResponse","jsonText","trim","startsWith","replace","JSON","parse","warnings","sanitized","sanitizeExtractedData","validation","createActivitySchema","safeParse","createAccommodationSchema","createVendorSchema","details","issues","push","Array","isArray","map","item","key","value","Object","entries","determineConfidence","hasRequiredFields","hasOptionalFields","keys","request","fetchResult","apiKey","process","env","GEMINI_API_KEY","genAI","GoogleGenerativeAI","model","getGenerativeModel","prompt","result","generateContent","parseResult","extractedData","confidence","sourceUrl","rawResponse","undefined"],"mappings":";;;;;;;;;;;QAgXsBA;eAAAA;;QAzSNC;eAAAA;;QAdAC;eAAAA;;QAgZAC;eAAAA;;;8BAzcmB;8BACa;qBAC9B;iCAE2C;sCACU;+BACd;AAOzD;;CAEC,GACD,MAAMC,YAAYC,MAAC,CAACC,MAAM,GAAGC,GAAG,CAAC,sBAAsBC,MAAM,CAC3D,CAACD;IACC,IAAI;QACF,MAAME,SAAS,IAAIC,IAAIH;QACvB,OAAOE,OAAOE,QAAQ,KAAK,WAAWF,OAAOE,QAAQ,KAAK;IAC5D,EAAE,OAAM;QACN,OAAO;IACT;AACF,GACA;IAAEC,SAAS;AAAsC;AAGnD;;CAEC,GACD,MAAMC,0BAA0BR,MAAC,CAACS,MAAM,CAAC;IACvCP,KAAKH;IACLW,aAAaV,MAAC,CAACW,IAAI,CAAC;QAAC;QAAY;QAAiB;KAAS;IAC3DC,mBAAmBZ,MAAC,CAACC,MAAM,GAAGY,GAAG,CAAC,KAAKC,QAAQ;AACjD;AAsBO,SAASjB,sBAAsBkB,KAAa;IACjD,IAAI,CAACA,SAAS,OAAOA,UAAU,UAAU;QACvC,OAAO;IACT;IAEA,OAAOC,IAAAA,2BAAa,EAACD;AACvB;AAQO,SAASnB,0BAA0BqB,IAAY;IACpD,IAAI,CAACA,QAAQ,OAAOA,SAAS,UAAU;QACrC,OAAO;IACT;IAEA,OAAOC,IAAAA,8BAAgB,EAACD;AAC1B;AAEA;;;;;CAKC,GACD,eAAeE,gBAAgBjB,GAAW;IACxC,IAAI;QACF,MAAMkB,aAAa,IAAIC;QACvB,MAAMC,YAAYC,WAAW,IAAMH,WAAWI,KAAK,IAAI,QAAQ,oBAAoB;QAEnF,MAAMC,WAAW,MAAMC,MAAMxB,KAAK;YAChCyB,QAAQP,WAAWO,MAAM;YACzBC,SAAS;gBACP,cAAc;YAChB;QACF;QAEAC,aAAaP;QAEb,IAAI,CAACG,SAASK,EAAE,EAAE;YAChB,OAAO;gBACLC,SAAS;gBACTC,OAAO;oBACLC,MAAM;oBACN1B,SAAS,CAAC,qBAAqB,EAAEkB,SAASS,MAAM,CAAC,CAAC,EAAET,SAASU,UAAU,EAAE;gBAC3E;YACF;QACF;QAEA,MAAMzB,cAAce,SAASG,OAAO,CAACQ,GAAG,CAAC;QACzC,IAAI,CAAC1B,eAAe,CAACA,YAAY2B,QAAQ,CAAC,cAAc;YACtD,OAAO;gBACLN,SAAS;gBACTC,OAAO;oBACLC,MAAM;oBACN1B,SAAS;gBACX;YACF;QACF;QAEA,4BAA4B;QAC5B,MAAM+B,OAAO,MAAMb,SAASa,IAAI;QAChC,IAAIA,KAAKC,MAAM,GAAG,OAAO,MAAM;YAC7B,OAAO;gBACLR,SAAS;gBACTC,OAAO;oBACLC,MAAM;oBACN1B,SAAS;gBACX;YACF;QACF;QAEA,OAAO;YAAEwB,SAAS;YAAMS,MAAMF;QAAK;IACrC,EAAE,OAAON,OAAO;QACd,IAAIA,iBAAiBS,SAAST,MAAMU,IAAI,KAAK,cAAc;YACzD,OAAO;gBACLX,SAAS;gBACTC,OAAO;oBACLC,MAAM;oBACN1B,SAAS;gBACX;YACF;QACF;QAEA,OAAO;YACLwB,SAAS;YACTC,OAAO;gBACLC,MAAM;gBACN1B,SAASyB,iBAAiBS,QAAQT,MAAMzB,OAAO,GAAG;YACpD;QACF;IACF;AACF;AAEA;;;;;;;CAOC,GACD,SAASoC,yBACPjC,WAAwB,EACxBkC,WAAmB,EACnBhC,iBAA0B;IAE1B,MAAMiC,aAAa,CAAC;;cAER,EAAEnC,YAAY;;AAE5B,EAAEE,oBAAoB,CAAC,oBAAoB,EAAEA,kBAAkB,IAAI,CAAC,GAAG,IAAI;IAEzE,MAAMkC,UAAU;QACdC,UAAU,CAAC;;;;;;;;;;;;CAYd,CAAC;QACEC,eAAe,CAAC;;;;;;CAMnB,CAAC;QACEC,QAAQ,CAAC;;;;;;;;;;;CAWZ,CAAC;IACA;IAEA,OAAO,GAAGJ,aAAaC,OAAO,CAACpC,YAAY,CAAC;;;AAG9C,EAAEkC,YAAYM,SAAS,CAAC,GAAG,OAAO,CAAC,EAAEN,YAAYL,MAAM,GAAG,QAAQ,mBAAmB,GAAG;;sFAEF,CAAC;AACvF;AAEA;;;;;;CAMC,GACD,SAASY,yBACPzC,WAAwB,EACxB0C,UAAkB;IAElB,IAAI;QACF,2DAA2D;QAC3D,IAAIC,WAAWD,WAAWE,IAAI;QAC9B,IAAID,SAASE,UAAU,CAAC,YAAY;YAClCF,WAAWA,SAASG,OAAO,CAAC,cAAc,IAAIA,OAAO,CAAC,WAAW;QACnE,OAAO,IAAIH,SAASE,UAAU,CAAC,QAAQ;YACrCF,WAAWA,SAASG,OAAO,CAAC,UAAU,IAAIA,OAAO,CAAC,WAAW;QAC/D;QAEA,MAAMpD,SAASqD,KAAKC,KAAK,CAACL;QAC1B,MAAMM,WAAqB,EAAE;QAE7B,6BAA6B;QAC7B,MAAMC,YAAYC,sBAAsBzD,QAAQuD;QAEhD,sCAAsC;QACtC,IAAIG;QACJ,OAAQpD;YACN,KAAK;gBACHoD,aAAaC,qCAAoB,CAACC,SAAS,CAACJ;gBAC5C;YACF,KAAK;gBACHE,aAAaG,+CAAyB,CAACD,SAAS,CAACJ;gBACjD;YACF,KAAK;gBACHE,aAAaI,iCAAkB,CAACF,SAAS,CAACJ;gBAC1C;YACF;gBACE,OAAO;oBACL7B,SAAS;oBACTC,OAAO;wBACLC,MAAM;wBACN1B,SAAS,CAAC,0BAA0B,EAAEG,aAAa;oBACrD;gBACF;QACJ;QAEA,IAAI,CAACoD,WAAW/B,OAAO,EAAE;YACvB,OAAO;gBACLA,SAAS;gBACTC,OAAO;oBACLC,MAAM;oBACN1B,SAAS;oBACT4D,SAASL,WAAW9B,KAAK,CAACoC,MAAM;gBAClC;YACF;QACF;QAEA,OAAO;YACLrC,SAAS;YACTS,MAAM;gBACJA,MAAMsB,WAAWtB,IAAI;gBACrBmB;YACF;QACF;IACF,EAAE,OAAO3B,OAAO;QACd,OAAO;YACLD,SAAS;YACTC,OAAO;gBACLC,MAAM;gBACN1B,SAASyB,iBAAiBS,QAAQT,MAAMzB,OAAO,GAAG;YACpD;QACF;IACF;AACF;AAEA;;;;;;CAMC,GACD,SAASsD,sBAAsBrB,IAAS,EAAEmB,QAAkB;IAC1D,IAAI,OAAOnB,SAAS,UAAU;QAC5B,MAAMoB,YAAY/D,sBAAsB2C;QACxC,IAAIoB,cAAcpB,MAAM;YACtBmB,SAASU,IAAI,CAAC;QAChB;QACA,OAAOT;IACT;IAEA,IAAIU,MAAMC,OAAO,CAAC/B,OAAO;QACvB,OAAOA,KAAKgC,GAAG,CAAC,CAACC,OAASZ,sBAAsBY,MAAMd;IACxD;IAEA,IAAInB,QAAQ,OAAOA,SAAS,UAAU;QACpC,MAAMoB,YAAiB,CAAC;QACxB,KAAK,MAAM,CAACc,KAAKC,MAAM,IAAIC,OAAOC,OAAO,CAACrC,MAAO;YAC/CoB,SAAS,CAACc,IAAI,GAAGb,sBAAsBc,OAAOhB;QAChD;QACA,OAAOC;IACT;IAEA,OAAOpB;AACT;AAEA;;;;;;CAMC,GACD,SAASsC,oBAAoBtC,IAAS,EAAEmB,QAAkB;IACxD,IAAIA,SAASpB,MAAM,GAAG,GAAG;QACvB,OAAO;IACT;IAEA,yCAAyC;IACzC,MAAMwC,oBAAoBvC,KAAKE,IAAI,IAAIF,KAAKE,IAAI,CAACH,MAAM,GAAG;IAC1D,MAAMyC,oBAAoBJ,OAAOK,IAAI,CAACzC,MAAMD,MAAM,GAAG;IAErD,IAAIwC,qBAAqBC,qBAAqBrB,SAASpB,MAAM,KAAK,GAAG;QACnE,OAAO;IACT;IAEA,IAAIwC,mBAAmB;QACrB,OAAO;IACT;IAEA,OAAO;AACT;AAmBO,eAAepF,sBACpBuF,OAA6B;IAE7B,IAAI;QACF,sBAAsB;QACtB,MAAMpB,aAAatD,wBAAwBwD,SAAS,CAACkB;QACrD,IAAI,CAACpB,WAAW/B,OAAO,EAAE;YACvB,OAAO;gBACLA,SAAS;gBACTC,OAAO;oBACLC,MAAM;oBACN1B,SAAS;oBACT4D,SAASL,WAAW9B,KAAK,CAACoC,MAAM;gBAClC;YACF;QACF;QAEA,MAAM,EAAElE,GAAG,EAAEQ,WAAW,EAAEE,iBAAiB,EAAE,GAAGkD,WAAWtB,IAAI;QAE/D,uBAAuB;QACvB,MAAM2C,cAAc,MAAMhE,gBAAgBjB;QAC1C,IAAI,CAACiF,YAAYpD,OAAO,EAAE;YACxB,OAAOoD;QACT;QAEA,0BAA0B;QAC1B,MAAMC,SAASC,QAAQC,GAAG,CAACC,cAAc;QACzC,IAAI,CAACH,QAAQ;YACX,OAAO;gBACLrD,SAAS;gBACTC,OAAO;oBACLC,MAAM;oBACN1B,SAAS;gBACX;YACF;QACF;QAEA,MAAMiF,QAAQ,IAAIC,gCAAkB,CAACL;QACrC,MAAMM,QAAQF,MAAMG,kBAAkB,CAAC;YAAED,OAAO;QAAa;QAE7D,yCAAyC;QACzC,MAAME,SAASjD,yBAAyBjC,aAAayE,YAAY3C,IAAI,EAAE5B;QAEvE,MAAMiF,SAAS,MAAMH,MAAMI,eAAe,CAACF;QAC3C,MAAMnE,WAAW,MAAMoE,OAAOpE,QAAQ;QACtC,MAAM2B,aAAa3B,SAASa,IAAI;QAEhC,iCAAiC;QACjC,MAAMyD,cAAc5C,yBAA4BzC,aAAa0C;QAC7D,IAAI,CAAC2C,YAAYhE,OAAO,EAAE;YACxB,OAAOgE;QACT;QAEA,MAAM,EAAEvD,MAAMwD,aAAa,EAAErC,QAAQ,EAAE,GAAGoC,YAAYvD,IAAI;QAE1D,gCAAgC;QAChC,MAAMyD,aAAanB,oBAAoBkB,eAAerC;QAEtD,OAAO;YACL5B,SAAS;YACTS,MAAM;gBACJ9B;gBACAwF,WAAWhG;gBACX8F;gBACAG,aAAa/C;gBACb6C;gBACAtC;YACF;QACF;IACF,EAAE,OAAO3B,OAAO;QACd,OAAO;YACLD,SAAS;YACTC,OAAO;gBACLC,MAAM;gBACN1B,SAASyB,iBAAiBS,QAAQT,MAAMzB,OAAO,GAAG;gBAClD4D,SAASnC;YACX;QACF;IACF;AACF;AAUO,SAASlC,yBACdY,WAAwB,EACxB8B,IAAa;IAEb,IAAI;QACF,IAAIsB;QACJ,OAAQpD;YACN,KAAK;gBACHoD,aAAaC,qCAAoB,CAACC,SAAS,CAACxB;gBAC5C;YACF,KAAK;gBACHsB,aAAaG,+CAAyB,CAACD,SAAS,CAACxB;gBACjD;YACF,KAAK;gBACHsB,aAAaI,iCAAkB,CAACF,SAAS,CAACxB;gBAC1C;YACF;gBACE,OAAO;oBACLT,SAAS;oBACTC,OAAO;wBACLC,MAAM;wBACN1B,SAAS,CAAC,0BAA0B,EAAEG,aAAa;oBACrD;gBACF;QACJ;QAEA,IAAI,CAACoD,WAAW/B,OAAO,EAAE;YACvB,OAAO;gBACLA,SAAS;gBACTC,OAAO;oBACLC,MAAM;oBACN1B,SAAS;oBACT4D,SAASL,WAAW9B,KAAK,CAACoC,MAAM;gBAClC;YACF;QACF;QAEA,OAAO;YAAErC,SAAS;YAAMS,MAAM4D;QAAU;IAC1C,EAAE,OAAOpE,OAAO;QACd,OAAO;YACLD,SAAS;YACTC,OAAO;gBACLC,MAAM;gBACN1B,SAASyB,iBAAiBS,QAAQT,MAAMzB,OAAO,GAAG;YACpD;QACF;IACF;AACF"}