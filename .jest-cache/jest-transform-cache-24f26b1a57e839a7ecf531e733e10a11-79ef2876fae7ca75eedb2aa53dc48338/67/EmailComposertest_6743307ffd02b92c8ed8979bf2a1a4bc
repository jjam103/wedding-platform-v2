802b78604b3601c6874fd4f20f1278a4
/**
 * Unit Tests for EmailComposer Component
 * 
 * Tests:
 * - Modal display and closing
 * - Data loading (guests, groups, templates)
 * - Form submission
 * - Template selection
 * - Recipient selection
 * - Email preview
 * - Error handling
 * 
 * Requirements: Email composer functionality
 */ "use strict";
jest.mock('@/components/ui/ToastContext', ()=>({
        useToast: ()=>({
                addToast: mockAddToast
            })
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = require("@testing-library/react");
const _userevent = /*#__PURE__*/ _interop_require_default(require("@testing-library/user-event"));
const _EmailComposer = require("./EmailComposer");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Mock toast context
const mockAddToast = jest.fn();
// Mock fetch
global.fetch = jest.fn();
const mockGuests = [
    {
        id: '1',
        first_name: 'John',
        last_name: 'Doe',
        email: 'john@example.com'
    },
    {
        id: '2',
        first_name: 'Jane',
        last_name: 'Smith',
        email: 'jane@example.com'
    },
    {
        id: '3',
        first_name: 'Bob',
        last_name: 'Wilson',
        email: null
    }
];
const mockGroups = [
    {
        id: '1',
        name: 'Family'
    },
    {
        id: '2',
        name: 'Friends'
    }
];
const mockTemplates = [
    {
        id: '1',
        name: 'RSVP Reminder',
        subject: 'Please RSVP',
        body_html: '<p>Please respond by...</p>'
    },
    {
        id: '2',
        name: 'Welcome Email',
        subject: 'Welcome!',
        body_html: '<p>Welcome to our wedding...</p>'
    }
];
describe('EmailComposer', ()=>{
    const mockFetch = fetch;
    let mockOnClose;
    let mockOnSuccess;
    // Helper function to set up mocks for each test
    const setupMocks = ()=>{
        mockFetch.mockClear();
        mockFetch.mockResolvedValueOnce({
            ok: true,
            json: async ()=>({
                    success: true,
                    data: {
                        guests: mockGuests
                    }
                })
        }).mockResolvedValueOnce({
            ok: true,
            json: async ()=>({
                    success: true,
                    data: mockGroups
                })
        }).mockResolvedValueOnce({
            ok: true,
            json: async ()=>({
                    success: true,
                    data: mockTemplates
                })
        });
    };
    beforeEach(()=>{
        mockOnClose = jest.fn();
        mockOnSuccess = jest.fn();
        mockAddToast.mockClear();
        mockFetch.mockClear();
    });
    afterEach(()=>{
        (0, _react.cleanup)();
    });
    describe('Modal Display', ()=>{
        it('should not render when isOpen is false', ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: false,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            expect(_react.screen.queryByText('Compose Email')).not.toBeInTheDocument();
        });
        it('should render when isOpen is true', ()=>{
            setupMocks();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            expect(_react.screen.getByText('Compose Email')).toBeInTheDocument();
        });
        it('should call onClose when close button is clicked', ()=>{
            setupMocks();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            const closeButton = _react.screen.getByLabelText('Close');
            _react.fireEvent.click(closeButton);
            expect(mockOnClose).toHaveBeenCalled();
        });
        it('should call onClose when cancel button is clicked', async ()=>{
            setupMocks();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            });
            const cancelButton = _react.screen.getByRole('button', {
                name: /cancel/i
            });
            _react.fireEvent.click(cancelButton);
            expect(mockOnClose).toHaveBeenCalled();
        });
    });
    describe('Data Loading', ()=>{
        it('should show loading state initially', ()=>{
            setupMocks();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            expect(_react.screen.getByText('Loading...')).toBeInTheDocument();
        });
        it('should fetch guests, groups, and templates on open', async ()=>{
            setupMocks();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            await (0, _react.waitFor)(()=>{
                expect(mockFetch).toHaveBeenCalledWith('/api/admin/guests');
                expect(mockFetch).toHaveBeenCalledWith('/api/admin/groups');
                expect(mockFetch).toHaveBeenCalledWith('/api/admin/emails/templates');
            });
        });
        it('should not fetch data when modal is closed', ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: false,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            expect(mockFetch).not.toHaveBeenCalled();
        });
        it('should display loaded data', async ()=>{
            setupMocks();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            });
            // Check templates are loaded
            expect(_react.screen.getByText('RSVP Reminder')).toBeInTheDocument();
            expect(_react.screen.getByText('Welcome Email')).toBeInTheDocument();
            // Check guests are loaded (only those with emails) - guests are shown by default
            expect(_react.screen.getByText('John Doe (john@example.com)')).toBeInTheDocument();
            expect(_react.screen.getByText('Jane Smith (jane@example.com)')).toBeInTheDocument();
            expect(_react.screen.queryByText('Bob Wilson')).not.toBeInTheDocument(); // No email
            // Switch to groups to check they're loaded
            const groupRadio = _react.screen.getByLabelText('Guest Groups');
            _react.fireEvent.click(groupRadio);
            // Check groups are loaded
            expect(_react.screen.getByText('Family')).toBeInTheDocument();
            expect(_react.screen.getByText('Friends')).toBeInTheDocument();
        });
        it('should handle fetch errors gracefully', async ()=>{
            // Clear previous mocks and set up error
            mockFetch.mockClear();
            mockFetch.mockRejectedValue(new Error('Network error'));
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            await (0, _react.waitFor)(()=>{
                expect(mockAddToast).toHaveBeenCalledWith({
                    type: 'error',
                    message: 'Failed to load data'
                });
            }, {
                timeout: 2000
            });
        });
    });
    describe('Template Selection', ()=>{
        it('should populate subject and body when template is selected', async ()=>{
            setupMocks();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            });
            const templateSelect = _react.screen.getByLabelText(/email template/i);
            _react.fireEvent.change(templateSelect, {
                target: {
                    value: '1'
                }
            });
            const subjectInput = _react.screen.getByLabelText(/subject/i);
            const bodyTextarea = _react.screen.getByLabelText(/email body/i);
            expect(subjectInput).toHaveValue('Please RSVP');
            expect(bodyTextarea).toHaveValue('<p>Please respond by...</p>');
        });
        it('should clear subject and body when no template is selected', async ()=>{
            setupMocks();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            });
            const templateSelect = _react.screen.getByLabelText(/email template/i);
            const subjectInput = _react.screen.getByLabelText(/subject/i);
            const bodyTextarea = _react.screen.getByLabelText(/email body/i);
            // Select template first
            _react.fireEvent.change(templateSelect, {
                target: {
                    value: '1'
                }
            });
            expect(subjectInput).toHaveValue('Please RSVP');
            // Clear template
            _react.fireEvent.change(templateSelect, {
                target: {
                    value: ''
                }
            });
            expect(subjectInput).toHaveValue('');
            expect(bodyTextarea).toHaveValue('');
        });
    });
    describe('Recipient Selection', ()=>{
        it('should switch between guest and group recipient types', async ()=>{
            setupMocks();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            });
            // Initially guests should be selected
            const guestRadio = _react.screen.getByLabelText('Individual Guests');
            const groupRadio = _react.screen.getByLabelText('Guest Groups');
            expect(guestRadio).toBeChecked();
            expect(_react.screen.getByText('John Doe (john@example.com)')).toBeInTheDocument();
            // Switch to groups
            _react.fireEvent.click(groupRadio);
            expect(groupRadio).toBeChecked();
            expect(_react.screen.getByText('Family')).toBeInTheDocument();
            expect(_react.screen.queryByText('John Doe (john@example.com)')).not.toBeInTheDocument();
        });
        it('should clear selected recipients when switching types', async ()=>{
            setupMocks();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            });
            const recipientSelect = _react.screen.getByLabelText(/recipients/i);
            const groupRadio = _react.screen.getByLabelText('Guest Groups');
            // Select a guest
            _react.fireEvent.change(recipientSelect, {
                target: {
                    value: [
                        '1'
                    ]
                }
            });
            // Switch to groups
            _react.fireEvent.click(groupRadio);
            // Recipients should be cleared
            expect(recipientSelect.selectedOptions.length).toBe(0);
        });
    });
    describe('Form Validation', ()=>{
        it('should validate that recipients are selected', async ()=>{
            setupMocks();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            });
            const sendButton = _react.screen.getByRole('button', {
                name: /send email/i
            });
            _react.fireEvent.click(sendButton);
            await (0, _react.waitFor)(()=>{
                expect(mockAddToast).toHaveBeenCalledWith({
                    type: 'error',
                    message: 'Please select at least one recipient'
                });
            });
        });
        it('should validate that subject is entered', async ()=>{
            setupMocks();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            });
            const recipientSelect = _react.screen.getByLabelText(/recipients/i);
            _react.fireEvent.change(recipientSelect, {
                target: {
                    value: [
                        '1'
                    ]
                }
            });
            const sendButton = _react.screen.getByRole('button', {
                name: /send email/i
            });
            _react.fireEvent.click(sendButton);
            await (0, _react.waitFor)(()=>{
                expect(mockAddToast).toHaveBeenCalledWith({
                    type: 'error',
                    message: 'Please enter a subject'
                });
            });
        });
        it('should validate that body is entered', async ()=>{
            setupMocks();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            });
            const recipientSelect = _react.screen.getByLabelText(/recipients/i);
            const subjectInput = _react.screen.getByLabelText(/subject/i);
            _react.fireEvent.change(recipientSelect, {
                target: {
                    value: [
                        '1'
                    ]
                }
            });
            _react.fireEvent.change(subjectInput, {
                target: {
                    value: 'Test Subject'
                }
            });
            const sendButton = _react.screen.getByRole('button', {
                name: /send email/i
            });
            _react.fireEvent.click(sendButton);
            await (0, _react.waitFor)(()=>{
                expect(mockAddToast).toHaveBeenCalledWith({
                    type: 'error',
                    message: 'Please enter email body'
                });
            });
        });
        it('should validate that selected recipients have email addresses', async ()=>{
            // This test is not applicable because the component filters out guests without emails
            // from the selection list, so it's impossible to select a guest without an email.
            // Instead, we'll test that guests without emails are not shown in the list.
            // Mock guests with mixed email status
            mockFetch.mockClear();
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: {
                            guests: [
                                {
                                    id: '1',
                                    first_name: 'John',
                                    last_name: 'Doe',
                                    email: 'john@example.com'
                                },
                                {
                                    id: '2',
                                    first_name: 'Jane',
                                    last_name: 'Smith',
                                    email: null
                                }
                            ]
                        }
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockGroups
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockTemplates
                    })
            });
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            });
            // John should be in the list (has email)
            expect(_react.screen.getByText('John Doe (john@example.com)')).toBeInTheDocument();
            // Jane should NOT be in the list (no email)
            expect(_react.screen.queryByText(/Jane Smith/)).not.toBeInTheDocument();
        });
    });
    describe('Email Sending', ()=>{
        it('should send email successfully', async ()=>{
            setupMocks();
            const user = _userevent.default.setup();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            // Wait for loading to complete
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            }, {
                timeout: 3000
            });
            // Fill out the form
            const recipientSelect = _react.screen.getByLabelText(/recipients/i);
            const subjectInput = _react.screen.getByLabelText(/subject/i);
            const bodyTextarea = _react.screen.getByLabelText(/email body/i);
            await user.selectOptions(recipientSelect, [
                '1',
                '2'
            ]);
            await user.type(subjectInput, 'Test Subject');
            await user.type(bodyTextarea, '<p>Test Body</p>');
            // Mock the send email API call AFTER filling the form
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true
                    })
            });
            // Submit the form
            const sendButtons = _react.screen.getAllByRole('button', {
                name: /send email/i
            });
            const sendButton = sendButtons[sendButtons.length - 1];
            await user.click(sendButton);
            await (0, _react.waitFor)(()=>{
                // Check the fetch call for sending email
                const sendCall = mockFetch.mock.calls.find((call)=>call[0] === '/api/admin/emails/send');
                expect(sendCall).toBeDefined();
                expect(sendCall[1]).toMatchObject({
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                const body = JSON.parse(sendCall[1].body);
                expect(body.recipients).toEqual([
                    'john@example.com',
                    'jane@example.com'
                ]);
                expect(body.subject).toBe('Test Subject');
                expect(body.html).toBe('<p>Test Body</p>');
            });
            await (0, _react.waitFor)(()=>{
                expect(mockAddToast).toHaveBeenCalledWith({
                    type: 'success',
                    message: 'Email sent to 2 recipient(s)'
                });
            });
            expect(mockOnSuccess).toHaveBeenCalled();
            expect(mockOnClose).toHaveBeenCalled();
        });
        it('should include template ID when template is selected', async ()=>{
            setupMocks();
            const user = _userevent.default.setup();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            // Wait for loading to complete
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            }, {
                timeout: 3000
            });
            const templateSelect = _react.screen.getByLabelText(/email template/i);
            const recipientSelect = _react.screen.getByLabelText(/recipients/i);
            await user.selectOptions(templateSelect, '1');
            await user.selectOptions(recipientSelect, [
                '1'
            ]);
            // Mock the send email API call AFTER filling the form
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true
                    })
            });
            const sendButtons = _react.screen.getAllByRole('button', {
                name: /send email/i
            });
            const sendButton = sendButtons[sendButtons.length - 1];
            await user.click(sendButton);
            await (0, _react.waitFor)(()=>{
                const sendCall = mockFetch.mock.calls.find((call)=>call[0] === '/api/admin/emails/send');
                expect(sendCall).toBeDefined();
                const body = JSON.parse(sendCall[1].body);
                expect(body.recipients).toEqual([
                    'john@example.com'
                ]);
                expect(body.subject).toBe('Please RSVP');
                expect(body.html).toBe('<p>Please respond by...</p>');
                expect(body.template_id).toBe('1');
            });
        });
        it('should handle send errors', async ()=>{
            setupMocks();
            const user = _userevent.default.setup();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            // Wait for loading to complete
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            }, {
                timeout: 3000
            });
            const recipientSelect = _react.screen.getByLabelText(/recipients/i);
            const subjectInput = _react.screen.getByLabelText(/subject/i);
            const bodyTextarea = _react.screen.getByLabelText(/email body/i);
            await user.selectOptions(recipientSelect, [
                '1'
            ]);
            await user.type(subjectInput, 'Test Subject');
            await user.type(bodyTextarea, 'Test Body');
            // Mock the send email API call with error AFTER filling the form
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: false,
                        error: {
                            message: 'Send failed'
                        }
                    })
            });
            const sendButtons = _react.screen.getAllByRole('button', {
                name: /send email/i
            });
            const sendButton = sendButtons[sendButtons.length - 1];
            await user.click(sendButton);
            await (0, _react.waitFor)(()=>{
                expect(mockAddToast).toHaveBeenCalledWith({
                    type: 'error',
                    message: 'Send failed'
                });
            });
            expect(mockOnSuccess).not.toHaveBeenCalled();
            expect(mockOnClose).not.toHaveBeenCalled();
        });
        it('should handle network errors', async ()=>{
            setupMocks();
            const user = _userevent.default.setup();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            // Wait for loading to complete
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            }, {
                timeout: 3000
            });
            const recipientSelect = _react.screen.getByLabelText(/recipients/i);
            const subjectInput = _react.screen.getByLabelText(/subject/i);
            const bodyTextarea = _react.screen.getByLabelText(/email body/i);
            await user.selectOptions(recipientSelect, [
                '1'
            ]);
            await user.type(subjectInput, 'Test Subject');
            await user.type(bodyTextarea, 'Test Body');
            // Mock network error AFTER filling the form
            mockFetch.mockRejectedValueOnce(new Error('Network error'));
            const sendButtons = _react.screen.getAllByRole('button', {
                name: /send email/i
            });
            const sendButton = sendButtons[sendButtons.length - 1];
            await user.click(sendButton);
            await (0, _react.waitFor)(()=>{
                expect(mockAddToast).toHaveBeenCalledWith({
                    type: 'error',
                    message: 'Failed to send email'
                });
            });
        });
    });
    describe('Email Preview', ()=>{
        it('should show preview when preview button is clicked', async ()=>{
            setupMocks();
            const user = _userevent.default.setup();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            // Wait for loading to complete
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            }, {
                timeout: 3000
            });
            const previewButton = _react.screen.getByRole('button', {
                name: /show preview/i
            });
            await user.click(previewButton);
            expect(_react.screen.getByText('Preview')).toBeInTheDocument();
            expect(_react.screen.getByRole('button', {
                name: /hide preview/i
            })).toBeInTheDocument();
        });
        it('should hide preview when hide button is clicked', async ()=>{
            setupMocks();
            const user = _userevent.default.setup();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            // Wait for loading to complete
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            }, {
                timeout: 3000
            });
            const previewButton = _react.screen.getByRole('button', {
                name: /show preview/i
            });
            await user.click(previewButton);
            const hideButton = _react.screen.getByRole('button', {
                name: /hide preview/i
            });
            await user.click(hideButton);
            expect(_react.screen.queryByText('Preview')).not.toBeInTheDocument();
            expect(_react.screen.getByRole('button', {
                name: /show preview/i
            })).toBeInTheDocument();
        });
        it('should display preview content', async ()=>{
            setupMocks();
            const user = _userevent.default.setup();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            // Wait for loading to complete
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            }, {
                timeout: 3000
            });
            const recipientSelect = _react.screen.getByLabelText(/recipients/i);
            const subjectInput = _react.screen.getByLabelText(/subject/i);
            const bodyTextarea = _react.screen.getByLabelText(/email body/i);
            await user.selectOptions(recipientSelect, [
                '1',
                '2'
            ]);
            await user.type(subjectInput, 'Test Subject');
            await user.type(bodyTextarea, '<p>Test Body</p>');
            const previewButton = _react.screen.getByRole('button', {
                name: /show preview/i
            });
            await user.click(previewButton);
            expect(_react.screen.getByText('Subject:')).toBeInTheDocument();
            expect(_react.screen.getByText('Test Subject')).toBeInTheDocument();
            expect(_react.screen.getByText('To:')).toBeInTheDocument();
            expect(_react.screen.getByText('2 recipient(s)')).toBeInTheDocument();
        });
    });
    describe('Loading States', ()=>{
        it('should disable buttons during submission', async ()=>{
            setupMocks();
            const user = _userevent.default.setup();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            // Wait for loading to complete
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            }, {
                timeout: 3000
            });
            // Fill out the form
            const recipientSelect = _react.screen.getByLabelText(/recipients/i);
            const subjectInput = _react.screen.getByLabelText(/subject/i);
            const bodyTextarea = _react.screen.getByLabelText(/email body/i);
            await user.selectOptions(recipientSelect, [
                '1'
            ]);
            await user.type(subjectInput, 'Test Subject');
            await user.type(bodyTextarea, 'Test Body');
            // Mock a slow send operation
            let resolvePromise;
            const slowSend = new Promise((resolve)=>{
                resolvePromise = resolve;
            });
            mockFetch.mockReturnValueOnce(slowSend);
            // Submit the form
            const sendButtons = _react.screen.getAllByRole('button', {
                name: /send email/i
            });
            const sendButton = sendButtons[sendButtons.length - 1];
            await user.click(sendButton);
            // Wait for buttons to be disabled
            await (0, _react.waitFor)(()=>{
                expect(sendButton).toBeDisabled();
            });
            const cancelButton = _react.screen.getByRole('button', {
                name: /cancel/i
            });
            const previewButton = _react.screen.getByRole('button', {
                name: /show preview/i
            });
            expect(cancelButton).toBeDisabled();
            expect(previewButton).toBeDisabled();
            // Resolve the promise to clean up
            resolvePromise({
                ok: true,
                json: async ()=>({
                        success: true
                    })
            });
        });
        it('should show sending text during submission', async ()=>{
            setupMocks();
            const user = _userevent.default.setup();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            // Wait for loading to complete
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            }, {
                timeout: 3000
            });
            // Fill out the form
            const recipientSelect = _react.screen.getByLabelText(/recipients/i);
            const subjectInput = _react.screen.getByLabelText(/subject/i);
            const bodyTextarea = _react.screen.getByLabelText(/email body/i);
            await user.selectOptions(recipientSelect, [
                '1'
            ]);
            await user.type(subjectInput, 'Test Subject');
            await user.type(bodyTextarea, 'Test Body');
            // Mock a slow send operation
            let resolvePromise;
            const slowSend = new Promise((resolve)=>{
                resolvePromise = resolve;
            });
            mockFetch.mockReturnValueOnce(slowSend);
            // Submit the form
            const sendButtons = _react.screen.getAllByRole('button', {
                name: /send email/i
            });
            const sendButton = sendButtons[sendButtons.length - 1];
            await user.click(sendButton);
            // Wait for sending text to appear
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByText('Sending...')).toBeInTheDocument();
            });
            // Resolve the promise to clean up
            resolvePromise({
                ok: true,
                json: async ()=>({
                        success: true
                    })
            });
        });
    });
    describe('Accessibility', ()=>{
        it('should have proper form labels', async ()=>{
            // Clear and set up fresh mocks
            mockFetch.mockClear();
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: {
                            guests: mockGuests
                        }
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockGroups
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockTemplates
                    })
            });
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            }, {
                timeout: 3000
            });
            expect(_react.screen.getByLabelText(/email template/i)).toBeInTheDocument();
            expect(_react.screen.getByLabelText(/recipients/i)).toBeInTheDocument();
            expect(_react.screen.getByLabelText(/subject/i)).toBeInTheDocument();
            expect(_react.screen.getByLabelText(/email body/i)).toBeInTheDocument();
        });
        it('should have required attributes on required fields', async ()=>{
            mockFetch.mockClear();
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: {
                            guests: mockGuests
                        }
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockGroups
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockTemplates
                    })
            });
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            }, {
                timeout: 3000
            });
            expect(_react.screen.getByLabelText(/recipients/i)).toHaveAttribute('required');
            expect(_react.screen.getByLabelText(/subject/i)).toHaveAttribute('required');
            expect(_react.screen.getByLabelText(/email body/i)).toHaveAttribute('required');
        });
        it('should have proper close button accessibility', async ()=>{
            mockFetch.mockClear();
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: {
                            guests: mockGuests
                        }
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockGroups
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockTemplates
                    })
            });
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            }, {
                timeout: 3000
            });
            const closeButton = _react.screen.getByLabelText('Close');
            expect(closeButton).toBeInTheDocument();
        });
        it('should provide help text for recipients field', async ()=>{
            mockFetch.mockClear();
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: {
                            guests: mockGuests
                        }
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockGroups
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockTemplates
                    })
            });
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            }, {
                timeout: 3000
            });
            expect(_react.screen.getByText('Hold Ctrl/Cmd to select multiple recipients')).toBeInTheDocument();
        });
        it('should provide help text for email body', async ()=>{
            mockFetch.mockClear();
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: {
                            guests: mockGuests
                        }
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockGroups
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockTemplates
                    })
            });
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_EmailComposer.EmailComposer, {
                isOpen: true,
                onClose: mockOnClose,
                onSuccess: mockOnSuccess
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Loading...')).not.toBeInTheDocument();
            }, {
                timeout: 3000
            });
            expect(_react.screen.getByText(/HTML tags are supported/)).toBeInTheDocument();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvY29tcG9uZW50cy9hZG1pbi9FbWFpbENvbXBvc2VyLnRlc3QudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVW5pdCBUZXN0cyBmb3IgRW1haWxDb21wb3NlciBDb21wb25lbnRcbiAqIFxuICogVGVzdHM6XG4gKiAtIE1vZGFsIGRpc3BsYXkgYW5kIGNsb3NpbmdcbiAqIC0gRGF0YSBsb2FkaW5nIChndWVzdHMsIGdyb3VwcywgdGVtcGxhdGVzKVxuICogLSBGb3JtIHN1Ym1pc3Npb25cbiAqIC0gVGVtcGxhdGUgc2VsZWN0aW9uXG4gKiAtIFJlY2lwaWVudCBzZWxlY3Rpb25cbiAqIC0gRW1haWwgcHJldmlld1xuICogLSBFcnJvciBoYW5kbGluZ1xuICogXG4gKiBSZXF1aXJlbWVudHM6IEVtYWlsIGNvbXBvc2VyIGZ1bmN0aW9uYWxpdHlcbiAqL1xuXG5pbXBvcnQgeyByZW5kZXIsIHNjcmVlbiwgZmlyZUV2ZW50LCB3YWl0Rm9yLCBjbGVhbnVwIH0gZnJvbSAnQHRlc3RpbmctbGlicmFyeS9yZWFjdCc7XG5pbXBvcnQgdXNlckV2ZW50IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvdXNlci1ldmVudCc7XG5pbXBvcnQgeyBFbWFpbENvbXBvc2VyIH0gZnJvbSAnLi9FbWFpbENvbXBvc2VyJztcblxuLy8gTW9jayB0b2FzdCBjb250ZXh0XG5jb25zdCBtb2NrQWRkVG9hc3QgPSBqZXN0LmZuKCk7XG5qZXN0Lm1vY2soJ0AvY29tcG9uZW50cy91aS9Ub2FzdENvbnRleHQnLCAoKSA9PiAoe1xuICB1c2VUb2FzdDogKCkgPT4gKHsgYWRkVG9hc3Q6IG1vY2tBZGRUb2FzdCB9KSxcbn0pKTtcblxuLy8gTW9jayBmZXRjaFxuZ2xvYmFsLmZldGNoID0gamVzdC5mbigpO1xuXG5jb25zdCBtb2NrR3Vlc3RzID0gW1xuICB7IGlkOiAnMScsIGZpcnN0X25hbWU6ICdKb2huJywgbGFzdF9uYW1lOiAnRG9lJywgZW1haWw6ICdqb2huQGV4YW1wbGUuY29tJyB9LFxuICB7IGlkOiAnMicsIGZpcnN0X25hbWU6ICdKYW5lJywgbGFzdF9uYW1lOiAnU21pdGgnLCBlbWFpbDogJ2phbmVAZXhhbXBsZS5jb20nIH0sXG4gIHsgaWQ6ICczJywgZmlyc3RfbmFtZTogJ0JvYicsIGxhc3RfbmFtZTogJ1dpbHNvbicsIGVtYWlsOiBudWxsIH0sXG5dO1xuXG5jb25zdCBtb2NrR3JvdXBzID0gW1xuICB7IGlkOiAnMScsIG5hbWU6ICdGYW1pbHknIH0sXG4gIHsgaWQ6ICcyJywgbmFtZTogJ0ZyaWVuZHMnIH0sXG5dO1xuXG5jb25zdCBtb2NrVGVtcGxhdGVzID0gW1xuICB7IGlkOiAnMScsIG5hbWU6ICdSU1ZQIFJlbWluZGVyJywgc3ViamVjdDogJ1BsZWFzZSBSU1ZQJywgYm9keV9odG1sOiAnPHA+UGxlYXNlIHJlc3BvbmQgYnkuLi48L3A+JyB9LFxuICB7IGlkOiAnMicsIG5hbWU6ICdXZWxjb21lIEVtYWlsJywgc3ViamVjdDogJ1dlbGNvbWUhJywgYm9keV9odG1sOiAnPHA+V2VsY29tZSB0byBvdXIgd2VkZGluZy4uLjwvcD4nIH0sXG5dO1xuXG5kZXNjcmliZSgnRW1haWxDb21wb3NlcicsICgpID0+IHtcbiAgY29uc3QgbW9ja0ZldGNoID0gZmV0Y2ggYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgZmV0Y2g+O1xuICBsZXQgbW9ja09uQ2xvc2U6IGplc3QuTW9jaztcbiAgbGV0IG1vY2tPblN1Y2Nlc3M6IGplc3QuTW9jaztcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gc2V0IHVwIG1vY2tzIGZvciBlYWNoIHRlc3RcbiAgY29uc3Qgc2V0dXBNb2NrcyA9ICgpID0+IHtcbiAgICBtb2NrRmV0Y2gubW9ja0NsZWFyKCk7XG4gICAgbW9ja0ZldGNoXG4gICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHsgZ3Vlc3RzOiBtb2NrR3Vlc3RzIH0gfSksXG4gICAgICB9IGFzIFJlc3BvbnNlKVxuICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBtb2NrR3JvdXBzIH0pLFxuICAgICAgfSBhcyBSZXNwb25zZSlcbiAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogbW9ja1RlbXBsYXRlcyB9KSxcbiAgICAgIH0gYXMgUmVzcG9uc2UpO1xuICB9O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIG1vY2tPbkNsb3NlID0gamVzdC5mbigpO1xuICAgIG1vY2tPblN1Y2Nlc3MgPSBqZXN0LmZuKCk7XG4gICAgbW9ja0FkZFRvYXN0Lm1vY2tDbGVhcigpO1xuICAgIG1vY2tGZXRjaC5tb2NrQ2xlYXIoKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBjbGVhbnVwKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNb2RhbCBEaXNwbGF5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgbm90IHJlbmRlciB3aGVuIGlzT3BlbiBpcyBmYWxzZScsICgpID0+IHtcbiAgICAgIHJlbmRlcihcbiAgICAgICAgPEVtYWlsQ29tcG9zZXJcbiAgICAgICAgICBpc09wZW49e2ZhbHNlfVxuICAgICAgICAgIG9uQ2xvc2U9e21vY2tPbkNsb3NlfVxuICAgICAgICAgIG9uU3VjY2Vzcz17bW9ja09uU3VjY2Vzc31cbiAgICAgICAgLz5cbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChzY3JlZW4ucXVlcnlCeVRleHQoJ0NvbXBvc2UgRW1haWwnKSkubm90LnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlbmRlciB3aGVuIGlzT3BlbiBpcyB0cnVlJywgKCkgPT4ge1xuICAgICAgc2V0dXBNb2NrcygpO1xuICAgICAgXG4gICAgICByZW5kZXIoXG4gICAgICAgIDxFbWFpbENvbXBvc2VyXG4gICAgICAgICAgaXNPcGVuPXt0cnVlfVxuICAgICAgICAgIG9uQ2xvc2U9e21vY2tPbkNsb3NlfVxuICAgICAgICAgIG9uU3VjY2Vzcz17bW9ja09uU3VjY2Vzc31cbiAgICAgICAgLz5cbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdDb21wb3NlIEVtYWlsJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNhbGwgb25DbG9zZSB3aGVuIGNsb3NlIGJ1dHRvbiBpcyBjbGlja2VkJywgKCkgPT4ge1xuICAgICAgc2V0dXBNb2NrcygpO1xuICAgICAgXG4gICAgICByZW5kZXIoXG4gICAgICAgIDxFbWFpbENvbXBvc2VyXG4gICAgICAgICAgaXNPcGVuPXt0cnVlfVxuICAgICAgICAgIG9uQ2xvc2U9e21vY2tPbkNsb3NlfVxuICAgICAgICAgIG9uU3VjY2Vzcz17bW9ja09uU3VjY2Vzc31cbiAgICAgICAgLz5cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGNsb3NlQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KCdDbG9zZScpO1xuICAgICAgZmlyZUV2ZW50LmNsaWNrKGNsb3NlQnV0dG9uKTtcblxuICAgICAgZXhwZWN0KG1vY2tPbkNsb3NlKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNhbGwgb25DbG9zZSB3aGVuIGNhbmNlbCBidXR0b24gaXMgY2xpY2tlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHNldHVwTW9ja3MoKTtcbiAgICAgIFxuICAgICAgcmVuZGVyKFxuICAgICAgICA8RW1haWxDb21wb3NlclxuICAgICAgICAgIGlzT3Blbj17dHJ1ZX1cbiAgICAgICAgICBvbkNsb3NlPXttb2NrT25DbG9zZX1cbiAgICAgICAgICBvblN1Y2Nlc3M9e21vY2tPblN1Y2Nlc3N9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5VGV4dCgnTG9hZGluZy4uLicpKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjYW5jZWxCdXR0b24gPSBzY3JlZW4uZ2V0QnlSb2xlKCdidXR0b24nLCB7IG5hbWU6IC9jYW5jZWwvaSB9KTtcbiAgICAgIGZpcmVFdmVudC5jbGljayhjYW5jZWxCdXR0b24pO1xuXG4gICAgICBleHBlY3QobW9ja09uQ2xvc2UpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0RhdGEgTG9hZGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHNob3cgbG9hZGluZyBzdGF0ZSBpbml0aWFsbHknLCAoKSA9PiB7XG4gICAgICBzZXR1cE1vY2tzKCk7XG4gICAgICBcbiAgICAgIHJlbmRlcihcbiAgICAgICAgPEVtYWlsQ29tcG9zZXJcbiAgICAgICAgICBpc09wZW49e3RydWV9XG4gICAgICAgICAgb25DbG9zZT17bW9ja09uQ2xvc2V9XG4gICAgICAgICAgb25TdWNjZXNzPXttb2NrT25TdWNjZXNzfVxuICAgICAgICAvPlxuICAgICAgKTtcblxuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ0xvYWRpbmcuLi4nKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZmV0Y2ggZ3Vlc3RzLCBncm91cHMsIGFuZCB0ZW1wbGF0ZXMgb24gb3BlbicsIGFzeW5jICgpID0+IHtcbiAgICAgIHNldHVwTW9ja3MoKTtcbiAgICAgIFxuICAgICAgcmVuZGVyKFxuICAgICAgICA8RW1haWxDb21wb3NlclxuICAgICAgICAgIGlzT3Blbj17dHJ1ZX1cbiAgICAgICAgICBvbkNsb3NlPXttb2NrT25DbG9zZX1cbiAgICAgICAgICBvblN1Y2Nlc3M9e21vY2tPblN1Y2Nlc3N9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJy9hcGkvYWRtaW4vZ3Vlc3RzJyk7XG4gICAgICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvYXBpL2FkbWluL2dyb3VwcycpO1xuICAgICAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2FwaS9hZG1pbi9lbWFpbHMvdGVtcGxhdGVzJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbm90IGZldGNoIGRhdGEgd2hlbiBtb2RhbCBpcyBjbG9zZWQnLCAoKSA9PiB7XG4gICAgICByZW5kZXIoXG4gICAgICAgIDxFbWFpbENvbXBvc2VyXG4gICAgICAgICAgaXNPcGVuPXtmYWxzZX1cbiAgICAgICAgICBvbkNsb3NlPXttb2NrT25DbG9zZX1cbiAgICAgICAgICBvblN1Y2Nlc3M9e21vY2tPblN1Y2Nlc3N9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICBleHBlY3QobW9ja0ZldGNoKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBkaXNwbGF5IGxvYWRlZCBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgc2V0dXBNb2NrcygpO1xuICAgICAgXG4gICAgICByZW5kZXIoXG4gICAgICAgIDxFbWFpbENvbXBvc2VyXG4gICAgICAgICAgaXNPcGVuPXt0cnVlfVxuICAgICAgICAgIG9uQ2xvc2U9e21vY2tPbkNsb3NlfVxuICAgICAgICAgIG9uU3VjY2Vzcz17bW9ja09uU3VjY2Vzc31cbiAgICAgICAgLz5cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlUZXh0KCdMb2FkaW5nLi4uJykpLm5vdC50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIENoZWNrIHRlbXBsYXRlcyBhcmUgbG9hZGVkXG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnUlNWUCBSZW1pbmRlcicpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ1dlbGNvbWUgRW1haWwnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcblxuICAgICAgLy8gQ2hlY2sgZ3Vlc3RzIGFyZSBsb2FkZWQgKG9ubHkgdGhvc2Ugd2l0aCBlbWFpbHMpIC0gZ3Vlc3RzIGFyZSBzaG93biBieSBkZWZhdWx0XG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnSm9obiBEb2UgKGpvaG5AZXhhbXBsZS5jb20pJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnSmFuZSBTbWl0aCAoamFuZUBleGFtcGxlLmNvbSknKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIGV4cGVjdChzY3JlZW4ucXVlcnlCeVRleHQoJ0JvYiBXaWxzb24nKSkubm90LnRvQmVJblRoZURvY3VtZW50KCk7IC8vIE5vIGVtYWlsXG5cbiAgICAgIC8vIFN3aXRjaCB0byBncm91cHMgdG8gY2hlY2sgdGhleSdyZSBsb2FkZWRcbiAgICAgIGNvbnN0IGdyb3VwUmFkaW8gPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoJ0d1ZXN0IEdyb3VwcycpO1xuICAgICAgZmlyZUV2ZW50LmNsaWNrKGdyb3VwUmFkaW8pO1xuXG4gICAgICAvLyBDaGVjayBncm91cHMgYXJlIGxvYWRlZFxuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ0ZhbWlseScpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ0ZyaWVuZHMnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGZldGNoIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ2xlYXIgcHJldmlvdXMgbW9ja3MgYW5kIHNldCB1cCBlcnJvclxuICAgICAgbW9ja0ZldGNoLm1vY2tDbGVhcigpO1xuICAgICAgbW9ja0ZldGNoLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignTmV0d29yayBlcnJvcicpKTtcblxuICAgICAgcmVuZGVyKFxuICAgICAgICA8RW1haWxDb21wb3NlclxuICAgICAgICAgIGlzT3Blbj17dHJ1ZX1cbiAgICAgICAgICBvbkNsb3NlPXttb2NrT25DbG9zZX1cbiAgICAgICAgICBvblN1Y2Nlc3M9e21vY2tPblN1Y2Nlc3N9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tBZGRUb2FzdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgbWVzc2FnZTogJ0ZhaWxlZCB0byBsb2FkIGRhdGEnLFxuICAgICAgICB9KTtcbiAgICAgIH0sIHsgdGltZW91dDogMjAwMCB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1RlbXBsYXRlIFNlbGVjdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHBvcHVsYXRlIHN1YmplY3QgYW5kIGJvZHkgd2hlbiB0ZW1wbGF0ZSBpcyBzZWxlY3RlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHNldHVwTW9ja3MoKTtcbiAgICAgIFxuICAgICAgcmVuZGVyKFxuICAgICAgICA8RW1haWxDb21wb3NlclxuICAgICAgICAgIGlzT3Blbj17dHJ1ZX1cbiAgICAgICAgICBvbkNsb3NlPXttb2NrT25DbG9zZX1cbiAgICAgICAgICBvblN1Y2Nlc3M9e21vY2tPblN1Y2Nlc3N9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5VGV4dCgnTG9hZGluZy4uLicpKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB0ZW1wbGF0ZVNlbGVjdCA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvZW1haWwgdGVtcGxhdGUvaSk7XG4gICAgICBmaXJlRXZlbnQuY2hhbmdlKHRlbXBsYXRlU2VsZWN0LCB7IHRhcmdldDogeyB2YWx1ZTogJzEnIH0gfSk7XG5cbiAgICAgIGNvbnN0IHN1YmplY3RJbnB1dCA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvc3ViamVjdC9pKTtcbiAgICAgIGNvbnN0IGJvZHlUZXh0YXJlYSA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvZW1haWwgYm9keS9pKTtcblxuICAgICAgZXhwZWN0KHN1YmplY3RJbnB1dCkudG9IYXZlVmFsdWUoJ1BsZWFzZSBSU1ZQJyk7XG4gICAgICBleHBlY3QoYm9keVRleHRhcmVhKS50b0hhdmVWYWx1ZSgnPHA+UGxlYXNlIHJlc3BvbmQgYnkuLi48L3A+Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNsZWFyIHN1YmplY3QgYW5kIGJvZHkgd2hlbiBubyB0ZW1wbGF0ZSBpcyBzZWxlY3RlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHNldHVwTW9ja3MoKTtcbiAgICAgIFxuICAgICAgcmVuZGVyKFxuICAgICAgICA8RW1haWxDb21wb3NlclxuICAgICAgICAgIGlzT3Blbj17dHJ1ZX1cbiAgICAgICAgICBvbkNsb3NlPXttb2NrT25DbG9zZX1cbiAgICAgICAgICBvblN1Y2Nlc3M9e21vY2tPblN1Y2Nlc3N9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5VGV4dCgnTG9hZGluZy4uLicpKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB0ZW1wbGF0ZVNlbGVjdCA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvZW1haWwgdGVtcGxhdGUvaSk7XG4gICAgICBjb25zdCBzdWJqZWN0SW5wdXQgPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL3N1YmplY3QvaSk7XG4gICAgICBjb25zdCBib2R5VGV4dGFyZWEgPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL2VtYWlsIGJvZHkvaSk7XG5cbiAgICAgIC8vIFNlbGVjdCB0ZW1wbGF0ZSBmaXJzdFxuICAgICAgZmlyZUV2ZW50LmNoYW5nZSh0ZW1wbGF0ZVNlbGVjdCwgeyB0YXJnZXQ6IHsgdmFsdWU6ICcxJyB9IH0pO1xuICAgICAgZXhwZWN0KHN1YmplY3RJbnB1dCkudG9IYXZlVmFsdWUoJ1BsZWFzZSBSU1ZQJyk7XG5cbiAgICAgIC8vIENsZWFyIHRlbXBsYXRlXG4gICAgICBmaXJlRXZlbnQuY2hhbmdlKHRlbXBsYXRlU2VsZWN0LCB7IHRhcmdldDogeyB2YWx1ZTogJycgfSB9KTtcbiAgICAgIGV4cGVjdChzdWJqZWN0SW5wdXQpLnRvSGF2ZVZhbHVlKCcnKTtcbiAgICAgIGV4cGVjdChib2R5VGV4dGFyZWEpLnRvSGF2ZVZhbHVlKCcnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JlY2lwaWVudCBTZWxlY3Rpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzd2l0Y2ggYmV0d2VlbiBndWVzdCBhbmQgZ3JvdXAgcmVjaXBpZW50IHR5cGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgc2V0dXBNb2NrcygpO1xuICAgICAgXG4gICAgICByZW5kZXIoXG4gICAgICAgIDxFbWFpbENvbXBvc2VyXG4gICAgICAgICAgaXNPcGVuPXt0cnVlfVxuICAgICAgICAgIG9uQ2xvc2U9e21vY2tPbkNsb3NlfVxuICAgICAgICAgIG9uU3VjY2Vzcz17bW9ja09uU3VjY2Vzc31cbiAgICAgICAgLz5cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlUZXh0KCdMb2FkaW5nLi4uJykpLm5vdC50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEluaXRpYWxseSBndWVzdHMgc2hvdWxkIGJlIHNlbGVjdGVkXG4gICAgICBjb25zdCBndWVzdFJhZGlvID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KCdJbmRpdmlkdWFsIEd1ZXN0cycpO1xuICAgICAgY29uc3QgZ3JvdXBSYWRpbyA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgnR3Vlc3QgR3JvdXBzJyk7XG5cbiAgICAgIGV4cGVjdChndWVzdFJhZGlvKS50b0JlQ2hlY2tlZCgpO1xuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ0pvaG4gRG9lIChqb2huQGV4YW1wbGUuY29tKScpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuXG4gICAgICAvLyBTd2l0Y2ggdG8gZ3JvdXBzXG4gICAgICBmaXJlRXZlbnQuY2xpY2soZ3JvdXBSYWRpbyk7XG5cbiAgICAgIGV4cGVjdChncm91cFJhZGlvKS50b0JlQ2hlY2tlZCgpO1xuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ0ZhbWlseScpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5VGV4dCgnSm9obiBEb2UgKGpvaG5AZXhhbXBsZS5jb20pJykpLm5vdC50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjbGVhciBzZWxlY3RlZCByZWNpcGllbnRzIHdoZW4gc3dpdGNoaW5nIHR5cGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgc2V0dXBNb2NrcygpO1xuICAgICAgXG4gICAgICByZW5kZXIoXG4gICAgICAgIDxFbWFpbENvbXBvc2VyXG4gICAgICAgICAgaXNPcGVuPXt0cnVlfVxuICAgICAgICAgIG9uQ2xvc2U9e21vY2tPbkNsb3NlfVxuICAgICAgICAgIG9uU3VjY2Vzcz17bW9ja09uU3VjY2Vzc31cbiAgICAgICAgLz5cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlUZXh0KCdMb2FkaW5nLi4uJykpLm5vdC50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlY2lwaWVudFNlbGVjdCA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvcmVjaXBpZW50cy9pKTtcbiAgICAgIGNvbnN0IGdyb3VwUmFkaW8gPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoJ0d1ZXN0IEdyb3VwcycpO1xuXG4gICAgICAvLyBTZWxlY3QgYSBndWVzdFxuICAgICAgZmlyZUV2ZW50LmNoYW5nZShyZWNpcGllbnRTZWxlY3QsIHsgdGFyZ2V0OiB7IHZhbHVlOiBbJzEnXSB9IH0pO1xuXG4gICAgICAvLyBTd2l0Y2ggdG8gZ3JvdXBzXG4gICAgICBmaXJlRXZlbnQuY2xpY2soZ3JvdXBSYWRpbyk7XG5cbiAgICAgIC8vIFJlY2lwaWVudHMgc2hvdWxkIGJlIGNsZWFyZWRcbiAgICAgIGV4cGVjdChyZWNpcGllbnRTZWxlY3Quc2VsZWN0ZWRPcHRpb25zLmxlbmd0aCkudG9CZSgwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Zvcm0gVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHRoYXQgcmVjaXBpZW50cyBhcmUgc2VsZWN0ZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBzZXR1cE1vY2tzKCk7XG4gICAgICBcbiAgICAgIHJlbmRlcihcbiAgICAgICAgPEVtYWlsQ29tcG9zZXJcbiAgICAgICAgICBpc09wZW49e3RydWV9XG4gICAgICAgICAgb25DbG9zZT17bW9ja09uQ2xvc2V9XG4gICAgICAgICAgb25TdWNjZXNzPXttb2NrT25TdWNjZXNzfVxuICAgICAgICAvPlxuICAgICAgKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4ucXVlcnlCeVRleHQoJ0xvYWRpbmcuLi4nKSkubm90LnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc2VuZEJ1dHRvbiA9IHNjcmVlbi5nZXRCeVJvbGUoJ2J1dHRvbicsIHsgbmFtZTogL3NlbmQgZW1haWwvaSB9KTtcbiAgICAgIGZpcmVFdmVudC5jbGljayhzZW5kQnV0dG9uKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChtb2NrQWRkVG9hc3QpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgIG1lc3NhZ2U6ICdQbGVhc2Ugc2VsZWN0IGF0IGxlYXN0IG9uZSByZWNpcGllbnQnLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSB0aGF0IHN1YmplY3QgaXMgZW50ZXJlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHNldHVwTW9ja3MoKTtcbiAgICAgIFxuICAgICAgcmVuZGVyKFxuICAgICAgICA8RW1haWxDb21wb3NlclxuICAgICAgICAgIGlzT3Blbj17dHJ1ZX1cbiAgICAgICAgICBvbkNsb3NlPXttb2NrT25DbG9zZX1cbiAgICAgICAgICBvblN1Y2Nlc3M9e21vY2tPblN1Y2Nlc3N9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5VGV4dCgnTG9hZGluZy4uLicpKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZWNpcGllbnRTZWxlY3QgPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL3JlY2lwaWVudHMvaSk7XG4gICAgICBmaXJlRXZlbnQuY2hhbmdlKHJlY2lwaWVudFNlbGVjdCwgeyB0YXJnZXQ6IHsgdmFsdWU6IFsnMSddIH0gfSk7XG5cbiAgICAgIGNvbnN0IHNlbmRCdXR0b24gPSBzY3JlZW4uZ2V0QnlSb2xlKCdidXR0b24nLCB7IG5hbWU6IC9zZW5kIGVtYWlsL2kgfSk7XG4gICAgICBmaXJlRXZlbnQuY2xpY2soc2VuZEJ1dHRvbik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QobW9ja0FkZFRvYXN0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICBtZXNzYWdlOiAnUGxlYXNlIGVudGVyIGEgc3ViamVjdCcsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHRoYXQgYm9keSBpcyBlbnRlcmVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgc2V0dXBNb2NrcygpO1xuICAgICAgXG4gICAgICByZW5kZXIoXG4gICAgICAgIDxFbWFpbENvbXBvc2VyXG4gICAgICAgICAgaXNPcGVuPXt0cnVlfVxuICAgICAgICAgIG9uQ2xvc2U9e21vY2tPbkNsb3NlfVxuICAgICAgICAgIG9uU3VjY2Vzcz17bW9ja09uU3VjY2Vzc31cbiAgICAgICAgLz5cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlUZXh0KCdMb2FkaW5nLi4uJykpLm5vdC50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlY2lwaWVudFNlbGVjdCA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvcmVjaXBpZW50cy9pKTtcbiAgICAgIGNvbnN0IHN1YmplY3RJbnB1dCA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvc3ViamVjdC9pKTtcblxuICAgICAgZmlyZUV2ZW50LmNoYW5nZShyZWNpcGllbnRTZWxlY3QsIHsgdGFyZ2V0OiB7IHZhbHVlOiBbJzEnXSB9IH0pO1xuICAgICAgZmlyZUV2ZW50LmNoYW5nZShzdWJqZWN0SW5wdXQsIHsgdGFyZ2V0OiB7IHZhbHVlOiAnVGVzdCBTdWJqZWN0JyB9IH0pO1xuXG4gICAgICBjb25zdCBzZW5kQnV0dG9uID0gc2NyZWVuLmdldEJ5Um9sZSgnYnV0dG9uJywgeyBuYW1lOiAvc2VuZCBlbWFpbC9pIH0pO1xuICAgICAgZmlyZUV2ZW50LmNsaWNrKHNlbmRCdXR0b24pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tBZGRUb2FzdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgbWVzc2FnZTogJ1BsZWFzZSBlbnRlciBlbWFpbCBib2R5JyxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgdGhhdCBzZWxlY3RlZCByZWNpcGllbnRzIGhhdmUgZW1haWwgYWRkcmVzc2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gVGhpcyB0ZXN0IGlzIG5vdCBhcHBsaWNhYmxlIGJlY2F1c2UgdGhlIGNvbXBvbmVudCBmaWx0ZXJzIG91dCBndWVzdHMgd2l0aG91dCBlbWFpbHNcbiAgICAgIC8vIGZyb20gdGhlIHNlbGVjdGlvbiBsaXN0LCBzbyBpdCdzIGltcG9zc2libGUgdG8gc2VsZWN0IGEgZ3Vlc3Qgd2l0aG91dCBhbiBlbWFpbC5cbiAgICAgIC8vIEluc3RlYWQsIHdlJ2xsIHRlc3QgdGhhdCBndWVzdHMgd2l0aG91dCBlbWFpbHMgYXJlIG5vdCBzaG93biBpbiB0aGUgbGlzdC5cbiAgICAgIFxuICAgICAgLy8gTW9jayBndWVzdHMgd2l0aCBtaXhlZCBlbWFpbCBzdGF0dXNcbiAgICAgIG1vY2tGZXRjaC5tb2NrQ2xlYXIoKTtcbiAgICAgIG1vY2tGZXRjaFxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsIFxuICAgICAgICAgICAgZGF0YTogeyBcbiAgICAgICAgICAgICAgZ3Vlc3RzOiBbXG4gICAgICAgICAgICAgICAgeyBpZDogJzEnLCBmaXJzdF9uYW1lOiAnSm9obicsIGxhc3RfbmFtZTogJ0RvZScsIGVtYWlsOiAnam9obkBleGFtcGxlLmNvbScgfSxcbiAgICAgICAgICAgICAgICB7IGlkOiAnMicsIGZpcnN0X25hbWU6ICdKYW5lJywgbGFzdF9uYW1lOiAnU21pdGgnLCBlbWFpbDogbnVsbCB9XG4gICAgICAgICAgICAgIF0gXG4gICAgICAgICAgICB9IFxuICAgICAgICAgIH0pLFxuICAgICAgICB9IGFzIFJlc3BvbnNlKVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBtb2NrR3JvdXBzIH0pLFxuICAgICAgICB9IGFzIFJlc3BvbnNlKVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBtb2NrVGVtcGxhdGVzIH0pLFxuICAgICAgICB9IGFzIFJlc3BvbnNlKTtcblxuICAgICAgcmVuZGVyKFxuICAgICAgICA8RW1haWxDb21wb3NlclxuICAgICAgICAgIGlzT3Blbj17dHJ1ZX1cbiAgICAgICAgICBvbkNsb3NlPXttb2NrT25DbG9zZX1cbiAgICAgICAgICBvblN1Y2Nlc3M9e21vY2tPblN1Y2Nlc3N9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5VGV4dCgnTG9hZGluZy4uLicpKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBKb2huIHNob3VsZCBiZSBpbiB0aGUgbGlzdCAoaGFzIGVtYWlsKVxuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ0pvaG4gRG9lIChqb2huQGV4YW1wbGUuY29tKScpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgXG4gICAgICAvLyBKYW5lIHNob3VsZCBOT1QgYmUgaW4gdGhlIGxpc3QgKG5vIGVtYWlsKVxuICAgICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5VGV4dCgvSmFuZSBTbWl0aC8pKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0VtYWlsIFNlbmRpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzZW5kIGVtYWlsIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIHNldHVwTW9ja3MoKTtcbiAgICAgIFxuICAgICAgY29uc3QgdXNlciA9IHVzZXJFdmVudC5zZXR1cCgpO1xuICAgICAgXG4gICAgICByZW5kZXIoXG4gICAgICAgIDxFbWFpbENvbXBvc2VyXG4gICAgICAgICAgaXNPcGVuPXt0cnVlfVxuICAgICAgICAgIG9uQ2xvc2U9e21vY2tPbkNsb3NlfVxuICAgICAgICAgIG9uU3VjY2Vzcz17bW9ja09uU3VjY2Vzc31cbiAgICAgICAgLz5cbiAgICAgICk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIGxvYWRpbmcgdG8gY29tcGxldGVcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlUZXh0KCdMb2FkaW5nLi4uJykpLm5vdC50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSwgeyB0aW1lb3V0OiAzMDAwIH0pO1xuXG4gICAgICAvLyBGaWxsIG91dCB0aGUgZm9ybVxuICAgICAgY29uc3QgcmVjaXBpZW50U2VsZWN0ID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9yZWNpcGllbnRzL2kpO1xuICAgICAgY29uc3Qgc3ViamVjdElucHV0ID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9zdWJqZWN0L2kpO1xuICAgICAgY29uc3QgYm9keVRleHRhcmVhID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9lbWFpbCBib2R5L2kpO1xuXG4gICAgICBhd2FpdCB1c2VyLnNlbGVjdE9wdGlvbnMocmVjaXBpZW50U2VsZWN0LCBbJzEnLCAnMiddKTtcbiAgICAgIGF3YWl0IHVzZXIudHlwZShzdWJqZWN0SW5wdXQsICdUZXN0IFN1YmplY3QnKTtcbiAgICAgIGF3YWl0IHVzZXIudHlwZShib2R5VGV4dGFyZWEsICc8cD5UZXN0IEJvZHk8L3A+Jyk7XG5cbiAgICAgIC8vIE1vY2sgdGhlIHNlbmQgZW1haWwgQVBJIGNhbGwgQUZURVIgZmlsbGluZyB0aGUgZm9ybVxuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlIH0pLFxuICAgICAgfSBhcyBSZXNwb25zZSk7XG5cbiAgICAgIC8vIFN1Ym1pdCB0aGUgZm9ybVxuICAgICAgY29uc3Qgc2VuZEJ1dHRvbnMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCdidXR0b24nLCB7IG5hbWU6IC9zZW5kIGVtYWlsL2kgfSk7XG4gICAgICBjb25zdCBzZW5kQnV0dG9uID0gc2VuZEJ1dHRvbnNbc2VuZEJ1dHRvbnMubGVuZ3RoIC0gMV07XG4gICAgICBhd2FpdCB1c2VyLmNsaWNrKHNlbmRCdXR0b24pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgLy8gQ2hlY2sgdGhlIGZldGNoIGNhbGwgZm9yIHNlbmRpbmcgZW1haWxcbiAgICAgICAgY29uc3Qgc2VuZENhbGwgPSBtb2NrRmV0Y2gubW9jay5jYWxscy5maW5kKGNhbGwgPT4gXG4gICAgICAgICAgY2FsbFswXSA9PT0gJy9hcGkvYWRtaW4vZW1haWxzL3NlbmQnXG4gICAgICAgICk7XG4gICAgICAgIGV4cGVjdChzZW5kQ2FsbCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgZXhwZWN0KHNlbmRDYWxsIVsxXSkudG9NYXRjaE9iamVjdCh7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgYm9keSA9IEpTT04ucGFyc2Uoc2VuZENhbGwhWzFdIS5ib2R5IGFzIHN0cmluZyk7XG4gICAgICAgIGV4cGVjdChib2R5LnJlY2lwaWVudHMpLnRvRXF1YWwoWydqb2huQGV4YW1wbGUuY29tJywgJ2phbmVAZXhhbXBsZS5jb20nXSk7XG4gICAgICAgIGV4cGVjdChib2R5LnN1YmplY3QpLnRvQmUoJ1Rlc3QgU3ViamVjdCcpO1xuICAgICAgICBleHBlY3QoYm9keS5odG1sKS50b0JlKCc8cD5UZXN0IEJvZHk8L3A+Jyk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChtb2NrQWRkVG9hc3QpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgICB0eXBlOiAnc3VjY2VzcycsXG4gICAgICAgICAgbWVzc2FnZTogJ0VtYWlsIHNlbnQgdG8gMiByZWNpcGllbnQocyknLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QobW9ja09uU3VjY2VzcykudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KG1vY2tPbkNsb3NlKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGluY2x1ZGUgdGVtcGxhdGUgSUQgd2hlbiB0ZW1wbGF0ZSBpcyBzZWxlY3RlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHNldHVwTW9ja3MoKTtcbiAgICAgIFxuICAgICAgY29uc3QgdXNlciA9IHVzZXJFdmVudC5zZXR1cCgpO1xuICAgICAgXG4gICAgICByZW5kZXIoXG4gICAgICAgIDxFbWFpbENvbXBvc2VyXG4gICAgICAgICAgaXNPcGVuPXt0cnVlfVxuICAgICAgICAgIG9uQ2xvc2U9e21vY2tPbkNsb3NlfVxuICAgICAgICAgIG9uU3VjY2Vzcz17bW9ja09uU3VjY2Vzc31cbiAgICAgICAgLz5cbiAgICAgICk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIGxvYWRpbmcgdG8gY29tcGxldGVcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlUZXh0KCdMb2FkaW5nLi4uJykpLm5vdC50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSwgeyB0aW1lb3V0OiAzMDAwIH0pO1xuXG4gICAgICBjb25zdCB0ZW1wbGF0ZVNlbGVjdCA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvZW1haWwgdGVtcGxhdGUvaSk7XG4gICAgICBjb25zdCByZWNpcGllbnRTZWxlY3QgPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL3JlY2lwaWVudHMvaSk7XG5cbiAgICAgIGF3YWl0IHVzZXIuc2VsZWN0T3B0aW9ucyh0ZW1wbGF0ZVNlbGVjdCwgJzEnKTtcbiAgICAgIGF3YWl0IHVzZXIuc2VsZWN0T3B0aW9ucyhyZWNpcGllbnRTZWxlY3QsIFsnMSddKTtcblxuICAgICAgLy8gTW9jayB0aGUgc2VuZCBlbWFpbCBBUEkgY2FsbCBBRlRFUiBmaWxsaW5nIHRoZSBmb3JtXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IHN1Y2Nlc3M6IHRydWUgfSksXG4gICAgICB9IGFzIFJlc3BvbnNlKTtcblxuICAgICAgY29uc3Qgc2VuZEJ1dHRvbnMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCdidXR0b24nLCB7IG5hbWU6IC9zZW5kIGVtYWlsL2kgfSk7XG4gICAgICBjb25zdCBzZW5kQnV0dG9uID0gc2VuZEJ1dHRvbnNbc2VuZEJ1dHRvbnMubGVuZ3RoIC0gMV07XG4gICAgICBhd2FpdCB1c2VyLmNsaWNrKHNlbmRCdXR0b24pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc2VuZENhbGwgPSBtb2NrRmV0Y2gubW9jay5jYWxscy5maW5kKGNhbGwgPT4gXG4gICAgICAgICAgY2FsbFswXSA9PT0gJy9hcGkvYWRtaW4vZW1haWxzL3NlbmQnXG4gICAgICAgICk7XG4gICAgICAgIGV4cGVjdChzZW5kQ2FsbCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnBhcnNlKHNlbmRDYWxsIVsxXSEuYm9keSBhcyBzdHJpbmcpO1xuICAgICAgICBleHBlY3QoYm9keS5yZWNpcGllbnRzKS50b0VxdWFsKFsnam9obkBleGFtcGxlLmNvbSddKTtcbiAgICAgICAgZXhwZWN0KGJvZHkuc3ViamVjdCkudG9CZSgnUGxlYXNlIFJTVlAnKTtcbiAgICAgICAgZXhwZWN0KGJvZHkuaHRtbCkudG9CZSgnPHA+UGxlYXNlIHJlc3BvbmQgYnkuLi48L3A+Jyk7XG4gICAgICAgIGV4cGVjdChib2R5LnRlbXBsYXRlX2lkKS50b0JlKCcxJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHNlbmQgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgc2V0dXBNb2NrcygpO1xuICAgICAgXG4gICAgICBjb25zdCB1c2VyID0gdXNlckV2ZW50LnNldHVwKCk7XG4gICAgICBcbiAgICAgIHJlbmRlcihcbiAgICAgICAgPEVtYWlsQ29tcG9zZXJcbiAgICAgICAgICBpc09wZW49e3RydWV9XG4gICAgICAgICAgb25DbG9zZT17bW9ja09uQ2xvc2V9XG4gICAgICAgICAgb25TdWNjZXNzPXttb2NrT25TdWNjZXNzfVxuICAgICAgICAvPlxuICAgICAgKTtcblxuICAgICAgLy8gV2FpdCBmb3IgbG9hZGluZyB0byBjb21wbGV0ZVxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4ucXVlcnlCeVRleHQoJ0xvYWRpbmcuLi4nKSkubm90LnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9LCB7IHRpbWVvdXQ6IDMwMDAgfSk7XG5cbiAgICAgIGNvbnN0IHJlY2lwaWVudFNlbGVjdCA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvcmVjaXBpZW50cy9pKTtcbiAgICAgIGNvbnN0IHN1YmplY3RJbnB1dCA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvc3ViamVjdC9pKTtcbiAgICAgIGNvbnN0IGJvZHlUZXh0YXJlYSA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvZW1haWwgYm9keS9pKTtcblxuICAgICAgYXdhaXQgdXNlci5zZWxlY3RPcHRpb25zKHJlY2lwaWVudFNlbGVjdCwgWycxJ10pO1xuICAgICAgYXdhaXQgdXNlci50eXBlKHN1YmplY3RJbnB1dCwgJ1Rlc3QgU3ViamVjdCcpO1xuICAgICAgYXdhaXQgdXNlci50eXBlKGJvZHlUZXh0YXJlYSwgJ1Rlc3QgQm9keScpO1xuXG4gICAgICAvLyBNb2NrIHRoZSBzZW5kIGVtYWlsIEFQSSBjYWxsIHdpdGggZXJyb3IgQUZURVIgZmlsbGluZyB0aGUgZm9ybVxuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IHsgbWVzc2FnZTogJ1NlbmQgZmFpbGVkJyB9IH0pLFxuICAgICAgfSBhcyBSZXNwb25zZSk7XG5cbiAgICAgIGNvbnN0IHNlbmRCdXR0b25zID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgnYnV0dG9uJywgeyBuYW1lOiAvc2VuZCBlbWFpbC9pIH0pO1xuICAgICAgY29uc3Qgc2VuZEJ1dHRvbiA9IHNlbmRCdXR0b25zW3NlbmRCdXR0b25zLmxlbmd0aCAtIDFdO1xuICAgICAgYXdhaXQgdXNlci5jbGljayhzZW5kQnV0dG9uKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChtb2NrQWRkVG9hc3QpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgIG1lc3NhZ2U6ICdTZW5kIGZhaWxlZCcsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChtb2NrT25TdWNjZXNzKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KG1vY2tPbkNsb3NlKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbmV0d29yayBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBzZXR1cE1vY2tzKCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHVzZXIgPSB1c2VyRXZlbnQuc2V0dXAoKTtcbiAgICAgIFxuICAgICAgcmVuZGVyKFxuICAgICAgICA8RW1haWxDb21wb3NlclxuICAgICAgICAgIGlzT3Blbj17dHJ1ZX1cbiAgICAgICAgICBvbkNsb3NlPXttb2NrT25DbG9zZX1cbiAgICAgICAgICBvblN1Y2Nlc3M9e21vY2tPblN1Y2Nlc3N9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICAvLyBXYWl0IGZvciBsb2FkaW5nIHRvIGNvbXBsZXRlXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5VGV4dCgnTG9hZGluZy4uLicpKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0sIHsgdGltZW91dDogMzAwMCB9KTtcblxuICAgICAgY29uc3QgcmVjaXBpZW50U2VsZWN0ID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9yZWNpcGllbnRzL2kpO1xuICAgICAgY29uc3Qgc3ViamVjdElucHV0ID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9zdWJqZWN0L2kpO1xuICAgICAgY29uc3QgYm9keVRleHRhcmVhID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9lbWFpbCBib2R5L2kpO1xuXG4gICAgICBhd2FpdCB1c2VyLnNlbGVjdE9wdGlvbnMocmVjaXBpZW50U2VsZWN0LCBbJzEnXSk7XG4gICAgICBhd2FpdCB1c2VyLnR5cGUoc3ViamVjdElucHV0LCAnVGVzdCBTdWJqZWN0Jyk7XG4gICAgICBhd2FpdCB1c2VyLnR5cGUoYm9keVRleHRhcmVhLCAnVGVzdCBCb2R5Jyk7XG5cbiAgICAgIC8vIE1vY2sgbmV0d29yayBlcnJvciBBRlRFUiBmaWxsaW5nIHRoZSBmb3JtXG4gICAgICBtb2NrRmV0Y2gubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldyBFcnJvcignTmV0d29yayBlcnJvcicpKTtcblxuICAgICAgY29uc3Qgc2VuZEJ1dHRvbnMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCdidXR0b24nLCB7IG5hbWU6IC9zZW5kIGVtYWlsL2kgfSk7XG4gICAgICBjb25zdCBzZW5kQnV0dG9uID0gc2VuZEJ1dHRvbnNbc2VuZEJ1dHRvbnMubGVuZ3RoIC0gMV07XG4gICAgICBhd2FpdCB1c2VyLmNsaWNrKHNlbmRCdXR0b24pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tBZGRUb2FzdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgbWVzc2FnZTogJ0ZhaWxlZCB0byBzZW5kIGVtYWlsJyxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0VtYWlsIFByZXZpZXcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzaG93IHByZXZpZXcgd2hlbiBwcmV2aWV3IGJ1dHRvbiBpcyBjbGlja2VkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgc2V0dXBNb2NrcygpO1xuICAgICAgXG4gICAgICBjb25zdCB1c2VyID0gdXNlckV2ZW50LnNldHVwKCk7XG4gICAgICBcbiAgICAgIHJlbmRlcihcbiAgICAgICAgPEVtYWlsQ29tcG9zZXJcbiAgICAgICAgICBpc09wZW49e3RydWV9XG4gICAgICAgICAgb25DbG9zZT17bW9ja09uQ2xvc2V9XG4gICAgICAgICAgb25TdWNjZXNzPXttb2NrT25TdWNjZXNzfVxuICAgICAgICAvPlxuICAgICAgKTtcblxuICAgICAgLy8gV2FpdCBmb3IgbG9hZGluZyB0byBjb21wbGV0ZVxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4ucXVlcnlCeVRleHQoJ0xvYWRpbmcuLi4nKSkubm90LnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9LCB7IHRpbWVvdXQ6IDMwMDAgfSk7XG5cbiAgICAgIGNvbnN0IHByZXZpZXdCdXR0b24gPSBzY3JlZW4uZ2V0QnlSb2xlKCdidXR0b24nLCB7IG5hbWU6IC9zaG93IHByZXZpZXcvaSB9KTtcbiAgICAgIGF3YWl0IHVzZXIuY2xpY2socHJldmlld0J1dHRvbik7XG5cbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdQcmV2aWV3JykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5Um9sZSgnYnV0dG9uJywgeyBuYW1lOiAvaGlkZSBwcmV2aWV3L2kgfSkpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhpZGUgcHJldmlldyB3aGVuIGhpZGUgYnV0dG9uIGlzIGNsaWNrZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBzZXR1cE1vY2tzKCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHVzZXIgPSB1c2VyRXZlbnQuc2V0dXAoKTtcbiAgICAgIFxuICAgICAgcmVuZGVyKFxuICAgICAgICA8RW1haWxDb21wb3NlclxuICAgICAgICAgIGlzT3Blbj17dHJ1ZX1cbiAgICAgICAgICBvbkNsb3NlPXttb2NrT25DbG9zZX1cbiAgICAgICAgICBvblN1Y2Nlc3M9e21vY2tPblN1Y2Nlc3N9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICAvLyBXYWl0IGZvciBsb2FkaW5nIHRvIGNvbXBsZXRlXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5VGV4dCgnTG9hZGluZy4uLicpKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0sIHsgdGltZW91dDogMzAwMCB9KTtcblxuICAgICAgY29uc3QgcHJldmlld0J1dHRvbiA9IHNjcmVlbi5nZXRCeVJvbGUoJ2J1dHRvbicsIHsgbmFtZTogL3Nob3cgcHJldmlldy9pIH0pO1xuICAgICAgYXdhaXQgdXNlci5jbGljayhwcmV2aWV3QnV0dG9uKTtcblxuICAgICAgY29uc3QgaGlkZUJ1dHRvbiA9IHNjcmVlbi5nZXRCeVJvbGUoJ2J1dHRvbicsIHsgbmFtZTogL2hpZGUgcHJldmlldy9pIH0pO1xuICAgICAgYXdhaXQgdXNlci5jbGljayhoaWRlQnV0dG9uKTtcblxuICAgICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5VGV4dCgnUHJldmlldycpKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlSb2xlKCdidXR0b24nLCB7IG5hbWU6IC9zaG93IHByZXZpZXcvaSB9KSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGlzcGxheSBwcmV2aWV3IGNvbnRlbnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBzZXR1cE1vY2tzKCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHVzZXIgPSB1c2VyRXZlbnQuc2V0dXAoKTtcbiAgICAgIFxuICAgICAgcmVuZGVyKFxuICAgICAgICA8RW1haWxDb21wb3NlclxuICAgICAgICAgIGlzT3Blbj17dHJ1ZX1cbiAgICAgICAgICBvbkNsb3NlPXttb2NrT25DbG9zZX1cbiAgICAgICAgICBvblN1Y2Nlc3M9e21vY2tPblN1Y2Nlc3N9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICAvLyBXYWl0IGZvciBsb2FkaW5nIHRvIGNvbXBsZXRlXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5VGV4dCgnTG9hZGluZy4uLicpKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0sIHsgdGltZW91dDogMzAwMCB9KTtcblxuICAgICAgY29uc3QgcmVjaXBpZW50U2VsZWN0ID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9yZWNpcGllbnRzL2kpO1xuICAgICAgY29uc3Qgc3ViamVjdElucHV0ID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9zdWJqZWN0L2kpO1xuICAgICAgY29uc3QgYm9keVRleHRhcmVhID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9lbWFpbCBib2R5L2kpO1xuXG4gICAgICBhd2FpdCB1c2VyLnNlbGVjdE9wdGlvbnMocmVjaXBpZW50U2VsZWN0LCBbJzEnLCAnMiddKTtcbiAgICAgIGF3YWl0IHVzZXIudHlwZShzdWJqZWN0SW5wdXQsICdUZXN0IFN1YmplY3QnKTtcbiAgICAgIGF3YWl0IHVzZXIudHlwZShib2R5VGV4dGFyZWEsICc8cD5UZXN0IEJvZHk8L3A+Jyk7XG5cbiAgICAgIGNvbnN0IHByZXZpZXdCdXR0b24gPSBzY3JlZW4uZ2V0QnlSb2xlKCdidXR0b24nLCB7IG5hbWU6IC9zaG93IHByZXZpZXcvaSB9KTtcbiAgICAgIGF3YWl0IHVzZXIuY2xpY2socHJldmlld0J1dHRvbik7XG5cbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdTdWJqZWN0OicpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ1Rlc3QgU3ViamVjdCcpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ1RvOicpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJzIgcmVjaXBpZW50KHMpJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdMb2FkaW5nIFN0YXRlcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGRpc2FibGUgYnV0dG9ucyBkdXJpbmcgc3VibWlzc2lvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIHNldHVwTW9ja3MoKTtcbiAgICAgIFxuICAgICAgY29uc3QgdXNlciA9IHVzZXJFdmVudC5zZXR1cCgpO1xuICAgICAgXG4gICAgICByZW5kZXIoXG4gICAgICAgIDxFbWFpbENvbXBvc2VyXG4gICAgICAgICAgaXNPcGVuPXt0cnVlfVxuICAgICAgICAgIG9uQ2xvc2U9e21vY2tPbkNsb3NlfVxuICAgICAgICAgIG9uU3VjY2Vzcz17bW9ja09uU3VjY2Vzc31cbiAgICAgICAgLz5cbiAgICAgICk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIGxvYWRpbmcgdG8gY29tcGxldGVcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlUZXh0KCdMb2FkaW5nLi4uJykpLm5vdC50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSwgeyB0aW1lb3V0OiAzMDAwIH0pO1xuXG4gICAgICAvLyBGaWxsIG91dCB0aGUgZm9ybVxuICAgICAgY29uc3QgcmVjaXBpZW50U2VsZWN0ID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9yZWNpcGllbnRzL2kpO1xuICAgICAgY29uc3Qgc3ViamVjdElucHV0ID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9zdWJqZWN0L2kpO1xuICAgICAgY29uc3QgYm9keVRleHRhcmVhID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9lbWFpbCBib2R5L2kpO1xuXG4gICAgICBhd2FpdCB1c2VyLnNlbGVjdE9wdGlvbnMocmVjaXBpZW50U2VsZWN0LCBbJzEnXSk7XG4gICAgICBhd2FpdCB1c2VyLnR5cGUoc3ViamVjdElucHV0LCAnVGVzdCBTdWJqZWN0Jyk7XG4gICAgICBhd2FpdCB1c2VyLnR5cGUoYm9keVRleHRhcmVhLCAnVGVzdCBCb2R5Jyk7XG5cbiAgICAgIC8vIE1vY2sgYSBzbG93IHNlbmQgb3BlcmF0aW9uXG4gICAgICBsZXQgcmVzb2x2ZVByb21pc2U6IGFueTtcbiAgICAgIGNvbnN0IHNsb3dTZW5kID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgfSk7XG4gICAgICBtb2NrRmV0Y2gubW9ja1JldHVyblZhbHVlT25jZShzbG93U2VuZCBhcyBhbnkpO1xuXG4gICAgICAvLyBTdWJtaXQgdGhlIGZvcm1cbiAgICAgIGNvbnN0IHNlbmRCdXR0b25zID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgnYnV0dG9uJywgeyBuYW1lOiAvc2VuZCBlbWFpbC9pIH0pO1xuICAgICAgY29uc3Qgc2VuZEJ1dHRvbiA9IHNlbmRCdXR0b25zW3NlbmRCdXR0b25zLmxlbmd0aCAtIDFdO1xuICAgICAgXG4gICAgICBhd2FpdCB1c2VyLmNsaWNrKHNlbmRCdXR0b24pO1xuXG4gICAgICAvLyBXYWl0IGZvciBidXR0b25zIHRvIGJlIGRpc2FibGVkXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNlbmRCdXR0b24pLnRvQmVEaXNhYmxlZCgpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGNhbmNlbEJ1dHRvbiA9IHNjcmVlbi5nZXRCeVJvbGUoJ2J1dHRvbicsIHsgbmFtZTogL2NhbmNlbC9pIH0pO1xuICAgICAgY29uc3QgcHJldmlld0J1dHRvbiA9IHNjcmVlbi5nZXRCeVJvbGUoJ2J1dHRvbicsIHsgbmFtZTogL3Nob3cgcHJldmlldy9pIH0pO1xuICAgICAgXG4gICAgICBleHBlY3QoY2FuY2VsQnV0dG9uKS50b0JlRGlzYWJsZWQoKTtcbiAgICAgIGV4cGVjdChwcmV2aWV3QnV0dG9uKS50b0JlRGlzYWJsZWQoKTtcblxuICAgICAgLy8gUmVzb2x2ZSB0aGUgcHJvbWlzZSB0byBjbGVhbiB1cFxuICAgICAgcmVzb2x2ZVByb21pc2UoeyBvazogdHJ1ZSwganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSB9KSB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc2hvdyBzZW5kaW5nIHRleHQgZHVyaW5nIHN1Ym1pc3Npb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBzZXR1cE1vY2tzKCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHVzZXIgPSB1c2VyRXZlbnQuc2V0dXAoKTtcbiAgICAgIFxuICAgICAgcmVuZGVyKFxuICAgICAgICA8RW1haWxDb21wb3NlclxuICAgICAgICAgIGlzT3Blbj17dHJ1ZX1cbiAgICAgICAgICBvbkNsb3NlPXttb2NrT25DbG9zZX1cbiAgICAgICAgICBvblN1Y2Nlc3M9e21vY2tPblN1Y2Nlc3N9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICAvLyBXYWl0IGZvciBsb2FkaW5nIHRvIGNvbXBsZXRlXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5VGV4dCgnTG9hZGluZy4uLicpKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0sIHsgdGltZW91dDogMzAwMCB9KTtcblxuICAgICAgLy8gRmlsbCBvdXQgdGhlIGZvcm1cbiAgICAgIGNvbnN0IHJlY2lwaWVudFNlbGVjdCA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvcmVjaXBpZW50cy9pKTtcbiAgICAgIGNvbnN0IHN1YmplY3RJbnB1dCA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvc3ViamVjdC9pKTtcbiAgICAgIGNvbnN0IGJvZHlUZXh0YXJlYSA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvZW1haWwgYm9keS9pKTtcblxuICAgICAgYXdhaXQgdXNlci5zZWxlY3RPcHRpb25zKHJlY2lwaWVudFNlbGVjdCwgWycxJ10pO1xuICAgICAgYXdhaXQgdXNlci50eXBlKHN1YmplY3RJbnB1dCwgJ1Rlc3QgU3ViamVjdCcpO1xuICAgICAgYXdhaXQgdXNlci50eXBlKGJvZHlUZXh0YXJlYSwgJ1Rlc3QgQm9keScpO1xuXG4gICAgICAvLyBNb2NrIGEgc2xvdyBzZW5kIG9wZXJhdGlvblxuICAgICAgbGV0IHJlc29sdmVQcm9taXNlOiBhbnk7XG4gICAgICBjb25zdCBzbG93U2VuZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgIH0pO1xuICAgICAgbW9ja0ZldGNoLm1vY2tSZXR1cm5WYWx1ZU9uY2Uoc2xvd1NlbmQgYXMgYW55KTtcblxuICAgICAgLy8gU3VibWl0IHRoZSBmb3JtXG4gICAgICBjb25zdCBzZW5kQnV0dG9ucyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ2J1dHRvbicsIHsgbmFtZTogL3NlbmQgZW1haWwvaSB9KTtcbiAgICAgIGNvbnN0IHNlbmRCdXR0b24gPSBzZW5kQnV0dG9uc1tzZW5kQnV0dG9ucy5sZW5ndGggLSAxXTtcbiAgICAgIFxuICAgICAgYXdhaXQgdXNlci5jbGljayhzZW5kQnV0dG9uKTtcblxuICAgICAgLy8gV2FpdCBmb3Igc2VuZGluZyB0ZXh0IHRvIGFwcGVhclxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdTZW5kaW5nLi4uJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gUmVzb2x2ZSB0aGUgcHJvbWlzZSB0byBjbGVhbiB1cFxuICAgICAgcmVzb2x2ZVByb21pc2UoeyBvazogdHJ1ZSwganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSB9KSB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0FjY2Vzc2liaWxpdHknLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYXZlIHByb3BlciBmb3JtIGxhYmVscycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENsZWFyIGFuZCBzZXQgdXAgZnJlc2ggbW9ja3NcbiAgICAgIG1vY2tGZXRjaC5tb2NrQ2xlYXIoKTtcbiAgICAgIG1vY2tGZXRjaFxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiB7IGd1ZXN0czogbW9ja0d1ZXN0cyB9IH0pLFxuICAgICAgICB9IGFzIFJlc3BvbnNlKVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBtb2NrR3JvdXBzIH0pLFxuICAgICAgICB9IGFzIFJlc3BvbnNlKVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBtb2NrVGVtcGxhdGVzIH0pLFxuICAgICAgICB9IGFzIFJlc3BvbnNlKTtcblxuICAgICAgcmVuZGVyKFxuICAgICAgICA8RW1haWxDb21wb3NlclxuICAgICAgICAgIGlzT3Blbj17dHJ1ZX1cbiAgICAgICAgICBvbkNsb3NlPXttb2NrT25DbG9zZX1cbiAgICAgICAgICBvblN1Y2Nlc3M9e21vY2tPblN1Y2Nlc3N9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5VGV4dCgnTG9hZGluZy4uLicpKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0sIHsgdGltZW91dDogMzAwMCB9KTtcblxuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvZW1haWwgdGVtcGxhdGUvaSkpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5TGFiZWxUZXh0KC9yZWNpcGllbnRzL2kpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgvc3ViamVjdC9pKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL2VtYWlsIGJvZHkvaSkpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhdmUgcmVxdWlyZWQgYXR0cmlidXRlcyBvbiByZXF1aXJlZCBmaWVsZHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRmV0Y2gubW9ja0NsZWFyKCk7XG4gICAgICBtb2NrRmV0Y2hcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogeyBndWVzdHM6IG1vY2tHdWVzdHMgfSB9KSxcbiAgICAgICAgfSBhcyBSZXNwb25zZSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogbW9ja0dyb3VwcyB9KSxcbiAgICAgICAgfSBhcyBSZXNwb25zZSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogbW9ja1RlbXBsYXRlcyB9KSxcbiAgICAgICAgfSBhcyBSZXNwb25zZSk7XG5cbiAgICAgIHJlbmRlcihcbiAgICAgICAgPEVtYWlsQ29tcG9zZXJcbiAgICAgICAgICBpc09wZW49e3RydWV9XG4gICAgICAgICAgb25DbG9zZT17bW9ja09uQ2xvc2V9XG4gICAgICAgICAgb25TdWNjZXNzPXttb2NrT25TdWNjZXNzfVxuICAgICAgICAvPlxuICAgICAgKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4ucXVlcnlCeVRleHQoJ0xvYWRpbmcuLi4nKSkubm90LnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9LCB7IHRpbWVvdXQ6IDMwMDAgfSk7XG5cbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL3JlY2lwaWVudHMvaSkpLnRvSGF2ZUF0dHJpYnV0ZSgncmVxdWlyZWQnKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL3N1YmplY3QvaSkpLnRvSGF2ZUF0dHJpYnV0ZSgncmVxdWlyZWQnKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL2VtYWlsIGJvZHkvaSkpLnRvSGF2ZUF0dHJpYnV0ZSgncmVxdWlyZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGF2ZSBwcm9wZXIgY2xvc2UgYnV0dG9uIGFjY2Vzc2liaWxpdHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRmV0Y2gubW9ja0NsZWFyKCk7XG4gICAgICBtb2NrRmV0Y2hcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogeyBndWVzdHM6IG1vY2tHdWVzdHMgfSB9KSxcbiAgICAgICAgfSBhcyBSZXNwb25zZSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogbW9ja0dyb3VwcyB9KSxcbiAgICAgICAgfSBhcyBSZXNwb25zZSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogbW9ja1RlbXBsYXRlcyB9KSxcbiAgICAgICAgfSBhcyBSZXNwb25zZSk7XG5cbiAgICAgIHJlbmRlcihcbiAgICAgICAgPEVtYWlsQ29tcG9zZXJcbiAgICAgICAgICBpc09wZW49e3RydWV9XG4gICAgICAgICAgb25DbG9zZT17bW9ja09uQ2xvc2V9XG4gICAgICAgICAgb25TdWNjZXNzPXttb2NrT25TdWNjZXNzfVxuICAgICAgICAvPlxuICAgICAgKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4ucXVlcnlCeVRleHQoJ0xvYWRpbmcuLi4nKSkubm90LnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9LCB7IHRpbWVvdXQ6IDMwMDAgfSk7XG5cbiAgICAgIGNvbnN0IGNsb3NlQnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KCdDbG9zZScpO1xuICAgICAgZXhwZWN0KGNsb3NlQnV0dG9uKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBwcm92aWRlIGhlbHAgdGV4dCBmb3IgcmVjaXBpZW50cyBmaWVsZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGZXRjaC5tb2NrQ2xlYXIoKTtcbiAgICAgIG1vY2tGZXRjaFxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiB7IGd1ZXN0czogbW9ja0d1ZXN0cyB9IH0pLFxuICAgICAgICB9IGFzIFJlc3BvbnNlKVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBtb2NrR3JvdXBzIH0pLFxuICAgICAgICB9IGFzIFJlc3BvbnNlKVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBtb2NrVGVtcGxhdGVzIH0pLFxuICAgICAgICB9IGFzIFJlc3BvbnNlKTtcblxuICAgICAgcmVuZGVyKFxuICAgICAgICA8RW1haWxDb21wb3NlclxuICAgICAgICAgIGlzT3Blbj17dHJ1ZX1cbiAgICAgICAgICBvbkNsb3NlPXttb2NrT25DbG9zZX1cbiAgICAgICAgICBvblN1Y2Nlc3M9e21vY2tPblN1Y2Nlc3N9XG4gICAgICAgIC8+XG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5VGV4dCgnTG9hZGluZy4uLicpKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0sIHsgdGltZW91dDogMzAwMCB9KTtcblxuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ0hvbGQgQ3RybC9DbWQgdG8gc2VsZWN0IG11bHRpcGxlIHJlY2lwaWVudHMnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcHJvdmlkZSBoZWxwIHRleHQgZm9yIGVtYWlsIGJvZHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRmV0Y2gubW9ja0NsZWFyKCk7XG4gICAgICBtb2NrRmV0Y2hcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogeyBndWVzdHM6IG1vY2tHdWVzdHMgfSB9KSxcbiAgICAgICAgfSBhcyBSZXNwb25zZSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogbW9ja0dyb3VwcyB9KSxcbiAgICAgICAgfSBhcyBSZXNwb25zZSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogbW9ja1RlbXBsYXRlcyB9KSxcbiAgICAgICAgfSBhcyBSZXNwb25zZSk7XG5cbiAgICAgIHJlbmRlcihcbiAgICAgICAgPEVtYWlsQ29tcG9zZXJcbiAgICAgICAgICBpc09wZW49e3RydWV9XG4gICAgICAgICAgb25DbG9zZT17bW9ja09uQ2xvc2V9XG4gICAgICAgICAgb25TdWNjZXNzPXttb2NrT25TdWNjZXNzfVxuICAgICAgICAvPlxuICAgICAgKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4ucXVlcnlCeVRleHQoJ0xvYWRpbmcuLi4nKSkubm90LnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9LCB7IHRpbWVvdXQ6IDMwMDAgfSk7XG5cbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KC9IVE1MIHRhZ3MgYXJlIHN1cHBvcnRlZC8pKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsInVzZVRvYXN0IiwiYWRkVG9hc3QiLCJtb2NrQWRkVG9hc3QiLCJmbiIsImdsb2JhbCIsImZldGNoIiwibW9ja0d1ZXN0cyIsImlkIiwiZmlyc3RfbmFtZSIsImxhc3RfbmFtZSIsImVtYWlsIiwibW9ja0dyb3VwcyIsIm5hbWUiLCJtb2NrVGVtcGxhdGVzIiwic3ViamVjdCIsImJvZHlfaHRtbCIsImRlc2NyaWJlIiwibW9ja0ZldGNoIiwibW9ja09uQ2xvc2UiLCJtb2NrT25TdWNjZXNzIiwic2V0dXBNb2NrcyIsIm1vY2tDbGVhciIsIm1vY2tSZXNvbHZlZFZhbHVlT25jZSIsIm9rIiwianNvbiIsInN1Y2Nlc3MiLCJkYXRhIiwiZ3Vlc3RzIiwiYmVmb3JlRWFjaCIsImFmdGVyRWFjaCIsImNsZWFudXAiLCJpdCIsInJlbmRlciIsIkVtYWlsQ29tcG9zZXIiLCJpc09wZW4iLCJvbkNsb3NlIiwib25TdWNjZXNzIiwiZXhwZWN0Iiwic2NyZWVuIiwicXVlcnlCeVRleHQiLCJub3QiLCJ0b0JlSW5UaGVEb2N1bWVudCIsImdldEJ5VGV4dCIsImNsb3NlQnV0dG9uIiwiZ2V0QnlMYWJlbFRleHQiLCJmaXJlRXZlbnQiLCJjbGljayIsInRvSGF2ZUJlZW5DYWxsZWQiLCJ3YWl0Rm9yIiwiY2FuY2VsQnV0dG9uIiwiZ2V0QnlSb2xlIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJncm91cFJhZGlvIiwibW9ja1JlamVjdGVkVmFsdWUiLCJFcnJvciIsInR5cGUiLCJtZXNzYWdlIiwidGltZW91dCIsInRlbXBsYXRlU2VsZWN0IiwiY2hhbmdlIiwidGFyZ2V0IiwidmFsdWUiLCJzdWJqZWN0SW5wdXQiLCJib2R5VGV4dGFyZWEiLCJ0b0hhdmVWYWx1ZSIsImd1ZXN0UmFkaW8iLCJ0b0JlQ2hlY2tlZCIsInJlY2lwaWVudFNlbGVjdCIsInNlbGVjdGVkT3B0aW9ucyIsImxlbmd0aCIsInRvQmUiLCJzZW5kQnV0dG9uIiwidXNlciIsInVzZXJFdmVudCIsInNldHVwIiwic2VsZWN0T3B0aW9ucyIsInNlbmRCdXR0b25zIiwiZ2V0QWxsQnlSb2xlIiwic2VuZENhbGwiLCJjYWxscyIsImZpbmQiLCJjYWxsIiwidG9CZURlZmluZWQiLCJ0b01hdGNoT2JqZWN0IiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwicGFyc2UiLCJyZWNpcGllbnRzIiwidG9FcXVhbCIsImh0bWwiLCJ0ZW1wbGF0ZV9pZCIsImVycm9yIiwibW9ja1JlamVjdGVkVmFsdWVPbmNlIiwicHJldmlld0J1dHRvbiIsImhpZGVCdXR0b24iLCJyZXNvbHZlUHJvbWlzZSIsInNsb3dTZW5kIiwiUHJvbWlzZSIsInJlc29sdmUiLCJtb2NrUmV0dXJuVmFsdWVPbmNlIiwidG9CZURpc2FibGVkIiwidG9IYXZlQXR0cmlidXRlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7OztDQWFDO0FBUURBLEtBQUtDLElBQUksQ0FBQyxnQ0FBZ0MsSUFBTyxDQUFBO1FBQy9DQyxVQUFVLElBQU8sQ0FBQTtnQkFBRUMsVUFBVUM7WUFBYSxDQUFBO0lBQzVDLENBQUE7Ozs7O3VCQVI0RDtrRUFDdEM7K0JBQ1E7Ozs7OztBQUU5QixxQkFBcUI7QUFDckIsTUFBTUEsZUFBZUosS0FBS0ssRUFBRTtBQUs1QixhQUFhO0FBQ2JDLE9BQU9DLEtBQUssR0FBR1AsS0FBS0ssRUFBRTtBQUV0QixNQUFNRyxhQUFhO0lBQ2pCO1FBQUVDLElBQUk7UUFBS0MsWUFBWTtRQUFRQyxXQUFXO1FBQU9DLE9BQU87SUFBbUI7SUFDM0U7UUFBRUgsSUFBSTtRQUFLQyxZQUFZO1FBQVFDLFdBQVc7UUFBU0MsT0FBTztJQUFtQjtJQUM3RTtRQUFFSCxJQUFJO1FBQUtDLFlBQVk7UUFBT0MsV0FBVztRQUFVQyxPQUFPO0lBQUs7Q0FDaEU7QUFFRCxNQUFNQyxhQUFhO0lBQ2pCO1FBQUVKLElBQUk7UUFBS0ssTUFBTTtJQUFTO0lBQzFCO1FBQUVMLElBQUk7UUFBS0ssTUFBTTtJQUFVO0NBQzVCO0FBRUQsTUFBTUMsZ0JB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