b8323a2c085d85989dabe300e8888b5c
"use strict";
// Mock Supabase
jest.mock('@supabase/supabase-js', ()=>({
        createClient: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _mockSupabase = require("../__tests__/helpers/mockSupabase");
const _rsvpManagementService = /*#__PURE__*/ _interop_require_wildcard(require("./rsvpManagementService"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('rsvpManagementService', ()=>{
    let mockSupabase;
    beforeEach(()=>{
        mockSupabase = (0, _mockSupabase.createMockSupabaseClient)();
        (0, _mockSupabase.resetMockSupabaseClient)(mockSupabase);
        const { createClient } = require('@supabase/supabase-js');
        createClient.mockReturnValue(mockSupabase);
        // Restore all mocks including spies
        jest.restoreAllMocks();
    });
    describe('listRSVPs', ()=>{
        const mockRSVPData = [
            {
                id: 'rsvp-1',
                guest_id: 'guest-1',
                event_id: 'event-1',
                activity_id: null,
                status: 'attending',
                guest_count: 2,
                dietary_notes: 'Vegetarian',
                special_requirements: null,
                notes: null,
                responded_at: '2024-01-15T10:00:00Z',
                created_at: '2024-01-10T10:00:00Z',
                updated_at: '2024-01-15T10:00:00Z',
                guests: {
                    first_name: 'John',
                    last_name: 'Doe',
                    email: 'john@example.com'
                },
                events: {
                    name: 'Wedding Ceremony'
                },
                activities: null
            },
            {
                id: 'rsvp-2',
                guest_id: 'guest-2',
                event_id: null,
                activity_id: 'activity-1',
                status: 'pending',
                guest_count: 1,
                dietary_notes: null,
                special_requirements: null,
                notes: null,
                responded_at: null,
                created_at: '2024-01-12T10:00:00Z',
                updated_at: '2024-01-12T10:00:00Z',
                guests: {
                    first_name: 'Jane',
                    last_name: 'Smith',
                    email: 'jane@example.com'
                },
                events: null,
                activities: {
                    name: 'Beach Activity'
                }
            }
        ];
        it('should return success with RSVPs when valid filters and pagination', async ()=>{
            // Mock the query chain properly
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.eq.mockReturnValue(mockSupabase);
            mockSupabase.range.mockReturnValue(mockSupabase);
            mockSupabase.order.mockResolvedValue({
                data: mockRSVPData,
                error: null,
                count: 2
            });
            // Mock getRSVPStatistics
            jest.spyOn(_rsvpManagementService, 'getRSVPStatistics').mockResolvedValue({
                success: true,
                data: {
                    totalRSVPs: 2,
                    byStatus: {
                        attending: 1,
                        declined: 0,
                        maybe: 0,
                        pending: 1
                    },
                    totalGuestCount: 2
                }
            });
            const filters = {
                eventId: 'event-1'
            };
            const pagination = {
                page: 1,
                limit: 50
            };
            const result = await _rsvpManagementService.listRSVPs(filters, pagination);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.data).toHaveLength(2);
                expect(result.data.data[0].guestFirstName).toBe('John');
                expect(result.data.data[0].eventName).toBe('Wedding Ceremony');
                expect(result.data.pagination.page).toBe(1);
                expect(result.data.pagination.limit).toBe(50);
                expect(result.data.pagination.total).toBe(2);
                expect(result.data.pagination.totalPages).toBe(1);
            }
        });
        it('should filter by event ID', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.eq.mockReturnValue(mockSupabase);
            mockSupabase.range.mockReturnValue(mockSupabase);
            mockSupabase.order.mockResolvedValue({
                data: [
                    mockRSVPData[0]
                ],
                error: null,
                count: 1
            });
            // Mock getRSVPStatistics
            jest.spyOn(_rsvpManagementService, 'getRSVPStatistics').mockResolvedValue({
                success: true,
                data: {
                    totalRSVPs: 1,
                    byStatus: {
                        attending: 1,
                        declined: 0,
                        maybe: 0,
                        pending: 0
                    },
                    totalGuestCount: 2
                }
            });
            const result = await _rsvpManagementService.listRSVPs({
                eventId: 'event-1'
            }, {
                page: 1,
                limit: 50
            });
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.data).toHaveLength(1);
                expect(result.data.data[0].eventId).toBe('event-1');
            }
            // Verify eq was called with event_id
            expect(mockSupabase.eq).toHaveBeenCalledWith('event_id', 'event-1');
        });
        it('should filter by activity ID', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.eq.mockReturnValue(mockSupabase);
            mockSupabase.range.mockReturnValue(mockSupabase);
            mockSupabase.order.mockResolvedValue({
                data: [
                    mockRSVPData[1]
                ],
                error: null,
                count: 1
            });
            // Mock getRSVPStatistics
            jest.spyOn(_rsvpManagementService, 'getRSVPStatistics').mockResolvedValue({
                success: true,
                data: {
                    totalRSVPs: 1,
                    byStatus: {
                        attending: 0,
                        declined: 0,
                        maybe: 0,
                        pending: 1
                    },
                    totalGuestCount: 0
                }
            });
            const result = await _rsvpManagementService.listRSVPs({
                activityId: 'activity-1'
            }, {
                page: 1,
                limit: 50
            });
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.data).toHaveLength(1);
                expect(result.data.data[0].activityId).toBe('activity-1');
            }
            // Verify eq was called with activity_id
            expect(mockSupabase.eq).toHaveBeenCalledWith('activity_id', 'activity-1');
        });
        it('should filter by status', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.eq.mockReturnValue(mockSupabase);
            mockSupabase.range.mockReturnValue(mockSupabase);
            mockSupabase.order.mockResolvedValue({
                data: [
                    mockRSVPData[0]
                ],
                error: null,
                count: 1
            });
            // Mock getRSVPStatistics
            jest.spyOn(_rsvpManagementService, 'getRSVPStatistics').mockResolvedValue({
                success: true,
                data: {
                    totalRSVPs: 1,
                    byStatus: {
                        attending: 1,
                        declined: 0,
                        maybe: 0,
                        pending: 0
                    },
                    totalGuestCount: 2
                }
            });
            const result = await _rsvpManagementService.listRSVPs({
                status: 'attending'
            }, {
                page: 1,
                limit: 50
            });
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.data).toHaveLength(1);
                expect(result.data.data[0].status).toBe('attending');
            }
            // Verify eq was called with status
            expect(mockSupabase.eq).toHaveBeenCalledWith('status', 'attending');
        });
        it('should filter by guest ID', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.eq.mockReturnValue(mockSupabase);
            mockSupabase.range.mockReturnValue(mockSupabase);
            mockSupabase.order.mockResolvedValue({
                data: [
                    mockRSVPData[0]
                ],
                error: null,
                count: 1
            });
            // Mock getRSVPStatistics
            jest.spyOn(_rsvpManagementService, 'getRSVPStatistics').mockResolvedValue({
                success: true,
                data: {
                    totalRSVPs: 1,
                    byStatus: {
                        attending: 1,
                        declined: 0,
                        maybe: 0,
                        pending: 0
                    },
                    totalGuestCount: 2
                }
            });
            const result = await _rsvpManagementService.listRSVPs({
                guestId: 'guest-1'
            }, {
                page: 1,
                limit: 50
            });
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.data).toHaveLength(1);
                expect(result.data.data[0].guestId).toBe('guest-1');
            }
            // Verify eq was called with guest_id
            expect(mockSupabase.eq).toHaveBeenCalledWith('guest_id', 'guest-1');
        });
        it('should apply pagination correctly', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.range.mockReturnValue(mockSupabase);
            mockSupabase.order.mockResolvedValue({
                data: mockRSVPData,
                error: null,
                count: 100
            });
            // Mock getRSVPStatistics
            jest.spyOn(_rsvpManagementService, 'getRSVPStatistics').mockResolvedValue({
                success: true,
                data: {
                    totalRSVPs: 100,
                    byStatus: {
                        attending: 50,
                        declined: 25,
                        maybe: 15,
                        pending: 10
                    },
                    totalGuestCount: 50
                }
            });
            const result = await _rsvpManagementService.listRSVPs({}, {
                page: 2,
                limit: 25
            });
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.pagination.page).toBe(2);
                expect(result.data.pagination.limit).toBe(25);
                expect(result.data.pagination.total).toBe(100);
                expect(result.data.pagination.totalPages).toBe(4);
            }
            // Verify range was called with correct values (page 2, limit 25 = from 25 to 49)
            expect(mockSupabase.range).toHaveBeenCalledWith(25, 49);
        });
        it('should return VALIDATION_ERROR when invalid filter parameters', async ()=>{
            const result = await _rsvpManagementService.listRSVPs({
                eventId: 'invalid-uuid'
            }, {
                page: 1,
                limit: 50
            });
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        it('should return VALIDATION_ERROR when invalid pagination parameters', async ()=>{
            const result = await _rsvpManagementService.listRSVPs({}, {
                page: -1,
                limit: 50
            });
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        it('should return DATABASE_ERROR when database query fails', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.range.mockReturnValue(mockSupabase);
            mockSupabase.order.mockResolvedValue({
                data: null,
                error: {
                    message: 'Database connection failed'
                },
                count: null
            });
            const result = await _rsvpManagementService.listRSVPs({}, {
                page: 1,
                limit: 50
            });
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('DATABASE_ERROR');
                expect(result.error.message).toBe('Database connection failed');
            }
        });
        it('should apply multiple filters together', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.eq.mockReturnValue(mockSupabase);
            mockSupabase.range.mockReturnValue(mockSupabase);
            mockSupabase.order.mockResolvedValue({
                data: [
                    mockRSVPData[0]
                ],
                error: null,
                count: 1
            });
            // Mock getRSVPStatistics
            jest.spyOn(_rsvpManagementService, 'getRSVPStatistics').mockResolvedValue({
                success: true,
                data: {
                    totalRSVPs: 1,
                    byStatus: {
                        attending: 1,
                        declined: 0,
                        maybe: 0,
                        pending: 0
                    },
                    totalGuestCount: 2
                }
            });
            const result = await _rsvpManagementService.listRSVPs({
                eventId: 'event-1',
                status: 'attending',
                guestId: 'guest-1'
            }, {
                page: 1,
                limit: 50
            });
            expect(result.success).toBe(true);
            // Verify all filters were applied
            expect(mockSupabase.eq).toHaveBeenCalledWith('event_id', 'event-1');
            expect(mockSupabase.eq).toHaveBeenCalledWith('status', 'attending');
            expect(mockSupabase.eq).toHaveBeenCalledWith('guest_id', 'guest-1');
        });
        it('should handle search query filter', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.or.mockReturnValue(mockSupabase);
            mockSupabase.range.mockReturnValue(mockSupabase);
            mockSupabase.order.mockResolvedValue({
                data: [
                    mockRSVPData[0]
                ],
                error: null,
                count: 1
            });
            // Mock getRSVPStatistics
            jest.spyOn(_rsvpManagementService, 'getRSVPStatistics').mockResolvedValue({
                success: true,
                data: {
                    totalRSVPs: 1,
                    byStatus: {
                        attending: 1,
                        declined: 0,
                        maybe: 0,
                        pending: 0
                    },
                    totalGuestCount: 2
                }
            });
            const result = await _rsvpManagementService.listRSVPs({
                searchQuery: 'John'
            }, {
                page: 1,
                limit: 50
            });
            expect(result.success).toBe(true);
            // Verify or was called for search
            expect(mockSupabase.or).toHaveBeenCalled();
        });
        it('should default to page 1 and limit 50 when not specified', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.range.mockReturnValue(mockSupabase);
            mockSupabase.order.mockResolvedValue({
                data: mockRSVPData,
                error: null,
                count: 2
            });
            // Mock getRSVPStatistics
            jest.spyOn(_rsvpManagementService, 'getRSVPStatistics').mockResolvedValue({
                success: true,
                data: {
                    totalRSVPs: 2,
                    byStatus: {
                        attending: 1,
                        declined: 0,
                        maybe: 0,
                        pending: 1
                    },
                    totalGuestCount: 2
                }
            });
            const result = await _rsvpManagementService.listRSVPs();
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.pagination.page).toBe(1);
                expect(result.data.pagination.limit).toBe(50);
            }
            // Verify range was called with default values (page 1, limit 50 = from 0 to 49)
            expect(mockSupabase.range).toHaveBeenCalledWith(0, 49);
        });
    });
    describe('getRSVPStatistics', ()=>{
        const mockStatisticsData = [
            {
                status: 'attending',
                guest_count: 2
            },
            {
                status: 'attending',
                guest_count: 1
            },
            {
                status: 'declined',
                guest_count: 1
            },
            {
                status: 'maybe',
                guest_count: null
            },
            {
                status: 'pending',
                guest_count: 1
            }
        ];
        it('should return success with accurate statistics', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockResolvedValue({
                data: mockStatisticsData,
                error: null
            });
            const result = await _rsvpManagementService.getRSVPStatistics({});
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.totalRSVPs).toBe(5);
                expect(result.data.byStatus.attending).toBe(2);
                expect(result.data.byStatus.declined).toBe(1);
                expect(result.data.byStatus.maybe).toBe(1);
                expect(result.data.byStatus.pending).toBe(1);
                expect(result.data.totalGuestCount).toBe(3); // 2 + 1 from attending
            }
        });
        it('should filter statistics by event ID', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.eq.mockResolvedValue({
                data: [
                    mockStatisticsData[0],
                    mockStatisticsData[1]
                ],
                error: null
            });
            const result = await _rsvpManagementService.getRSVPStatistics({
                eventId: 'event-1'
            });
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.totalRSVPs).toBe(2);
                expect(result.data.byStatus.attending).toBe(2);
            }
            // Verify eq was called with event_id
            expect(mockSupabase.eq).toHaveBeenCalledWith('event_id', 'event-1');
        });
        it('should handle empty results', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockResolvedValue({
                data: [],
                error: null
            });
            const result = await _rsvpManagementService.getRSVPStatistics({});
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.totalRSVPs).toBe(0);
                expect(result.data.byStatus.attending).toBe(0);
                expect(result.data.totalGuestCount).toBe(0);
            }
        });
        it('should return VALIDATION_ERROR when invalid filter parameters', async ()=>{
            const result = await _rsvpManagementService.getRSVPStatistics({
                eventId: 'invalid-uuid'
            });
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        it('should return DATABASE_ERROR when database query fails', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockResolvedValue({
                data: null,
                error: {
                    message: 'Database connection failed'
                }
            });
            const result = await _rsvpManagementService.getRSVPStatistics({});
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('DATABASE_ERROR');
                expect(result.error.message).toBe('Database connection failed');
            }
        });
        it('should filter statistics by multiple criteria', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.eq.mockResolvedValue({
                data: [
                    mockStatisticsData[0]
                ],
                error: null
            });
            const result = await _rsvpManagementService.getRSVPStatistics({
                eventId: 'event-1',
                status: 'attending'
            });
            expect(result.success).toBe(true);
            // Verify both filters were applied
            expect(mockSupabase.eq).toHaveBeenCalledWith('event_id', 'event-1');
            expect(mockSupabase.eq).toHaveBeenCalledWith('status', 'attending');
        });
        it('should default guest_count to 1 when null for attending RSVPs', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockResolvedValue({
                data: [
                    {
                        status: 'attending',
                        guest_count: null
                    },
                    {
                        status: 'attending',
                        guest_count: 2
                    }
                ],
                error: null
            });
            const result = await _rsvpManagementService.getRSVPStatistics({});
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.totalGuestCount).toBe(3); // 1 (default) + 2
            }
        });
    });
    describe('bulkUpdateRSVPs', ()=>{
        it('should return success with updated count when valid input', async ()=>{
            const rsvpIds = [
                'rsvp-1',
                'rsvp-2',
                'rsvp-3'
            ];
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.update.mockReturnValue(mockSupabase);
            mockSupabase.in.mockReturnValue(mockSupabase);
            mockSupabase.select.mockResolvedValue({
                data: [
                    {
                        id: 'rsvp-1'
                    },
                    {
                        id: 'rsvp-2'
                    },
                    {
                        id: 'rsvp-3'
                    }
                ],
                error: null
            });
            const result = await _rsvpManagementService.bulkUpdateRSVPs(rsvpIds, 'attending', 'Bulk approved');
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.updatedCount).toBe(3);
            }
            // Verify update was called with correct data
            expect(mockSupabase.update).toHaveBeenCalledWith(expect.objectContaining({
                status: 'attending',
                notes: 'Bulk approved',
                responded_at: expect.any(String),
                updated_at: expect.any(String)
            }));
            // Verify in was called with correct IDs
            expect(mockSupabase.in).toHaveBeenCalledWith('id', rsvpIds);
        });
        it('should update status and set responded_at for non-pending status', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.update.mockReturnValue(mockSupabase);
            mockSupabase.in.mockReturnValue(mockSupabase);
            mockSupabase.select.mockResolvedValue({
                data: [
                    {
                        id: 'rsvp-1'
                    }
                ],
                error: null
            });
            await _rsvpManagementService.bulkUpdateRSVPs([
                'rsvp-1'
            ], 'attending');
            expect(mockSupabase.update).toHaveBeenCalledWith(expect.objectContaining({
                status: 'attending',
                responded_at: expect.any(String)
            }));
        });
        it('should include notes when provided', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.update.mockReturnValue(mockSupabase);
            mockSupabase.in.mockReturnValue(mockSupabase);
            mockSupabase.select.mockResolvedValue({
                data: [
                    {
                        id: 'rsvp-1'
                    }
                ],
                error: null
            });
            await _rsvpManagementService.bulkUpdateRSVPs([
                'rsvp-1'
            ], 'attending', 'Admin approved');
            expect(mockSupabase.update).toHaveBeenCalledWith(expect.objectContaining({
                notes: 'Admin approved'
            }));
        });
        it('should handle partial updates when some RSVPs not found', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.update.mockReturnValue(mockSupabase);
            mockSupabase.in.mockReturnValue(mockSupabase);
            mockSupabase.select.mockResolvedValue({
                data: [
                    {
                        id: 'rsvp-1'
                    },
                    {
                        id: 'rsvp-2'
                    }
                ],
                error: null
            });
            const result = await _rsvpManagementService.bulkUpdateRSVPs([
                'rsvp-1',
                'rsvp-2',
                'rsvp-3'
            ], 'attending');
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.updatedCount).toBe(2);
            }
        });
        it('should return VALIDATION_ERROR when empty rsvpIds array', async ()=>{
            const result = await _rsvpManagementService.bulkUpdateRSVPs([], 'attending');
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        it('should return VALIDATION_ERROR when too many rsvpIds (>100)', async ()=>{
            const tooManyIds = Array.from({
                length: 101
            }, (_, i)=>`rsvp-${i}`);
            const result = await _rsvpManagementService.bulkUpdateRSVPs(tooManyIds, 'attending');
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        it('should return VALIDATION_ERROR when invalid status', async ()=>{
            const result = await _rsvpManagementService.bulkUpdateRSVPs([
                'rsvp-1'
            ], 'invalid-status');
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        it('should return DATABASE_ERROR when database update fails', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.update.mockReturnValue(mockSupabase);
            mockSupabase.in.mockReturnValue(mockSupabase);
            mockSupabase.select.mockResolvedValue({
                data: null,
                error: {
                    message: 'Database connection failed'
                }
            });
            const result = await _rsvpManagementService.bulkUpdateRSVPs([
                'rsvp-1'
            ], 'attending');
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('DATABASE_ERROR');
                expect(result.error.message).toBe('Database connection failed');
            }
        });
        it('should not set responded_at when status is pending', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.update.mockReturnValue(mockSupabase);
            mockSupabase.in.mockReturnValue(mockSupabase);
            mockSupabase.select.mockResolvedValue({
                data: [
                    {
                        id: 'rsvp-1'
                    }
                ],
                error: null
            });
            await _rsvpManagementService.bulkUpdateRSVPs([
                'rsvp-1'
            ], 'pending');
            expect(mockSupabase.update).toHaveBeenCalledWith(expect.objectContaining({
                status: 'pending'
            }));
            // Verify responded_at is NOT in the update data
            const updateCall = mockSupabase.update.mock.calls[0][0];
            expect(updateCall.responded_at).toBeUndefined();
        });
        it('should handle all valid status values', async ()=>{
            const statuses = [
                'pending',
                'attending',
                'declined',
                'maybe'
            ];
            for (const status of statuses){
                // Reset mocks for each iteration
                jest.clearAllMocks();
                (0, _mockSupabase.resetMockSupabaseClient)(mockSupabase);
                mockSupabase.from.mockReturnValue(mockSupabase);
                mockSupabase.update.mockReturnValue(mockSupabase);
                mockSupabase.in.mockReturnValue(mockSupabase);
                mockSupabase.select.mockResolvedValue({
                    data: [
                        {
                            id: 'rsvp-1'
                        }
                    ],
                    error: null
                });
                const result = await _rsvpManagementService.bulkUpdateRSVPs([
                    'rsvp-1'
                ], status);
                expect(result.success).toBe(true);
                if (result.success) {
                    expect(result.data.updatedCount).toBe(1);
                }
                expect(mockSupabase.update).toHaveBeenCalledWith(expect.objectContaining({
                    status
                }));
            }
        });
    });
    describe('exportRSVPsToCSV', ()=>{
        it('should return success with CSV string when valid filters', async ()=>{
            const mockRSVPs = [
                {
                    id: 'rsvp-1',
                    guestFirstName: 'John',
                    guestLastName: 'Doe',
                    guestEmail: 'john@example.com',
                    eventName: 'Wedding Ceremony',
                    activityName: null,
                    status: 'attending',
                    guestCount: 2,
                    dietaryNotes: 'Vegetarian',
                    specialRequirements: null,
                    notes: null,
                    respondedAt: '2024-01-15T10:00:00Z',
                    createdAt: '2024-01-10T10:00:00Z',
                    updatedAt: '2024-01-15T10:00:00Z',
                    guestId: 'guest-1',
                    eventId: 'event-1',
                    activityId: null
                }
            ];
            // Mock listRSVPs to return test data
            jest.spyOn(_rsvpManagementService, 'listRSVPs').mockResolvedValue({
                success: true,
                data: {
                    data: mockRSVPs,
                    pagination: {
                        page: 1,
                        limit: 10000,
                        total: 1,
                        totalPages: 1
                    },
                    statistics: {
                        totalRSVPs: 1,
                        byStatus: {
                            attending: 1,
                            declined: 0,
                            maybe: 0,
                            pending: 0
                        },
                        totalGuestCount: 2
                    }
                }
            });
            const result = await _rsvpManagementService.exportRSVPsToCSV({});
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data).toContain('RSVP ID,Guest First Name,Guest Last Name');
                expect(result.data).toContain('rsvp-1,John,Doe');
                expect(result.data).toContain('Wedding Ceremony');
                expect(result.data).toContain('attending');
                expect(result.data).toContain('Vegetarian');
            }
            // Verify listRSVPs was called with correct parameters
            expect(_rsvpManagementService.listRSVPs).toHaveBeenCalledWith({}, {
                page: 1,
                limit: 10000
            });
        });
        it('should escape CSV values with commas', async ()=>{
            const mockRSVPs = [
                {
                    id: 'rsvp-1',
                    guestFirstName: 'John',
                    guestLastName: 'Doe, Jr.',
                    guestEmail: 'john@example.com',
                    eventName: 'Wedding Ceremony',
                    activityName: null,
                    status: 'attending',
                    guestCount: 1,
                    dietaryNotes: 'No nuts, no dairy',
                    specialRequirements: null,
                    notes: null,
                    respondedAt: '2024-01-15T10:00:00Z',
                    createdAt: '2024-01-10T10:00:00Z',
                    updatedAt: '2024-01-15T10:00:00Z',
                    guestId: 'guest-1',
                    eventId: 'event-1',
                    activityId: null
                }
            ];
            jest.spyOn(_rsvpManagementService, 'listRSVPs').mockResolvedValue({
                success: true,
                data: {
                    data: mockRSVPs,
                    pagination: {
                        page: 1,
                        limit: 10000,
                        total: 1,
                        totalPages: 1
                    },
                    statistics: {
                        totalRSVPs: 1,
                        byStatus: {
                            attending: 1,
                            declined: 0,
                            maybe: 0,
                            pending: 0
                        },
                        totalGuestCount: 1
                    }
                }
            });
            const result = await _rsvpManagementService.exportRSVPsToCSV({});
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data).toContain('"Doe, Jr."');
                expect(result.data).toContain('"No nuts, no dairy"');
            }
        });
        it('should escape CSV values with quotes', async ()=>{
            const mockRSVPs = [
                {
                    id: 'rsvp-1',
                    guestFirstName: 'John',
                    guestLastName: 'Doe',
                    guestEmail: 'john@example.com',
                    eventName: 'Wedding Ceremony',
                    activityName: null,
                    status: 'attending',
                    guestCount: 1,
                    dietaryNotes: null,
                    specialRequirements: null,
                    notes: 'Guest said "excited to attend"',
                    respondedAt: '2024-01-15T10:00:00Z',
                    createdAt: '2024-01-10T10:00:00Z',
                    updatedAt: '2024-01-15T10:00:00Z',
                    guestId: 'guest-1',
                    eventId: 'event-1',
                    activityId: null
                }
            ];
            jest.spyOn(_rsvpManagementService, 'listRSVPs').mockResolvedValue({
                success: true,
                data: {
                    data: mockRSVPs,
                    pagination: {
                        page: 1,
                        limit: 10000,
                        total: 1,
                        totalPages: 1
                    },
                    statistics: {
                        totalRSVPs: 1,
                        byStatus: {
                            attending: 1,
                            declined: 0,
                            maybe: 0,
                            pending: 0
                        },
                        totalGuestCount: 1
                    }
                }
            });
            const result = await _rsvpManagementService.exportRSVPsToCSV({});
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data).toContain('""excited to attend""');
            }
        });
        it('should handle empty results', async ()=>{
            jest.spyOn(_rsvpManagementService, 'listRSVPs').mockResolvedValue({
                success: true,
                data: {
                    data: [],
                    pagination: {
                        page: 1,
                        limit: 10000,
                        total: 0,
                        totalPages: 0
                    },
                    statistics: {
                        totalRSVPs: 0,
                        byStatus: {
                            attending: 0,
                            declined: 0,
                            maybe: 0,
                            pending: 0
                        },
                        totalGuestCount: 0
                    }
                }
            });
            const result = await _rsvpManagementService.exportRSVPsToCSV({});
            expect(result.success).toBe(true);
            if (result.success) {
                // Should only have header row
                const lines = result.data.split('\n');
                expect(lines.length).toBe(1);
                expect(lines[0]).toContain('RSVP ID,Guest First Name');
            }
        });
        it('should return VALIDATION_ERROR when invalid filter parameters', async ()=>{
            const result = await _rsvpManagementService.exportRSVPsToCSV({
                eventId: 'invalid-uuid'
            });
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        it('should propagate errors from listRSVPs', async ()=>{
            jest.spyOn(_rsvpManagementService, 'listRSVPs').mockResolvedValue({
                success: false,
                error: {
                    code: 'DATABASE_ERROR',
                    message: 'Database connection failed'
                }
            });
            const result = await _rsvpManagementService.exportRSVPsToCSV({});
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('DATABASE_ERROR');
                expect(result.error.message).toBe('Database connection failed');
            }
        });
        it('should apply filters when exporting', async ()=>{
            jest.spyOn(_rsvpManagementService, 'listRSVPs').mockResolvedValue({
                success: true,
                data: {
                    data: [],
                    pagination: {
                        page: 1,
                        limit: 10000,
                        total: 0,
                        totalPages: 0
                    },
                    statistics: {
                        totalRSVPs: 0,
                        byStatus: {
                            attending: 0,
                            declined: 0,
                            maybe: 0,
                            pending: 0
                        },
                        totalGuestCount: 0
                    }
                }
            });
            const filters = {
                eventId: 'event-1',
                status: 'attending'
            };
            await _rsvpManagementService.exportRSVPsToCSV(filters);
            // Verify listRSVPs was called with the filters
            expect(_rsvpManagementService.listRSVPs).toHaveBeenCalledWith(filters, {
                page: 1,
                limit: 10000
            });
        });
        it('should handle newlines in CSV values', async ()=>{
            const mockRSVPs = [
                {
                    id: 'rsvp-1',
                    guestFirstName: 'John',
                    guestLastName: 'Doe',
                    guestEmail: 'john@example.com',
                    eventName: 'Wedding Ceremony',
                    activityName: null,
                    status: 'attending',
                    guestCount: 1,
                    dietaryNotes: null,
                    specialRequirements: null,
                    notes: 'Line 1\nLine 2',
                    respondedAt: '2024-01-15T10:00:00Z',
                    createdAt: '2024-01-10T10:00:00Z',
                    updatedAt: '2024-01-15T10:00:00Z',
                    guestId: 'guest-1',
                    eventId: 'event-1',
                    activityId: null
                }
            ];
            jest.spyOn(_rsvpManagementService, 'listRSVPs').mockResolvedValue({
                success: true,
                data: {
                    data: mockRSVPs,
                    pagination: {
                        page: 1,
                        limit: 10000,
                        total: 1,
                        totalPages: 1
                    },
                    statistics: {
                        totalRSVPs: 1,
                        byStatus: {
                            attending: 1,
                            declined: 0,
                            maybe: 0,
                            pending: 0
                        },
                        totalGuestCount: 1
                    }
                }
            });
            const result = await _rsvpManagementService.exportRSVPsToCSV({});
            expect(result.success).toBe(true);
            if (result.success) {
                // Newlines should be wrapped in quotes
                expect(result.data).toContain('"Line 1\nLine 2"');
            }
        });
        it('should handle null values in CSV', async ()=>{
            const mockRSVPs = [
                {
                    id: 'rsvp-1',
                    guestFirstName: 'John',
                    guestLastName: 'Doe',
                    guestEmail: null,
                    eventName: null,
                    activityName: null,
                    status: 'pending',
                    guestCount: null,
                    dietaryNotes: null,
                    specialRequirements: null,
                    notes: null,
                    respondedAt: null,
                    createdAt: '2024-01-10T10:00:00Z',
                    updatedAt: '2024-01-10T10:00:00Z',
                    guestId: 'guest-1',
                    eventId: null,
                    activityId: null
                }
            ];
            jest.spyOn(_rsvpManagementService, 'listRSVPs').mockResolvedValue({
                success: true,
                data: {
                    data: mockRSVPs,
                    pagination: {
                        page: 1,
                        limit: 10000,
                        total: 1,
                        totalPages: 1
                    },
                    statistics: {
                        totalRSVPs: 1,
                        byStatus: {
                            attending: 0,
                            declined: 0,
                            maybe: 0,
                            pending: 1
                        },
                        totalGuestCount: 0
                    }
                }
            });
            const result = await _rsvpManagementService.exportRSVPsToCSV({});
            expect(result.success).toBe(true);
            if (result.success) {
                // Null values should be empty strings
                const lines = result.data.split('\n');
                expect(lines[1]).toContain('rsvp-1,John,Doe,,,');
                // Guest count should default to 1
                expect(lines[1]).toContain(',1,');
            }
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlTW9ja1N1cGFiYXNlQ2xpZW50LCByZXNldE1vY2tTdXBhYmFzZUNsaWVudCB9IGZyb20gJ0AvX190ZXN0c19fL2hlbHBlcnMvbW9ja1N1cGFiYXNlJztcbmltcG9ydCAqIGFzIHJzdnBNYW5hZ2VtZW50U2VydmljZSBmcm9tICcuL3JzdnBNYW5hZ2VtZW50U2VydmljZSc7XG5pbXBvcnQgdHlwZSB7IFJTVlBGaWx0ZXJzLCBQYWdpbmF0aW9uUGFyYW1zIH0gZnJvbSAnLi9yc3ZwTWFuYWdlbWVudFNlcnZpY2UnO1xuXG4vLyBNb2NrIFN1cGFiYXNlXG5qZXN0Lm1vY2soJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcycsICgpID0+ICh7XG4gIGNyZWF0ZUNsaWVudDogamVzdC5mbigpLFxufSkpO1xuXG5kZXNjcmliZSgncnN2cE1hbmFnZW1lbnRTZXJ2aWNlJywgKCkgPT4ge1xuICBsZXQgbW9ja1N1cGFiYXNlOiBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVNb2NrU3VwYWJhc2VDbGllbnQ+O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIG1vY2tTdXBhYmFzZSA9IGNyZWF0ZU1vY2tTdXBhYmFzZUNsaWVudCgpO1xuICAgIHJlc2V0TW9ja1N1cGFiYXNlQ2xpZW50KG1vY2tTdXBhYmFzZSk7XG4gICAgY29uc3QgeyBjcmVhdGVDbGllbnQgfSA9IHJlcXVpcmUoJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcycpO1xuICAgIGNyZWF0ZUNsaWVudC5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICBcbiAgICAvLyBSZXN0b3JlIGFsbCBtb2NrcyBpbmNsdWRpbmcgc3BpZXNcbiAgICBqZXN0LnJlc3RvcmVBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnbGlzdFJTVlBzJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tSU1ZQRGF0YSA9IFtcbiAgICAgIHtcbiAgICAgICAgaWQ6ICdyc3ZwLTEnLFxuICAgICAgICBndWVzdF9pZDogJ2d1ZXN0LTEnLFxuICAgICAgICBldmVudF9pZDogJ2V2ZW50LTEnLFxuICAgICAgICBhY3Rpdml0eV9pZDogbnVsbCxcbiAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyxcbiAgICAgICAgZ3Vlc3RfY291bnQ6IDIsXG4gICAgICAgIGRpZXRhcnlfbm90ZXM6ICdWZWdldGFyaWFuJyxcbiAgICAgICAgc3BlY2lhbF9yZXF1aXJlbWVudHM6IG51bGwsXG4gICAgICAgIG5vdGVzOiBudWxsLFxuICAgICAgICByZXNwb25kZWRfYXQ6ICcyMDI0LTAxLTE1VDEwOjAwOjAwWicsXG4gICAgICAgIGNyZWF0ZWRfYXQ6ICcyMDI0LTAxLTEwVDEwOjAwOjAwWicsXG4gICAgICAgIHVwZGF0ZWRfYXQ6ICcyMDI0LTAxLTE1VDEwOjAwOjAwWicsXG4gICAgICAgIGd1ZXN0czoge1xuICAgICAgICAgIGZpcnN0X25hbWU6ICdKb2huJyxcbiAgICAgICAgICBsYXN0X25hbWU6ICdEb2UnLFxuICAgICAgICAgIGVtYWlsOiAnam9obkBleGFtcGxlLmNvbScsXG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIG5hbWU6ICdXZWRkaW5nIENlcmVtb255JyxcbiAgICAgICAgfSxcbiAgICAgICAgYWN0aXZpdGllczogbnVsbCxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiAncnN2cC0yJyxcbiAgICAgICAgZ3Vlc3RfaWQ6ICdndWVzdC0yJyxcbiAgICAgICAgZXZlbnRfaWQ6IG51bGwsXG4gICAgICAgIGFjdGl2aXR5X2lkOiAnYWN0aXZpdHktMScsXG4gICAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgICBndWVzdF9jb3VudDogMSxcbiAgICAgICAgZGlldGFyeV9ub3RlczogbnVsbCxcbiAgICAgICAgc3BlY2lhbF9yZXF1aXJlbWVudHM6IG51bGwsXG4gICAgICAgIG5vdGVzOiBudWxsLFxuICAgICAgICByZXNwb25kZWRfYXQ6IG51bGwsXG4gICAgICAgIGNyZWF0ZWRfYXQ6ICcyMDI0LTAxLTEyVDEwOjAwOjAwWicsXG4gICAgICAgIHVwZGF0ZWRfYXQ6ICcyMDI0LTAxLTEyVDEwOjAwOjAwWicsXG4gICAgICAgIGd1ZXN0czoge1xuICAgICAgICAgIGZpcnN0X25hbWU6ICdKYW5lJyxcbiAgICAgICAgICBsYXN0X25hbWU6ICdTbWl0aCcsXG4gICAgICAgICAgZW1haWw6ICdqYW5lQGV4YW1wbGUuY29tJyxcbiAgICAgICAgfSxcbiAgICAgICAgZXZlbnRzOiBudWxsLFxuICAgICAgICBhY3Rpdml0aWVzOiB7XG4gICAgICAgICAgbmFtZTogJ0JlYWNoIEFjdGl2aXR5JyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgXTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3Mgd2l0aCBSU1ZQcyB3aGVuIHZhbGlkIGZpbHRlcnMgYW5kIHBhZ2luYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHRoZSBxdWVyeSBjaGFpbiBwcm9wZXJseVxuICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLmVxLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnJhbmdlLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLm9yZGVyLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbW9ja1JTVlBEYXRhLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgY291bnQ6IDIsXG4gICAgICB9KTtcblxuICAgICAgLy8gTW9jayBnZXRSU1ZQU3RhdGlzdGljc1xuICAgICAgamVzdC5zcHlPbihyc3ZwTWFuYWdlbWVudFNlcnZpY2UsICdnZXRSU1ZQU3RhdGlzdGljcycpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHRvdGFsUlNWUHM6IDIsXG4gICAgICAgICAgYnlTdGF0dXM6IHsgYXR0ZW5kaW5nOiAxLCBkZWNsaW5lZDogMCwgbWF5YmU6IDAsIHBlbmRpbmc6IDEgfSxcbiAgICAgICAgICB0b3RhbEd1ZXN0Q291bnQ6IDIsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZmlsdGVyczogUlNWUEZpbHRlcnMgPSB7IGV2ZW50SWQ6ICdldmVudC0xJyB9O1xuICAgICAgY29uc3QgcGFnaW5hdGlvbjogUGFnaW5hdGlvblBhcmFtcyA9IHsgcGFnZTogMSwgbGltaXQ6IDUwIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5saXN0UlNWUHMoZmlsdGVycywgcGFnaW5hdGlvbik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuZGF0YSkudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuZGF0YVswXS5ndWVzdEZpcnN0TmFtZSkudG9CZSgnSm9obicpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuZGF0YVswXS5ldmVudE5hbWUpLnRvQmUoJ1dlZGRpbmcgQ2VyZW1vbnknKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnBhZ2luYXRpb24ucGFnZSkudG9CZSgxKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnBhZ2luYXRpb24ubGltaXQpLnRvQmUoNTApO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEucGFnaW5hdGlvbi50b3RhbCkudG9CZSgyKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnBhZ2luYXRpb24udG90YWxQYWdlcykudG9CZSgxKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZmlsdGVyIGJ5IGV2ZW50IElEJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLmVxLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnJhbmdlLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLm9yZGVyLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogW21vY2tSU1ZQRGF0YVswXV0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICBjb3VudDogMSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrIGdldFJTVlBTdGF0aXN0aWNzXG4gICAgICBqZXN0LnNweU9uKHJzdnBNYW5hZ2VtZW50U2VydmljZSwgJ2dldFJTVlBTdGF0aXN0aWNzJykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdG90YWxSU1ZQczogMSxcbiAgICAgICAgICBieVN0YXR1czogeyBhdHRlbmRpbmc6IDEsIGRlY2xpbmVkOiAwLCBtYXliZTogMCwgcGVuZGluZzogMCB9LFxuICAgICAgICAgIHRvdGFsR3Vlc3RDb3VudDogMixcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UubGlzdFJTVlBzKFxuICAgICAgICB7IGV2ZW50SWQ6ICdldmVudC0xJyB9LFxuICAgICAgICB7IHBhZ2U6IDEsIGxpbWl0OiA1MCB9XG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmRhdGEpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmRhdGFbMF0uZXZlbnRJZCkudG9CZSgnZXZlbnQtMScpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBWZXJpZnkgZXEgd2FzIGNhbGxlZCB3aXRoIGV2ZW50X2lkXG4gICAgICBleHBlY3QobW9ja1N1cGFiYXNlLmVxKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnZXZlbnRfaWQnLCAnZXZlbnQtMScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBmaWx0ZXIgYnkgYWN0aXZpdHkgSUQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5zZWxlY3QubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2UuZXEubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2UucmFuZ2UubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uub3JkZXIubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBbbW9ja1JTVlBEYXRhWzFdXSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIGNvdW50OiAxLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIE1vY2sgZ2V0UlNWUFN0YXRpc3RpY3NcbiAgICAgIGplc3Quc3B5T24ocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLCAnZ2V0UlNWUFN0YXRpc3RpY3MnKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB0b3RhbFJTVlBzOiAxLFxuICAgICAgICAgIGJ5U3RhdHVzOiB7IGF0dGVuZGluZzogMCwgZGVjbGluZWQ6IDAsIG1heWJlOiAwLCBwZW5kaW5nOiAxIH0sXG4gICAgICAgICAgdG90YWxHdWVzdENvdW50OiAwLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5saXN0UlNWUHMoXG4gICAgICAgIHsgYWN0aXZpdHlJZDogJ2FjdGl2aXR5LTEnIH0sXG4gICAgICAgIHsgcGFnZTogMSwgbGltaXQ6IDUwIH1cbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuZGF0YSkudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuZGF0YVswXS5hY3Rpdml0eUlkKS50b0JlKCdhY3Rpdml0eS0xJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBlcSB3YXMgY2FsbGVkIHdpdGggYWN0aXZpdHlfaWRcbiAgICAgIGV4cGVjdChtb2NrU3VwYWJhc2UuZXEpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdhY3Rpdml0eV9pZCcsICdhY3Rpdml0eS0xJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGZpbHRlciBieSBzdGF0dXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5zZWxlY3QubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2UuZXEubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2UucmFuZ2UubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uub3JkZXIubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBbbW9ja1JTVlBEYXRhWzBdXSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIGNvdW50OiAxLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIE1vY2sgZ2V0UlNWUFN0YXRpc3RpY3NcbiAgICAgIGplc3Quc3B5T24ocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLCAnZ2V0UlNWUFN0YXRpc3RpY3MnKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB0b3RhbFJTVlBzOiAxLFxuICAgICAgICAgIGJ5U3RhdHVzOiB7IGF0dGVuZGluZzogMSwgZGVjbGluZWQ6IDAsIG1heWJlOiAwLCBwZW5kaW5nOiAwIH0sXG4gICAgICAgICAgdG90YWxHdWVzdENvdW50OiAyLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5saXN0UlNWUHMoXG4gICAgICAgIHsgc3RhdHVzOiAnYXR0ZW5kaW5nJyB9LFxuICAgICAgICB7IHBhZ2U6IDEsIGxpbWl0OiA1MCB9XG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmRhdGEpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmRhdGFbMF0uc3RhdHVzKS50b0JlKCdhdHRlbmRpbmcnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGVxIHdhcyBjYWxsZWQgd2l0aCBzdGF0dXNcbiAgICAgIGV4cGVjdChtb2NrU3VwYWJhc2UuZXEpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdzdGF0dXMnLCAnYXR0ZW5kaW5nJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGZpbHRlciBieSBndWVzdCBJRCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnNlbGVjdC5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5lcS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5yYW5nZS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5vcmRlci5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IFttb2NrUlNWUERhdGFbMF1dLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgY291bnQ6IDEsXG4gICAgICB9KTtcblxuICAgICAgLy8gTW9jayBnZXRSU1ZQU3RhdGlzdGljc1xuICAgICAgamVzdC5zcHlPbihyc3ZwTWFuYWdlbWVudFNlcnZpY2UsICdnZXRSU1ZQU3RhdGlzdGljcycpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHRvdGFsUlNWUHM6IDEsXG4gICAgICAgICAgYnlTdGF0dXM6IHsgYXR0ZW5kaW5nOiAxLCBkZWNsaW5lZDogMCwgbWF5YmU6IDAsIHBlbmRpbmc6IDAgfSxcbiAgICAgICAgICB0b3RhbEd1ZXN0Q291bnQ6IDIsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmxpc3RSU1ZQcyhcbiAgICAgICAgeyBndWVzdElkOiAnZ3Vlc3QtMScgfSxcbiAgICAgICAgeyBwYWdlOiAxLCBsaW1pdDogNTAgfVxuICAgICAgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5kYXRhKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5kYXRhWzBdLmd1ZXN0SWQpLnRvQmUoJ2d1ZXN0LTEnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGVxIHdhcyBjYWxsZWQgd2l0aCBndWVzdF9pZFxuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZS5lcSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2d1ZXN0X2lkJywgJ2d1ZXN0LTEnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYXBwbHkgcGFnaW5hdGlvbiBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5zZWxlY3QubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2UucmFuZ2UubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uub3JkZXIubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBtb2NrUlNWUERhdGEsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICBjb3VudDogMTAwLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIE1vY2sgZ2V0UlNWUFN0YXRpc3RpY3NcbiAgICAgIGplc3Quc3B5T24ocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLCAnZ2V0UlNWUFN0YXRpc3RpY3MnKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB0b3RhbFJTVlBzOiAxMDAsXG4gICAgICAgICAgYnlTdGF0dXM6IHsgYXR0ZW5kaW5nOiA1MCwgZGVjbGluZWQ6IDI1LCBtYXliZTogMTUsIHBlbmRpbmc6IDEwIH0sXG4gICAgICAgICAgdG90YWxHdWVzdENvdW50OiA1MCxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UubGlzdFJTVlBzKFxuICAgICAgICB7fSxcbiAgICAgICAgeyBwYWdlOiAyLCBsaW1pdDogMjUgfVxuICAgICAgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5wYWdpbmF0aW9uLnBhZ2UpLnRvQmUoMik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5wYWdpbmF0aW9uLmxpbWl0KS50b0JlKDI1KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnBhZ2luYXRpb24udG90YWwpLnRvQmUoMTAwKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnBhZ2luYXRpb24udG90YWxQYWdlcykudG9CZSg0KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IHJhbmdlIHdhcyBjYWxsZWQgd2l0aCBjb3JyZWN0IHZhbHVlcyAocGFnZSAyLCBsaW1pdCAyNSA9IGZyb20gMjUgdG8gNDkpXG4gICAgICBleHBlY3QobW9ja1N1cGFiYXNlLnJhbmdlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgyNSwgNDkpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gVkFMSURBVElPTl9FUlJPUiB3aGVuIGludmFsaWQgZmlsdGVyIHBhcmFtZXRlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UubGlzdFJTVlBzKFxuICAgICAgICB7IGV2ZW50SWQ6ICdpbnZhbGlkLXV1aWQnIH0gYXMgYW55LFxuICAgICAgICB7IHBhZ2U6IDEsIGxpbWl0OiA1MCB9XG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ1ZBTElEQVRJT05fRVJST1InKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIFZBTElEQVRJT05fRVJST1Igd2hlbiBpbnZhbGlkIHBhZ2luYXRpb24gcGFyYW1ldGVycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5saXN0UlNWUHMoXG4gICAgICAgIHt9LFxuICAgICAgICB7IHBhZ2U6IC0xLCBsaW1pdDogNTAgfSBhcyBhbnlcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnVkFMSURBVElPTl9FUlJPUicpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gREFUQUJBU0VfRVJST1Igd2hlbiBkYXRhYmFzZSBxdWVyeSBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnNlbGVjdC5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5yYW5nZS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5vcmRlci5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6ICdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcgfSxcbiAgICAgICAgY291bnQ6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmxpc3RSU1ZQcyh7fSwgeyBwYWdlOiAxLCBsaW1pdDogNTAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnREFUQUJBU0VfRVJST1InKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0JlKCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBhcHBseSBtdWx0aXBsZSBmaWx0ZXJzIHRvZ2V0aGVyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLmVxLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnJhbmdlLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLm9yZGVyLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogW21vY2tSU1ZQRGF0YVswXV0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICBjb3VudDogMSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrIGdldFJTVlBTdGF0aXN0aWNzXG4gICAgICBqZXN0LnNweU9uKHJzdnBNYW5hZ2VtZW50U2VydmljZSwgJ2dldFJTVlBTdGF0aXN0aWNzJykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdG90YWxSU1ZQczogMSxcbiAgICAgICAgICBieVN0YXR1czogeyBhdHRlbmRpbmc6IDEsIGRlY2xpbmVkOiAwLCBtYXliZTogMCwgcGVuZGluZzogMCB9LFxuICAgICAgICAgIHRvdGFsR3Vlc3RDb3VudDogMixcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UubGlzdFJTVlBzKFxuICAgICAgICB7IGV2ZW50SWQ6ICdldmVudC0xJywgc3RhdHVzOiAnYXR0ZW5kaW5nJywgZ3Vlc3RJZDogJ2d1ZXN0LTEnIH0sXG4gICAgICAgIHsgcGFnZTogMSwgbGltaXQ6IDUwIH1cbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGFsbCBmaWx0ZXJzIHdlcmUgYXBwbGllZFxuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZS5lcSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2V2ZW50X2lkJywgJ2V2ZW50LTEnKTtcbiAgICAgIGV4cGVjdChtb2NrU3VwYWJhc2UuZXEpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdzdGF0dXMnLCAnYXR0ZW5kaW5nJyk7XG4gICAgICBleHBlY3QobW9ja1N1cGFiYXNlLmVxKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnZ3Vlc3RfaWQnLCAnZ3Vlc3QtMScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc2VhcmNoIHF1ZXJ5IGZpbHRlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnNlbGVjdC5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5vci5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5yYW5nZS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5vcmRlci5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IFttb2NrUlNWUERhdGFbMF1dLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgY291bnQ6IDEsXG4gICAgICB9KTtcblxuICAgICAgLy8gTW9jayBnZXRSU1ZQU3RhdGlzdGljc1xuICAgICAgamVzdC5zcHlPbihyc3ZwTWFuYWdlbWVudFNlcnZpY2UsICdnZXRSU1ZQU3RhdGlzdGljcycpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHRvdGFsUlNWUHM6IDEsXG4gICAgICAgICAgYnlTdGF0dXM6IHsgYXR0ZW5kaW5nOiAxLCBkZWNsaW5lZDogMCwgbWF5YmU6IDAsIHBlbmRpbmc6IDAgfSxcbiAgICAgICAgICB0b3RhbEd1ZXN0Q291bnQ6IDIsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmxpc3RSU1ZQcyhcbiAgICAgICAgeyBzZWFyY2hRdWVyeTogJ0pvaG4nIH0sXG4gICAgICAgIHsgcGFnZTogMSwgbGltaXQ6IDUwIH1cbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IG9yIHdhcyBjYWxsZWQgZm9yIHNlYXJjaFxuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZS5vcikudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBkZWZhdWx0IHRvIHBhZ2UgMSBhbmQgbGltaXQgNTAgd2hlbiBub3Qgc3BlY2lmaWVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnJhbmdlLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLm9yZGVyLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbW9ja1JTVlBEYXRhLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgY291bnQ6IDIsXG4gICAgICB9KTtcblxuICAgICAgLy8gTW9jayBnZXRSU1ZQU3RhdGlzdGljc1xuICAgICAgamVzdC5zcHlPbihyc3ZwTWFuYWdlbWVudFNlcnZpY2UsICdnZXRSU1ZQU3RhdGlzdGljcycpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHRvdGFsUlNWUHM6IDIsXG4gICAgICAgICAgYnlTdGF0dXM6IHsgYXR0ZW5kaW5nOiAxLCBkZWNsaW5lZDogMCwgbWF5YmU6IDAsIHBlbmRpbmc6IDEgfSxcbiAgICAgICAgICB0b3RhbEd1ZXN0Q291bnQ6IDIsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmxpc3RSU1ZQcygpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnBhZ2luYXRpb24ucGFnZSkudG9CZSgxKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnBhZ2luYXRpb24ubGltaXQpLnRvQmUoNTApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBWZXJpZnkgcmFuZ2Ugd2FzIGNhbGxlZCB3aXRoIGRlZmF1bHQgdmFsdWVzIChwYWdlIDEsIGxpbWl0IDUwID0gZnJvbSAwIHRvIDQ5KVxuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZS5yYW5nZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoMCwgNDkpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0UlNWUFN0YXRpc3RpY3MnLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1N0YXRpc3RpY3NEYXRhID0gW1xuICAgICAgeyBzdGF0dXM6ICdhdHRlbmRpbmcnLCBndWVzdF9jb3VudDogMiB9LFxuICAgICAgeyBzdGF0dXM6ICdhdHRlbmRpbmcnLCBndWVzdF9jb3VudDogMSB9LFxuICAgICAgeyBzdGF0dXM6ICdkZWNsaW5lZCcsIGd1ZXN0X2NvdW50OiAxIH0sXG4gICAgICB7IHN0YXR1czogJ21heWJlJywgZ3Vlc3RfY291bnQ6IG51bGwgfSxcbiAgICAgIHsgc3RhdHVzOiAncGVuZGluZycsIGd1ZXN0X2NvdW50OiAxIH0sXG4gICAgXTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3Mgd2l0aCBhY2N1cmF0ZSBzdGF0aXN0aWNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbW9ja1N0YXRpc3RpY3NEYXRhLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UuZ2V0UlNWUFN0YXRpc3RpY3Moe30pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnRvdGFsUlNWUHMpLnRvQmUoNSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5ieVN0YXR1cy5hdHRlbmRpbmcpLnRvQmUoMik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5ieVN0YXR1cy5kZWNsaW5lZCkudG9CZSgxKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmJ5U3RhdHVzLm1heWJlKS50b0JlKDEpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuYnlTdGF0dXMucGVuZGluZykudG9CZSgxKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnRvdGFsR3Vlc3RDb3VudCkudG9CZSgzKTsgLy8gMiArIDEgZnJvbSBhdHRlbmRpbmdcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZmlsdGVyIHN0YXRpc3RpY3MgYnkgZXZlbnQgSUQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5zZWxlY3QubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2UuZXEubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBbbW9ja1N0YXRpc3RpY3NEYXRhWzBdLCBtb2NrU3RhdGlzdGljc0RhdGFbMV1dLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UuZ2V0UlNWUFN0YXRpc3RpY3Moe1xuICAgICAgICBldmVudElkOiAnZXZlbnQtMScsXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS50b3RhbFJTVlBzKS50b0JlKDIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuYnlTdGF0dXMuYXR0ZW5kaW5nKS50b0JlKDIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBWZXJpZnkgZXEgd2FzIGNhbGxlZCB3aXRoIGV2ZW50X2lkXG4gICAgICBleHBlY3QobW9ja1N1cGFiYXNlLmVxKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnZXZlbnRfaWQnLCAnZXZlbnQtMScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgcmVzdWx0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnNlbGVjdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UuZ2V0UlNWUFN0YXRpc3RpY3Moe30pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnRvdGFsUlNWUHMpLnRvQmUoMCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5ieVN0YXR1cy5hdHRlbmRpbmcpLnRvQmUoMCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS50b3RhbEd1ZXN0Q291bnQpLnRvQmUoMCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBWQUxJREFUSU9OX0VSUk9SIHdoZW4gaW52YWxpZCBmaWx0ZXIgcGFyYW1ldGVycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5nZXRSU1ZQU3RhdGlzdGljcyh7XG4gICAgICAgIGV2ZW50SWQ6ICdpbnZhbGlkLXV1aWQnLFxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ1ZBTElEQVRJT05fRVJST1InKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIERBVEFCQVNFX0VSUk9SIHdoZW4gZGF0YWJhc2UgcXVlcnkgZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5zZWxlY3QubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmdldFJTVlBTdGF0aXN0aWNzKHt9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdEQVRBQkFTRV9FUlJPUicpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQmUoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGZpbHRlciBzdGF0aXN0aWNzIGJ5IG11bHRpcGxlIGNyaXRlcmlhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLmVxLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogW21vY2tTdGF0aXN0aWNzRGF0YVswXV0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5nZXRSU1ZQU3RhdGlzdGljcyh7XG4gICAgICAgIGV2ZW50SWQ6ICdldmVudC0xJyxcbiAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBib3RoIGZpbHRlcnMgd2VyZSBhcHBsaWVkXG4gICAgICBleHBlY3QobW9ja1N1cGFiYXNlLmVxKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnZXZlbnRfaWQnLCAnZXZlbnQtMScpO1xuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZS5lcSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3N0YXR1cycsICdhdHRlbmRpbmcnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGVmYXVsdCBndWVzdF9jb3VudCB0byAxIHdoZW4gbnVsbCBmb3IgYXR0ZW5kaW5nIFJTVlBzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogW1xuICAgICAgICAgIHsgc3RhdHVzOiAnYXR0ZW5kaW5nJywgZ3Vlc3RfY291bnQ6IG51bGwgfSxcbiAgICAgICAgICB7IHN0YXR1czogJ2F0dGVuZGluZycsIGd1ZXN0X2NvdW50OiAyIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5nZXRSU1ZQU3RhdGlzdGljcyh7fSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudG90YWxHdWVzdENvdW50KS50b0JlKDMpOyAvLyAxIChkZWZhdWx0KSArIDJcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2J1bGtVcGRhdGVSU1ZQcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIHdpdGggdXBkYXRlZCBjb3VudCB3aGVuIHZhbGlkIGlucHV0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcnN2cElkcyA9IFsncnN2cC0xJywgJ3JzdnAtMicsICdyc3ZwLTMnXTtcbiAgICAgIFxuICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2UudXBkYXRlLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLmluLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnNlbGVjdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IFt7IGlkOiAncnN2cC0xJyB9LCB7IGlkOiAncnN2cC0yJyB9LCB7IGlkOiAncnN2cC0zJyB9XSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmJ1bGtVcGRhdGVSU1ZQcyhcbiAgICAgICAgcnN2cElkcyxcbiAgICAgICAgJ2F0dGVuZGluZycsXG4gICAgICAgICdCdWxrIGFwcHJvdmVkJ1xuICAgICAgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS51cGRhdGVkQ291bnQpLnRvQmUoMyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSB1cGRhdGUgd2FzIGNhbGxlZCB3aXRoIGNvcnJlY3QgZGF0YVxuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZS51cGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyxcbiAgICAgICAgICBub3RlczogJ0J1bGsgYXBwcm92ZWQnLFxuICAgICAgICAgIHJlc3BvbmRlZF9hdDogZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBpbiB3YXMgY2FsbGVkIHdpdGggY29ycmVjdCBJRHNcbiAgICAgIGV4cGVjdChtb2NrU3VwYWJhc2UuaW4pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdpZCcsIHJzdnBJZHMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB1cGRhdGUgc3RhdHVzIGFuZCBzZXQgcmVzcG9uZGVkX2F0IGZvciBub24tcGVuZGluZyBzdGF0dXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS51cGRhdGUubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2UuaW4ubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogW3sgaWQ6ICdyc3ZwLTEnIH1dLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UuYnVsa1VwZGF0ZVJTVlBzKFsncnN2cC0xJ10sICdhdHRlbmRpbmcnKTtcblxuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZS51cGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyxcbiAgICAgICAgICByZXNwb25kZWRfYXQ6IGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGluY2x1ZGUgbm90ZXMgd2hlbiBwcm92aWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnVwZGF0ZS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5pbi5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5zZWxlY3QubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBbeyBpZDogJ3JzdnAtMScgfV0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5idWxrVXBkYXRlUlNWUHMoXG4gICAgICAgIFsncnN2cC0xJ10sXG4gICAgICAgICdhdHRlbmRpbmcnLFxuICAgICAgICAnQWRtaW4gYXBwcm92ZWQnXG4gICAgICApO1xuXG4gICAgICBleHBlY3QobW9ja1N1cGFiYXNlLnVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBub3RlczogJ0FkbWluIGFwcHJvdmVkJyxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBwYXJ0aWFsIHVwZGF0ZXMgd2hlbiBzb21lIFJTVlBzIG5vdCBmb3VuZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnVwZGF0ZS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5pbi5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5zZWxlY3QubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBbeyBpZDogJ3JzdnAtMScgfSwgeyBpZDogJ3JzdnAtMicgfV0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5idWxrVXBkYXRlUlNWUHMoXG4gICAgICAgIFsncnN2cC0xJywgJ3JzdnAtMicsICdyc3ZwLTMnXSxcbiAgICAgICAgJ2F0dGVuZGluZydcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudXBkYXRlZENvdW50KS50b0JlKDIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gVkFMSURBVElPTl9FUlJPUiB3aGVuIGVtcHR5IHJzdnBJZHMgYXJyYXknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UuYnVsa1VwZGF0ZVJTVlBzKFxuICAgICAgICBbXSxcbiAgICAgICAgJ2F0dGVuZGluZydcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnVkFMSURBVElPTl9FUlJPUicpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gVkFMSURBVElPTl9FUlJPUiB3aGVuIHRvbyBtYW55IHJzdnBJZHMgKD4xMDApJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdG9vTWFueUlkcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMSB9LCAoXywgaSkgPT4gYHJzdnAtJHtpfWApO1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UuYnVsa1VwZGF0ZVJTVlBzKFxuICAgICAgICB0b29NYW55SWRzLFxuICAgICAgICAnYXR0ZW5kaW5nJ1xuICAgICAgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdWQUxJREFUSU9OX0VSUk9SJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBWQUxJREFUSU9OX0VSUk9SIHdoZW4gaW52YWxpZCBzdGF0dXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UuYnVsa1VwZGF0ZVJTVlBzKFxuICAgICAgICBbJ3JzdnAtMSddLFxuICAgICAgICAnaW52YWxpZC1zdGF0dXMnIGFzIGFueVxuICAgICAgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdWQUxJREFUSU9OX0VSUk9SJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBEQVRBQkFTRV9FUlJPUiB3aGVuIGRhdGFiYXNlIHVwZGF0ZSBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnVwZGF0ZS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5pbi5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5zZWxlY3QubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmJ1bGtVcGRhdGVSU1ZQcyhcbiAgICAgICAgWydyc3ZwLTEnXSxcbiAgICAgICAgJ2F0dGVuZGluZydcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnREFUQUJBU0VfRVJST1InKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0JlKCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBub3Qgc2V0IHJlc3BvbmRlZF9hdCB3aGVuIHN0YXR1cyBpcyBwZW5kaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2UudXBkYXRlLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLmluLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnNlbGVjdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IFt7IGlkOiAncnN2cC0xJyB9XSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmJ1bGtVcGRhdGVSU1ZQcyhbJ3JzdnAtMSddLCAncGVuZGluZycpO1xuXG4gICAgICBleHBlY3QobW9ja1N1cGFiYXNlLnVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSByZXNwb25kZWRfYXQgaXMgTk9UIGluIHRoZSB1cGRhdGUgZGF0YVxuICAgICAgY29uc3QgdXBkYXRlQ2FsbCA9IG1vY2tTdXBhYmFzZS51cGRhdGUubW9jay5jYWxsc1swXVswXTtcbiAgICAgIGV4cGVjdCh1cGRhdGVDYWxsLnJlc3BvbmRlZF9hdCkudG9CZVVuZGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYWxsIHZhbGlkIHN0YXR1cyB2YWx1ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzdGF0dXNlczogQXJyYXk8J3BlbmRpbmcnIHwgJ2F0dGVuZGluZycgfCAnZGVjbGluZWQnIHwgJ21heWJlJz4gPSBbXG4gICAgICAgICdwZW5kaW5nJyxcbiAgICAgICAgJ2F0dGVuZGluZycsXG4gICAgICAgICdkZWNsaW5lZCcsXG4gICAgICAgICdtYXliZScsXG4gICAgICBdO1xuXG4gICAgICBmb3IgKGNvbnN0IHN0YXR1cyBvZiBzdGF0dXNlcykge1xuICAgICAgICAvLyBSZXNldCBtb2NrcyBmb3IgZWFjaCBpdGVyYXRpb25cbiAgICAgICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgICAgIHJlc2V0TW9ja1N1cGFiYXNlQ2xpZW50KG1vY2tTdXBhYmFzZSk7XG4gICAgICAgIFxuICAgICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgICAgbW9ja1N1cGFiYXNlLnVwZGF0ZS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgICAgbW9ja1N1cGFiYXNlLmluLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICBkYXRhOiBbeyBpZDogJ3JzdnAtMScgfV0sXG4gICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5idWxrVXBkYXRlUlNWUHMoWydyc3ZwLTEnXSwgc3RhdHVzKTtcblxuICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS51cGRhdGVkQ291bnQpLnRvQmUoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZS51cGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZXhwb3J0UlNWUHNUb0NTVicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIHdpdGggQ1NWIHN0cmluZyB3aGVuIHZhbGlkIGZpbHRlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUlNWUHMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3JzdnAtMScsXG4gICAgICAgICAgZ3Vlc3RGaXJzdE5hbWU6ICdKb2huJyxcbiAgICAgICAgICBndWVzdExhc3ROYW1lOiAnRG9lJyxcbiAgICAgICAgICBndWVzdEVtYWlsOiAnam9obkBleGFtcGxlLmNvbScsXG4gICAgICAgICAgZXZlbnROYW1lOiAnV2VkZGluZyBDZXJlbW9ueScsXG4gICAgICAgICAgYWN0aXZpdHlOYW1lOiBudWxsLFxuICAgICAgICAgIHN0YXR1czogJ2F0dGVuZGluZycgYXMgY29uc3QsXG4gICAgICAgICAgZ3Vlc3RDb3VudDogMixcbiAgICAgICAgICBkaWV0YXJ5Tm90ZXM6ICdWZWdldGFyaWFuJyxcbiAgICAgICAgICBzcGVjaWFsUmVxdWlyZW1lbnRzOiBudWxsLFxuICAgICAgICAgIG5vdGVzOiBudWxsLFxuICAgICAgICAgIHJlc3BvbmRlZEF0OiAnMjAyNC0wMS0xNVQxMDowMDowMFonLFxuICAgICAgICAgIGNyZWF0ZWRBdDogJzIwMjQtMDEtMTBUMTA6MDA6MDBaJyxcbiAgICAgICAgICB1cGRhdGVkQXQ6ICcyMDI0LTAxLTE1VDEwOjAwOjAwWicsXG4gICAgICAgICAgZ3Vlc3RJZDogJ2d1ZXN0LTEnLFxuICAgICAgICAgIGV2ZW50SWQ6ICdldmVudC0xJyxcbiAgICAgICAgICBhY3Rpdml0eUlkOiBudWxsLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgLy8gTW9jayBsaXN0UlNWUHMgdG8gcmV0dXJuIHRlc3QgZGF0YVxuICAgICAgamVzdC5zcHlPbihyc3ZwTWFuYWdlbWVudFNlcnZpY2UsICdsaXN0UlNWUHMnKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBkYXRhOiBtb2NrUlNWUHMsXG4gICAgICAgICAgcGFnaW5hdGlvbjogeyBwYWdlOiAxLCBsaW1pdDogMTAwMDAsIHRvdGFsOiAxLCB0b3RhbFBhZ2VzOiAxIH0sXG4gICAgICAgICAgc3RhdGlzdGljczoge1xuICAgICAgICAgICAgdG90YWxSU1ZQczogMSxcbiAgICAgICAgICAgIGJ5U3RhdHVzOiB7IGF0dGVuZGluZzogMSwgZGVjbGluZWQ6IDAsIG1heWJlOiAwLCBwZW5kaW5nOiAwIH0sXG4gICAgICAgICAgICB0b3RhbEd1ZXN0Q291bnQ6IDIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UuZXhwb3J0UlNWUHNUb0NTVih7fSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEpLnRvQ29udGFpbignUlNWUCBJRCxHdWVzdCBGaXJzdCBOYW1lLEd1ZXN0IExhc3QgTmFtZScpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEpLnRvQ29udGFpbigncnN2cC0xLEpvaG4sRG9lJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YSkudG9Db250YWluKCdXZWRkaW5nIENlcmVtb255Jyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YSkudG9Db250YWluKCdhdHRlbmRpbmcnKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhKS50b0NvbnRhaW4oJ1ZlZ2V0YXJpYW4nKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGxpc3RSU1ZQcyB3YXMgY2FsbGVkIHdpdGggY29ycmVjdCBwYXJhbWV0ZXJzXG4gICAgICBleHBlY3QocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmxpc3RSU1ZQcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoe30sIHsgcGFnZTogMSwgbGltaXQ6IDEwMDAwIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBlc2NhcGUgQ1NWIHZhbHVlcyB3aXRoIGNvbW1hcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tSU1ZQcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAncnN2cC0xJyxcbiAgICAgICAgICBndWVzdEZpcnN0TmFtZTogJ0pvaG4nLFxuICAgICAgICAgIGd1ZXN0TGFzdE5hbWU6ICdEb2UsIEpyLicsXG4gICAgICAgICAgZ3Vlc3RFbWFpbDogJ2pvaG5AZXhhbXBsZS5jb20nLFxuICAgICAgICAgIGV2ZW50TmFtZTogJ1dlZGRpbmcgQ2VyZW1vbnknLFxuICAgICAgICAgIGFjdGl2aXR5TmFtZTogbnVsbCxcbiAgICAgICAgICBzdGF0dXM6ICdhdHRlbmRpbmcnIGFzIGNvbnN0LFxuICAgICAgICAgIGd1ZXN0Q291bnQ6IDEsXG4gICAgICAgICAgZGlldGFyeU5vdGVzOiAnTm8gbnV0cywgbm8gZGFpcnknLFxuICAgICAgICAgIHNwZWNpYWxSZXF1aXJlbWVudHM6IG51bGwsXG4gICAgICAgICAgbm90ZXM6IG51bGwsXG4gICAgICAgICAgcmVzcG9uZGVkQXQ6ICcyMDI0LTAxLTE1VDEwOjAwOjAwWicsXG4gICAgICAgICAgY3JlYXRlZEF0OiAnMjAyNC0wMS0xMFQxMDowMDowMFonLFxuICAgICAgICAgIHVwZGF0ZWRBdDogJzIwMjQtMDEtMTVUMTA6MDA6MDBaJyxcbiAgICAgICAgICBndWVzdElkOiAnZ3Vlc3QtMScsXG4gICAgICAgICAgZXZlbnRJZDogJ2V2ZW50LTEnLFxuICAgICAgICAgIGFjdGl2aXR5SWQ6IG51bGwsXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICBqZXN0LnNweU9uKHJzdnBNYW5hZ2VtZW50U2VydmljZSwgJ2xpc3RSU1ZQcycpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGRhdGE6IG1vY2tSU1ZQcyxcbiAgICAgICAgICBwYWdpbmF0aW9uOiB7IHBhZ2U6IDEsIGxpbWl0OiAxMDAwMCwgdG90YWw6IDEsIHRvdGFsUGFnZXM6IDEgfSxcbiAgICAgICAgICBzdGF0aXN0aWNzOiB7XG4gICAgICAgICAgICB0b3RhbFJTVlBzOiAxLFxuICAgICAgICAgICAgYnlTdGF0dXM6IHsgYXR0ZW5kaW5nOiAxLCBkZWNsaW5lZDogMCwgbWF5YmU6IDAsIHBlbmRpbmc6IDAgfSxcbiAgICAgICAgICAgIHRvdGFsR3Vlc3RDb3VudDogMSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5leHBvcnRSU1ZQc1RvQ1NWKHt9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YSkudG9Db250YWluKCdcIkRvZSwgSnIuXCInKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhKS50b0NvbnRhaW4oJ1wiTm8gbnV0cywgbm8gZGFpcnlcIicpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBlc2NhcGUgQ1NWIHZhbHVlcyB3aXRoIHF1b3RlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tSU1ZQcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAncnN2cC0xJyxcbiAgICAgICAgICBndWVzdEZpcnN0TmFtZTogJ0pvaG4nLFxuICAgICAgICAgIGd1ZXN0TGFzdE5hbWU6ICdEb2UnLFxuICAgICAgICAgIGd1ZXN0RW1haWw6ICdqb2huQGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBldmVudE5hbWU6ICdXZWRkaW5nIENlcmVtb255JyxcbiAgICAgICAgICBhY3Rpdml0eU5hbWU6IG51bGwsXG4gICAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyBhcyBjb25zdCxcbiAgICAgICAgICBndWVzdENvdW50OiAxLFxuICAgICAgICAgIGRpZXRhcnlOb3RlczogbnVsbCxcbiAgICAgICAgICBzcGVjaWFsUmVxdWlyZW1lbnRzOiBudWxsLFxuICAgICAgICAgIG5vdGVzOiAnR3Vlc3Qgc2FpZCBcImV4Y2l0ZWQgdG8gYXR0ZW5kXCInLFxuICAgICAgICAgIHJlc3BvbmRlZEF0OiAnMjAyNC0wMS0xNVQxMDowMDowMFonLFxuICAgICAgICAgIGNyZWF0ZWRBdDogJzIwMjQtMDEtMTBUMTA6MDA6MDBaJyxcbiAgICAgICAgICB1cGRhdGVkQXQ6ICcyMDI0LTAxLTE1VDEwOjAwOjAwWicsXG4gICAgICAgICAgZ3Vlc3RJZDogJ2d1ZXN0LTEnLFxuICAgICAgICAgIGV2ZW50SWQ6ICdldmVudC0xJyxcbiAgICAgICAgICBhY3Rpdml0eUlkOiBudWxsLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgamVzdC5zcHlPbihyc3ZwTWFuYWdlbWVudFNlcnZpY2UsICdsaXN0UlNWUHMnKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBkYXRhOiBtb2NrUlNWUHMsXG4gICAgICAgICAgcGFnaW5hdGlvbjogeyBwYWdlOiAxLCBsaW1pdDogMTAwMDAsIHRvdGFsOiAxLCB0b3RhbFBhZ2VzOiAxIH0sXG4gICAgICAgICAgc3RhdGlzdGljczoge1xuICAgICAgICAgICAgdG90YWxSU1ZQczogMSxcbiAgICAgICAgICAgIGJ5U3RhdHVzOiB7IGF0dGVuZGluZzogMSwgZGVjbGluZWQ6IDAsIG1heWJlOiAwLCBwZW5kaW5nOiAwIH0sXG4gICAgICAgICAgICB0b3RhbEd1ZXN0Q291bnQ6IDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UuZXhwb3J0UlNWUHNUb0NTVih7fSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEpLnRvQ29udGFpbignXCJcImV4Y2l0ZWQgdG8gYXR0ZW5kXCJcIicpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgcmVzdWx0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGplc3Quc3B5T24ocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLCAnbGlzdFJTVlBzJykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgcGFnaW5hdGlvbjogeyBwYWdlOiAxLCBsaW1pdDogMTAwMDAsIHRvdGFsOiAwLCB0b3RhbFBhZ2VzOiAwIH0sXG4gICAgICAgICAgc3RhdGlzdGljczoge1xuICAgICAgICAgICAgdG90YWxSU1ZQczogMCxcbiAgICAgICAgICAgIGJ5U3RhdHVzOiB7IGF0dGVuZGluZzogMCwgZGVjbGluZWQ6IDAsIG1heWJlOiAwLCBwZW5kaW5nOiAwIH0sXG4gICAgICAgICAgICB0b3RhbEd1ZXN0Q291bnQ6IDAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UuZXhwb3J0UlNWUHNUb0NTVih7fSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAvLyBTaG91bGQgb25seSBoYXZlIGhlYWRlciByb3dcbiAgICAgICAgY29uc3QgbGluZXMgPSByZXN1bHQuZGF0YS5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGV4cGVjdChsaW5lcy5sZW5ndGgpLnRvQmUoMSk7XG4gICAgICAgIGV4cGVjdChsaW5lc1swXSkudG9Db250YWluKCdSU1ZQIElELEd1ZXN0IEZpcnN0IE5hbWUnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIFZBTElEQVRJT05fRVJST1Igd2hlbiBpbnZhbGlkIGZpbHRlciBwYXJhbWV0ZXJzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmV4cG9ydFJTVlBzVG9DU1Yoe1xuICAgICAgICBldmVudElkOiAnaW52YWxpZC11dWlkJyxcbiAgICAgIH0gYXMgYW55KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdWQUxJREFUSU9OX0VSUk9SJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHByb3BhZ2F0ZSBlcnJvcnMgZnJvbSBsaXN0UlNWUHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBqZXN0LnNweU9uKHJzdnBNYW5hZ2VtZW50U2VydmljZSwgJ2xpc3RSU1ZQcycpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgY29kZTogJ0RBVEFCQVNFX0VSUk9SJyxcbiAgICAgICAgICBtZXNzYWdlOiAnRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5leHBvcnRSU1ZQc1RvQ1NWKHt9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdEQVRBQkFTRV9FUlJPUicpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQmUoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGFwcGx5IGZpbHRlcnMgd2hlbiBleHBvcnRpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBqZXN0LnNweU9uKHJzdnBNYW5hZ2VtZW50U2VydmljZSwgJ2xpc3RSU1ZQcycpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgIHBhZ2luYXRpb246IHsgcGFnZTogMSwgbGltaXQ6IDEwMDAwLCB0b3RhbDogMCwgdG90YWxQYWdlczogMCB9LFxuICAgICAgICAgIHN0YXRpc3RpY3M6IHtcbiAgICAgICAgICAgIHRvdGFsUlNWUHM6IDAsXG4gICAgICAgICAgICBieVN0YXR1czogeyBhdHRlbmRpbmc6IDAsIGRlY2xpbmVkOiAwLCBtYXliZTogMCwgcGVuZGluZzogMCB9LFxuICAgICAgICAgICAgdG90YWxHdWVzdENvdW50OiAwLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZmlsdGVyczogUlNWUEZpbHRlcnMgPSB7IGV2ZW50SWQ6ICdldmVudC0xJywgc3RhdHVzOiAnYXR0ZW5kaW5nJyB9O1xuICAgICAgYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmV4cG9ydFJTVlBzVG9DU1YoZmlsdGVycyk7XG5cbiAgICAgIC8vIFZlcmlmeSBsaXN0UlNWUHMgd2FzIGNhbGxlZCB3aXRoIHRoZSBmaWx0ZXJzXG4gICAgICBleHBlY3QocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmxpc3RSU1ZQcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZmlsdGVycywgeyBwYWdlOiAxLCBsaW1pdDogMTAwMDAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBuZXdsaW5lcyBpbiBDU1YgdmFsdWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1JTVlBzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdyc3ZwLTEnLFxuICAgICAgICAgIGd1ZXN0Rmlyc3ROYW1lOiAnSm9obicsXG4gICAgICAgICAgZ3Vlc3RMYXN0TmFtZTogJ0RvZScsXG4gICAgICAgICAgZ3Vlc3RFbWFpbDogJ2pvaG5AZXhhbXBsZS5jb20nLFxuICAgICAgICAgIGV2ZW50TmFtZTogJ1dlZGRpbmcgQ2VyZW1vbnknLFxuICAgICAgICAgIGFjdGl2aXR5TmFtZTogbnVsbCxcbiAgICAgICAgICBzdGF0dXM6ICdhdHRlbmRpbmcnIGFzIGNvbnN0LFxuICAgICAgICAgIGd1ZXN0Q291bnQ6IDEsXG4gICAgICAgICAgZGlldGFyeU5vdGVzOiBudWxsLFxuICAgICAgICAgIHNwZWNpYWxSZXF1aXJlbWVudHM6IG51bGwsXG4gICAgICAgICAgbm90ZXM6ICdMaW5lIDFcXG5MaW5lIDInLFxuICAgICAgICAgIHJlc3BvbmRlZEF0OiAnMjAyNC0wMS0xNVQxMDowMDowMFonLFxuICAgICAgICAgIGNyZWF0ZWRBdDogJzIwMjQtMDEtMTBUMTA6MDA6MDBaJyxcbiAgICAgICAgICB1cGRhdGVkQXQ6ICcyMDI0LTAxLTE1VDEwOjAwOjAwWicsXG4gICAgICAgICAgZ3Vlc3RJZDogJ2d1ZXN0LTEnLFxuICAgICAgICAgIGV2ZW50SWQ6ICdldmVudC0xJyxcbiAgICAgICAgICBhY3Rpdml0eUlkOiBudWxsLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgamVzdC5zcHlPbihyc3ZwTWFuYWdlbWVudFNlcnZpY2UsICdsaXN0UlNWUHMnKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBkYXRhOiBtb2NrUlNWUHMsXG4gICAgICAgICAgcGFnaW5hdGlvbjogeyBwYWdlOiAxLCBsaW1pdDogMTAwMDAsIHRvdGFsOiAxLCB0b3RhbFBhZ2VzOiAxIH0sXG4gICAgICAgICAgc3RhdGlzdGljczoge1xuICAgICAgICAgICAgdG90YWxSU1ZQczogMSxcbiAgICAgICAgICAgIGJ5U3RhdHVzOiB7IGF0dGVuZGluZzogMSwgZGVjbGluZWQ6IDAsIG1heWJlOiAwLCBwZW5kaW5nOiAwIH0sXG4gICAgICAgICAgICB0b3RhbEd1ZXN0Q291bnQ6IDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UuZXhwb3J0UlNWUHNUb0NTVih7fSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAvLyBOZXdsaW5lcyBzaG91bGQgYmUgd3JhcHBlZCBpbiBxdW90ZXNcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhKS50b0NvbnRhaW4oJ1wiTGluZSAxXFxuTGluZSAyXCInKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG51bGwgdmFsdWVzIGluIENTVicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tSU1ZQcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAncnN2cC0xJyxcbiAgICAgICAgICBndWVzdEZpcnN0TmFtZTogJ0pvaG4nLFxuICAgICAgICAgIGd1ZXN0TGFzdE5hbWU6ICdEb2UnLFxuICAgICAgICAgIGd1ZXN0RW1haWw6IG51bGwsXG4gICAgICAgICAgZXZlbnROYW1lOiBudWxsLFxuICAgICAgICAgIGFjdGl2aXR5TmFtZTogbnVsbCxcbiAgICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyBhcyBjb25zdCxcbiAgICAgICAgICBndWVzdENvdW50OiBudWxsLFxuICAgICAgICAgIGRpZXRhcnlOb3RlczogbnVsbCxcbiAgICAgICAgICBzcGVjaWFsUmVxdWlyZW1lbnRzOiBudWxsLFxuICAgICAgICAgIG5vdGVzOiBudWxsLFxuICAgICAgICAgIHJlc3BvbmRlZEF0OiBudWxsLFxuICAgICAgICAgIGNyZWF0ZWRBdDogJzIwMjQtMDEtMTBUMTA6MDA6MDBaJyxcbiAgICAgICAgICB1cGRhdGVkQXQ6ICcyMDI0LTAxLTEwVDEwOjAwOjAwWicsXG4gICAgICAgICAgZ3Vlc3RJZDogJ2d1ZXN0LTEnLFxuICAgICAgICAgIGV2ZW50SWQ6IG51bGwsXG4gICAgICAgICAgYWN0aXZpdHlJZDogbnVsbCxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIGplc3Quc3B5T24ocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLCAnbGlzdFJTVlBzJykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZGF0YTogbW9ja1JTVlBzLFxuICAgICAgICAgIHBhZ2luYXRpb246IHsgcGFnZTogMSwgbGltaXQ6IDEwMDAwLCB0b3RhbDogMSwgdG90YWxQYWdlczogMSB9LFxuICAgICAgICAgIHN0YXRpc3RpY3M6IHtcbiAgICAgICAgICAgIHRvdGFsUlNWUHM6IDEsXG4gICAgICAgICAgICBieVN0YXR1czogeyBhdHRlbmRpbmc6IDAsIGRlY2xpbmVkOiAwLCBtYXliZTogMCwgcGVuZGluZzogMSB9LFxuICAgICAgICAgICAgdG90YWxHdWVzdENvdW50OiAwLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmV4cG9ydFJTVlBzVG9DU1Yoe30pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgLy8gTnVsbCB2YWx1ZXMgc2hvdWxkIGJlIGVtcHR5IHN0cmluZ3NcbiAgICAgICAgY29uc3QgbGluZXMgPSByZXN1bHQuZGF0YS5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGV4cGVjdChsaW5lc1sxXSkudG9Db250YWluKCdyc3ZwLTEsSm9obixEb2UsLCwnKTtcbiAgICAgICAgLy8gR3Vlc3QgY291bnQgc2hvdWxkIGRlZmF1bHQgdG8gMVxuICAgICAgICBleHBlY3QobGluZXNbMV0pLnRvQ29udGFpbignLDEsJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJjcmVhdGVDbGllbnQiLCJmbiIsImRlc2NyaWJlIiwibW9ja1N1cGFiYXNlIiwiYmVmb3JlRWFjaCIsImNyZWF0ZU1vY2tTdXBhYmFzZUNsaWVudCIsInJlc2V0TW9ja1N1cGFiYXNlQ2xpZW50IiwicmVxdWlyZSIsIm1vY2tSZXR1cm5WYWx1ZSIsInJlc3RvcmVBbGxNb2NrcyIsIm1vY2tSU1ZQRGF0YSIsImlkIiwiZ3Vlc3RfaWQiLCJldmVudF9pZCIsImFjdGl2aXR5X2lkIiwic3RhdHVzIiwiZ3Vlc3RfY291bnQiLCJkaWV0YXJ5X25vdGVzIiwic3BlY2lhbF9yZXF1aXJlbWVudHMiLCJub3RlcyIsInJlc3BvbmRlZF9hdCIsImNyZWF0ZWRfYXQiLCJ1cGRhdGVkX2F0IiwiZ3Vlc3RzIiwiZmlyc3RfbmFtZSIsImxhc3RfbmFtZSIsImVtYWlsIiwiZXZlbnRzIiwibmFtZSIsImFjdGl2aXRpZXMiLCJpdCIsImZyb20iLCJzZWxlY3QiLCJlcSIsInJhbmdlIiwib3JkZXIiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsImRhdGEiLCJlcnJvciIsImNvdW50Iiwic3B5T24iLCJyc3ZwTWFuYWdlbWVudFNlcnZpY2UiLCJzdWNjZXNzIiwidG90YWxSU1ZQcyIsImJ5U3RhdHVzIiwiYXR0ZW5kaW5nIiwiZGVjbGluZWQiLCJtYXliZSIsInBlbmRpbmciLCJ0b3RhbEd1ZXN0Q291bnQiLCJmaWx0ZXJzIiwiZXZlbnRJZCIsInBhZ2luYXRpb24iLCJwYWdlIiwibGltaXQiLCJyZXN1bHQiLCJsaXN0UlNWUHMiLCJleHBlY3QiLCJ0b0JlIiwidG9IYXZlTGVuZ3RoIiwiZ3Vlc3RGaXJzdE5hbWUiLCJldmVudE5hbWUiLCJ0b3RhbCIsInRvdGFsUGFnZXMiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsImFjdGl2aXR5SWQiLCJndWVzdElkIiwiY29kZSIsIm1lc3NhZ2UiLCJvciIsInNlYXJjaFF1ZXJ5IiwidG9IYXZlQmVlbkNhbGxlZCIsIm1vY2tTdGF0aXN0aWNzRGF0YSIsImdldFJTVlBTdGF0aXN0aWNzIiwicnN2cElkcyIsInVwZGF0ZSIsImluIiwiYnVsa1VwZGF0ZVJTVlBzIiwidXBkYXRlZENvdW50Iiwib2JqZWN0Q29udGFpbmluZyIsImFueSIsIlN0cmluZyIsInRvb01hbnlJZHMiLCJBcnJheSIsImxlbmd0aCIsIl8iLCJpIiwidXBkYXRlQ2FsbCIsImNhbGxzIiwidG9CZVVuZGVmaW5lZCIsInN0YXR1c2VzIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tSU1ZQcyIsImd1ZXN0TGFzdE5hbWUiLCJndWVzdEVtYWlsIiwiYWN0aXZpdHlOYW1lIiwiZ3Vlc3RDb3VudCIsImRpZXRhcnlOb3RlcyIsInNwZWNpYWxSZXF1aXJlbWVudHMiLCJyZXNwb25kZWRBdCIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsInN0YXRpc3RpY3MiLCJleHBvcnRSU1ZQc1RvQ1NWIiwidG9Db250YWluIiwibGluZXMiLCJzcGxpdCJdLCJtYXBwaW5ncyI6IjtBQUlBLGdCQUFnQjtBQUNoQkEsS0FBS0MsSUFBSSxDQUFDLHlCQUF5QixJQUFPLENBQUE7UUFDeENDLGNBQWNGLEtBQUtHLEVBQUU7SUFDdkIsQ0FBQTs7Ozs4QkFQa0U7K0VBQzNCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFRdkNDLFNBQVMseUJBQXlCO0lBQ2hDLElBQUlDO0lBRUpDLFdBQVc7UUFDVEQsZUFBZUUsSUFBQUEsc0NBQXdCO1FBQ3ZDQyxJQUFBQSxxQ0FBdUIsRUFBQ0g7UUFDeEIsTUFBTSxFQUFFSCxZQUFZLEVBQUUsR0FBR08sUUFBUTtRQUNqQ1AsYUFBYVEsZUFBZSxDQUFDTDtRQUU3QixvQ0FBb0M7UUFDcENMLEtBQUtXLGVBQWU7SUFDdEI7SUFFQVAsU0FBUyxhQUFhO1FBQ3BCLE1BQU1RLGVBQWU7WUFDbkI7Z0JBQ0VDLElBQUk7Z0JBQ0pDLFVBQVU7Z0JBQ1ZDLFVBQVU7Z0JBQ1ZDLGFBQWE7Z0JBQ2JDLFFBQVE7Z0JBQ1JDLGFBQWE7Z0JBQ2JDLGVBQWU7Z0JBQ2ZDLHNCQUFzQjtnQkFDdEJDLE9BQU87Z0JBQ1BDLGNBQWM7Z0JBQ2RDLFlBQVk7Z0JBQ1pDLFlBQVk7Z0JBQ1pDLFFBQVE7b0JBQ05DLFlBQVk7b0JBQ1pDLFdBQVc7b0JBQ1hDLE9BQU87Z0JBQ1Q7Z0JBQ0FDLFFBQVE7b0JBQ05DLE1BQU07Z0JBQ1I7Z0JBQ0FDLFlBQVk7WUFDZDtZQUNBO2dCQUNFbEIsSUFBSTtnQkFDSkMsVUFBVTtnQkFDVkMsVUFBVTtnQkFDVkMsYUFBYTtnQkFDYkMsUUFBUTtnQkFDUkMsYUFBYTtnQkFDYkMsZUFBZTtnQkFDZkMsc0JBQXNCO2dCQUN0QkMsT0FBTztnQkFDUEMsY0FBYztnQkFDZEMsWUFBWTtnQkFDWkMsWUFBWTtnQkFDWkMsUUFB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