7092f9938fea69fa9f7f8ccbedf79dc7
/**
 * Property-based tests for auth method configuration
 * 
 * **Feature: admin-ux-enhancements, Property 4: Default Auth Method Inheritance**
 * **Validates: Requirements 4.3**
 * 
 * Property: For any newly created guest, the auth_method should automatically 
 * inherit the system's default_auth_method setting
 * 
 * **Feature: admin-ux-enhancements, Property 5: Bulk Auth Method Update**
 * **Validates: Requirements 4.4**
 * 
 * Property: For any bulk update operation on guest auth methods, all selected 
 * guests should have their auth_method updated to the specified value
 */ "use strict";
// Mock supabase
jest.mock('../lib/supabase', ()=>({
        supabase: {
            from: jest.fn(),
            auth: {
                getSession: jest.fn()
            }
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _settingsService = /*#__PURE__*/ _interop_require_wildcard(require("./settingsService"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('Auth Method Configuration - Property Tests', ()=>{
    let mockSupabase;
    beforeEach(()=>{
        jest.clearAllMocks();
        const { supabase } = require('../lib/supabase');
        mockSupabase = supabase;
    });
    describe('Property 4: Default Auth Method Inheritance', ()=>{
        /**
     * Property: New guests should inherit the system's default_auth_method
     * 
     * This test verifies that regardless of which auth method is set as default,
     * the system correctly retrieves and returns that value.
     */ it('should always return a valid auth method (email_matching or magic_link)', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.constantFrom('email_matching', 'magic_link'), async (authMethod)=>{
                // Mock database to return the auth method
                mockSupabase.from.mockReturnValue({
                    select: jest.fn().mockReturnValue({
                        eq: jest.fn().mockReturnValue({
                            single: jest.fn().mockResolvedValue({
                                data: {
                                    value: authMethod
                                },
                                error: null
                            })
                        })
                    })
                });
                const result = await _settingsService.getDefaultAuthMethod();
                // Property: Result should always be successful
                expect(result.success).toBe(true);
                if (result.success) {
                    // Property: Returned value should match the stored value
                    expect(result.data).toBe(authMethod);
                    // Property: Returned value should be one of the valid options
                    expect([
                        'email_matching',
                        'magic_link'
                    ]).toContain(result.data);
                }
            }), {
                numRuns: 100
            });
        });
        it('should return email_matching as default when setting does not exist', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.constant(null), async ()=>{
                // Mock database to return not found error
                mockSupabase.from.mockReturnValue({
                    select: jest.fn().mockReturnValue({
                        eq: jest.fn().mockReturnValue({
                            single: jest.fn().mockResolvedValue({
                                data: null,
                                error: {
                                    code: 'PGRST116',
                                    message: 'Not found'
                                }
                            })
                        })
                    })
                });
                const result = await _settingsService.getDefaultAuthMethod();
                // Property: Should always succeed with default value
                expect(result.success).toBe(true);
                if (result.success) {
                    // Property: Default should always be email_matching
                    expect(result.data).toBe('email_matching');
                }
            }), {
                numRuns: 50
            });
        });
    });
    describe('Property 5: Bulk Auth Method Update', ()=>{
        /**
     * Property: All selected guests should be updated atomically
     * 
     * This test verifies that when bulk updating guests, the operation
     * correctly updates the setting and reports the number of guests updated.
     */ it('should update all guests when bulk update is requested', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.constantFrom('email_matching', 'magic_link'), _fastcheck.integer({
                min: 0,
                max: 100
            }), async (authMethod, guestCount)=>{
                const mockFrom = jest.fn();
                mockSupabase.from = mockFrom;
                // First call: upsert setting (success)
                mockFrom.mockReturnValueOnce({
                    upsert: jest.fn().mockReturnValue({
                        select: jest.fn().mockReturnValue({
                            single: jest.fn().mockResolvedValue({
                                data: {
                                    key: 'default_auth_method',
                                    value: authMethod
                                },
                                error: null
                            })
                        })
                    })
                });
                // Second call: update guests
                const mockGuestData = Array.from({
                    length: guestCount
                }, (_, i)=>({
                        id: `guest-${i}`
                    }));
                mockFrom.mockReturnValueOnce({
                    update: jest.fn().mockReturnValue({
                        neq: jest.fn().mockReturnValue({
                            select: jest.fn().mockResolvedValue({
                                data: mockGuestData,
                                error: null
                            })
                        })
                    })
                });
                const result = await _settingsService.updateDefaultAuthMethod(authMethod, true);
                // Property: Update should always succeed
                expect(result.success).toBe(true);
                if (result.success) {
                    // Property: Updated count should match the number of guests
                    expect(result.data.updatedGuestsCount).toBe(guestCount);
                    // Property: Updated count should be non-negative
                    expect(result.data.updatedGuestsCount).toBeGreaterThanOrEqual(0);
                }
            }), {
                numRuns: 100
            });
        });
        it('should not update guests when bulk update is not requested', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.constantFrom('email_matching', 'magic_link'), async (authMethod)=>{
                // Mock upsert for setting only
                mockSupabase.from.mockReturnValue({
                    upsert: jest.fn().mockReturnValue({
                        select: jest.fn().mockReturnValue({
                            single: jest.fn().mockResolvedValue({
                                data: {
                                    key: 'default_auth_method',
                                    value: authMethod
                                },
                                error: null
                            })
                        })
                    })
                });
                const result = await _settingsService.updateDefaultAuthMethod(authMethod, false);
                // Property: Update should always succeed
                expect(result.success).toBe(true);
                if (result.success) {
                    // Property: No guests should be updated when bulk update is false
                    expect(result.data.updatedGuestsCount).toBe(0);
                }
            }), {
                numRuns: 100
            });
        });
        it('should maintain atomicity - either all guests updated or none', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.constantFrom('email_matching', 'magic_link'), _fastcheck.boolean(), async (authMethod, shouldFail)=>{
                const mockFrom = jest.fn();
                mockSupabase.from = mockFrom;
                // First call: upsert setting (always succeeds)
                mockFrom.mockReturnValueOnce({
                    upsert: jest.fn().mockReturnValue({
                        select: jest.fn().mockReturnValue({
                            single: jest.fn().mockResolvedValue({
                                data: {
                                    key: 'default_auth_method',
                                    value: authMethod
                                },
                                error: null
                            })
                        })
                    })
                });
                // Second call: update guests (may fail)
                if (shouldFail) {
                    mockFrom.mockReturnValueOnce({
                        update: jest.fn().mockReturnValue({
                            neq: jest.fn().mockReturnValue({
                                select: jest.fn().mockResolvedValue({
                                    data: null,
                                    error: {
                                        message: 'Database error'
                                    }
                                })
                            })
                        })
                    });
                } else {
                    mockFrom.mockReturnValueOnce({
                        update: jest.fn().mockReturnValue({
                            neq: jest.fn().mockReturnValue({
                                select: jest.fn().mockResolvedValue({
                                    data: [
                                        {
                                            id: '1'
                                        },
                                        {
                                            id: '2'
                                        }
                                    ],
                                    error: null
                                })
                            })
                        })
                    });
                }
                const result = await _settingsService.updateDefaultAuthMethod(authMethod, true);
                if (shouldFail) {
                    // Property: If guest update fails, entire operation should fail
                    expect(result.success).toBe(false);
                    if (!result.success) {
                        expect(result.error.code).toBe('DATABASE_ERROR');
                    }
                } else {
                    // Property: If guest update succeeds, operation should succeed
                    expect(result.success).toBe(true);
                    if (result.success) {
                        expect(result.data.updatedGuestsCount).toBeGreaterThanOrEqual(0);
                    }
                }
            }), {
                numRuns: 100
            });
        });
    });
    describe('Property: Auth Method Validation', ()=>{
        /**
     * Property: Invalid auth methods should always be rejected
     * 
     * This test verifies that the system properly validates auth method values
     * and rejects any invalid values.
     */ it('should reject invalid auth method values', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.string().filter((s)=>s !== 'email_matching' && s !== 'magic_link'), async (invalidMethod)=>{
                const result = await _settingsService.updateDefaultAuthMethod(invalidMethod, false);
                // Property: Invalid methods should always fail validation
                expect(result.success).toBe(false);
                if (!result.success) {
                    // Property: Error code should be VALIDATION_ERROR
                    expect(result.error.code).toBe('VALIDATION_ERROR');
                    // Property: Error message should mention invalid auth method
                    expect(result.error.message.toLowerCase()).toContain('invalid');
                }
            }), {
                numRuns: 100
            });
        });
        it('should only accept email_matching or magic_link as valid values', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.constantFrom('email_matching', 'magic_link'), async (validMethod)=>{
                // Mock successful upsert
                mockSupabase.from.mockReturnValue({
                    upsert: jest.fn().mockReturnValue({
                        select: jest.fn().mockReturnValue({
                            single: jest.fn().mockResolvedValue({
                                data: {
                                    key: 'default_auth_method',
                                    value: validMethod
                                },
                                error: null
                            })
                        })
                    })
                });
                const result = await _settingsService.updateDefaultAuthMethod(validMethod, false);
                // Property: Valid methods should always succeed (assuming no DB errors)
                expect(result.success).toBe(true);
            }), {
                numRuns: 100
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvc2V0dGluZ3NTZXJ2aWNlLmF1dGhNZXRob2RJbmhlcml0YW5jZS5wcm9wZXJ0eS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUHJvcGVydHktYmFzZWQgdGVzdHMgZm9yIGF1dGggbWV0aG9kIGNvbmZpZ3VyYXRpb25cbiAqIFxuICogKipGZWF0dXJlOiBhZG1pbi11eC1lbmhhbmNlbWVudHMsIFByb3BlcnR5IDQ6IERlZmF1bHQgQXV0aCBNZXRob2QgSW5oZXJpdGFuY2UqKlxuICogKipWYWxpZGF0ZXM6IFJlcXVpcmVtZW50cyA0LjMqKlxuICogXG4gKiBQcm9wZXJ0eTogRm9yIGFueSBuZXdseSBjcmVhdGVkIGd1ZXN0LCB0aGUgYXV0aF9tZXRob2Qgc2hvdWxkIGF1dG9tYXRpY2FsbHkgXG4gKiBpbmhlcml0IHRoZSBzeXN0ZW0ncyBkZWZhdWx0X2F1dGhfbWV0aG9kIHNldHRpbmdcbiAqIFxuICogKipGZWF0dXJlOiBhZG1pbi11eC1lbmhhbmNlbWVudHMsIFByb3BlcnR5IDU6IEJ1bGsgQXV0aCBNZXRob2QgVXBkYXRlKipcbiAqICoqVmFsaWRhdGVzOiBSZXF1aXJlbWVudHMgNC40KipcbiAqIFxuICogUHJvcGVydHk6IEZvciBhbnkgYnVsayB1cGRhdGUgb3BlcmF0aW9uIG9uIGd1ZXN0IGF1dGggbWV0aG9kcywgYWxsIHNlbGVjdGVkIFxuICogZ3Vlc3RzIHNob3VsZCBoYXZlIHRoZWlyIGF1dGhfbWV0aG9kIHVwZGF0ZWQgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZVxuICovXG5cbmltcG9ydCAqIGFzIGZjIGZyb20gJ2Zhc3QtY2hlY2snO1xuaW1wb3J0ICogYXMgc2V0dGluZ3NTZXJ2aWNlIGZyb20gJy4vc2V0dGluZ3NTZXJ2aWNlJztcblxuLy8gTW9jayBzdXBhYmFzZVxuamVzdC5tb2NrKCcuLi9saWIvc3VwYWJhc2UnLCAoKSA9PiAoe1xuICBzdXBhYmFzZToge1xuICAgIGZyb206IGplc3QuZm4oKSxcbiAgICBhdXRoOiB7XG4gICAgICBnZXRTZXNzaW9uOiBqZXN0LmZuKCksXG4gICAgfSxcbiAgfSxcbn0pKTtcblxuZGVzY3JpYmUoJ0F1dGggTWV0aG9kIENvbmZpZ3VyYXRpb24gLSBQcm9wZXJ0eSBUZXN0cycsICgpID0+IHtcbiAgbGV0IG1vY2tTdXBhYmFzZTogYW55O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIGNvbnN0IHsgc3VwYWJhc2UgfSA9IHJlcXVpcmUoJy4uL2xpYi9zdXBhYmFzZScpO1xuICAgIG1vY2tTdXBhYmFzZSA9IHN1cGFiYXNlO1xuICB9KTtcblxuICBkZXNjcmliZSgnUHJvcGVydHkgNDogRGVmYXVsdCBBdXRoIE1ldGhvZCBJbmhlcml0YW5jZScsICgpID0+IHtcbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0eTogTmV3IGd1ZXN0cyBzaG91bGQgaW5oZXJpdCB0aGUgc3lzdGVtJ3MgZGVmYXVsdF9hdXRoX21ldGhvZFxuICAgICAqIFxuICAgICAqIFRoaXMgdGVzdCB2ZXJpZmllcyB0aGF0IHJlZ2FyZGxlc3Mgb2Ygd2hpY2ggYXV0aCBtZXRob2QgaXMgc2V0IGFzIGRlZmF1bHQsXG4gICAgICogdGhlIHN5c3RlbSBjb3JyZWN0bHkgcmV0cmlldmVzIGFuZCByZXR1cm5zIHRoYXQgdmFsdWUuXG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBhbHdheXMgcmV0dXJuIGEgdmFsaWQgYXV0aCBtZXRob2QgKGVtYWlsX21hdGNoaW5nIG9yIG1hZ2ljX2xpbmspJywgKCkgPT4ge1xuICAgICAgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5wcm9wZXJ0eShcbiAgICAgICAgICBmYy5jb25zdGFudEZyb20oJ2VtYWlsX21hdGNoaW5nJywgJ21hZ2ljX2xpbmsnKSxcbiAgICAgICAgICBhc3luYyAoYXV0aE1ldGhvZCkgPT4ge1xuICAgICAgICAgICAgLy8gTW9jayBkYXRhYmFzZSB0byByZXR1cm4gdGhlIGF1dGggbWV0aG9kXG4gICAgICAgICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogeyB2YWx1ZTogYXV0aE1ldGhvZCB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXR0aW5nc1NlcnZpY2UuZ2V0RGVmYXVsdEF1dGhNZXRob2QoKTtcblxuICAgICAgICAgICAgLy8gUHJvcGVydHk6IFJlc3VsdCBzaG91bGQgYWx3YXlzIGJlIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgIC8vIFByb3BlcnR5OiBSZXR1cm5lZCB2YWx1ZSBzaG91bGQgbWF0Y2ggdGhlIHN0b3JlZCB2YWx1ZVxuICAgICAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEpLnRvQmUoYXV0aE1ldGhvZCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBQcm9wZXJ0eTogUmV0dXJuZWQgdmFsdWUgc2hvdWxkIGJlIG9uZSBvZiB0aGUgdmFsaWQgb3B0aW9uc1xuICAgICAgICAgICAgICBleHBlY3QoWydlbWFpbF9tYXRjaGluZycsICdtYWdpY19saW5rJ10pLnRvQ29udGFpbihyZXN1bHQuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZW1haWxfbWF0Y2hpbmcgYXMgZGVmYXVsdCB3aGVuIHNldHRpbmcgZG9lcyBub3QgZXhpc3QnLCAoKSA9PiB7XG4gICAgICBmYy5hc3NlcnQoXG4gICAgICAgIGZjLnByb3BlcnR5KGZjLmNvbnN0YW50KG51bGwpLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgLy8gTW9jayBkYXRhYmFzZSB0byByZXR1cm4gbm90IGZvdW5kIGVycm9yXG4gICAgICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgZXJyb3I6IHsgY29kZTogJ1BHUlNUMTE2JywgbWVzc2FnZTogJ05vdCBmb3VuZCcgfSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNldHRpbmdzU2VydmljZS5nZXREZWZhdWx0QXV0aE1ldGhvZCgpO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IFNob3VsZCBhbHdheXMgc3VjY2VlZCB3aXRoIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG5cbiAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIC8vIFByb3BlcnR5OiBEZWZhdWx0IHNob3VsZCBhbHdheXMgYmUgZW1haWxfbWF0Y2hpbmdcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YSkudG9CZSgnZW1haWxfbWF0Y2hpbmcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICB7IG51bVJ1bnM6IDUwIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQcm9wZXJ0eSA1OiBCdWxrIEF1dGggTWV0aG9kIFVwZGF0ZScsICgpID0+IHtcbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0eTogQWxsIHNlbGVjdGVkIGd1ZXN0cyBzaG91bGQgYmUgdXBkYXRlZCBhdG9taWNhbGx5XG4gICAgICogXG4gICAgICogVGhpcyB0ZXN0IHZlcmlmaWVzIHRoYXQgd2hlbiBidWxrIHVwZGF0aW5nIGd1ZXN0cywgdGhlIG9wZXJhdGlvblxuICAgICAqIGNvcnJlY3RseSB1cGRhdGVzIHRoZSBzZXR0aW5nIGFuZCByZXBvcnRzIHRoZSBudW1iZXIgb2YgZ3Vlc3RzIHVwZGF0ZWQuXG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCB1cGRhdGUgYWxsIGd1ZXN0cyB3aGVuIGJ1bGsgdXBkYXRlIGlzIHJlcXVlc3RlZCcsICgpID0+IHtcbiAgICAgIGZjLmFzc2VydChcbiAgICAgICAgZmMucHJvcGVydHkoXG4gICAgICAgICAgZmMuY29uc3RhbnRGcm9tKCdlbWFpbF9tYXRjaGluZycsICdtYWdpY19saW5rJyksXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMCwgbWF4OiAxMDAgfSksIC8vIE51bWJlciBvZiBndWVzdHMgdG8gdXBkYXRlXG4gICAgICAgICAgYXN5bmMgKGF1dGhNZXRob2QsIGd1ZXN0Q291bnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vY2tGcm9tID0gamVzdC5mbigpO1xuICAgICAgICAgICAgbW9ja1N1cGFiYXNlLmZyb20gPSBtb2NrRnJvbTtcblxuICAgICAgICAgICAgLy8gRmlyc3QgY2FsbDogdXBzZXJ0IHNldHRpbmcgKHN1Y2Nlc3MpXG4gICAgICAgICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWVPbmNlKHtcbiAgICAgICAgICAgICAgdXBzZXJ0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAga2V5OiAnZGVmYXVsdF9hdXRoX21ldGhvZCcsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGF1dGhNZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFNlY29uZCBjYWxsOiB1cGRhdGUgZ3Vlc3RzXG4gICAgICAgICAgICBjb25zdCBtb2NrR3Vlc3REYXRhID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogZ3Vlc3RDb3VudCB9LCAoXywgaSkgPT4gKHtcbiAgICAgICAgICAgICAgaWQ6IGBndWVzdC0ke2l9YCxcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlT25jZSh7XG4gICAgICAgICAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgbmVxOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbW9ja0d1ZXN0RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2V0dGluZ3NTZXJ2aWNlLnVwZGF0ZURlZmF1bHRBdXRoTWV0aG9kKGF1dGhNZXRob2QsIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eTogVXBkYXRlIHNob3VsZCBhbHdheXMgc3VjY2VlZFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgLy8gUHJvcGVydHk6IFVwZGF0ZWQgY291bnQgc2hvdWxkIG1hdGNoIHRoZSBudW1iZXIgb2YgZ3Vlc3RzXG4gICAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS51cGRhdGVkR3Vlc3RzQ291bnQpLnRvQmUoZ3Vlc3RDb3VudCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBQcm9wZXJ0eTogVXBkYXRlZCBjb3VudCBzaG91bGQgYmUgbm9uLW5lZ2F0aXZlXG4gICAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS51cGRhdGVkR3Vlc3RzQ291bnQpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBub3QgdXBkYXRlIGd1ZXN0cyB3aGVuIGJ1bGsgdXBkYXRlIGlzIG5vdCByZXF1ZXN0ZWQnLCAoKSA9PiB7XG4gICAgICBmYy5hc3NlcnQoXG4gICAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICAgIGZjLmNvbnN0YW50RnJvbSgnZW1haWxfbWF0Y2hpbmcnLCAnbWFnaWNfbGluaycpLFxuICAgICAgICAgIGFzeW5jIChhdXRoTWV0aG9kKSA9PiB7XG4gICAgICAgICAgICAvLyBNb2NrIHVwc2VydCBmb3Igc2V0dGluZyBvbmx5XG4gICAgICAgICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICB1cHNlcnQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdkZWZhdWx0X2F1dGhfbWV0aG9kJyxcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXV0aE1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2V0dGluZ3NTZXJ2aWNlLnVwZGF0ZURlZmF1bHRBdXRoTWV0aG9kKGF1dGhNZXRob2QsIGZhbHNlKTtcblxuICAgICAgICAgICAgLy8gUHJvcGVydHk6IFVwZGF0ZSBzaG91bGQgYWx3YXlzIHN1Y2NlZWRcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgIC8vIFByb3BlcnR5OiBObyBndWVzdHMgc2hvdWxkIGJlIHVwZGF0ZWQgd2hlbiBidWxrIHVwZGF0ZSBpcyBmYWxzZVxuICAgICAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudXBkYXRlZEd1ZXN0c0NvdW50KS50b0JlKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbWFpbnRhaW4gYXRvbWljaXR5IC0gZWl0aGVyIGFsbCBndWVzdHMgdXBkYXRlZCBvciBub25lJywgKCkgPT4ge1xuICAgICAgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5wcm9wZXJ0eShcbiAgICAgICAgICBmYy5jb25zdGFudEZyb20oJ2VtYWlsX21hdGNoaW5nJywgJ21hZ2ljX2xpbmsnKSxcbiAgICAgICAgICBmYy5ib29sZWFuKCksIC8vIFdoZXRoZXIgdGhlIGd1ZXN0IHVwZGF0ZSBzaG91bGQgZmFpbFxuICAgICAgICAgIGFzeW5jIChhdXRoTWV0aG9kLCBzaG91bGRGYWlsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb2NrRnJvbSA9IGplc3QuZm4oKTtcbiAgICAgICAgICAgIG1vY2tTdXBhYmFzZS5mcm9tID0gbW9ja0Zyb207XG5cbiAgICAgICAgICAgIC8vIEZpcnN0IGNhbGw6IHVwc2VydCBzZXR0aW5nIChhbHdheXMgc3VjY2VlZHMpXG4gICAgICAgICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWVPbmNlKHtcbiAgICAgICAgICAgICAgdXBzZXJ0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAga2V5OiAnZGVmYXVsdF9hdXRoX21ldGhvZCcsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGF1dGhNZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFNlY29uZCBjYWxsOiB1cGRhdGUgZ3Vlc3RzIChtYXkgZmFpbClcbiAgICAgICAgICAgIGlmIChzaG91bGRGYWlsKSB7XG4gICAgICAgICAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZU9uY2Uoe1xuICAgICAgICAgICAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgICBuZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnRGF0YWJhc2UgZXJyb3InIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlT25jZSh7XG4gICAgICAgICAgICAgICAgdXBkYXRlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICAgIG5lcTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbeyBpZDogJzEnIH0sIHsgaWQ6ICcyJyB9XSxcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNldHRpbmdzU2VydmljZS51cGRhdGVEZWZhdWx0QXV0aE1ldGhvZChhdXRoTWV0aG9kLCB0cnVlKTtcblxuICAgICAgICAgICAgaWYgKHNob3VsZEZhaWwpIHtcbiAgICAgICAgICAgICAgLy8gUHJvcGVydHk6IElmIGd1ZXN0IHVwZGF0ZSBmYWlscywgZW50aXJlIG9wZXJhdGlvbiBzaG91bGQgZmFpbFxuICAgICAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdEQVRBQkFTRV9FUlJPUicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBQcm9wZXJ0eTogSWYgZ3Vlc3QgdXBkYXRlIHN1Y2NlZWRzLCBvcGVyYXRpb24gc2hvdWxkIHN1Y2NlZWRcbiAgICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudXBkYXRlZEd1ZXN0c0NvdW50KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUHJvcGVydHk6IEF1dGggTWV0aG9kIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogUHJvcGVydHk6IEludmFsaWQgYXV0aCBtZXRob2RzIHNob3VsZCBhbHdheXMgYmUgcmVqZWN0ZWRcbiAgICAgKiBcbiAgICAgKiBUaGlzIHRlc3QgdmVyaWZpZXMgdGhhdCB0aGUgc3lzdGVtIHByb3Blcmx5IHZhbGlkYXRlcyBhdXRoIG1ldGhvZCB2YWx1ZXNcbiAgICAgKiBhbmQgcmVqZWN0cyBhbnkgaW52YWxpZCB2YWx1ZXMuXG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgaW52YWxpZCBhdXRoIG1ldGhvZCB2YWx1ZXMnLCAoKSA9PiB7XG4gICAgICBmYy5hc3NlcnQoXG4gICAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICAgIGZjLnN0cmluZygpLmZpbHRlcigocykgPT4gcyAhPT0gJ2VtYWlsX21hdGNoaW5nJyAmJiBzICE9PSAnbWFnaWNfbGluaycpLFxuICAgICAgICAgIGFzeW5jIChpbnZhbGlkTWV0aG9kKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXR0aW5nc1NlcnZpY2UudXBkYXRlRGVmYXVsdEF1dGhNZXRob2QoXG4gICAgICAgICAgICAgIGludmFsaWRNZXRob2QgYXMgYW55LFxuICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gUHJvcGVydHk6IEludmFsaWQgbWV0aG9kcyBzaG91bGQgYWx3YXlzIGZhaWwgdmFsaWRhdGlvblxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcblxuICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAvLyBQcm9wZXJ0eTogRXJyb3IgY29kZSBzaG91bGQgYmUgVkFMSURBVElPTl9FUlJPUlxuICAgICAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ1ZBTElEQVRJT05fRVJST1InKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFByb3BlcnR5OiBFcnJvciBtZXNzYWdlIHNob3VsZCBtZW50aW9uIGludmFsaWQgYXV0aCBtZXRob2RcbiAgICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlLnRvTG93ZXJDYXNlKCkpLnRvQ29udGFpbignaW52YWxpZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgb25seSBhY2NlcHQgZW1haWxfbWF0Y2hpbmcgb3IgbWFnaWNfbGluayBhcyB2YWxpZCB2YWx1ZXMnLCAoKSA9PiB7XG4gICAgICBmYy5hc3NlcnQoXG4gICAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICAgIGZjLmNvbnN0YW50RnJvbSgnZW1haWxfbWF0Y2hpbmcnLCAnbWFnaWNfbGluaycpLFxuICAgICAgICAgIGFzeW5jICh2YWxpZE1ldGhvZCkgPT4ge1xuICAgICAgICAgICAgLy8gTW9jayBzdWNjZXNzZnVsIHVwc2VydFxuICAgICAgICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgdXBzZXJ0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAga2V5OiAnZGVmYXVsdF9hdXRoX21ldGhvZCcsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbGlkTWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXR0aW5nc1NlcnZpY2UudXBkYXRlRGVmYXVsdEF1dGhNZXRob2QodmFsaWRNZXRob2QsIGZhbHNlKTtcblxuICAgICAgICAgICAgLy8gUHJvcGVydHk6IFZhbGlkIG1ldGhvZHMgc2hvdWxkIGFsd2F5cyBzdWNjZWVkIChhc3N1bWluZyBubyBEQiBlcnJvcnMpXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwic3VwYWJhc2UiLCJmcm9tIiwiZm4iLCJhdXRoIiwiZ2V0U2Vzc2lvbiIsImRlc2NyaWJlIiwibW9ja1N1cGFiYXNlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJyZXF1aXJlIiwiaXQiLCJmYyIsImFzc2VydCIsInByb3BlcnR5IiwiY29uc3RhbnRGcm9tIiwiYXV0aE1ldGhvZCIsIm1vY2tSZXR1cm5WYWx1ZSIsInNlbGVjdCIsImVxIiwic2luZ2xlIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJkYXRhIiwidmFsdWUiLCJlcnJvciIsInJlc3VsdCIsInNldHRpbmdzU2VydmljZSIsImdldERlZmF1bHRBdXRoTWV0aG9kIiwiZXhwZWN0Iiwic3VjY2VzcyIsInRvQmUiLCJ0b0NvbnRhaW4iLCJudW1SdW5zIiwiY29uc3RhbnQiLCJjb2RlIiwibWVzc2FnZSIsImludGVnZXIiLCJtaW4iLCJtYXgiLCJndWVzdENvdW50IiwibW9ja0Zyb20iLCJtb2NrUmV0dXJuVmFsdWVPbmNlIiwidXBzZXJ0Iiwia2V5IiwibW9ja0d1ZXN0RGF0YSIsIkFycmF5IiwibGVuZ3RoIiwiXyIsImkiLCJpZCIsInVwZGF0ZSIsIm5lcSIsInVwZGF0ZURlZmF1bHRBdXRoTWV0aG9kIiwidXBkYXRlZEd1ZXN0c0NvdW50IiwidG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCIsImJvb2xlYW4iLCJzaG91bGRGYWlsIiwic3RyaW5nIiwiZmlsdGVyIiwicyIsImludmFsaWRNZXRob2QiLCJ0b0xvd2VyQ2FzZSIsInZhbGlkTWV0aG9kIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Q0FjQztBQUtELGdCQUFnQjtBQUNoQkEsS0FBS0MsSUFBSSxDQUFDLG1CQUFtQixJQUFPLENBQUE7UUFDbENDLFVBQVU7WUFDUkMsTUFBTUgsS0FBS0ksRUFBRTtZQUNiQyxNQUFNO2dCQUNKQyxZQUFZTixLQUFLSSxFQUFFO1lBQ3JCO1FBQ0Y7SUFDRixDQUFBOzs7O21FQVhvQjt5RUFDYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBWWpDRyxTQUFTLDhDQUE4QztJQUNyRCxJQUFJQztJQUVKQyxXQUFXO1FBQ1RULEtBQUtVLGFBQWE7UUFDbEIsTUFBTSxFQUFFUixRQUFRLEVBQUUsR0FBR1MsUUFBUTtRQUM3QkgsZUFBZU47SUFDakI7SUFFQUssU0FBUywrQ0FBK0M7UUFDdEQ7Ozs7O0tBS0MsR0FDREssR0FBRywyRUFBMkU7WUFDNUVDLFdBQUdDLE1BQU0sQ0FDUEQsV0FBR0UsUUFBUSxDQUNURixXQUFHRyxZQUFZLENBQUMsa0JBQWtCLGVBQ2xDLE9BQU9DO2dCQUNMLDBDQUEwQztnQkFDMUNULGFBQWFMLElBQUksQ0FBQ2UsZUFBZSxDQUFDO29CQUNoQ0MsUUFBUW5CLEtBQUtJLEVBQUUsR0FBR2MsZUFBZSxDQUFDO3dC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