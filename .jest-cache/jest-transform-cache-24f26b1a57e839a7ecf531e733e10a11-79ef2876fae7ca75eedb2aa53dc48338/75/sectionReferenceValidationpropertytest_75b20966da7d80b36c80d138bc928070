3568d35b41064643861fcb6e310cb19f
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _globals = require("@jest/globals");
const _sectionsService = require("./sectionsService");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Mock Supabase before importing services
// Use the relative path that matches the require in sectionsService
const mockFrom = _globals.jest.fn();
const mockSupabase = {
    from: mockFrom
};
_globals.jest.mock('../lib/supabase', ()=>({
        supabase: mockSupabase
    }));
// Feature: destination-wedding-platform, Property 33: Section Reference Validation
(0, _globals.describe)('Feature: destination-wedding-platform, Property 33: Section Reference Validation', ()=>{
    (0, _globals.beforeEach)(()=>{
        _globals.jest.clearAllMocks();
    });
    (0, _globals.it)('should detect broken references for any non-existent entity IDs', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.array(_fastcheck.record({
            type: _fastcheck.constantFrom('activity', 'event', 'accommodation', 'location'),
            id: _fastcheck.uuid(),
            label: _fastcheck.option(_fastcheck.string({
                minLength: 1,
                maxLength: 100
            })),
            exists: _fastcheck.boolean()
        }), {
            minLength: 1,
            maxLength: 10
        }), async (testReferences)=>{
            // Mock database lookups for each reference
            for (const ref of testReferences){
                const tableName = ref.type === 'activity' ? 'activities' : ref.type === 'event' ? 'events' : ref.type === 'accommodation' ? 'accommodations' : 'locations';
                mockFrom.mockReturnValueOnce({
                    select: _globals.jest.fn().mockReturnValue({
                        eq: _globals.jest.fn().mockReturnValue({
                            single: _globals.jest.fn().mockResolvedValue({
                                data: ref.exists ? {
                                    id: ref.id
                                } : null,
                                error: ref.exists ? null : {
                                    code: 'PGRST116',
                                    message: 'Not found'
                                }
                            })
                        })
                    })
                });
            }
            const references = testReferences.map((r)=>({
                    type: r.type,
                    id: r.id,
                    label: r.label || undefined
                }));
            const result = await (0, _sectionsService.validateReferences)(references);
            // Property: Validation should succeed
            (0, _globals.expect)(result.success).toBe(true);
            if (!result.success) {
                return true;
            }
            // Property: All non-existent references should be in brokenReferences
            const expectedBroken = testReferences.filter((r)=>!r.exists);
            (0, _globals.expect)(result.data.brokenReferences.length).toBe(expectedBroken.length);
            // Property: All broken references should match the non-existent ones
            for (const broken of result.data.brokenReferences){
                const original = testReferences.find((r)=>r.id === broken.id && r.type === broken.type);
                (0, _globals.expect)(original).toBeDefined();
                (0, _globals.expect)(original?.exists).toBe(false);
            }
            // Property: Valid should be true only if all references exist
            const allExist = testReferences.every((r)=>r.exists);
            (0, _globals.expect)(result.data.valid).toBe(allExist);
            return true;
        }), {
            numRuns: 100
        });
    });
    (0, _globals.it)('should return valid=true when all referenced entities exist', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.array(_fastcheck.record({
            type: _fastcheck.constantFrom('activity', 'event', 'accommodation', 'location'),
            id: _fastcheck.uuid(),
            label: _fastcheck.option(_fastcheck.string({
                minLength: 1,
                maxLength: 100
            }))
        }), {
            minLength: 1,
            maxLength: 10
        }), async (testReferences)=>{
            // Mock all references as existing
            for (const ref of testReferences){
                const tableName = ref.type === 'activity' ? 'activities' : ref.type === 'event' ? 'events' : ref.type === 'accommodation' ? 'accommodations' : 'locations';
                mockFrom.mockReturnValueOnce({
                    select: _globals.jest.fn().mockReturnValue({
                        eq: _globals.jest.fn().mockReturnValue({
                            single: _globals.jest.fn().mockResolvedValue({
                                data: {
                                    id: ref.id
                                },
                                error: null
                            })
                        })
                    })
                });
            }
            const references = testReferences.map((r)=>({
                    type: r.type,
                    id: r.id,
                    label: r.label || undefined
                }));
            const result = await (0, _sectionsService.validateReferences)(references);
            // Property: Validation should succeed
            (0, _globals.expect)(result.success).toBe(true);
            if (!result.success) {
                return true;
            }
            // Property: Should be valid with no broken references
            (0, _globals.expect)(result.data.valid).toBe(true);
            (0, _globals.expect)(result.data.brokenReferences).toHaveLength(0);
            return true;
        }), {
            numRuns: 100
        });
    });
    (0, _globals.it)('should return valid=false when any referenced entity does not exist', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
            validRefs: _fastcheck.array(_fastcheck.record({
                type: _fastcheck.constantFrom('activity', 'event', 'accommodation', 'location'),
                id: _fastcheck.uuid()
            }), {
                minLength: 0,
                maxLength: 5
            }),
            brokenRef: _fastcheck.record({
                type: _fastcheck.constantFrom('activity', 'event', 'accommodation', 'location'),
                id: _fastcheck.uuid()
            })
        }), async (testData)=>{
            // Mock valid references as existing
            for (const ref of testData.validRefs){
                const tableName = ref.type === 'activity' ? 'activities' : ref.type === 'event' ? 'events' : ref.type === 'accommodation' ? 'accommodations' : 'locations';
                mockFrom.mockReturnValueOnce({
                    select: _globals.jest.fn().mockReturnValue({
                        eq: _globals.jest.fn().mockReturnValue({
                            single: _globals.jest.fn().mockResolvedValue({
                                data: {
                                    id: ref.id
                                },
                                error: null
                            })
                        })
                    })
                });
            }
            // Mock broken reference as not existing
            const brokenTableName = testData.brokenRef.type === 'activity' ? 'activities' : testData.brokenRef.type === 'event' ? 'events' : testData.brokenRef.type === 'accommodation' ? 'accommodations' : 'locations';
            mockFrom.mockReturnValueOnce({
                select: _globals.jest.fn().mockReturnValue({
                    eq: _globals.jest.fn().mockReturnValue({
                        single: _globals.jest.fn().mockResolvedValue({
                            data: null,
                            error: {
                                code: 'PGRST116',
                                message: 'Not found'
                            }
                        })
                    })
                })
            });
            const references = [
                ...testData.validRefs.map((r)=>({
                        type: r.type,
                        id: r.id
                    })),
                {
                    type: testData.brokenRef.type,
                    id: testData.brokenRef.id
                }
            ];
            const result = await (0, _sectionsService.validateReferences)(references);
            // Property: Validation should succeed
            (0, _globals.expect)(result.success).toBe(true);
            if (!result.success) {
                return true;
            }
            // Property: Should be invalid with at least one broken reference
            (0, _globals.expect)(result.data.valid).toBe(false);
            (0, _globals.expect)(result.data.brokenReferences.length).toBeGreaterThan(0);
            // Property: Broken reference should be the one we marked as non-existent
            const foundBroken = result.data.brokenReferences.find((r)=>r.id === testData.brokenRef.id && r.type === testData.brokenRef.type);
            (0, _globals.expect)(foundBroken).toBeDefined();
            return true;
        }), {
            numRuns: 50
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvc2VjdGlvblJlZmVyZW5jZVZhbGlkYXRpb24ucHJvcGVydHkudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmYyBmcm9tICdmYXN0LWNoZWNrJztcbmltcG9ydCB7IGplc3QsIGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBiZWZvcmVFYWNoIH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5cbi8vIE1vY2sgU3VwYWJhc2UgYmVmb3JlIGltcG9ydGluZyBzZXJ2aWNlc1xuLy8gVXNlIHRoZSByZWxhdGl2ZSBwYXRoIHRoYXQgbWF0Y2hlcyB0aGUgcmVxdWlyZSBpbiBzZWN0aW9uc1NlcnZpY2VcbmNvbnN0IG1vY2tGcm9tID0gamVzdC5mbigpO1xuY29uc3QgbW9ja1N1cGFiYXNlID0ge1xuICBmcm9tOiBtb2NrRnJvbSxcbn07XG5cbmplc3QubW9jaygnLi4vbGliL3N1cGFiYXNlJywgKCkgPT4gKHtcbiAgc3VwYWJhc2U6IG1vY2tTdXBhYmFzZSxcbn0pKTtcblxuLy8gSW1wb3J0IGFmdGVyIG1vY2tpbmdcbmltcG9ydCB7IHZhbGlkYXRlUmVmZXJlbmNlcyB9IGZyb20gJy4vc2VjdGlvbnNTZXJ2aWNlJztcbmltcG9ydCB0eXBlIHsgUmVmZXJlbmNlIH0gZnJvbSAnLi4vc2NoZW1hcy9jbXNTY2hlbWFzJztcblxuLy8gRmVhdHVyZTogZGVzdGluYXRpb24td2VkZGluZy1wbGF0Zm9ybSwgUHJvcGVydHkgMzM6IFNlY3Rpb24gUmVmZXJlbmNlIFZhbGlkYXRpb25cblxuZGVzY3JpYmUoJ0ZlYXR1cmU6IGRlc3RpbmF0aW9uLXdlZGRpbmctcGxhdGZvcm0sIFByb3BlcnR5IDMzOiBTZWN0aW9uIFJlZmVyZW5jZSBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBkZXRlY3QgYnJva2VuIHJlZmVyZW5jZXMgZm9yIGFueSBub24tZXhpc3RlbnQgZW50aXR5IElEcycsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBmYy5hcnJheShcbiAgICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgICAgdHlwZTogZmMuY29uc3RhbnRGcm9tKCdhY3Rpdml0eScsICdldmVudCcsICdhY2NvbW1vZGF0aW9uJywgJ2xvY2F0aW9uJykgYXMgZmMuQXJiaXRyYXJ5PCdhY3Rpdml0eScgfCAnZXZlbnQnIHwgJ2FjY29tbW9kYXRpb24nIHwgJ2xvY2F0aW9uJz4sXG4gICAgICAgICAgICBpZDogZmMudXVpZCgpLFxuICAgICAgICAgICAgbGFiZWw6IGZjLm9wdGlvbihmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTAwIH0pKSxcbiAgICAgICAgICAgIGV4aXN0czogZmMuYm9vbGVhbigpLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwIH1cbiAgICAgICAgKSxcbiAgICAgICAgYXN5bmMgKHRlc3RSZWZlcmVuY2VzKSA9PiB7XG4gICAgICAgICAgLy8gTW9jayBkYXRhYmFzZSBsb29rdXBzIGZvciBlYWNoIHJlZmVyZW5jZVxuICAgICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHRlc3RSZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBjb25zdCB0YWJsZU5hbWUgPSByZWYudHlwZSA9PT0gJ2FjdGl2aXR5JyA/ICdhY3Rpdml0aWVzJyA6IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZi50eXBlID09PSAnZXZlbnQnID8gJ2V2ZW50cycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZi50eXBlID09PSAnYWNjb21tb2RhdGlvbicgPyAnYWNjb21tb2RhdGlvbnMnIDogJ2xvY2F0aW9ucyc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZU9uY2Uoe1xuICAgICAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogcmVmLmV4aXN0cyA/IHsgaWQ6IHJlZi5pZCB9IDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHJlZi5leGlzdHMgPyBudWxsIDogeyBjb2RlOiAnUEdSU1QxMTYnLCBtZXNzYWdlOiAnTm90IGZvdW5kJyB9LFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcmVmZXJlbmNlczogUmVmZXJlbmNlW10gPSB0ZXN0UmVmZXJlbmNlcy5tYXAociA9PiAoe1xuICAgICAgICAgICAgdHlwZTogci50eXBlLFxuICAgICAgICAgICAgaWQ6IHIuaWQsXG4gICAgICAgICAgICBsYWJlbDogci5sYWJlbCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGVSZWZlcmVuY2VzKHJlZmVyZW5jZXMpO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IFZhbGlkYXRpb24gc2hvdWxkIHN1Y2NlZWRcbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBQcm9wZXJ0eTogQWxsIG5vbi1leGlzdGVudCByZWZlcmVuY2VzIHNob3VsZCBiZSBpbiBicm9rZW5SZWZlcmVuY2VzXG4gICAgICAgICAgY29uc3QgZXhwZWN0ZWRCcm9rZW4gPSB0ZXN0UmVmZXJlbmNlcy5maWx0ZXIociA9PiAhci5leGlzdHMpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5icm9rZW5SZWZlcmVuY2VzLmxlbmd0aCkudG9CZShleHBlY3RlZEJyb2tlbi5sZW5ndGgpO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IEFsbCBicm9rZW4gcmVmZXJlbmNlcyBzaG91bGQgbWF0Y2ggdGhlIG5vbi1leGlzdGVudCBvbmVzXG4gICAgICAgICAgZm9yIChjb25zdCBicm9rZW4gb2YgcmVzdWx0LmRhdGEuYnJva2VuUmVmZXJlbmNlcykge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSB0ZXN0UmVmZXJlbmNlcy5maW5kKHIgPT4gci5pZCA9PT0gYnJva2VuLmlkICYmIHIudHlwZSA9PT0gYnJva2VuLnR5cGUpO1xuICAgICAgICAgICAgZXhwZWN0KG9yaWdpbmFsKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KG9yaWdpbmFsPy5leGlzdHMpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBWYWxpZCBzaG91bGQgYmUgdHJ1ZSBvbmx5IGlmIGFsbCByZWZlcmVuY2VzIGV4aXN0XG4gICAgICAgICAgY29uc3QgYWxsRXhpc3QgPSB0ZXN0UmVmZXJlbmNlcy5ldmVyeShyID0+IHIuZXhpc3RzKTtcbiAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudmFsaWQpLnRvQmUoYWxsRXhpc3QpO1xuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCByZXR1cm4gdmFsaWQ9dHJ1ZSB3aGVuIGFsbCByZWZlcmVuY2VkIGVudGl0aWVzIGV4aXN0JywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGZjLmFycmF5KFxuICAgICAgICAgIGZjLnJlY29yZCh7XG4gICAgICAgICAgICB0eXBlOiBmYy5jb25zdGFudEZyb20oJ2FjdGl2aXR5JywgJ2V2ZW50JywgJ2FjY29tbW9kYXRpb24nLCAnbG9jYXRpb24nKSBhcyBmYy5BcmJpdHJhcnk8J2FjdGl2aXR5JyB8ICdldmVudCcgfCAnYWNjb21tb2RhdGlvbicgfCAnbG9jYXRpb24nPixcbiAgICAgICAgICAgIGlkOiBmYy51dWlkKCksXG4gICAgICAgICAgICBsYWJlbDogZmMub3B0aW9uKGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxMDAgfSkpLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwIH1cbiAgICAgICAgKSxcbiAgICAgICAgYXN5bmMgKHRlc3RSZWZlcmVuY2VzKSA9PiB7XG4gICAgICAgICAgLy8gTW9jayBhbGwgcmVmZXJlbmNlcyBhcyBleGlzdGluZ1xuICAgICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHRlc3RSZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBjb25zdCB0YWJsZU5hbWUgPSByZWYudHlwZSA9PT0gJ2FjdGl2aXR5JyA/ICdhY3Rpdml0aWVzJyA6IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZi50eXBlID09PSAnZXZlbnQnID8gJ2V2ZW50cycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZi50eXBlID09PSAnYWNjb21tb2RhdGlvbicgPyAnYWNjb21tb2RhdGlvbnMnIDogJ2xvY2F0aW9ucyc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZU9uY2Uoe1xuICAgICAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogeyBpZDogcmVmLmlkIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcmVmZXJlbmNlczogUmVmZXJlbmNlW10gPSB0ZXN0UmVmZXJlbmNlcy5tYXAociA9PiAoe1xuICAgICAgICAgICAgdHlwZTogci50eXBlLFxuICAgICAgICAgICAgaWQ6IHIuaWQsXG4gICAgICAgICAgICBsYWJlbDogci5sYWJlbCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGVSZWZlcmVuY2VzKHJlZmVyZW5jZXMpO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IFZhbGlkYXRpb24gc2hvdWxkIHN1Y2NlZWRcbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBQcm9wZXJ0eTogU2hvdWxkIGJlIHZhbGlkIHdpdGggbm8gYnJva2VuIHJlZmVyZW5jZXNcbiAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmJyb2tlblJlZmVyZW5jZXMpLnRvSGF2ZUxlbmd0aCgwKTtcblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgcmV0dXJuIHZhbGlkPWZhbHNlIHdoZW4gYW55IHJlZmVyZW5jZWQgZW50aXR5IGRvZXMgbm90IGV4aXN0JywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGZjLnJlY29yZCh7XG4gICAgICAgICAgdmFsaWRSZWZzOiBmYy5hcnJheShcbiAgICAgICAgICAgIGZjLnJlY29yZCh7XG4gICAgICAgICAgICAgIHR5cGU6IGZjLmNvbnN0YW50RnJvbSgnYWN0aXZpdHknLCAnZXZlbnQnLCAnYWNjb21tb2RhdGlvbicsICdsb2NhdGlvbicpIGFzIGZjLkFyYml0cmFyeTwnYWN0aXZpdHknIHwgJ2V2ZW50JyB8ICdhY2NvbW1vZGF0aW9uJyB8ICdsb2NhdGlvbic+LFxuICAgICAgICAgICAgICBpZDogZmMudXVpZCgpLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB7IG1pbkxlbmd0aDogMCwgbWF4TGVuZ3RoOiA1IH1cbiAgICAgICAgICApLFxuICAgICAgICAgIGJyb2tlblJlZjogZmMucmVjb3JkKHtcbiAgICAgICAgICAgIHR5cGU6IGZjLmNvbnN0YW50RnJvbSgnYWN0aXZpdHknLCAnZXZlbnQnLCAnYWNjb21tb2RhdGlvbicsICdsb2NhdGlvbicpIGFzIGZjLkFyYml0cmFyeTwnYWN0aXZpdHknIHwgJ2V2ZW50JyB8ICdhY2NvbW1vZGF0aW9uJyB8ICdsb2NhdGlvbic+LFxuICAgICAgICAgICAgaWQ6IGZjLnV1aWQoKSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICAgIGFzeW5jICh0ZXN0RGF0YSkgPT4ge1xuICAgICAgICAgIC8vIE1vY2sgdmFsaWQgcmVmZXJlbmNlcyBhcyBleGlzdGluZ1xuICAgICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHRlc3REYXRhLnZhbGlkUmVmcykge1xuICAgICAgICAgICAgY29uc3QgdGFibGVOYW1lID0gcmVmLnR5cGUgPT09ICdhY3Rpdml0eScgPyAnYWN0aXZpdGllcycgOiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYudHlwZSA9PT0gJ2V2ZW50JyA/ICdldmVudHMnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYudHlwZSA9PT0gJ2FjY29tbW9kYXRpb24nID8gJ2FjY29tbW9kYXRpb25zJyA6ICdsb2NhdGlvbnMnO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWVPbmNlKHtcbiAgICAgICAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgaWQ6IHJlZi5pZCB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE1vY2sgYnJva2VuIHJlZmVyZW5jZSBhcyBub3QgZXhpc3RpbmdcbiAgICAgICAgICBjb25zdCBicm9rZW5UYWJsZU5hbWUgPSB0ZXN0RGF0YS5icm9rZW5SZWYudHlwZSA9PT0gJ2FjdGl2aXR5JyA/ICdhY3Rpdml0aWVzJyA6IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdERhdGEuYnJva2VuUmVmLnR5cGUgPT09ICdldmVudCcgPyAnZXZlbnRzJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXN0RGF0YS5icm9rZW5SZWYudHlwZSA9PT0gJ2FjY29tbW9kYXRpb24nID8gJ2FjY29tbW9kYXRpb25zJyA6ICdsb2NhdGlvbnMnO1xuICAgICAgICAgIFxuICAgICAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZU9uY2Uoe1xuICAgICAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICBlcnJvcjogeyBjb2RlOiAnUEdSU1QxMTYnLCBtZXNzYWdlOiAnTm90IGZvdW5kJyB9LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3QgcmVmZXJlbmNlczogUmVmZXJlbmNlW10gPSBbXG4gICAgICAgICAgICAuLi50ZXN0RGF0YS52YWxpZFJlZnMubWFwKHIgPT4gKHsgdHlwZTogci50eXBlLCBpZDogci5pZCB9KSksXG4gICAgICAgICAgICB7IHR5cGU6IHRlc3REYXRhLmJyb2tlblJlZi50eXBlLCBpZDogdGVzdERhdGEuYnJva2VuUmVmLmlkIH0sXG4gICAgICAgICAgXTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlUmVmZXJlbmNlcyhyZWZlcmVuY2VzKTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBWYWxpZGF0aW9uIHNob3VsZCBzdWNjZWVkXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuXG4gICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IFNob3VsZCBiZSBpbnZhbGlkIHdpdGggYXQgbGVhc3Qgb25lIGJyb2tlbiByZWZlcmVuY2VcbiAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5icm9rZW5SZWZlcmVuY2VzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IEJyb2tlbiByZWZlcmVuY2Ugc2hvdWxkIGJlIHRoZSBvbmUgd2UgbWFya2VkIGFzIG5vbi1leGlzdGVudFxuICAgICAgICAgIGNvbnN0IGZvdW5kQnJva2VuID0gcmVzdWx0LmRhdGEuYnJva2VuUmVmZXJlbmNlcy5maW5kKFxuICAgICAgICAgICAgciA9PiByLmlkID09PSB0ZXN0RGF0YS5icm9rZW5SZWYuaWQgJiYgci50eXBlID09PSB0ZXN0RGF0YS5icm9rZW5SZWYudHlwZVxuICAgICAgICAgICk7XG4gICAgICAgICAgZXhwZWN0KGZvdW5kQnJva2VuKS50b0JlRGVmaW5lZCgpO1xuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDUwIH1cbiAgICApO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbIm1vY2tGcm9tIiwiamVzdCIsImZuIiwibW9ja1N1cGFiYXNlIiwiZnJvbSIsIm1vY2siLCJzdXBhYmFzZSIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJpdCIsImZjIiwiYXNzZXJ0IiwiYXN5bmNQcm9wZXJ0eSIsImFycmF5IiwicmVjb3JkIiwidHlwZSIsImNvbnN0YW50RnJvbSIsImlkIiwidXVpZCIsImxhYmVsIiwib3B0aW9uIiwic3RyaW5nIiwibWluTGVuZ3RoIiwibWF4TGVuZ3RoIiwiZXhpc3RzIiwiYm9vbGVhbiIsInRlc3RSZWZlcmVuY2VzIiwicmVmIiwidGFibGVOYW1lIiwibW9ja1JldHVyblZhbHVlT25jZSIsInNlbGVjdCIsIm1vY2tSZXR1cm5WYWx1ZSIsImVxIiwic2luZ2xlIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJkYXRhIiwiZXJyb3IiLCJjb2RlIiwibWVzc2FnZSIsInJlZmVyZW5jZXMiLCJtYXAiLCJyIiwidW5kZWZpbmVkIiwicmVzdWx0IiwidmFsaWRhdGVSZWZlcmVuY2VzIiwiZXhwZWN0Iiwic3VjY2VzcyIsInRvQmUiLCJleHBlY3RlZEJyb2tlbiIsImZpbHRlciIsImJyb2tlblJlZmVyZW5jZXMiLCJsZW5ndGgiLCJicm9rZW4iLCJvcmlnaW5hbCIsImZpbmQiLCJ0b0JlRGVmaW5lZCIsImFsbEV4aXN0IiwiZXZlcnkiLCJ2YWxpZCIsIm51bVJ1bnMiLCJ0b0hhdmVMZW5ndGgiLCJ2YWxpZFJlZnMiLCJicm9rZW5SZWYiLCJ0ZXN0RGF0YSIsImJyb2tlblRhYmxlTmFtZSIsInRvQmVHcmVhdGVyVGhhbiIsImZvdW5kQnJva2VuIl0sIm1hcHBpbmdzIjoiOzs7O21FQUFvQjt5QkFDbUM7aUNBY3BCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFabkMsMENBQTBDO0FBQzFDLG9FQUFvRTtBQUNwRSxNQUFNQSxXQUFXQyxhQUFJLENBQUNDLEVBQUU7QUFDeEIsTUFBTUMsZUFBZTtJQUNuQkMsTUFBTUo7QUFDUjtBQUVBQyxhQUFJLENBQUNJLElBQUksQ0FBQyxtQkFBbUIsSUFBTyxDQUFBO1FBQ2xDQyxVQUFVSDtJQUNaLENBQUE7QUFNQSxtRkFBbUY7QUFFbkZJLElBQUFBLGlCQUFRLEVBQUMsb0ZBQW9GO0lBQzNGQyxJQUFBQSxtQkFBVSxFQUFDO1FBQ1RQLGFBQUksQ0FBQ1EsYUFBYTtJQUNwQjtJQUVBQyxJQUFBQSxXQUFFLEVBQUMsbUVBQW1FO1FBQ3BFLE1BQU1DLFdBQUdDLE1BQU0sQ0FDYkQsV0FBR0UsYUFBYSxDQUNkRixXQUFHRyxLQUFL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