{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/services/sectionReferenceValidation.property.test.ts"],"sourcesContent":["import * as fc from 'fast-check';\nimport { jest, describe, it, expect, beforeEach } from '@jest/globals';\n\n// Mock Supabase before importing services\n// Use the relative path that matches the require in sectionsService\nconst mockFrom = jest.fn();\nconst mockSupabase = {\n  from: mockFrom,\n};\n\njest.mock('../lib/supabase', () => ({\n  supabase: mockSupabase,\n}));\n\n// Import after mocking\nimport { validateReferences } from './sectionsService';\nimport type { Reference } from '../schemas/cmsSchemas';\n\n// Feature: destination-wedding-platform, Property 33: Section Reference Validation\n\ndescribe('Feature: destination-wedding-platform, Property 33: Section Reference Validation', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('should detect broken references for any non-existent entity IDs', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.array(\n          fc.record({\n            type: fc.constantFrom('activity', 'event', 'accommodation', 'location') as fc.Arbitrary<'activity' | 'event' | 'accommodation' | 'location'>,\n            id: fc.uuid(),\n            label: fc.option(fc.string({ minLength: 1, maxLength: 100 })),\n            exists: fc.boolean(),\n          }),\n          { minLength: 1, maxLength: 10 }\n        ),\n        async (testReferences) => {\n          // Mock database lookups for each reference\n          for (const ref of testReferences) {\n            const tableName = ref.type === 'activity' ? 'activities' : \n                            ref.type === 'event' ? 'events' :\n                            ref.type === 'accommodation' ? 'accommodations' : 'locations';\n            \n            mockFrom.mockReturnValueOnce({\n              select: jest.fn().mockReturnValue({\n                eq: jest.fn().mockReturnValue({\n                  single: jest.fn().mockResolvedValue({\n                    data: ref.exists ? { id: ref.id } : null,\n                    error: ref.exists ? null : { code: 'PGRST116', message: 'Not found' },\n                  }),\n                }),\n              }),\n            });\n          }\n\n          const references: Reference[] = testReferences.map(r => ({\n            type: r.type,\n            id: r.id,\n            label: r.label || undefined,\n          }));\n\n          const result = await validateReferences(references);\n\n          // Property: Validation should succeed\n          expect(result.success).toBe(true);\n\n          if (!result.success) {\n            return true;\n          }\n\n          // Property: All non-existent references should be in brokenReferences\n          const expectedBroken = testReferences.filter(r => !r.exists);\n          expect(result.data.brokenReferences.length).toBe(expectedBroken.length);\n\n          // Property: All broken references should match the non-existent ones\n          for (const broken of result.data.brokenReferences) {\n            const original = testReferences.find(r => r.id === broken.id && r.type === broken.type);\n            expect(original).toBeDefined();\n            expect(original?.exists).toBe(false);\n          }\n\n          // Property: Valid should be true only if all references exist\n          const allExist = testReferences.every(r => r.exists);\n          expect(result.data.valid).toBe(allExist);\n\n          return true;\n        }\n      ),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should return valid=true when all referenced entities exist', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.array(\n          fc.record({\n            type: fc.constantFrom('activity', 'event', 'accommodation', 'location') as fc.Arbitrary<'activity' | 'event' | 'accommodation' | 'location'>,\n            id: fc.uuid(),\n            label: fc.option(fc.string({ minLength: 1, maxLength: 100 })),\n          }),\n          { minLength: 1, maxLength: 10 }\n        ),\n        async (testReferences) => {\n          // Mock all references as existing\n          for (const ref of testReferences) {\n            const tableName = ref.type === 'activity' ? 'activities' : \n                            ref.type === 'event' ? 'events' :\n                            ref.type === 'accommodation' ? 'accommodations' : 'locations';\n            \n            mockFrom.mockReturnValueOnce({\n              select: jest.fn().mockReturnValue({\n                eq: jest.fn().mockReturnValue({\n                  single: jest.fn().mockResolvedValue({\n                    data: { id: ref.id },\n                    error: null,\n                  }),\n                }),\n              }),\n            });\n          }\n\n          const references: Reference[] = testReferences.map(r => ({\n            type: r.type,\n            id: r.id,\n            label: r.label || undefined,\n          }));\n\n          const result = await validateReferences(references);\n\n          // Property: Validation should succeed\n          expect(result.success).toBe(true);\n\n          if (!result.success) {\n            return true;\n          }\n\n          // Property: Should be valid with no broken references\n          expect(result.data.valid).toBe(true);\n          expect(result.data.brokenReferences).toHaveLength(0);\n\n          return true;\n        }\n      ),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should return valid=false when any referenced entity does not exist', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.record({\n          validRefs: fc.array(\n            fc.record({\n              type: fc.constantFrom('activity', 'event', 'accommodation', 'location') as fc.Arbitrary<'activity' | 'event' | 'accommodation' | 'location'>,\n              id: fc.uuid(),\n            }),\n            { minLength: 0, maxLength: 5 }\n          ),\n          brokenRef: fc.record({\n            type: fc.constantFrom('activity', 'event', 'accommodation', 'location') as fc.Arbitrary<'activity' | 'event' | 'accommodation' | 'location'>,\n            id: fc.uuid(),\n          }),\n        }),\n        async (testData) => {\n          // Mock valid references as existing\n          for (const ref of testData.validRefs) {\n            const tableName = ref.type === 'activity' ? 'activities' : \n                            ref.type === 'event' ? 'events' :\n                            ref.type === 'accommodation' ? 'accommodations' : 'locations';\n            \n            mockFrom.mockReturnValueOnce({\n              select: jest.fn().mockReturnValue({\n                eq: jest.fn().mockReturnValue({\n                  single: jest.fn().mockResolvedValue({\n                    data: { id: ref.id },\n                    error: null,\n                  }),\n                }),\n              }),\n            });\n          }\n\n          // Mock broken reference as not existing\n          const brokenTableName = testData.brokenRef.type === 'activity' ? 'activities' : \n                                 testData.brokenRef.type === 'event' ? 'events' :\n                                 testData.brokenRef.type === 'accommodation' ? 'accommodations' : 'locations';\n          \n          mockFrom.mockReturnValueOnce({\n            select: jest.fn().mockReturnValue({\n              eq: jest.fn().mockReturnValue({\n                single: jest.fn().mockResolvedValue({\n                  data: null,\n                  error: { code: 'PGRST116', message: 'Not found' },\n                }),\n              }),\n            }),\n          });\n\n          const references: Reference[] = [\n            ...testData.validRefs.map(r => ({ type: r.type, id: r.id })),\n            { type: testData.brokenRef.type, id: testData.brokenRef.id },\n          ];\n\n          const result = await validateReferences(references);\n\n          // Property: Validation should succeed\n          expect(result.success).toBe(true);\n\n          if (!result.success) {\n            return true;\n          }\n\n          // Property: Should be invalid with at least one broken reference\n          expect(result.data.valid).toBe(false);\n          expect(result.data.brokenReferences.length).toBeGreaterThan(0);\n\n          // Property: Broken reference should be the one we marked as non-existent\n          const foundBroken = result.data.brokenReferences.find(\n            r => r.id === testData.brokenRef.id && r.type === testData.brokenRef.type\n          );\n          expect(foundBroken).toBeDefined();\n\n          return true;\n        }\n      ),\n      { numRuns: 50 }\n    );\n  });\n});\n"],"names":["mockFrom","jest","fn","mockSupabase","from","mock","supabase","describe","beforeEach","clearAllMocks","it","fc","assert","asyncProperty","array","record","type","constantFrom","id","uuid","label","option","string","minLength","maxLength","exists","boolean","testReferences","ref","tableName","mockReturnValueOnce","select","mockReturnValue","eq","single","mockResolvedValue","data","error","code","message","references","map","r","undefined","result","validateReferences","expect","success","toBe","expectedBroken","filter","brokenReferences","length","broken","original","find","toBeDefined","allExist","every","valid","numRuns","toHaveLength","validRefs","brokenRef","testData","brokenTableName","toBeGreaterThan","foundBroken"],"mappings":"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"}