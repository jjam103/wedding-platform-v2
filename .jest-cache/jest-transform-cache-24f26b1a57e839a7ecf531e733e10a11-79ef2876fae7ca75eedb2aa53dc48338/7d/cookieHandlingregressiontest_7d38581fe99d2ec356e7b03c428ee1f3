a47dfc05b7e100853751e88db32ce896
"use strict";
jest.mock('next/headers', ()=>({
        cookies: jest.fn(()=>Promise.resolve(mockCookieStore))
    }));
// Mock the Supabase auth helpers to avoid ESM transformation issues with jose
jest.mock('@supabase/auth-helpers-nextjs', ()=>({
        createRouteHandlerClient: jest.fn(()=>({
                auth: {
                    getSession: jest.fn().mockResolvedValue({
                        data: {
                            session: null
                        },
                        error: null
                    })
                }
            }))
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _headers = require("next/headers");
const _authhelpersnextjs = require("@supabase/auth-helpers-nextjs");
/**
 * Cookie Handling Regression Test
 * 
 * This test prevents regression of the "cookies is not a function" bug
 * that occurred when API routes used incorrect Next.js 15 cookie API.
 * 
 * Bug Description:
 * - Next.js 15 changed cookies() from sync to async
 * - Old code: const cookieStore = cookies()
 * - New code: const cookieStore = await cookies()
 * - API routes that didn't await cookies() failed at runtime
 * - Result: "cookies is not a function" or "Cannot read properties of undefined"
 * 
 * This test validates:
 * - API routes correctly use async cookies() API
 * - Cookie-based authentication works correctly
 * - No runtime errors related to cookie handling
 * 
 * Validates: Requirements 5.2
 */ // Mock Next.js cookies() to avoid request context requirement
const mockCookieStore = {
    get: jest.fn(),
    set: jest.fn(),
    delete: jest.fn(),
    has: jest.fn(),
    getAll: jest.fn()
};
describe('Cookie Handling Regression Tests', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        // Reset mock cookie store
        mockCookieStore.get.mockReturnValue(undefined);
        mockCookieStore.has.mockReturnValue(false);
        mockCookieStore.getAll.mockReturnValue([]);
    });
    it('should handle cookies() as async function', async ()=>{
        // Test that cookies() returns a Promise
        const cookiesPromise = (0, _headers.cookies)();
        expect(cookiesPromise).toBeInstanceOf(Promise);
        // Test that awaiting cookies() works
        const cookieStore = await (0, _headers.cookies)();
        expect(cookieStore).toBeDefined();
        expect(typeof cookieStore.get).toBe('function');
        expect(typeof cookieStore.set).toBe('function');
    });
    it('should create Supabase client with async cookies', async ()=>{
        // This is the pattern that was broken
        const cookieStore = await (0, _headers.cookies)();
        // Create Supabase client with cookie store
        const supabase = (0, _authhelpersnextjs.createRouteHandlerClient)({
            cookies: ()=>cookieStore
        });
        expect(supabase).toBeDefined();
        expect(supabase.auth).toBeDefined();
    });
    it('should handle cookie operations correctly', async ()=>{
        const cookieStore = await (0, _headers.cookies)();
        // Test cookie operations
        const testCookieName = `test-cookie-${Date.now()}`;
        const testCookieValue = 'test-value';
        // Set cookie
        cookieStore.set(testCookieName, testCookieValue);
        expect(mockCookieStore.set).toHaveBeenCalledWith(testCookieName, testCookieValue);
        // Mock the get to return our test cookie
        mockCookieStore.get.mockReturnValue({
            name: testCookieName,
            value: testCookieValue
        });
        // Get cookie
        const cookie = cookieStore.get(testCookieName);
        expect(cookie).toBeDefined();
        expect(cookie?.value).toBe(testCookieValue);
        // Delete cookie
        cookieStore.delete(testCookieName);
        expect(mockCookieStore.delete).toHaveBeenCalledWith(testCookieName);
    });
    it('should handle missing cookies gracefully', async ()=>{
        const cookieStore = await (0, _headers.cookies)();
        // Try to get non-existent cookie
        const nonExistentCookie = cookieStore.get('non-existent-cookie');
        expect(nonExistentCookie).toBeUndefined();
    });
    it('should handle cookie store in API route pattern', async ()=>{
        // Simulate API route handler pattern
        const handler = async ()=>{
            const cookieStore = await (0, _headers.cookies)();
            const supabase = (0, _authhelpersnextjs.createRouteHandlerClient)({
                cookies: ()=>cookieStore
            });
            const { data: { session }, error } = await supabase.auth.getSession();
            return {
                session,
                error
            };
        };
        const result = await handler();
        expect(result).toBeDefined();
    // Session might be null if not authenticated, but should not throw error
    });
}); /**
 * Why This Test Would Have Caught the Bug:
 * 
 * The cookie handling bug occurred because:
 * 1. Next.js 15 made cookies() async
 * 2. Code didn't await cookies() call
 * 3. TypeScript didn't catch this (cookies() returns Promise<ReadonlyRequestCookies>)
 * 4. Runtime error: "cookies is not a function" or similar
 * 
 * This test explicitly:
 * - Tests that cookies() returns a Promise
 * - Tests that awaiting cookies() works correctly
 * - Tests the exact pattern used in API routes
 * - Validates cookie operations work as expected
 * 
 * If code doesn't await cookies(), this test will fail with a clear error
 * message indicating the async/await issue.
 * 
 * Note: This is a runtime test, not a TypeScript test. TypeScript might not
 * catch this issue because the types are correct - the bug is in the runtime
 * behavior of not awaiting the Promise.
 */ 

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvX190ZXN0c19fL3JlZ3Jlc3Npb24vY29va2llSGFuZGxpbmcucmVncmVzc2lvbi50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29va2llIEhhbmRsaW5nIFJlZ3Jlc3Npb24gVGVzdFxuICogXG4gKiBUaGlzIHRlc3QgcHJldmVudHMgcmVncmVzc2lvbiBvZiB0aGUgXCJjb29raWVzIGlzIG5vdCBhIGZ1bmN0aW9uXCIgYnVnXG4gKiB0aGF0IG9jY3VycmVkIHdoZW4gQVBJIHJvdXRlcyB1c2VkIGluY29ycmVjdCBOZXh0LmpzIDE1IGNvb2tpZSBBUEkuXG4gKiBcbiAqIEJ1ZyBEZXNjcmlwdGlvbjpcbiAqIC0gTmV4dC5qcyAxNSBjaGFuZ2VkIGNvb2tpZXMoKSBmcm9tIHN5bmMgdG8gYXN5bmNcbiAqIC0gT2xkIGNvZGU6IGNvbnN0IGNvb2tpZVN0b3JlID0gY29va2llcygpXG4gKiAtIE5ldyBjb2RlOiBjb25zdCBjb29raWVTdG9yZSA9IGF3YWl0IGNvb2tpZXMoKVxuICogLSBBUEkgcm91dGVzIHRoYXQgZGlkbid0IGF3YWl0IGNvb2tpZXMoKSBmYWlsZWQgYXQgcnVudGltZVxuICogLSBSZXN1bHQ6IFwiY29va2llcyBpcyBub3QgYSBmdW5jdGlvblwiIG9yIFwiQ2Fubm90IHJlYWQgcHJvcGVydGllcyBvZiB1bmRlZmluZWRcIlxuICogXG4gKiBUaGlzIHRlc3QgdmFsaWRhdGVzOlxuICogLSBBUEkgcm91dGVzIGNvcnJlY3RseSB1c2UgYXN5bmMgY29va2llcygpIEFQSVxuICogLSBDb29raWUtYmFzZWQgYXV0aGVudGljYXRpb24gd29ya3MgY29ycmVjdGx5XG4gKiAtIE5vIHJ1bnRpbWUgZXJyb3JzIHJlbGF0ZWQgdG8gY29va2llIGhhbmRsaW5nXG4gKiBcbiAqIFZhbGlkYXRlczogUmVxdWlyZW1lbnRzIDUuMlxuICovXG5cbi8vIE1vY2sgTmV4dC5qcyBjb29raWVzKCkgdG8gYXZvaWQgcmVxdWVzdCBjb250ZXh0IHJlcXVpcmVtZW50XG5jb25zdCBtb2NrQ29va2llU3RvcmUgPSB7XG4gIGdldDogamVzdC5mbigpLFxuICBzZXQ6IGplc3QuZm4oKSxcbiAgZGVsZXRlOiBqZXN0LmZuKCksXG4gIGhhczogamVzdC5mbigpLFxuICBnZXRBbGw6IGplc3QuZm4oKSxcbn07XG5cbmplc3QubW9jaygnbmV4dC9oZWFkZXJzJywgKCkgPT4gKHtcbiAgY29va2llczogamVzdC5mbigoKSA9PiBQcm9taXNlLnJlc29sdmUobW9ja0Nvb2tpZVN0b3JlKSksXG59KSk7XG5cbi8vIE1vY2sgdGhlIFN1cGFiYXNlIGF1dGggaGVscGVycyB0byBhdm9pZCBFU00gdHJhbnNmb3JtYXRpb24gaXNzdWVzIHdpdGggam9zZVxuamVzdC5tb2NrKCdAc3VwYWJhc2UvYXV0aC1oZWxwZXJzLW5leHRqcycsICgpID0+ICh7XG4gIGNyZWF0ZVJvdXRlSGFuZGxlckNsaWVudDogamVzdC5mbigoKSA9PiAoe1xuICAgIGF1dGg6IHtcbiAgICAgIGdldFNlc3Npb246IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgc2Vzc2lvbjogbnVsbCB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pLFxuICAgIH0sXG4gIH0pKSxcbn0pKTtcblxuaW1wb3J0IHsgY29va2llcyB9IGZyb20gJ25leHQvaGVhZGVycyc7XG5pbXBvcnQgeyBjcmVhdGVSb3V0ZUhhbmRsZXJDbGllbnQgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1oZWxwZXJzLW5leHRqcyc7XG5cbmRlc2NyaWJlKCdDb29raWUgSGFuZGxpbmcgUmVncmVzc2lvbiBUZXN0cycsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgLy8gUmVzZXQgbW9jayBjb29raWUgc3RvcmVcbiAgICBtb2NrQ29va2llU3RvcmUuZ2V0Lm1vY2tSZXR1cm5WYWx1ZSh1bmRlZmluZWQpO1xuICAgIG1vY2tDb29raWVTdG9yZS5oYXMubW9ja1JldHVyblZhbHVlKGZhbHNlKTtcbiAgICBtb2NrQ29va2llU3RvcmUuZ2V0QWxsLm1vY2tSZXR1cm5WYWx1ZShbXSk7XG4gIH0pO1xuICBpdCgnc2hvdWxkIGhhbmRsZSBjb29raWVzKCkgYXMgYXN5bmMgZnVuY3Rpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgLy8gVGVzdCB0aGF0IGNvb2tpZXMoKSByZXR1cm5zIGEgUHJvbWlzZVxuICAgIGNvbnN0IGNvb2tpZXNQcm9taXNlID0gY29va2llcygpO1xuICAgIGV4cGVjdChjb29raWVzUHJvbWlzZSkudG9CZUluc3RhbmNlT2YoUHJvbWlzZSk7XG4gICAgXG4gICAgLy8gVGVzdCB0aGF0IGF3YWl0aW5nIGNvb2tpZXMoKSB3b3Jrc1xuICAgIGNvbnN0IGNvb2tpZVN0b3JlID0gYXdhaXQgY29va2llcygpO1xuICAgIGV4cGVjdChjb29raWVTdG9yZSkudG9CZURlZmluZWQoKTtcbiAgICBleHBlY3QodHlwZW9mIGNvb2tpZVN0b3JlLmdldCkudG9CZSgnZnVuY3Rpb24nKTtcbiAgICBleHBlY3QodHlwZW9mIGNvb2tpZVN0b3JlLnNldCkudG9CZSgnZnVuY3Rpb24nKTtcbiAgfSk7XG4gIFxuICBpdCgnc2hvdWxkIGNyZWF0ZSBTdXBhYmFzZSBjbGllbnQgd2l0aCBhc3luYyBjb29raWVzJywgYXN5bmMgKCkgPT4ge1xuICAgIC8vIFRoaXMgaXMgdGhlIHBhdHRlcm4gdGhhdCB3YXMgYnJva2VuXG4gICAgY29uc3QgY29va2llU3RvcmUgPSBhd2FpdCBjb29raWVzKCk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIFN1cGFiYXNlIGNsaWVudCB3aXRoIGNvb2tpZSBzdG9yZVxuICAgIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlUm91dGVIYW5kbGVyQ2xpZW50KHsgXG4gICAgICBjb29raWVzOiAoKSA9PiBjb29raWVTdG9yZSBcbiAgICB9KTtcbiAgICBcbiAgICBleHBlY3Qoc3VwYWJhc2UpLnRvQmVEZWZpbmVkKCk7XG4gICAgZXhwZWN0KHN1cGFiYXNlLmF1dGgpLnRvQmVEZWZpbmVkKCk7XG4gIH0pO1xuICBcbiAgaXQoJ3Nob3VsZCBoYW5kbGUgY29va2llIG9wZXJhdGlvbnMgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGNvb2tpZVN0b3JlID0gYXdhaXQgY29va2llcygpO1xuICAgIFxuICAgIC8vIFRlc3QgY29va2llIG9wZXJhdGlvbnNcbiAgICBjb25zdCB0ZXN0Q29va2llTmFtZSA9IGB0ZXN0LWNvb2tpZS0ke0RhdGUubm93KCl9YDtcbiAgICBjb25zdCB0ZXN0Q29va2llVmFsdWUgPSAndGVzdC12YWx1ZSc7XG4gICAgXG4gICAgLy8gU2V0IGNvb2tpZVxuICAgIGNvb2tpZVN0b3JlLnNldCh0ZXN0Q29va2llTmFtZSwgdGVzdENvb2tpZVZhbHVlKTtcbiAgICBleHBlY3QobW9ja0Nvb2tpZVN0b3JlLnNldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgodGVzdENvb2tpZU5hbWUsIHRlc3RDb29raWVWYWx1ZSk7XG4gICAgXG4gICAgLy8gTW9jayB0aGUgZ2V0IHRvIHJldHVybiBvdXIgdGVzdCBjb29raWVcbiAgICBtb2NrQ29va2llU3RvcmUuZ2V0Lm1vY2tSZXR1cm5WYWx1ZSh7IG5hbWU6IHRlc3RDb29raWVOYW1lLCB2YWx1ZTogdGVzdENvb2tpZVZhbHVlIH0pO1xuICAgIFxuICAgIC8vIEdldCBjb29raWVcbiAgICBjb25zdCBjb29raWUgPSBjb29raWVTdG9yZS5nZXQodGVzdENvb2tpZU5hbWUpO1xuICAgIGV4cGVjdChjb29raWUpLnRvQmVEZWZpbmVkKCk7XG4gICAgZXhwZWN0KGNvb2tpZT8udmFsdWUpLnRvQmUodGVzdENvb2tpZVZhbHVlKTtcbiAgICBcbiAgICAvLyBEZWxldGUgY29va2llXG4gICAgY29va2llU3RvcmUuZGVsZXRlKHRlc3RDb29raWVOYW1lKTtcbiAgICBleHBlY3QobW9ja0Nvb2tpZVN0b3JlLmRlbGV0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgodGVzdENvb2tpZU5hbWUpO1xuICB9KTtcbiAgXG4gIGl0KCdzaG91bGQgaGFuZGxlIG1pc3NpbmcgY29va2llcyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGNvb2tpZVN0b3JlID0gYXdhaXQgY29va2llcygpO1xuICAgIFxuICAgIC8vIFRyeSB0byBnZXQgbm9uLWV4aXN0ZW50IGNvb2tpZVxuICAgIGNvbnN0IG5vbkV4aXN0ZW50Q29va2llID0gY29va2llU3RvcmUuZ2V0KCdub24tZXhpc3RlbnQtY29va2llJyk7XG4gICAgZXhwZWN0KG5vbkV4aXN0ZW50Q29va2llKS50b0JlVW5kZWZpbmVkKCk7XG4gIH0pO1xuICBcbiAgaXQoJ3Nob3VsZCBoYW5kbGUgY29va2llIHN0b3JlIGluIEFQSSByb3V0ZSBwYXR0ZXJuJywgYXN5bmMgKCkgPT4ge1xuICAgIC8vIFNpbXVsYXRlIEFQSSByb3V0ZSBoYW5kbGVyIHBhdHRlcm5cbiAgICBjb25zdCBoYW5kbGVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29va2llU3RvcmUgPSBhd2FpdCBjb29raWVzKCk7XG4gICAgICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZVJvdXRlSGFuZGxlckNsaWVudCh7IFxuICAgICAgICBjb29raWVzOiAoKSA9PiBjb29raWVTdG9yZSBcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uKCk7XG4gICAgICBcbiAgICAgIHJldHVybiB7IHNlc3Npb24sIGVycm9yIH07XG4gICAgfTtcbiAgICBcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoYW5kbGVyKCk7XG4gICAgZXhwZWN0KHJlc3VsdCkudG9CZURlZmluZWQoKTtcbiAgICAvLyBTZXNzaW9uIG1pZ2h0IGJlIG51bGwgaWYgbm90IGF1dGhlbnRpY2F0ZWQsIGJ1dCBzaG91bGQgbm90IHRocm93IGVycm9yXG4gIH0pO1xufSk7XG5cbi8qKlxuICogV2h5IFRoaXMgVGVzdCBXb3VsZCBIYXZlIENhdWdodCB0aGUgQnVnOlxuICogXG4gKiBUaGUgY29va2llIGhhbmRsaW5nIGJ1ZyBvY2N1cnJlZCBiZWNhdXNlOlxuICogMS4gTmV4dC5qcyAxNSBtYWRlIGNvb2tpZXMoKSBhc3luY1xuICogMi4gQ29kZSBkaWRuJ3QgYXdhaXQgY29va2llcygpIGNhbGxcbiAqIDMuIFR5cGVTY3JpcHQgZGlkbid0IGNhdGNoIHRoaXMgKGNvb2tpZXMoKSByZXR1cm5zIFByb21pc2U8UmVhZG9ubHlSZXF1ZXN0Q29va2llcz4pXG4gKiA0LiBSdW50aW1lIGVycm9yOiBcImNvb2tpZXMgaXMgbm90IGEgZnVuY3Rpb25cIiBvciBzaW1pbGFyXG4gKiBcbiAqIFRoaXMgdGVzdCBleHBsaWNpdGx5OlxuICogLSBUZXN0cyB0aGF0IGNvb2tpZXMoKSByZXR1cm5zIGEgUHJvbWlzZVxuICogLSBUZXN0cyB0aGF0IGF3YWl0aW5nIGNvb2tpZXMoKSB3b3JrcyBjb3JyZWN0bHlcbiAqIC0gVGVzdHMgdGhlIGV4YWN0IHBhdHRlcm4gdXNlZCBpbiBBUEkgcm91dGVzXG4gKiAtIFZhbGlkYXRlcyBjb29raWUgb3BlcmF0aW9ucyB3b3JrIGFzIGV4cGVjdGVkXG4gKiBcbiAqIElmIGNvZGUgZG9lc24ndCBhd2FpdCBjb29raWVzKCksIHRoaXMgdGVzdCB3aWxsIGZhaWwgd2l0aCBhIGNsZWFyIGVycm9yXG4gKiBtZXNzYWdlIGluZGljYXRpbmcgdGhlIGFzeW5jL2F3YWl0IGlzc3VlLlxuICogXG4gKiBOb3RlOiBUaGlzIGlzIGEgcnVudGltZSB0ZXN0LCBub3QgYSBUeXBlU2NyaXB0IHRlc3QuIFR5cGVTY3JpcHQgbWlnaHQgbm90XG4gKiBjYXRjaCB0aGlzIGlzc3VlIGJlY2F1c2UgdGhlIHR5cGVzIGFyZSBjb3JyZWN0IC0gdGhlIGJ1ZyBpcyBpbiB0aGUgcnVudGltZVxuICogYmVoYXZpb3Igb2Ygbm90IGF3YWl0aW5nIHRoZSBQcm9taXNlLlxuICovXG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJjb29raWVzIiwiZm4iLCJQcm9taXNlIiwicmVzb2x2ZSIsIm1vY2tDb29raWVTdG9yZSIsImNyZWF0ZVJvdXRlSGFuZGxlckNsaWVudCIsImF1dGgiLCJnZXRTZXNzaW9uIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJkYXRhIiwic2Vzc2lvbiIsImVycm9yIiwiZ2V0Iiwic2V0IiwiZGVsZXRlIiwiaGFzIiwiZ2V0QWxsIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tSZXR1cm5WYWx1ZSIsInVuZGVmaW5lZCIsIml0IiwiY29va2llc1Byb21pc2UiLCJleHBlY3QiLCJ0b0JlSW5zdGFuY2VPZiIsImNvb2tpZVN0b3JlIiwidG9CZURlZmluZWQiLCJ0b0JlIiwic3VwYWJhc2UiLCJ0ZXN0Q29va2llTmFtZSIsIkRhdGUiLCJub3ciLCJ0ZXN0Q29va2llVmFsdWUiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsIm5hbWUiLCJ2YWx1ZSIsImNvb2tpZSIsIm5vbkV4aXN0ZW50Q29va2llIiwidG9CZVVuZGVmaW5lZCIsImhhbmRsZXIiLCJyZXN1bHQiXSwibWFwcGluZ3MiOiI7QUE4QkFBLEtBQUtDLElBQUksQ0FBQyxnQkFBZ0IsSUFBTyxDQUFBO1FBQy9CQyxTQUFTRixLQUFLRyxFQUFFLENBQUMsSUFBTUMsUUFBUUMsT0FBTyxDQUFDQztJQUN6QyxDQUFBO0FBRUEsOEVBQThFO0FBQzlFTixLQUFLQyxJQUFJLENBQUMsaUNBQWlDLElBQU8sQ0FBQTtRQUNoRE0sMEJBQTBCUCxLQUFLRyxFQUFFLENBQUMsSUFBTyxDQUFBO2dCQUN2Q0ssTUFBTTtvQkFDSkMsWUFBWVQsS0FBS0csRUFBRSxHQUFHTyxpQkFBaUIsQ0FBQzt3QkFDdENDLE1BQU07NEJBQUVDLFNBQVM7d0JBQUs7d0JBQ3RCQyxPQUFPO29CQUNUO2dCQUNGO1lBQ0YsQ0FBQTtJQUNGLENB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