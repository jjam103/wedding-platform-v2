{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/utils/slugs.property.test.ts"],"sourcesContent":["/**\n * Property-Based Tests for Slug Generation\n * \n * Feature: destination-wedding-platform\n * Property 19: Slug Auto-Generation\n * Validates: Requirements 31.1, 31.5\n */\n\nimport * as fc from 'fast-check';\nimport { generateSlug, isValidSlug, normalizeSlug, makeUniqueSlug } from './slugs';\n\ndescribe('Feature: destination-wedding-platform, Property 19: Slug Auto-Generation', () => {\n  describe('generateSlug', () => {\n    it('should always produce lowercase slugs', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 100 }),\n          (title) => {\n            const slug = generateSlug(title);\n            // If slug is not empty, it should be lowercase\n            if (slug.length > 0) {\n              expect(slug).toBe(slug.toLowerCase());\n            }\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should replace spaces with hyphens', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 100 }),\n          (title) => {\n            const slug = generateSlug(title);\n            // Slug should not contain spaces\n            expect(slug).not.toContain(' ');\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should remove special characters except hyphens', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 100 }),\n          (title) => {\n            const slug = generateSlug(title);\n            // Slug should only contain lowercase letters, numbers, and hyphens\n            if (slug.length > 0) {\n              expect(slug).toMatch(/^[a-z0-9-]+$/);\n            }\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should not have leading or trailing hyphens', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 100 }),\n          (title) => {\n            const slug = generateSlug(title);\n            if (slug.length > 0) {\n              expect(slug).not.toMatch(/^-/);\n              expect(slug).not.toMatch(/-$/);\n            }\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should not have consecutive hyphens', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 100 }),\n          (title) => {\n            const slug = generateSlug(title);\n            expect(slug).not.toContain('--');\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should be idempotent (generating slug from slug produces same result)', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 100 }),\n          (title) => {\n            const slug1 = generateSlug(title);\n            const slug2 = generateSlug(slug1);\n            expect(slug1).toBe(slug2);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should handle titles with only special characters by returning empty string', () => {\n      const specialCharsOnly = ['!!!', '@@@', '###', '***', '...', '---'];\n      specialCharsOnly.forEach((title) => {\n        const slug = generateSlug(title);\n        expect(slug).toBe('');\n      });\n    });\n\n    it('should preserve alphanumeric characters', () => {\n      fc.assert(\n        fc.property(\n          fc.stringOf(fc.constantFrom('a', 'b', 'c', '1', '2', '3', ' ', '-')),\n          (title) => {\n            const slug = generateSlug(title);\n            // Count alphanumeric chars in title\n            const alphanumericInTitle = (title.match(/[a-z0-9]/gi) || []).length;\n            // Count alphanumeric chars in slug\n            const alphanumericInSlug = (slug.match(/[a-z0-9]/g) || []).length;\n            // Slug should preserve all alphanumeric characters\n            expect(alphanumericInSlug).toBe(alphanumericInTitle);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n  });\n\n  describe('isValidSlug', () => {\n    it('should return false for empty strings', () => {\n      expect(isValidSlug('')).toBe(false);\n      expect(isValidSlug('   ')).toBe(false);\n    });\n\n    it('should return false for slugs with only special characters', () => {\n      expect(isValidSlug('---')).toBe(false);\n      expect(isValidSlug('-')).toBe(false);\n    });\n\n    it('should return true for valid slugs', () => {\n      expect(isValidSlug('hello-world')).toBe(true);\n      expect(isValidSlug('test123')).toBe(true);\n      expect(isValidSlug('my-page-2')).toBe(true);\n    });\n\n    it('should return false for slugs with uppercase letters', () => {\n      expect(isValidSlug('Hello-World')).toBe(false);\n    });\n\n    it('should return false for slugs with spaces', () => {\n      expect(isValidSlug('hello world')).toBe(false);\n    });\n\n    it('should accept any valid slug generated by generateSlug', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 100 }).filter((s) => /[a-z0-9]/i.test(s)),\n          (title) => {\n            const slug = generateSlug(title);\n            if (slug.length > 0) {\n              expect(isValidSlug(slug)).toBe(true);\n            }\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n  });\n\n  describe('normalizeSlug', () => {\n    it('should produce the same result as generateSlug', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 100 }),\n          (input) => {\n            const normalized = normalizeSlug(input);\n            const generated = generateSlug(input);\n            expect(normalized).toBe(generated);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n  });\n\n  describe('makeUniqueSlug', () => {\n    it('should return the base slug if it does not exist', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug).filter((s) => s.length > 0),\n          fc.array(fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug)),\n          (baseSlug, existingSlugs) => {\n            fc.pre(!existingSlugs.includes(baseSlug));\n            const unique = makeUniqueSlug(baseSlug, existingSlugs);\n            expect(unique).toBe(baseSlug);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should append -2 if base slug exists', () => {\n      const baseSlug = 'hello-world';\n      const existingSlugs = ['hello-world'];\n      const unique = makeUniqueSlug(baseSlug, existingSlugs);\n      expect(unique).toBe('hello-world-2');\n    });\n\n    it('should increment counter until unique slug is found', () => {\n      const baseSlug = 'hello-world';\n      const existingSlugs = ['hello-world', 'hello-world-2', 'hello-world-3'];\n      const unique = makeUniqueSlug(baseSlug, existingSlugs);\n      expect(unique).toBe('hello-world-4');\n    });\n\n    it('should always produce a unique slug', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug).filter((s) => s.length > 0),\n          fc.array(fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug), { maxLength: 20 }),\n          (baseSlug, existingSlugs) => {\n            const unique = makeUniqueSlug(baseSlug, existingSlugs);\n            expect(existingSlugs).not.toContain(unique);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should preserve the base slug structure', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug).filter((s) => s.length > 0),\n          fc.array(fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug), { maxLength: 20 }),\n          (baseSlug, existingSlugs) => {\n            const unique = makeUniqueSlug(baseSlug, existingSlugs);\n            // Unique slug should start with base slug\n            expect(unique.startsWith(baseSlug) || unique === baseSlug).toBe(true);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n  });\n});\n"],"names":["describe","it","fc","assert","property","string","minLength","maxLength","title","slug","generateSlug","length","expect","toBe","toLowerCase","numRuns","not","toContain","toMatch","slug1","slug2","specialCharsOnly","forEach","stringOf","constantFrom","alphanumericInTitle","match","alphanumericInSlug","isValidSlug","filter","s","test","input","normalized","normalizeSlug","generated","map","array","baseSlug","existingSlugs","pre","includes","unique","makeUniqueSlug","startsWith"],"mappings":"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"}