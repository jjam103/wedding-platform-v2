e7b95a265bdf99369a4c2257c0c16921
"use strict";
/**
 * Async Params Regression Test
 * 
 * This test prevents regression of the "params is a Promise" bug
 * that occurred when dynamic routes didn't handle async params correctly.
 * 
 * Bug Description:
 * - Next.js 15 made params async in dynamic routes
 * - Old code: function Page({ params }) { const { id } = params; }
 * - New code: async function Page({ params }) { const { id } = await params; }
 * - Routes that didn't await params tried to access properties on a Promise
 * - Result: "Cannot read property 'id' of undefined" or params.id was a Promise
 * 
 * This test validates:
 * - Dynamic routes correctly handle async params
 * - Params are awaited before accessing properties
 * - No runtime errors related to Promise access
 * 
 * Validates: Requirements 5.3
 */ describe('Async Params Regression Tests', ()=>{
    it('should handle params as async in dynamic routes', async ()=>{
        // Simulate Next.js 15 params behavior
        const mockParams = Promise.resolve({
            id: 'test-id',
            slug: 'test-slug'
        });
        // Test that params is a Promise
        expect(mockParams).toBeInstanceOf(Promise);
        // Test that awaiting params works
        const params = await mockParams;
        expect(params).toBeDefined();
        expect(params.id).toBe('test-id');
        expect(params.slug).toBe('test-slug');
    });
    it('should handle single param routes correctly', async ()=>{
        // Simulate [id] route
        const mockParams = Promise.resolve({
            id: 'test-123'
        });
        const params = await mockParams;
        expect(params.id).toBe('test-123');
        expect(typeof params.id).toBe('string');
    });
    it('should handle multiple param routes correctly', async ()=>{
        // Simulate [type]/[slug] route
        const mockParams = Promise.resolve({
            type: 'event',
            slug: 'wedding-ceremony'
        });
        const params = await mockParams;
        expect(params.type).toBe('event');
        expect(params.slug).toBe('wedding-ceremony');
    });
    it('should handle nested dynamic routes correctly', async ()=>{
        // Simulate accommodations/[id]/room-types route
        const mockParams = Promise.resolve({
            id: 'accommodation-123'
        });
        const params = await mockParams;
        expect(params.id).toBe('accommodation-123');
    });
    it('should fail if params not awaited (demonstrates the bug)', async ()=>{
        const mockParams = Promise.resolve({
            id: 'test-id'
        });
        // This is what the buggy code did - try to access property on Promise
        // @ts-expect-error - Intentionally accessing Promise property to demonstrate bug
        const buggyId = mockParams.id;
        // This would be undefined or a Promise, not the actual value
        expect(buggyId).toBeUndefined();
        // Correct way - await first
        const params = await mockParams;
        const correctId = params.id;
        expect(correctId).toBe('test-id');
    });
    it('should handle params in page component pattern', async ()=>{
        const mockPageComponent = async ({ params })=>{
            const { id } = await params;
            return {
                id
            };
        };
        const result = await mockPageComponent({
            params: Promise.resolve({
                id: 'test-id'
            })
        });
        expect(result.id).toBe('test-id');
    });
    it('should handle params in API route pattern', async ()=>{
        const mockApiRoute = async (request, context)=>{
            const { id } = await context.params;
            return {
                id
            };
        };
        const result = await mockApiRoute(new Request('http://localhost:3000/api/test/123'), {
            params: Promise.resolve({
                id: '123'
            })
        });
        expect(result.id).toBe('123');
    });
    it('should handle params with searchParams together', async ()=>{
        const mockPageComponent = async ({ params, searchParams })=>{
            const { id } = await params;
            const { filter } = await searchParams;
            return {
                id,
                filter
            };
        };
        const result = await mockPageComponent({
            params: Promise.resolve({
                id: 'test-id'
            }),
            searchParams: Promise.resolve({
                filter: 'active'
            })
        });
        expect(result.id).toBe('test-id');
        expect(result.filter).toBe('active');
    });
}); /**
 * Why This Test Would Have Caught the Bug:
 * 
 * The async params bug occurred because:
 * 1. Next.js 15 made params async in dynamic routes
 * 2. Code tried to destructure params directly: const { id } = params
 * 3. This accessed properties on a Promise, not the resolved value
 * 4. Result: id was undefined or a Promise, causing runtime errors
 * 
 * This test explicitly:
 * - Tests that params is a Promise
 * - Tests that awaiting params works correctly
 * - Tests the exact patterns used in pages and API routes
 * - Demonstrates what happens when params is not awaited
 * 
 * If code doesn't await params, this test will fail with a clear error
 * showing that params.id is undefined or a Promise.
 * 
 * Note: TypeScript might not catch this if the types aren't strict enough.
 * The bug is in the runtime behavior of accessing Promise properties.
 */ 

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvX190ZXN0c19fL3JlZ3Jlc3Npb24vYXN5bmNQYXJhbXMucmVncmVzc2lvbi50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQXN5bmMgUGFyYW1zIFJlZ3Jlc3Npb24gVGVzdFxuICogXG4gKiBUaGlzIHRlc3QgcHJldmVudHMgcmVncmVzc2lvbiBvZiB0aGUgXCJwYXJhbXMgaXMgYSBQcm9taXNlXCIgYnVnXG4gKiB0aGF0IG9jY3VycmVkIHdoZW4gZHluYW1pYyByb3V0ZXMgZGlkbid0IGhhbmRsZSBhc3luYyBwYXJhbXMgY29ycmVjdGx5LlxuICogXG4gKiBCdWcgRGVzY3JpcHRpb246XG4gKiAtIE5leHQuanMgMTUgbWFkZSBwYXJhbXMgYXN5bmMgaW4gZHluYW1pYyByb3V0ZXNcbiAqIC0gT2xkIGNvZGU6IGZ1bmN0aW9uIFBhZ2UoeyBwYXJhbXMgfSkgeyBjb25zdCB7IGlkIH0gPSBwYXJhbXM7IH1cbiAqIC0gTmV3IGNvZGU6IGFzeW5jIGZ1bmN0aW9uIFBhZ2UoeyBwYXJhbXMgfSkgeyBjb25zdCB7IGlkIH0gPSBhd2FpdCBwYXJhbXM7IH1cbiAqIC0gUm91dGVzIHRoYXQgZGlkbid0IGF3YWl0IHBhcmFtcyB0cmllZCB0byBhY2Nlc3MgcHJvcGVydGllcyBvbiBhIFByb21pc2VcbiAqIC0gUmVzdWx0OiBcIkNhbm5vdCByZWFkIHByb3BlcnR5ICdpZCcgb2YgdW5kZWZpbmVkXCIgb3IgcGFyYW1zLmlkIHdhcyBhIFByb21pc2VcbiAqIFxuICogVGhpcyB0ZXN0IHZhbGlkYXRlczpcbiAqIC0gRHluYW1pYyByb3V0ZXMgY29ycmVjdGx5IGhhbmRsZSBhc3luYyBwYXJhbXNcbiAqIC0gUGFyYW1zIGFyZSBhd2FpdGVkIGJlZm9yZSBhY2Nlc3NpbmcgcHJvcGVydGllc1xuICogLSBObyBydW50aW1lIGVycm9ycyByZWxhdGVkIHRvIFByb21pc2UgYWNjZXNzXG4gKiBcbiAqIFZhbGlkYXRlczogUmVxdWlyZW1lbnRzIDUuM1xuICovXG5cbmRlc2NyaWJlKCdBc3luYyBQYXJhbXMgUmVncmVzc2lvbiBUZXN0cycsICgpID0+IHtcbiAgaXQoJ3Nob3VsZCBoYW5kbGUgcGFyYW1zIGFzIGFzeW5jIGluIGR5bmFtaWMgcm91dGVzJywgYXN5bmMgKCkgPT4ge1xuICAgIC8vIFNpbXVsYXRlIE5leHQuanMgMTUgcGFyYW1zIGJlaGF2aW9yXG4gICAgY29uc3QgbW9ja1BhcmFtcyA9IFByb21pc2UucmVzb2x2ZSh7IGlkOiAndGVzdC1pZCcsIHNsdWc6ICd0ZXN0LXNsdWcnIH0pO1xuICAgIFxuICAgIC8vIFRlc3QgdGhhdCBwYXJhbXMgaXMgYSBQcm9taXNlXG4gICAgZXhwZWN0KG1vY2tQYXJhbXMpLnRvQmVJbnN0YW5jZU9mKFByb21pc2UpO1xuICAgIFxuICAgIC8vIFRlc3QgdGhhdCBhd2FpdGluZyBwYXJhbXMgd29ya3NcbiAgICBjb25zdCBwYXJhbXMgPSBhd2FpdCBtb2NrUGFyYW1zO1xuICAgIGV4cGVjdChwYXJhbXMpLnRvQmVEZWZpbmVkKCk7XG4gICAgZXhwZWN0KHBhcmFtcy5pZCkudG9CZSgndGVzdC1pZCcpO1xuICAgIGV4cGVjdChwYXJhbXMuc2x1ZykudG9CZSgndGVzdC1zbHVnJyk7XG4gIH0pO1xuICBcbiAgaXQoJ3Nob3VsZCBoYW5kbGUgc2luZ2xlIHBhcmFtIHJvdXRlcyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgLy8gU2ltdWxhdGUgW2lkXSByb3V0ZVxuICAgIGNvbnN0IG1vY2tQYXJhbXMgPSBQcm9taXNlLnJlc29sdmUoeyBpZDogJ3Rlc3QtMTIzJyB9KTtcbiAgICBcbiAgICBjb25zdCBwYXJhbXMgPSBhd2FpdCBtb2NrUGFyYW1zO1xuICAgIGV4cGVjdChwYXJhbXMuaWQpLnRvQmUoJ3Rlc3QtMTIzJyk7XG4gICAgZXhwZWN0KHR5cGVvZiBwYXJhbXMuaWQpLnRvQmUoJ3N0cmluZycpO1xuICB9KTtcbiAgXG4gIGl0KCdzaG91bGQgaGFuZGxlIG11bHRpcGxlIHBhcmFtIHJvdXRlcyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgLy8gU2ltdWxhdGUgW3R5cGVdL1tzbHVnXSByb3V0ZVxuICAgIGNvbnN0IG1vY2tQYXJhbXMgPSBQcm9taXNlLnJlc29sdmUoeyBcbiAgICAgIHR5cGU6ICdldmVudCcsIFxuICAgICAgc2x1ZzogJ3dlZGRpbmctY2VyZW1vbnknIFxuICAgIH0pO1xuICAgIFxuICAgIGNvbnN0IHBhcmFtcyA9IGF3YWl0IG1vY2tQYXJhbXM7XG4gICAgZXhwZWN0KHBhcmFtcy50eXBlKS50b0JlKCdldmVudCcpO1xuICAgIGV4cGVjdChwYXJhbXMuc2x1ZykudG9CZSgnd2VkZGluZy1jZXJlbW9ueScpO1xuICB9KTtcbiAgXG4gIGl0KCdzaG91bGQgaGFuZGxlIG5lc3RlZCBkeW5hbWljIHJvdXRlcyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgLy8gU2ltdWxhdGUgYWNjb21tb2RhdGlvbnMvW2lkXS9yb29tLXR5cGVzIHJvdXRlXG4gICAgY29uc3QgbW9ja1BhcmFtcyA9IFByb21pc2UucmVzb2x2ZSh7IGlkOiAnYWNjb21tb2RhdGlvbi0xMjMnIH0pO1xuICAgIFxuICAgIGNvbnN0IHBhcmFtcyA9IGF3YWl0IG1vY2tQYXJhbXM7XG4gICAgZXhwZWN0KHBhcmFtcy5pZCkudG9CZSgnYWNjb21tb2RhdGlvbi0xMjMnKTtcbiAgfSk7XG4gIFxuICBpdCgnc2hvdWxkIGZhaWwgaWYgcGFyYW1zIG5vdCBhd2FpdGVkIChkZW1vbnN0cmF0ZXMgdGhlIGJ1ZyknLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1BhcmFtcyA9IFByb21pc2UucmVzb2x2ZSh7IGlkOiAndGVzdC1pZCcgfSk7XG4gICAgXG4gICAgLy8gVGhpcyBpcyB3aGF0IHRoZSBidWdneSBjb2RlIGRpZCAtIHRyeSB0byBhY2Nlc3MgcHJvcGVydHkgb24gUHJvbWlzZVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBJbnRlbnRpb25hbGx5IGFjY2Vzc2luZyBQcm9taXNlIHByb3BlcnR5IHRvIGRlbW9uc3RyYXRlIGJ1Z1xuICAgIGNvbnN0IGJ1Z2d5SWQgPSBtb2NrUGFyYW1zLmlkO1xuICAgIFxuICAgIC8vIFRoaXMgd291bGQgYmUgdW5kZWZpbmVkIG9yIGEgUHJvbWlzZSwgbm90IHRoZSBhY3R1YWwgdmFsdWVcbiAgICBleHBlY3QoYnVnZ3lJZCkudG9CZVVuZGVmaW5lZCgpO1xuICAgIFxuICAgIC8vIENvcnJlY3Qgd2F5IC0gYXdhaXQgZmlyc3RcbiAgICBjb25zdCBwYXJhbXMgPSBhd2FpdCBtb2NrUGFyYW1zO1xuICAgIGNvbnN0IGNvcnJlY3RJZCA9IHBhcmFtcy5pZDtcbiAgICBleHBlY3QoY29ycmVjdElkKS50b0JlKCd0ZXN0LWlkJyk7XG4gIH0pO1xuICBcbiAgaXQoJ3Nob3VsZCBoYW5kbGUgcGFyYW1zIGluIHBhZ2UgY29tcG9uZW50IHBhdHRlcm4nLCBhc3luYyAoKSA9PiB7XG4gICAgLy8gU2ltdWxhdGUgcGFnZSBjb21wb25lbnQgd2l0aCBhc3luYyBwYXJhbXNcbiAgICBpbnRlcmZhY2UgUGFnZVByb3BzIHtcbiAgICAgIHBhcmFtczogUHJvbWlzZTx7IGlkOiBzdHJpbmcgfT47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IG1vY2tQYWdlQ29tcG9uZW50ID0gYXN5bmMgKHsgcGFyYW1zIH06IFBhZ2VQcm9wcykgPT4ge1xuICAgICAgY29uc3QgeyBpZCB9ID0gYXdhaXQgcGFyYW1zO1xuICAgICAgcmV0dXJuIHsgaWQgfTtcbiAgICB9O1xuICAgIFxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1vY2tQYWdlQ29tcG9uZW50KHsgXG4gICAgICBwYXJhbXM6IFByb21pc2UucmVzb2x2ZSh7IGlkOiAndGVzdC1pZCcgfSkgXG4gICAgfSk7XG4gICAgXG4gICAgZXhwZWN0KHJlc3VsdC5pZCkudG9CZSgndGVzdC1pZCcpO1xuICB9KTtcbiAgXG4gIGl0KCdzaG91bGQgaGFuZGxlIHBhcmFtcyBpbiBBUEkgcm91dGUgcGF0dGVybicsIGFzeW5jICgpID0+IHtcbiAgICAvLyBTaW11bGF0ZSBBUEkgcm91dGUgd2l0aCBhc3luYyBwYXJhbXNcbiAgICBpbnRlcmZhY2UgUm91dGVDb250ZXh0IHtcbiAgICAgIHBhcmFtczogUHJvbWlzZTx7IGlkOiBzdHJpbmcgfT47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IG1vY2tBcGlSb3V0ZSA9IGFzeW5jIChcbiAgICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgICBjb250ZXh0OiBSb3V0ZUNvbnRleHRcbiAgICApID0+IHtcbiAgICAgIGNvbnN0IHsgaWQgfSA9IGF3YWl0IGNvbnRleHQucGFyYW1zO1xuICAgICAgcmV0dXJuIHsgaWQgfTtcbiAgICB9O1xuICAgIFxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1vY2tBcGlSb3V0ZShcbiAgICAgIG5ldyBSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3Rlc3QvMTIzJyksXG4gICAgICB7IHBhcmFtczogUHJvbWlzZS5yZXNvbHZlKHsgaWQ6ICcxMjMnIH0pIH1cbiAgICApO1xuICAgIFxuICAgIGV4cGVjdChyZXN1bHQuaWQpLnRvQmUoJzEyMycpO1xuICB9KTtcbiAgXG4gIGl0KCdzaG91bGQgaGFuZGxlIHBhcmFtcyB3aXRoIHNlYXJjaFBhcmFtcyB0b2dldGhlcicsIGFzeW5jICgpID0+IHtcbiAgICAvLyBTaW11bGF0ZSBwYWdlIHdpdGggYm90aCBwYXJhbXMgYW5kIHNlYXJjaFBhcmFtc1xuICAgIGludGVyZmFjZSBQYWdlUHJvcHMge1xuICAgICAgcGFyYW1zOiBQcm9taXNlPHsgaWQ6IHN0cmluZyB9PjtcbiAgICAgIHNlYXJjaFBhcmFtczogUHJvbWlzZTx7IGZpbHRlcj86IHN0cmluZyB9PjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgbW9ja1BhZ2VDb21wb25lbnQgPSBhc3luYyAoeyBwYXJhbXMsIHNlYXJjaFBhcmFtcyB9OiBQYWdlUHJvcHMpID0+IHtcbiAgICAgIGNvbnN0IHsgaWQgfSA9IGF3YWl0IHBhcmFtcztcbiAgICAgIGNvbnN0IHsgZmlsdGVyIH0gPSBhd2FpdCBzZWFyY2hQYXJhbXM7XG4gICAgICByZXR1cm4geyBpZCwgZmlsdGVyIH07XG4gICAgfTtcbiAgICBcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtb2NrUGFnZUNvbXBvbmVudCh7XG4gICAgICBwYXJhbXM6IFByb21pc2UucmVzb2x2ZSh7IGlkOiAndGVzdC1pZCcgfSksXG4gICAgICBzZWFyY2hQYXJhbXM6IFByb21pc2UucmVzb2x2ZSh7IGZpbHRlcjogJ2FjdGl2ZScgfSksXG4gICAgfSk7XG4gICAgXG4gICAgZXhwZWN0KHJlc3VsdC5pZCkudG9CZSgndGVzdC1pZCcpO1xuICAgIGV4cGVjdChyZXN1bHQuZmlsdGVyKS50b0JlKCdhY3RpdmUnKTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBXaHkgVGhpcyBUZXN0IFdvdWxkIEhhdmUgQ2F1Z2h0IHRoZSBCdWc6XG4gKiBcbiAqIFRoZSBhc3luYyBwYXJhbXMgYnVnIG9jY3VycmVkIGJlY2F1c2U6XG4gKiAxLiBOZXh0LmpzIDE1IG1hZGUgcGFyYW1zIGFzeW5jIGluIGR5bmFtaWMgcm91dGVzXG4gKiAyLiBDb2RlIHRyaWVkIHRvIGRlc3RydWN0dXJlIHBhcmFtcyBkaXJlY3RseTogY29uc3QgeyBpZCB9ID0gcGFyYW1zXG4gKiAzLiBUaGlzIGFjY2Vzc2VkIHByb3BlcnRpZXMgb24gYSBQcm9taXNlLCBub3QgdGhlIHJlc29sdmVkIHZhbHVlXG4gKiA0LiBSZXN1bHQ6IGlkIHdhcyB1bmRlZmluZWQgb3IgYSBQcm9taXNlLCBjYXVzaW5nIHJ1bnRpbWUgZXJyb3JzXG4gKiBcbiAqIFRoaXMgdGVzdCBleHBsaWNpdGx5OlxuICogLSBUZXN0cyB0aGF0IHBhcmFtcyBpcyBhIFByb21pc2VcbiAqIC0gVGVzdHMgdGhhdCBhd2FpdGluZyBwYXJhbXMgd29ya3MgY29ycmVjdGx5XG4gKiAtIFRlc3RzIHRoZSBleGFjdCBwYXR0ZXJucyB1c2VkIGluIHBhZ2VzIGFuZCBBUEkgcm91dGVzXG4gKiAtIERlbW9uc3RyYXRlcyB3aGF0IGhhcHBlbnMgd2hlbiBwYXJhbXMgaXMgbm90IGF3YWl0ZWRcbiAqIFxuICogSWYgY29kZSBkb2Vzbid0IGF3YWl0IHBhcmFtcywgdGhpcyB0ZXN0IHdpbGwgZmFpbCB3aXRoIGEgY2xlYXIgZXJyb3JcbiAqIHNob3dpbmcgdGhhdCBwYXJhbXMuaWQgaXMgdW5kZWZpbmVkIG9yIGEgUHJvbWlzZS5cbiAqIFxuICogTm90ZTogVHlwZVNjcmlwdCBtaWdodCBub3QgY2F0Y2ggdGhpcyBpZiB0aGUgdHlwZXMgYXJlbid0IHN0cmljdCBlbm91Z2guXG4gKiBUaGUgYnVnIGlzIGluIHRoZSBydW50aW1lIGJlaGF2aW9yIG9mIGFjY2Vzc2luZyBQcm9taXNlIHByb3BlcnRpZXMuXG4gKi9cbiJdLCJuYW1lcyI6WyJkZXNjcmliZSIsIml0IiwibW9ja1BhcmFtcyIsIlByb21pc2UiLCJyZXNvbHZlIiwiaWQiLCJzbHVnIiwiZXhwZWN0IiwidG9CZUluc3RhbmNlT2YiLCJwYXJhbXMiLCJ0b0JlRGVmaW5lZCIsInRvQmUiLCJ0eXBlIiwiYnVnZ3lJZCIsInRvQmVVbmRlZmluZWQiLCJjb3JyZWN0SWQiLCJtb2NrUGFnZUNvbXBvbmVudCIsInJlc3VsdCIsIm1vY2tBcGlSb3V0ZSIsInJlcXVlc3QiLCJjb250ZXh0IiwiUmVxdWVzdCIsInNlYXJjaFBhcmFtcyIsImZpbHRlciJdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBRURBLFNBQVMsaUNBQWlDO0lBQ3hDQyxHQUFHLG1EQUFtRDtRQUNwRCxzQ0FBc0M7UUFDdEMsTUFBTUMsYUFBYUMsUUFBUUMsT0FBTyxDQUFDO1lBQUVDLElBQUk7WUFBV0MsTUFBTTtRQUFZO1FBRXRFLGdDQUFnQztRQUNoQ0MsT0FBT0wsWUFBWU0sY0FBYyxDQUFDTDtRQUVsQyxrQ0FBa0M7UUFDbEMsTUFBTU0sU0FBUyxNQUFNUDtRQUNyQkssT0FBT0UsUUFB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