3f8a8d5013d26628e7f5ac0bb19d7afc
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useLocations = require("./useLocations");
// Mock fetch globally
global.fetch = jest.fn();
describe('useLocations', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        global.fetch.mockClear();
    });
    afterEach(()=>{
        jest.restoreAllMocks();
    });
    describe('loading states', ()=>{
        it('should start with loading true', ()=>{
            global.fetch.mockImplementation(()=>new Promise(()=>{}) // Never resolves
            );
            const { result } = (0, _react.renderHook)(()=>(0, _useLocations.useLocations)());
            expect(result.current.loading).toBe(true);
            expect(result.current.data).toEqual([]);
            expect(result.current.error).toBeNull();
        });
        it('should set loading false after successful fetch', async ()=>{
            const mockData = [
                {
                    id: 'loc-1',
                    name: 'Costa Rica',
                    address: '',
                    description: 'Country',
                    createdAt: '2025-01-01T00:00:00Z',
                    updatedAt: '2025-01-01T00:00:00Z',
                    children: []
                }
            ];
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockData
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useLocations.useLocations)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(result.current.data).toEqual(mockData);
            expect(result.current.error).toBeNull();
        });
        it('should set loading false after failed fetch', async ()=>{
            global.fetch.mockResolvedValueOnce({
                ok: false,
                json: async ()=>({
                        success: false,
                        error: {
                            message: 'Failed to fetch'
                        }
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useLocations.useLocations)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(result.current.data).toEqual([]);
            expect(result.current.error).toBeInstanceOf(Error);
        });
    });
    describe('error handling', ()=>{
        it('should handle network errors', async ()=>{
            global.fetch.mockRejectedValueOnce(new Error('Network error'));
            const { result } = (0, _react.renderHook)(()=>(0, _useLocations.useLocations)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.error).toBeInstanceOf(Error);
            });
            expect(result.current.error?.message).toBe('Network error');
            expect(result.current.loading).toBe(false);
            expect(result.current.data).toEqual([]);
        });
        it('should handle API error responses', async ()=>{
            global.fetch.mockResolvedValueOnce({
                ok: false,
                json: async ()=>({
                        success: false,
                        error: {
                            message: 'Unauthorized'
                        }
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useLocations.useLocations)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.error).toBeInstanceOf(Error);
            });
            expect(result.current.error?.message).toBe('Unauthorized');
        });
    });
    describe('data refetching', ()=>{
        it('should refetch data when refetch is called', async ()=>{
            const initialData = [
                {
                    id: 'loc-1',
                    name: 'Costa Rica',
                    createdAt: '2025-01-01T00:00:00Z',
                    updatedAt: '2025-01-01T00:00:00Z',
                    children: []
                }
            ];
            const updatedData = [
                ...initialData,
                {
                    id: 'loc-2',
                    name: 'Guanacaste',
                    parentLocationId: 'loc-1',
                    createdAt: '2025-01-02T00:00:00Z',
                    updatedAt: '2025-01-02T00:00:00Z',
                    children: []
                }
            ];
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: initialData
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: updatedData
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useLocations.useLocations)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.data).toEqual(initialData);
            });
            await (0, _react.waitFor)(async ()=>{
                await result.current.refetch();
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.data).toEqual(updatedData);
            });
        });
        it('should reset error state on refetch', async ()=>{
            global.fetch.mockRejectedValueOnce(new Error('Initial error')).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: []
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useLocations.useLocations)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.error).toBeInstanceOf(Error);
            });
            await (0, _react.waitFor)(async ()=>{
                await result.current.refetch();
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current.error).toBeNull();
            });
        });
        it('should refetch after successful create', async ()=>{
            const initialData = [
                {
                    id: 'loc-1',
                    name: 'Costa Rica',
                    createdAt: '2025-01-01T00:00:00Z',
                    updatedAt: '2025-01-01T00:00:00Z',
                    children: []
                }
            ];
            const updatedData = [
                {
                    ...initialData[0],
                    children: [
                        {
                            id: 'loc-2',
                            name: 'Guanacaste',
                            parentLocationId: 'loc-1',
                            createdAt: '2025-01-02T00:00:00Z',
                            updatedAt: '2025-01-02T00:00:00Z',
                            children: []
                        }
                    ]
                }
            ];
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: initialData
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: {
                            id: 'loc-2',
                            name: 'Guanacaste'
                        }
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: updatedData
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useLocations.useLocations)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.data).toEqual(initialData);
            });
            let createResult;
            await (0, _react.waitFor)(async ()=>{
                createResult = await result.current.create({
                    name: 'Guanacaste',
                    parentLocationId: 'loc-1'
                });
            });
            expect(createResult.success).toBe(true);
            await (0, _react.waitFor)(()=>{
                expect(result.current.data).toEqual(updatedData);
            });
        });
        it('should refetch after successful update', async ()=>{
            const initialData = [
                {
                    id: 'loc-1',
                    name: 'Costa Rica',
                    createdAt: '2025-01-01T00:00:00Z',
                    updatedAt: '2025-01-01T00:00:00Z',
                    children: []
                }
            ];
            const updatedData = [
                {
                    ...initialData[0],
                    name: 'República de Costa Rica',
                    updatedAt: '2025-01-02T00:00:00Z'
                }
            ];
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: initialData
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: updatedData[0]
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: updatedData
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useLocations.useLocations)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.data[0].name).toBe('Costa Rica');
            });
            let updateResult;
            await (0, _react.waitFor)(async ()=>{
                updateResult = await result.current.update('loc-1', {
                    name: 'República de Costa Rica'
                });
            });
            expect(updateResult.success).toBe(true);
            await (0, _react.waitFor)(()=>{
                expect(result.current.data[0].name).toBe('República de Costa Rica');
            });
        });
        it('should refetch after successful delete', async ()=>{
            const initialData = [
                {
                    id: 'loc-1',
                    name: 'Costa Rica',
                    createdAt: '2025-01-01T00:00:00Z',
                    updatedAt: '2025-01-01T00:00:00Z',
                    children: [
                        {
                            id: 'loc-2',
                            name: 'Guanacaste',
                            parentLocationId: 'loc-1',
                            createdAt: '2025-01-02T00:00:00Z',
                            updatedAt: '2025-01-02T00:00:00Z',
                            children: []
                        }
                    ]
                }
            ];
            const updatedData = [
                {
                    ...initialData[0],
                    children: []
                }
            ];
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: initialData
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: updatedData
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useLocations.useLocations)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.data[0].children).toHaveLength(1);
            });
            let deleteResult;
            await (0, _react.waitFor)(async ()=>{
                deleteResult = await result.current.remove('loc-2');
            });
            expect(deleteResult.success).toBe(true);
            await (0, _react.waitFor)(()=>{
                expect(result.current.data[0].children).toHaveLength(0);
            });
        });
    });
    describe('parent validation', ()=>{
        it('should validate parent successfully', async ()=>{
            const mockData = [
                {
                    id: 'loc-1',
                    name: 'Costa Rica',
                    createdAt: '2025-01-01T00:00:00Z',
                    updatedAt: '2025-01-01T00:00:00Z',
                    children: []
                }
            ];
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockData
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useLocations.useLocations)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            let validationResult;
            await (0, _react.waitFor)(async ()=>{
                validationResult = await result.current.validateParent('loc-2', 'loc-1');
            });
            expect(validationResult.success).toBe(true);
            expect(global.fetch).toHaveBeenCalledWith('/api/admin/locations/loc-2/validate-parent', expect.objectContaining({
                method: 'POST',
                body: JSON.stringify({
                    parentId: 'loc-1'
                })
            }));
        });
        it('should handle circular reference validation error', async ()=>{
            const mockData = [
                {
                    id: 'loc-1',
                    name: 'Costa Rica',
                    createdAt: '2025-01-01T00:00:00Z',
                    updatedAt: '2025-01-01T00:00:00Z',
                    children: []
                }
            ];
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockData
                    })
            }).mockResolvedValueOnce({
                ok: false,
                json: async ()=>({
                        success: false,
                        error: {
                            message: 'Circular reference detected'
                        }
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useLocations.useLocations)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            let validationResult;
            await (0, _react.waitFor)(async ()=>{
                validationResult = await result.current.validateParent('loc-1', 'loc-2');
            });
            expect(validationResult.success).toBe(false);
            expect(validationResult.error).toBe('Circular reference detected');
        });
        it('should handle validation network errors', async ()=>{
            const mockData = [
                {
                    id: 'loc-1',
                    name: 'Costa Rica',
                    createdAt: '2025-01-01T00:00:00Z',
                    updatedAt: '2025-01-01T00:00:00Z',
                    children: []
                }
            ];
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockData
                    })
            }).mockRejectedValueOnce(new Error('Network error'));
            const { result } = (0, _react.renderHook)(()=>(0, _useLocations.useLocations)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            let validationResult;
            await (0, _react.waitFor)(async ()=>{
                validationResult = await result.current.validateParent('loc-2', 'loc-1');
            });
            expect(validationResult.success).toBe(false);
            expect(validationResult.error).toBe('Network error');
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvaG9va3MvdXNlTG9jYXRpb25zLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVuZGVySG9vaywgd2FpdEZvciB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xuaW1wb3J0IHsgdXNlTG9jYXRpb25zIH0gZnJvbSAnLi91c2VMb2NhdGlvbnMnO1xuXG4vLyBNb2NrIGZldGNoIGdsb2JhbGx5XG5nbG9iYWwuZmV0Y2ggPSBqZXN0LmZuKCk7XG5cbmRlc2NyaWJlKCd1c2VMb2NhdGlvbnMnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrQ2xlYXIoKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBqZXN0LnJlc3RvcmVBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnbG9hZGluZyBzdGF0ZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzdGFydCB3aXRoIGxvYWRpbmcgdHJ1ZScsICgpID0+IHtcbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT5cbiAgICAgICAgbmV3IFByb21pc2UoKCkgPT4ge30pIC8vIE5ldmVyIHJlc29sdmVzXG4gICAgICApO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VMb2NhdGlvbnMoKSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGEpLnRvRXF1YWwoW10pO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzZXQgbG9hZGluZyBmYWxzZSBhZnRlciBzdWNjZXNzZnVsIGZldGNoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0RhdGEgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ2xvYy0xJyxcbiAgICAgICAgICBuYW1lOiAnQ29zdGEgUmljYScsXG4gICAgICAgICAgYWRkcmVzczogJycsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdDb3VudHJ5JyxcbiAgICAgICAgICBjcmVhdGVkQXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgICAgdXBkYXRlZEF0OiAnMjAyNS0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogbW9ja0RhdGEgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlTG9jYXRpb25zKCkpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhKS50b0VxdWFsKG1vY2tEYXRhKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZU51bGwoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc2V0IGxvYWRpbmcgZmFsc2UgYWZ0ZXIgZmFpbGVkIGZldGNoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgKGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnRmFpbGVkIHRvIGZldGNoJyB9LFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VMb2NhdGlvbnMoKSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGEpLnRvRXF1YWwoW10pO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlSW5zdGFuY2VPZihFcnJvcik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdlcnJvciBoYW5kbGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBuZXR3b3JrIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UoXG4gICAgICAgIG5ldyBFcnJvcignTmV0d29yayBlcnJvcicpXG4gICAgICApO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VMb2NhdGlvbnMoKSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3IpLnRvQmVJbnN0YW5jZU9mKEVycm9yKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3I/Lm1lc3NhZ2UpLnRvQmUoJ05ldHdvcmsgZXJyb3InKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhKS50b0VxdWFsKFtdKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIEFQSSBlcnJvciByZXNwb25zZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6ICdVbmF1dGhvcml6ZWQnIH0sXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZUxvY2F0aW9ucygpKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZUluc3RhbmNlT2YoRXJyb3IpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcj8ubWVzc2FnZSkudG9CZSgnVW5hdXRob3JpemVkJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdkYXRhIHJlZmV0Y2hpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZWZldGNoIGRhdGEgd2hlbiByZWZldGNoIGlzIGNhbGxlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGluaXRpYWxEYXRhID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdsb2MtMScsXG4gICAgICAgICAgbmFtZTogJ0Nvc3RhIFJpY2EnLFxuICAgICAgICAgIGNyZWF0ZWRBdDogJzIwMjUtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgICAgICB1cGRhdGVkQXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgY29uc3QgdXBkYXRlZERhdGEgPSBbXG4gICAgICAgIC4uLmluaXRpYWxEYXRhLFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdsb2MtMicsXG4gICAgICAgICAgbmFtZTogJ0d1YW5hY2FzdGUnLFxuICAgICAgICAgIHBhcmVudExvY2F0aW9uSWQ6ICdsb2MtMScsXG4gICAgICAgICAgY3JlYXRlZEF0OiAnMjAyNS0wMS0wMlQwMDowMDowMFonLFxuICAgICAgICAgIHVwZGF0ZWRBdDogJzIwMjUtMDEtMDJUMDA6MDA6MDBaJyxcbiAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaylcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogaW5pdGlhbERhdGEgfSksXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHVwZGF0ZWREYXRhIH0pLFxuICAgICAgICB9KTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlTG9jYXRpb25zKCkpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGEpLnRvRXF1YWwoaW5pdGlhbERhdGEpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5yZWZldGNoKCk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhKS50b0VxdWFsKHVwZGF0ZWREYXRhKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXNldCBlcnJvciBzdGF0ZSBvbiByZWZldGNoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgKGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spXG4gICAgICAgIC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKCdJbml0aWFsIGVycm9yJykpXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IFtdIH0pLFxuICAgICAgICB9KTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlTG9jYXRpb25zKCkpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlSW5zdGFuY2VPZihFcnJvcik7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcihhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LnJlZmV0Y2goKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlZmV0Y2ggYWZ0ZXIgc3VjY2Vzc2Z1bCBjcmVhdGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbml0aWFsRGF0YSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAnbG9jLTEnLFxuICAgICAgICAgIG5hbWU6ICdDb3N0YSBSaWNhJyxcbiAgICAgICAgICBjcmVhdGVkQXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgICAgdXBkYXRlZEF0OiAnMjAyNS0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHVwZGF0ZWREYXRhID0gW1xuICAgICAgICB7XG4gICAgICAgICAgLi4uaW5pdGlhbERhdGFbMF0sXG4gICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWQ6ICdsb2MtMicsXG4gICAgICAgICAgICAgIG5hbWU6ICdHdWFuYWNhc3RlJyxcbiAgICAgICAgICAgICAgcGFyZW50TG9jYXRpb25JZDogJ2xvYy0xJyxcbiAgICAgICAgICAgICAgY3JlYXRlZEF0OiAnMjAyNS0wMS0wMlQwMDowMDowMFonLFxuICAgICAgICAgICAgICB1cGRhdGVkQXQ6ICcyMDI1LTAxLTAyVDAwOjAwOjAwWicsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBpbml0aWFsRGF0YSB9KSxcbiAgICAgICAgfSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBkYXRhOiB7IGlkOiAnbG9jLTInLCBuYW1lOiAnR3VhbmFjYXN0ZScgfSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogdXBkYXRlZERhdGEgfSksXG4gICAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VMb2NhdGlvbnMoKSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YSkudG9FcXVhbChpbml0aWFsRGF0YSk7XG4gICAgICB9KTtcblxuICAgICAgbGV0IGNyZWF0ZVJlc3VsdDtcbiAgICAgIGF3YWl0IHdhaXRGb3IoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjcmVhdGVSZXN1bHQgPSBhd2FpdCByZXN1bHQuY3VycmVudC5jcmVhdGUoe1xuICAgICAgICAgIG5hbWU6ICdHdWFuYWNhc3RlJyxcbiAgICAgICAgICBwYXJlbnRMb2NhdGlvbklkOiAnbG9jLTEnLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoY3JlYXRlUmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YSkudG9FcXVhbCh1cGRhdGVkRGF0YSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVmZXRjaCBhZnRlciBzdWNjZXNzZnVsIHVwZGF0ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGluaXRpYWxEYXRhID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdsb2MtMScsXG4gICAgICAgICAgbmFtZTogJ0Nvc3RhIFJpY2EnLFxuICAgICAgICAgIGNyZWF0ZWRBdDogJzIwMjUtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgICAgICB1cGRhdGVkQXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgY29uc3QgdXBkYXRlZERhdGEgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5pbml0aWFsRGF0YVswXSxcbiAgICAgICAgICBuYW1lOiAnUmVww7pibGljYSBkZSBDb3N0YSBSaWNhJyxcbiAgICAgICAgICB1cGRhdGVkQXQ6ICcyMDI1LTAxLTAyVDAwOjAwOjAwWicsXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaylcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogaW5pdGlhbERhdGEgfSksXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgZGF0YTogdXBkYXRlZERhdGFbMF0sXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHVwZGF0ZWREYXRhIH0pLFxuICAgICAgICB9KTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlTG9jYXRpb25zKCkpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGFbMF0ubmFtZSkudG9CZSgnQ29zdGEgUmljYScpO1xuICAgICAgfSk7XG5cbiAgICAgIGxldCB1cGRhdGVSZXN1bHQ7XG4gICAgICBhd2FpdCB3YWl0Rm9yKGFzeW5jICgpID0+IHtcbiAgICAgICAgdXBkYXRlUmVzdWx0ID0gYXdhaXQgcmVzdWx0LmN1cnJlbnQudXBkYXRlKCdsb2MtMScsIHtcbiAgICAgICAgICBuYW1lOiAnUmVww7pibGljYSBkZSBDb3N0YSBSaWNhJyxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHVwZGF0ZVJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGFbMF0ubmFtZSkudG9CZSgnUmVww7pibGljYSBkZSBDb3N0YSBSaWNhJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVmZXRjaCBhZnRlciBzdWNjZXNzZnVsIGRlbGV0ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGluaXRpYWxEYXRhID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdsb2MtMScsXG4gICAgICAgICAgbmFtZTogJ0Nvc3RhIFJpY2EnLFxuICAgICAgICAgIGNyZWF0ZWRBdDogJzIwMjUtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgICAgICB1cGRhdGVkQXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWQ6ICdsb2MtMicsXG4gICAgICAgICAgICAgIG5hbWU6ICdHdWFuYWNhc3RlJyxcbiAgICAgICAgICAgICAgcGFyZW50TG9jYXRpb25JZDogJ2xvYy0xJyxcbiAgICAgICAgICAgICAgY3JlYXRlZEF0OiAnMjAyNS0wMS0wMlQwMDowMDowMFonLFxuICAgICAgICAgICAgICB1cGRhdGVkQXQ6ICcyMDI1LTAxLTAyVDAwOjAwOjAwWicsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHVwZGF0ZWREYXRhID0gW1xuICAgICAgICB7XG4gICAgICAgICAgLi4uaW5pdGlhbERhdGFbMF0sXG4gICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgKGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IGluaXRpYWxEYXRhIH0pLFxuICAgICAgICB9KVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlIH0pLFxuICAgICAgICB9KVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiB1cGRhdGVkRGF0YSB9KSxcbiAgICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZUxvY2F0aW9ucygpKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhWzBdLmNoaWxkcmVuKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICB9KTtcblxuICAgICAgbGV0IGRlbGV0ZVJlc3VsdDtcbiAgICAgIGF3YWl0IHdhaXRGb3IoYXN5bmMgKCkgPT4ge1xuICAgICAgICBkZWxldGVSZXN1bHQgPSBhd2FpdCByZXN1bHQuY3VycmVudC5yZW1vdmUoJ2xvYy0yJyk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KGRlbGV0ZVJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGFbMF0uY2hpbGRyZW4pLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgncGFyZW50IHZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBwYXJlbnQgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0RhdGEgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ2xvYy0xJyxcbiAgICAgICAgICBuYW1lOiAnQ29zdGEgUmljYScsXG4gICAgICAgICAgY3JlYXRlZEF0OiAnMjAyNS0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICAgIHVwZGF0ZWRBdDogJzIwMjUtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaylcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogbW9ja0RhdGEgfSksXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IHN1Y2Nlc3M6IHRydWUgfSksXG4gICAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VMb2NhdGlvbnMoKSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XG4gICAgICB9KTtcblxuICAgICAgbGV0IHZhbGlkYXRpb25SZXN1bHQ7XG4gICAgICBhd2FpdCB3YWl0Rm9yKGFzeW5jICgpID0+IHtcbiAgICAgICAgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IHJlc3VsdC5jdXJyZW50LnZhbGlkYXRlUGFyZW50KFxuICAgICAgICAgICdsb2MtMicsXG4gICAgICAgICAgJ2xvYy0xJ1xuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoZ2xvYmFsLmZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJy9hcGkvYWRtaW4vbG9jYXRpb25zL2xvYy0yL3ZhbGlkYXRlLXBhcmVudCcsXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHBhcmVudElkOiAnbG9jLTEnIH0pLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNpcmN1bGFyIHJlZmVyZW5jZSB2YWxpZGF0aW9uIGVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0RhdGEgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ2xvYy0xJyxcbiAgICAgICAgICBuYW1lOiAnQ29zdGEgUmljYScsXG4gICAgICAgICAgY3JlYXRlZEF0OiAnMjAyNS0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICAgIHVwZGF0ZWRBdDogJzIwMjUtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaylcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogbW9ja0RhdGEgfSksXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnQ2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGVkJyB9LFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlTG9jYXRpb25zKCkpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG5cbiAgICAgIGxldCB2YWxpZGF0aW9uUmVzdWx0O1xuICAgICAgYXdhaXQgd2FpdEZvcihhc3luYyAoKSA9PiB7XG4gICAgICAgIHZhbGlkYXRpb25SZXN1bHQgPSBhd2FpdCByZXN1bHQuY3VycmVudC52YWxpZGF0ZVBhcmVudChcbiAgICAgICAgICAnbG9jLTEnLFxuICAgICAgICAgICdsb2MtMidcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QodmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uUmVzdWx0LmVycm9yKS50b0JlKCdDaXJjdWxhciByZWZlcmVuY2UgZGV0ZWN0ZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHZhbGlkYXRpb24gbmV0d29yayBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRGF0YSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAnbG9jLTEnLFxuICAgICAgICAgIG5hbWU6ICdDb3N0YSBSaWNhJyxcbiAgICAgICAgICBjcmVhdGVkQXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgICAgdXBkYXRlZEF0OiAnMjAyNS0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBtb2NrRGF0YSB9KSxcbiAgICAgICAgfSlcbiAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJ05ldHdvcmsgZXJyb3InKSk7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZUxvY2F0aW9ucygpKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKTtcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgdmFsaWRhdGlvblJlc3VsdDtcbiAgICAgIGF3YWl0IHdhaXRGb3IoYXN5bmMgKCkgPT4ge1xuICAgICAgICB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgcmVzdWx0LmN1cnJlbnQudmFsaWRhdGVQYXJlbnQoXG4gICAgICAgICAgJ2xvYy0yJyxcbiAgICAgICAgICAnbG9jLTEnXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHZhbGlkYXRpb25SZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvblJlc3VsdC5lcnJvcikudG9CZSgnTmV0d29yayBlcnJvcicpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImdsb2JhbCIsImZldGNoIiwiamVzdCIsImZuIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tDbGVhciIsImFmdGVyRWFjaCIsInJlc3RvcmVBbGxNb2NrcyIsIml0IiwibW9ja0ltcGxlbWVudGF0aW9uIiwiUHJvbWlzZSIsInJlc3VsdCIsInJlbmRlckhvb2siLCJ1c2VMb2NhdGlvbnMiLCJleHBlY3QiLCJjdXJyZW50IiwibG9hZGluZyIsInRvQmUiLCJkYXRhIiwidG9FcXVhbCIsImVycm9yIiwidG9CZU51bGwiLCJtb2NrRGF0YSIsImlkIiwibmFtZSIsImFkZHJlc3MiLCJkZXNjcmlwdGlvbiIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsImNoaWxkcmVuIiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwib2siLCJqc29uIiwic3VjY2VzcyIsIndhaXRGb3IiLCJtZXNzYWdlIiwidG9CZUluc3RhbmNlT2YiLCJFcnJvciIsIm1vY2tSZWplY3RlZFZhbHVlT25jZSIsImluaXRpYWxEYXRhIiwidXBkYXRlZERhdGEiLCJwYXJlbnRMb2NhdGlvbklkIiwicmVmZXRjaCIsImNyZWF0ZVJlc3VsdCIsImNyZWF0ZSIsInVwZGF0ZVJlc3VsdCIsInVwZGF0ZSIsInRvSGF2ZUxlbmd0aCIsImRlbGV0ZVJlc3VsdCIsInJlbW92ZSIsInZhbGlkYXRpb25SZXN1bHQiLCJ2YWxpZGF0ZVBhcmVudCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwib2JqZWN0Q29udGFpbmluZyIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwicGFyZW50SWQiXSwibWFwcGluZ3MiOiI7Ozs7dUJBQW9DOzhCQUNQO0FBRTdCLHNCQUFzQjtBQUN0QkEsT0FBT0MsS0FBSyxHQUFHQyxLQUFL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