b5fd1142007feccd72d99018a995fd54
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
/**
 * Property 19: Child Access Restriction
 * 
 * For any child/dependent family member in a guest group, they should only have
 * read and edit access to their own information, not to their parents' or siblings' information.
 * 
 * Validates: Requirements 14.4
 * Feature: destination-wedding-platform, Property 19: Child Access Restriction
 */ // Mock Supabase client for testing
function createMockSupabaseClient() {
    const mockData = {
        groups: new Map(),
        guests: new Map(),
        users: new Map()
    };
    return {
        from: (table)=>({
                select: (columns = '*')=>({
                        eq: (column, value)=>({
                                single: async ()=>{
                                    if (table === 'guests') {
                                        const guest = Array.from(mockData.guests.values()).find((g)=>g[column] === value);
                                        return guest ? {
                                            data: guest,
                                            error: null
                                        } : {
                                            data: null,
                                            error: {
                                                message: 'Not found'
                                            }
                                        };
                                    }
                                    return {
                                        data: null,
                                        error: {
                                            message: 'Not found'
                                        }
                                    };
                                },
                                then: async (resolve)=>{
                                    if (table === 'guests') {
                                        const guests = Array.from(mockData.guests.values()).filter((g)=>g[column] === value);
                                        resolve({
                                            data: guests,
                                            error: null
                                        });
                                    } else {
                                        resolve({
                                            data: [],
                                            error: null
                                        });
                                    }
                                }
                            })
                    }),
                update: (data)=>({
                        eq: (column, value)=>({
                                select: ()=>({
                                        single: async ()=>{
                                            if (table === 'guests') {
                                                const guest = mockData.guests.get(value);
                                                if (guest) {
                                                    const updated = {
                                                        ...guest,
                                                        ...data
                                                    };
                                                    mockData.guests.set(value, updated);
                                                    return {
                                                        data: updated,
                                                        error: null
                                                    };
                                                }
                                            }
                                            return {
                                                data: null,
                                                error: {
                                                    message: 'Not found'
                                                }
                                            };
                                        }
                                    })
                            })
                    }),
                insert: (data)=>({
                        select: ()=>({
                                single: async ()=>{
                                    const id = `${table}-${Date.now()}-${Math.random()}`;
                                    const record = {
                                        ...data,
                                        id
                                    };
                                    if (table === 'guests') {
                                        mockData.guests.set(id, record);
                                    } else if (table === 'groups') {
                                        mockData.groups.set(id, record);
                                    }
                                    return {
                                        data: record,
                                        error: null
                                    };
                                }
                            })
                    })
            }),
        auth: {
            getSession: async ()=>({
                    data: {
                        session: {
                            user: {
                                email: 'test@example.com'
                            }
                        }
                    },
                    error: null
                })
        },
        _mockData: mockData
    };
}
// Arbitraries for property-based testing
const groupIdArbitrary = _fastcheck.uuid();
const childGuestArbitrary = _fastcheck.record({
    id: _fastcheck.uuid(),
    group_id: _fastcheck.uuid(),
    first_name: _fastcheck.string({
        minLength: 1,
        maxLength: 50
    }),
    last_name: _fastcheck.string({
        minLength: 1,
        maxLength: 50
    }),
    email: _fastcheck.option(_fastcheck.emailAddress(), {
        nil: undefined
    }),
    age_type: _fastcheck.constant('child'),
    guest_type: _fastcheck.constantFrom('wedding_party', 'wedding_guest', 'prewedding_only', 'postwedding_only'),
    created_at: _fastcheck.date().map((d)=>d.toISOString()),
    updated_at: _fastcheck.date().map((d)=>d.toISOString())
});
const familyMemberArbitrary = _fastcheck.record({
    id: _fastcheck.uuid(),
    first_name: _fastcheck.string({
        minLength: 1,
        maxLength: 50
    }),
    last_name: _fastcheck.string({
        minLength: 1,
        maxLength: 50
    }),
    email: _fastcheck.option(_fastcheck.emailAddress(), {
        nil: undefined
    }),
    age_type: _fastcheck.constantFrom('adult', 'child', 'senior'),
    guest_type: _fastcheck.constantFrom('wedding_party', 'wedding_guest', 'prewedding_only', 'postwedding_only'),
    created_at: _fastcheck.date().map((d)=>d.toISOString()),
    updated_at: _fastcheck.date().map((d)=>d.toISOString())
});
/**
 * Simulates access control check for child guests
 * Children can only access their own record
 */ function canChildAccess(childId, targetId) {
    return childId === targetId;
}
describe('Feature: destination-wedding-platform, Property 19: Child Access Restriction', ()=>{
    it('should only allow children to read their own information', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(groupIdArbitrary, childGuestArbitrary, _fastcheck.array(familyMemberArbitrary, {
            minLength: 1,
            maxLength: 5
        }), async (groupId, childGuest, otherFamilyMembers)=>{
            // Arrange: Create mock client and setup data
            const mockClient = createMockSupabaseClient();
            const mockData = mockClient._mockData;
            // Set child guest with group
            const child = {
                ...childGuest,
                group_id: groupId
            };
            mockData.guests.set(child.id, child);
            // Set other family members with same group
            otherFamilyMembers.forEach((member)=>{
                const familyMember = {
                    ...member,
                    group_id: groupId
                };
                mockData.guests.set(familyMember.id, familyMember);
            });
            // Act: Simulate access control - child should only see themselves
            const accessibleMembers = Array.from(mockData.guests.values()).filter((guest)=>guest.group_id === groupId && canChildAccess(child.id, guest.id));
            // Assert: Child should only access their own record
            expect(accessibleMembers).toHaveLength(1);
            expect(accessibleMembers[0].id).toBe(child.id);
            // Verify child cannot access other family members
            otherFamilyMembers.forEach((member)=>{
                const canAccess = canChildAccess(child.id, member.id);
                expect(canAccess).toBe(false);
            });
        }), {
            numRuns: 100
        });
    });
    it('should only allow children to edit their own information', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(groupIdArbitrary, childGuestArbitrary, familyMemberArbitrary, _fastcheck.string({
            minLength: 1,
            maxLength: 50
        }), async (groupId, childGuest, otherMember, newFirstName)=>{
            // Ensure other member is different from child
            _fastcheck.pre(childGuest.id !== otherMember.id);
            // Arrange: Create mock client and setup data
            const mockClient = createMockSupabaseClient();
            const mockData = mockClient._mockData;
            // Set child guest with group
            const child = {
                ...childGuest,
                group_id: groupId
            };
            mockData.guests.set(child.id, child);
            // Set other family member with same group
            const other = {
                ...otherMember,
                group_id: groupId
            };
            mockData.guests.set(other.id, other);
            // Act & Assert: Child can edit themselves
            const canEditSelf = canChildAccess(child.id, child.id);
            expect(canEditSelf).toBe(true);
            if (canEditSelf) {
                const selfUpdateResult = await mockClient.from('guests').update({
                    first_name: newFirstName
                }).eq('id', child.id).select().single();
                expect(selfUpdateResult.data).toBeDefined();
                expect(selfUpdateResult.data.first_name).toBe(newFirstName);
            }
            // Act & Assert: Child cannot edit other family members
            const canEditOther = canChildAccess(child.id, other.id);
            expect(canEditOther).toBe(false);
        }), {
            numRuns: 100
        });
    });
    it('should restrict children from accessing parent information', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(groupIdArbitrary, childGuestArbitrary, _fastcheck.record({
            id: _fastcheck.uuid(),
            first_name: _fastcheck.string({
                minLength: 1,
                maxLength: 50
            }),
            last_name: _fastcheck.string({
                minLength: 1,
                maxLength: 50
            }),
            email: _fastcheck.emailAddress(),
            age_type: _fastcheck.constant('adult'),
            guest_type: _fastcheck.constantFrom('wedding_party', 'wedding_guest'),
            created_at: _fastcheck.date().map((d)=>d.toISOString()),
            updated_at: _fastcheck.date().map((d)=>d.toISOString())
        }), async (groupId, childGuest, parentGuest)=>{
            // Ensure parent is different from child
            _fastcheck.pre(childGuest.id !== parentGuest.id);
            // Arrange: Create mock client and setup data
            const mockClient = createMockSupabaseClient();
            const mockData = mockClient._mockData;
            // Set child guest with group
            const child = {
                ...childGuest,
                group_id: groupId
            };
            mockData.guests.set(child.id, child);
            // Set parent with same group
            const parent = {
                ...parentGuest,
                group_id: groupId
            };
            mockData.guests.set(parent.id, parent);
            // Act: Check if child can access parent
            const canAccessParent = canChildAccess(child.id, parent.id);
            // Assert: Child should not be able to access parent information
            expect(canAccessParent).toBe(false);
        }), {
            numRuns: 100
        });
    });
    it('should restrict children from accessing sibling information', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(groupIdArbitrary, childGuestArbitrary, _fastcheck.record({
            id: _fastcheck.uuid(),
            first_name: _fastcheck.string({
                minLength: 1,
                maxLength: 50
            }),
            last_name: _fastcheck.string({
                minLength: 1,
                maxLength: 50
            }),
            email: _fastcheck.option(_fastcheck.emailAddress(), {
                nil: undefined
            }),
            age_type: _fastcheck.constant('child'),
            guest_type: _fastcheck.constantFrom('wedding_party', 'wedding_guest'),
            created_at: _fastcheck.date().map((d)=>d.toISOString()),
            updated_at: _fastcheck.date().map((d)=>d.toISOString())
        }), async (groupId, childGuest1, childGuest2)=>{
            // Ensure siblings are different
            _fastcheck.pre(childGuest1.id !== childGuest2.id);
            // Arrange: Create mock client and setup data
            const mockClient = createMockSupabaseClient();
            const mockData = mockClient._mockData;
            // Set first child with group
            const child1 = {
                ...childGuest1,
                group_id: groupId
            };
            mockData.guests.set(child1.id, child1);
            // Set sibling with same group
            const child2 = {
                ...childGuest2,
                group_id: groupId
            };
            mockData.guests.set(child2.id, child2);
            // Act: Check if child can access sibling
            const canAccessSibling = canChildAccess(child1.id, child2.id);
            // Assert: Child should not be able to access sibling information
            expect(canAccessSibling).toBe(false);
        }), {
            numRuns: 100
        });
    });
    it('should allow children to access only themselves in a family with multiple members', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(groupIdArbitrary, childGuestArbitrary, _fastcheck.array(_fastcheck.record({
            id: _fastcheck.uuid(),
            first_name: _fastcheck.string({
                minLength: 1,
                maxLength: 50
            }),
            last_name: _fastcheck.string({
                minLength: 1,
                maxLength: 50
            }),
            age_type: _fastcheck.constantFrom('adult', 'child', 'senior'),
            guest_type: _fastcheck.constantFrom('wedding_party', 'wedding_guest'),
            created_at: _fastcheck.date().map((d)=>d.toISOString()),
            updated_at: _fastcheck.date().map((d)=>d.toISOString())
        }), {
            minLength: 2,
            maxLength: 6
        }), async (groupId, childGuest, otherMembers)=>{
            // Ensure other members are different from child
            const uniqueOthers = otherMembers.filter((m)=>m.id !== childGuest.id);
            _fastcheck.pre(uniqueOthers.length >= 2);
            // Arrange: Create mock client and setup data
            const mockClient = createMockSupabaseClient();
            const mockData = mockClient._mockData;
            // Set child guest with group
            const child = {
                ...childGuest,
                group_id: groupId
            };
            mockData.guests.set(child.id, child);
            // Set other family members with same group
            uniqueOthers.forEach((member)=>{
                const familyMember = {
                    ...member,
                    group_id: groupId
                };
                mockData.guests.set(familyMember.id, familyMember);
            });
            // Act: Count accessible members for child
            const accessibleCount = Array.from(mockData.guests.values()).filter((guest)=>guest.group_id === groupId && canChildAccess(child.id, guest.id)).length;
            // Assert: Child should only access exactly 1 member (themselves)
            expect(accessibleCount).toBe(1);
            // Verify child cannot access any other member
            uniqueOthers.forEach((member)=>{
                const canAccess = canChildAccess(child.id, member.id);
                expect(canAccess).toBe(false);
            });
        }), {
            numRuns: 100
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvY2hpbGRBY2Nlc3NSZXN0cmljdGlvbi5wcm9wZXJ0eS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGZjIGZyb20gJ2Zhc3QtY2hlY2snO1xuXG4vKipcbiAqIFByb3BlcnR5IDE5OiBDaGlsZCBBY2Nlc3MgUmVzdHJpY3Rpb25cbiAqIFxuICogRm9yIGFueSBjaGlsZC9kZXBlbmRlbnQgZmFtaWx5IG1lbWJlciBpbiBhIGd1ZXN0IGdyb3VwLCB0aGV5IHNob3VsZCBvbmx5IGhhdmVcbiAqIHJlYWQgYW5kIGVkaXQgYWNjZXNzIHRvIHRoZWlyIG93biBpbmZvcm1hdGlvbiwgbm90IHRvIHRoZWlyIHBhcmVudHMnIG9yIHNpYmxpbmdzJyBpbmZvcm1hdGlvbi5cbiAqIFxuICogVmFsaWRhdGVzOiBSZXF1aXJlbWVudHMgMTQuNFxuICogRmVhdHVyZTogZGVzdGluYXRpb24td2VkZGluZy1wbGF0Zm9ybSwgUHJvcGVydHkgMTk6IENoaWxkIEFjY2VzcyBSZXN0cmljdGlvblxuICovXG5cbi8vIE1vY2sgU3VwYWJhc2UgY2xpZW50IGZvciB0ZXN0aW5nXG5mdW5jdGlvbiBjcmVhdGVNb2NrU3VwYWJhc2VDbGllbnQoKSB7XG4gIGNvbnN0IG1vY2tEYXRhID0ge1xuICAgIGdyb3VwczogbmV3IE1hcDxzdHJpbmcsIGFueT4oKSxcbiAgICBndWVzdHM6IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCksXG4gICAgdXNlcnM6IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCksXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBmcm9tOiAodGFibGU6IHN0cmluZykgPT4gKHtcbiAgICAgIHNlbGVjdDogKGNvbHVtbnM6IHN0cmluZyA9ICcqJykgPT4gKHtcbiAgICAgICAgZXE6IChjb2x1bW46IHN0cmluZywgdmFsdWU6IGFueSkgPT4gKHtcbiAgICAgICAgICBzaW5nbGU6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0YWJsZSA9PT0gJ2d1ZXN0cycpIHtcbiAgICAgICAgICAgICAgY29uc3QgZ3Vlc3QgPSBBcnJheS5mcm9tKG1vY2tEYXRhLmd1ZXN0cy52YWx1ZXMoKSkuZmluZChcbiAgICAgICAgICAgICAgICAoZzogYW55KSA9PiBnW2NvbHVtbl0gPT09IHZhbHVlXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiBndWVzdFxuICAgICAgICAgICAgICAgID8geyBkYXRhOiBndWVzdCwgZXJyb3I6IG51bGwgfVxuICAgICAgICAgICAgICAgIDogeyBkYXRhOiBudWxsLCBlcnJvcjogeyBtZXNzYWdlOiAnTm90IGZvdW5kJyB9IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogeyBtZXNzYWdlOiAnTm90IGZvdW5kJyB9IH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aGVuOiBhc3luYyAocmVzb2x2ZTogYW55KSA9PiB7XG4gICAgICAgICAgICBpZiAodGFibGUgPT09ICdndWVzdHMnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGd1ZXN0cyA9IEFycmF5LmZyb20obW9ja0RhdGEuZ3Vlc3RzLnZhbHVlcygpKS5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKGc6IGFueSkgPT4gZ1tjb2x1bW5dID09PSB2YWx1ZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXNvbHZlKHsgZGF0YTogZ3Vlc3RzLCBlcnJvcjogbnVsbCB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoeyBkYXRhOiBbXSwgZXJyb3I6IG51bGwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgfSksXG4gICAgICB9KSxcbiAgICAgIHVwZGF0ZTogKGRhdGE6IGFueSkgPT4gKHtcbiAgICAgICAgZXE6IChjb2x1bW46IHN0cmluZywgdmFsdWU6IGFueSkgPT4gKHtcbiAgICAgICAgICBzZWxlY3Q6ICgpID0+ICh7XG4gICAgICAgICAgICBzaW5nbGU6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHRhYmxlID09PSAnZ3Vlc3RzJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGd1ZXN0ID0gbW9ja0RhdGEuZ3Vlc3RzLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGd1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkID0geyAuLi5ndWVzdCwgLi4uZGF0YSB9O1xuICAgICAgICAgICAgICAgICAgbW9ja0RhdGEuZ3Vlc3RzLnNldCh2YWx1ZSwgdXBkYXRlZCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB1cGRhdGVkLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogeyBtZXNzYWdlOiAnTm90IGZvdW5kJyB9IH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pLFxuICAgICAgaW5zZXJ0OiAoZGF0YTogYW55KSA9PiAoe1xuICAgICAgICBzZWxlY3Q6ICgpID0+ICh7XG4gICAgICAgICAgc2luZ2xlOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGAke3RhYmxlfS0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKX1gO1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkID0geyAuLi5kYXRhLCBpZCB9O1xuICAgICAgICAgICAgaWYgKHRhYmxlID09PSAnZ3Vlc3RzJykge1xuICAgICAgICAgICAgICBtb2NrRGF0YS5ndWVzdHMuc2V0KGlkLCByZWNvcmQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YWJsZSA9PT0gJ2dyb3VwcycpIHtcbiAgICAgICAgICAgICAgbW9ja0RhdGEuZ3JvdXBzLnNldChpZCwgcmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHJlY29yZCwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICB9LFxuICAgICAgICB9KSxcbiAgICAgIH0pLFxuICAgIH0pLFxuICAgIGF1dGg6IHtcbiAgICAgIGdldFNlc3Npb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgIGRhdGE6IHsgc2Vzc2lvbjogeyB1c2VyOiB7IGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScgfSB9IH0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSksXG4gICAgfSxcbiAgICBfbW9ja0RhdGE6IG1vY2tEYXRhLFxuICB9O1xufVxuXG4vLyBBcmJpdHJhcmllcyBmb3IgcHJvcGVydHktYmFzZWQgdGVzdGluZ1xuY29uc3QgZ3JvdXBJZEFyYml0cmFyeSA9IGZjLnV1aWQoKTtcblxuY29uc3QgY2hpbGRHdWVzdEFyYml0cmFyeSA9IGZjLnJlY29yZCh7XG4gIGlkOiBmYy51dWlkKCksXG4gIGdyb3VwX2lkOiBmYy51dWlkKCksXG4gIGZpcnN0X25hbWU6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1MCB9KSxcbiAgbGFzdF9uYW1lOiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogNTAgfSksXG4gIGVtYWlsOiBmYy5vcHRpb24oZmMuZW1haWxBZGRyZXNzKCksIHsgbmlsOiB1bmRlZmluZWQgfSksXG4gIGFnZV90eXBlOiBmYy5jb25zdGFudCgnY2hpbGQnIGFzIGNvbnN0KSxcbiAgZ3Vlc3RfdHlwZTogZmMuY29uc3RhbnRGcm9tKFxuICAgICd3ZWRkaW5nX3BhcnR5JyxcbiAgICAnd2VkZGluZ19ndWVzdCcsXG4gICAgJ3ByZXdlZGRpbmdfb25seScsXG4gICAgJ3Bvc3R3ZWRkaW5nX29ubHknXG4gICksXG4gIGNyZWF0ZWRfYXQ6IGZjLmRhdGUoKS5tYXAoKGQpID0+IGQudG9JU09TdHJpbmcoKSksXG4gIHVwZGF0ZWRfYXQ6IGZjLmRhdGUoKS5tYXAoKGQpID0+IGQudG9JU09TdHJpbmcoKSksXG59KTtcblxuY29uc3QgZmFtaWx5TWVtYmVyQXJiaXRyYXJ5ID0gZmMucmVjb3JkKHtcbiAgaWQ6IGZjLnV1aWQoKSxcbiAgZmlyc3RfbmFtZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLFxuICBsYXN0X25hbWU6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1MCB9KSxcbiAgZW1haWw6IGZjLm9wdGlvbihmYy5lbWFpbEFkZHJlc3MoKSwgeyBuaWw6IHVuZGVmaW5lZCB9KSxcbiAgYWdlX3R5cGU6IGZjLmNvbnN0YW50RnJvbSgnYWR1bHQnLCAnY2hpbGQnLCAnc2VuaW9yJyksXG4gIGd1ZXN0X3R5cGU6IGZjLmNvbnN0YW50RnJvbShcbiAgICAnd2VkZGluZ19wYXJ0eScsXG4gICAgJ3dlZGRpbmdfZ3Vlc3QnLFxuICAgICdwcmV3ZWRkaW5nX29ubHknLFxuICAgICdwb3N0d2VkZGluZ19vbmx5J1xuICApLFxuICBjcmVhdGVkX2F0OiBmYy5kYXRlKCkubWFwKChkKSA9PiBkLnRvSVNPU3RyaW5nKCkpLFxuICB1cGRhdGVkX2F0OiBmYy5kYXRlKCkubWFwKChkKSA9PiBkLnRvSVNPU3RyaW5nKCkpLFxufSk7XG5cbi8qKlxuICogU2ltdWxhdGVzIGFjY2VzcyBjb250cm9sIGNoZWNrIGZvciBjaGlsZCBndWVzdHNcbiAqIENoaWxkcmVuIGNhbiBvbmx5IGFjY2VzcyB0aGVpciBvd24gcmVjb3JkXG4gKi9cbmZ1bmN0aW9uIGNhbkNoaWxkQWNjZXNzKGNoaWxkSWQ6IHN0cmluZywgdGFyZ2V0SWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gY2hpbGRJZCA9PT0gdGFyZ2V0SWQ7XG59XG5cbmRlc2NyaWJlKCdGZWF0dXJlOiBkZXN0aW5hdGlvbi13ZWRkaW5nLXBsYXRmb3JtLCBQcm9wZXJ0eSAxOTogQ2hpbGQgQWNjZXNzIFJlc3RyaWN0aW9uJywgKCkgPT4ge1xuICBpdCgnc2hvdWxkIG9ubHkgYWxsb3cgY2hpbGRyZW4gdG8gcmVhZCB0aGVpciBvd24gaW5mb3JtYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZ3JvdXBJZEFyYml0cmFyeSxcbiAgICAgICAgY2hpbGRHdWVzdEFyYml0cmFyeSxcbiAgICAgICAgZmMuYXJyYXkoZmFtaWx5TWVtYmVyQXJiaXRyYXJ5LCB7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1IH0pLFxuICAgICAgICBhc3luYyAoZ3JvdXBJZCwgY2hpbGRHdWVzdCwgb3RoZXJGYW1pbHlNZW1iZXJzKSA9PiB7XG4gICAgICAgICAgLy8gQXJyYW5nZTogQ3JlYXRlIG1vY2sgY2xpZW50IGFuZCBzZXR1cCBkYXRhXG4gICAgICAgICAgY29uc3QgbW9ja0NsaWVudCA9IGNyZWF0ZU1vY2tTdXBhYmFzZUNsaWVudCgpO1xuICAgICAgICAgIGNvbnN0IG1vY2tEYXRhID0gbW9ja0NsaWVudC5fbW9ja0RhdGE7XG5cbiAgICAgICAgICAvLyBTZXQgY2hpbGQgZ3Vlc3Qgd2l0aCBncm91cFxuICAgICAgICAgIGNvbnN0IGNoaWxkID0geyAuLi5jaGlsZEd1ZXN0LCBncm91cF9pZDogZ3JvdXBJZCB9O1xuICAgICAgICAgIG1vY2tEYXRhLmd1ZXN0cy5zZXQoY2hpbGQuaWQsIGNoaWxkKTtcblxuICAgICAgICAgIC8vIFNldCBvdGhlciBmYW1pbHkgbWVtYmVycyB3aXRoIHNhbWUgZ3JvdXBcbiAgICAgICAgICBvdGhlckZhbWlseU1lbWJlcnMuZm9yRWFjaCgobWVtYmVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmYW1pbHlNZW1iZXIgPSB7IC4uLm1lbWJlciwgZ3JvdXBfaWQ6IGdyb3VwSWQgfTtcbiAgICAgICAgICAgIG1vY2tEYXRhLmd1ZXN0cy5zZXQoZmFtaWx5TWVtYmVyLmlkLCBmYW1pbHlNZW1iZXIpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gQWN0OiBTaW11bGF0ZSBhY2Nlc3MgY29udHJvbCAtIGNoaWxkIHNob3VsZCBvbmx5IHNlZSB0aGVtc2VsdmVzXG4gICAgICAgICAgY29uc3QgYWNjZXNzaWJsZU1lbWJlcnMgPSBBcnJheS5mcm9tKG1vY2tEYXRhLmd1ZXN0cy52YWx1ZXMoKSkuZmlsdGVyKFxuICAgICAgICAgICAgKGd1ZXN0OiBhbnkpID0+XG4gICAgICAgICAgICAgIGd1ZXN0Lmdyb3VwX2lkID09PSBncm91cElkICYmIGNhbkNoaWxkQWNjZXNzKGNoaWxkLmlkLCBndWVzdC5pZClcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gQXNzZXJ0OiBDaGlsZCBzaG91bGQgb25seSBhY2Nlc3MgdGhlaXIgb3duIHJlY29yZFxuICAgICAgICAgIGV4cGVjdChhY2Nlc3NpYmxlTWVtYmVycykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgICAgIGV4cGVjdChhY2Nlc3NpYmxlTWVtYmVyc1swXS5pZCkudG9CZShjaGlsZC5pZCk7XG5cbiAgICAgICAgICAvLyBWZXJpZnkgY2hpbGQgY2Fubm90IGFjY2VzcyBvdGhlciBmYW1pbHkgbWVtYmVyc1xuICAgICAgICAgIG90aGVyRmFtaWx5TWVtYmVycy5mb3JFYWNoKChtZW1iZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhbkFjY2VzcyA9IGNhbkNoaWxkQWNjZXNzKGNoaWxkLmlkLCBtZW1iZXIuaWQpO1xuICAgICAgICAgICAgZXhwZWN0KGNhbkFjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBvbmx5IGFsbG93IGNoaWxkcmVuIHRvIGVkaXQgdGhlaXIgb3duIGluZm9ybWF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGdyb3VwSWRBcmJpdHJhcnksXG4gICAgICAgIGNoaWxkR3Vlc3RBcmJpdHJhcnksXG4gICAgICAgIGZhbWlseU1lbWJlckFyYml0cmFyeSxcbiAgICAgICAgZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLFxuICAgICAgICBhc3luYyAoZ3JvdXBJZCwgY2hpbGRHdWVzdCwgb3RoZXJNZW1iZXIsIG5ld0ZpcnN0TmFtZSkgPT4ge1xuICAgICAgICAgIC8vIEVuc3VyZSBvdGhlciBtZW1iZXIgaXMgZGlmZmVyZW50IGZyb20gY2hpbGRcbiAgICAgICAgICBmYy5wcmUoY2hpbGRHdWVzdC5pZCAhPT0gb3RoZXJNZW1iZXIuaWQpO1xuXG4gICAgICAgICAgLy8gQXJyYW5nZTogQ3JlYXRlIG1vY2sgY2xpZW50IGFuZCBzZXR1cCBkYXRhXG4gICAgICAgICAgY29uc3QgbW9ja0NsaWVudCA9IGNyZWF0ZU1vY2tTdXBhYmFzZUNsaWVudCgpO1xuICAgICAgICAgIGNvbnN0IG1vY2tEYXRhID0gbW9ja0NsaWVudC5fbW9ja0RhdGE7XG5cbiAgICAgICAgICAvLyBTZXQgY2hpbGQgZ3Vlc3Qgd2l0aCBncm91cFxuICAgICAgICAgIGNvbnN0IGNoaWxkID0geyAuLi5jaGlsZEd1ZXN0LCBncm91cF9pZDogZ3JvdXBJZCB9O1xuICAgICAgICAgIG1vY2tEYXRhLmd1ZXN0cy5zZXQoY2hpbGQuaWQsIGNoaWxkKTtcblxuICAgICAgICAgIC8vIFNldCBvdGhlciBmYW1pbHkgbWVtYmVyIHdpdGggc2FtZSBncm91cFxuICAgICAgICAgIGNvbnN0IG90aGVyID0geyAuLi5vdGhlck1lbWJlciwgZ3JvdXBfaWQ6IGdyb3VwSWQgfTtcbiAgICAgICAgICBtb2NrRGF0YS5ndWVzdHMuc2V0KG90aGVyLmlkLCBvdGhlcik7XG5cbiAgICAgICAgICAvLyBBY3QgJiBBc3NlcnQ6IENoaWxkIGNhbiBlZGl0IHRoZW1zZWx2ZXNcbiAgICAgICAgICBjb25zdCBjYW5FZGl0U2VsZiA9IGNhbkNoaWxkQWNjZXNzKGNoaWxkLmlkLCBjaGlsZC5pZCk7XG4gICAgICAgICAgZXhwZWN0KGNhbkVkaXRTZWxmKS50b0JlKHRydWUpO1xuXG4gICAgICAgICAgaWYgKGNhbkVkaXRTZWxmKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxmVXBkYXRlUmVzdWx0ID0gYXdhaXQgbW9ja0NsaWVudFxuICAgICAgICAgICAgICAuZnJvbSgnZ3Vlc3RzJylcbiAgICAgICAgICAgICAgLnVwZGF0ZSh7IGZpcnN0X25hbWU6IG5ld0ZpcnN0TmFtZSB9KVxuICAgICAgICAgICAgICAuZXEoJ2lkJywgY2hpbGQuaWQpXG4gICAgICAgICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgICAgICAgIGV4cGVjdChzZWxmVXBkYXRlUmVzdWx0LmRhdGEpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3Qoc2VsZlVwZGF0ZVJlc3VsdC5kYXRhLmZpcnN0X25hbWUpLnRvQmUobmV3Rmlyc3ROYW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBY3QgJiBBc3NlcnQ6IENoaWxkIGNhbm5vdCBlZGl0IG90aGVyIGZhbWlseSBtZW1iZXJzXG4gICAgICAgICAgY29uc3QgY2FuRWRpdE90aGVyID0gY2FuQ2hpbGRBY2Nlc3MoY2hpbGQuaWQsIG90aGVyLmlkKTtcbiAgICAgICAgICBleHBlY3QoY2FuRWRpdE90aGVyKS50b0JlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHJlc3RyaWN0IGNoaWxkcmVuIGZyb20gYWNjZXNzaW5nIHBhcmVudCBpbmZvcm1hdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBncm91cElkQXJiaXRyYXJ5LFxuICAgICAgICBjaGlsZEd1ZXN0QXJiaXRyYXJ5LFxuICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgIGlkOiBmYy51dWlkKCksXG4gICAgICAgICAgZmlyc3RfbmFtZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLFxuICAgICAgICAgIGxhc3RfbmFtZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLFxuICAgICAgICAgIGVtYWlsOiBmYy5lbWFpbEFkZHJlc3MoKSxcbiAgICAgICAgICBhZ2VfdHlwZTogZmMuY29uc3RhbnQoJ2FkdWx0JyBhcyBjb25zdCksXG4gICAgICAgICAgZ3Vlc3RfdHlwZTogZmMuY29uc3RhbnRGcm9tKCd3ZWRkaW5nX3BhcnR5JywgJ3dlZGRpbmdfZ3Vlc3QnKSxcbiAgICAgICAgICBjcmVhdGVkX2F0OiBmYy5kYXRlKCkubWFwKChkKSA9PiBkLnRvSVNPU3RyaW5nKCkpLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IGZjLmRhdGUoKS5tYXAoKGQpID0+IGQudG9JU09TdHJpbmcoKSksXG4gICAgICAgIH0pLFxuICAgICAgICBhc3luYyAoZ3JvdXBJZCwgY2hpbGRHdWVzdCwgcGFyZW50R3Vlc3QpID0+IHtcbiAgICAgICAgICAvLyBFbnN1cmUgcGFyZW50IGlzIGRpZmZlcmVudCBmcm9tIGNoaWxkXG4gICAgICAgICAgZmMucHJlKGNoaWxkR3Vlc3QuaWQgIT09IHBhcmVudEd1ZXN0LmlkKTtcblxuICAgICAgICAgIC8vIEFycmFuZ2U6IENyZWF0ZSBtb2NrIGNsaWVudCBhbmQgc2V0dXAgZGF0YVxuICAgICAgICAgIGNvbnN0IG1vY2tDbGllbnQgPSBjcmVhdGVNb2NrU3VwYWJhc2VDbGllbnQoKTtcbiAgICAgICAgICBjb25zdCBtb2NrRGF0YSA9IG1vY2tDbGllbnQuX21vY2tEYXRhO1xuXG4gICAgICAgICAgLy8gU2V0IGNoaWxkIGd1ZXN0IHdpdGggZ3JvdXBcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IHsgLi4uY2hpbGRHdWVzdCwgZ3JvdXBfaWQ6IGdyb3VwSWQgfTtcbiAgICAgICAgICBtb2NrRGF0YS5ndWVzdHMuc2V0KGNoaWxkLmlkLCBjaGlsZCk7XG5cbiAgICAgICAgICAvLyBTZXQgcGFyZW50IHdpdGggc2FtZSBncm91cFxuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHsgLi4ucGFyZW50R3Vlc3QsIGdyb3VwX2lkOiBncm91cElkIH07XG4gICAgICAgICAgbW9ja0RhdGEuZ3Vlc3RzLnNldChwYXJlbnQuaWQsIHBhcmVudCk7XG5cbiAgICAgICAgICAvLyBBY3Q6IENoZWNrIGlmIGNoaWxkIGNhbiBhY2Nlc3MgcGFyZW50XG4gICAgICAgICAgY29uc3QgY2FuQWNjZXNzUGFyZW50ID0gY2FuQ2hpbGRBY2Nlc3MoY2hpbGQuaWQsIHBhcmVudC5pZCk7XG5cbiAgICAgICAgICAvLyBBc3NlcnQ6IENoaWxkIHNob3VsZCBub3QgYmUgYWJsZSB0byBhY2Nlc3MgcGFyZW50IGluZm9ybWF0aW9uXG4gICAgICAgICAgZXhwZWN0KGNhbkFjY2Vzc1BhcmVudCkudG9CZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCByZXN0cmljdCBjaGlsZHJlbiBmcm9tIGFjY2Vzc2luZyBzaWJsaW5nIGluZm9ybWF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGdyb3VwSWRBcmJpdHJhcnksXG4gICAgICAgIGNoaWxkR3Vlc3RBcmJpdHJhcnksXG4gICAgICAgIGZjLnJlY29yZCh7XG4gICAgICAgICAgaWQ6IGZjLnV1aWQoKSxcbiAgICAgICAgICBmaXJzdF9uYW1lOiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogNTAgfSksXG4gICAgICAgICAgbGFzdF9uYW1lOiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogNTAgfSksXG4gICAgICAgICAgZW1haWw6IGZjLm9wdGlvbihmYy5lbWFpbEFkZHJlc3MoKSwgeyBuaWw6IHVuZGVmaW5lZCB9KSxcbiAgICAgICAgICBhZ2VfdHlwZTogZmMuY29uc3RhbnQoJ2NoaWxkJyBhcyBjb25zdCksXG4gICAgICAgICAgZ3Vlc3RfdHlwZTogZmMuY29uc3RhbnRGcm9tKCd3ZWRkaW5nX3BhcnR5JywgJ3dlZGRpbmdfZ3Vlc3QnKSxcbiAgICAgICAgICBjcmVhdGVkX2F0OiBmYy5kYXRlKCkubWFwKChkKSA9PiBkLnRvSVNPU3RyaW5nKCkpLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IGZjLmRhdGUoKS5tYXAoKGQpID0+IGQudG9JU09TdHJpbmcoKSksXG4gICAgICAgIH0pLFxuICAgICAgICBhc3luYyAoZ3JvdXBJZCwgY2hpbGRHdWVzdDEsIGNoaWxkR3Vlc3QyKSA9PiB7XG4gICAgICAgICAgLy8gRW5zdXJlIHNpYmxpbmdzIGFyZSBkaWZmZXJlbnRcbiAgICAgICAgICBmYy5wcmUoY2hpbGRHdWVzdDEuaWQgIT09IGNoaWxkR3Vlc3QyLmlkKTtcblxuICAgICAgICAgIC8vIEFycmFuZ2U6IENyZWF0ZSBtb2NrIGNsaWVudCBhbmQgc2V0dXAgZGF0YVxuICAgICAgICAgIGNvbnN0IG1vY2tDbGllbnQgPSBjcmVhdGVNb2NrU3VwYWJhc2VDbGllbnQoKTtcbiAgICAgICAgICBjb25zdCBtb2NrRGF0YSA9IG1vY2tDbGllbnQuX21vY2tEYXRhO1xuXG4gICAgICAgICAgLy8gU2V0IGZpcnN0IGNoaWxkIHdpdGggZ3JvdXBcbiAgICAgICAgICBjb25zdCBjaGlsZDEgPSB7IC4uLmNoaWxkR3Vlc3QxLCBncm91cF9pZDogZ3JvdXBJZCB9O1xuICAgICAgICAgIG1vY2tEYXRhLmd1ZXN0cy5zZXQoY2hpbGQxLmlkLCBjaGlsZDEpO1xuXG4gICAgICAgICAgLy8gU2V0IHNpYmxpbmcgd2l0aCBzYW1lIGdyb3VwXG4gICAgICAgICAgY29uc3QgY2hpbGQyID0geyAuLi5jaGlsZEd1ZXN0MiwgZ3JvdXBfaWQ6IGdyb3VwSWQgfTtcbiAgICAgICAgICBtb2NrRGF0YS5ndWVzdHMuc2V0KGNoaWxkMi5pZCwgY2hpbGQyKTtcblxuICAgICAgICAgIC8vIEFjdDogQ2hlY2sgaWYgY2hpbGQgY2FuIGFjY2VzcyBzaWJsaW5nXG4gICAgICAgICAgY29uc3QgY2FuQWNjZXNzU2libGluZyA9IGNhbkNoaWxkQWNjZXNzKGNoaWxkMS5pZCwgY2hpbGQyLmlkKTtcblxuICAgICAgICAgIC8vIEFzc2VydDogQ2hpbGQgc2hvdWxkIG5vdCBiZSBhYmxlIHRvIGFjY2VzcyBzaWJsaW5nIGluZm9ybWF0aW9uXG4gICAgICAgICAgZXhwZWN0KGNhbkFjY2Vzc1NpYmxpbmcpLnRvQmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgYWxsb3cgY2hpbGRyZW4gdG8gYWNjZXNzIG9ubHkgdGhlbXNlbHZlcyBpbiBhIGZhbWlseSB3aXRoIG11bHRpcGxlIG1lbWJlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZ3JvdXBJZEFyYml0cmFyeSxcbiAgICAgICAgY2hpbGRHdWVzdEFyYml0cmFyeSxcbiAgICAgICAgZmMuYXJyYXkoXG4gICAgICAgICAgZmMucmVjb3JkKHtcbiAgICAgICAgICAgIGlkOiBmYy51dWlkKCksXG4gICAgICAgICAgICBmaXJzdF9uYW1lOiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogNTAgfSksXG4gICAgICAgICAgICBsYXN0X25hbWU6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1MCB9KSxcbiAgICAgICAgICAgIGFnZV90eXBlOiBmYy5jb25zdGFudEZyb20oJ2FkdWx0JywgJ2NoaWxkJywgJ3NlbmlvcicpLFxuICAgICAgICAgICAgZ3Vlc3RfdHlwZTogZmMuY29uc3RhbnRGcm9tKCd3ZWRkaW5nX3BhcnR5JywgJ3dlZGRpbmdfZ3Vlc3QnKSxcbiAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IGZjLmRhdGUoKS5tYXAoKGQpID0+IGQudG9JU09TdHJpbmcoKSksXG4gICAgICAgICAgICB1cGRhdGVkX2F0OiBmYy5kYXRlKCkubWFwKChkKSA9PiBkLnRvSVNPU3RyaW5nKCkpLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHsgbWluTGVuZ3RoOiAyLCBtYXhMZW5ndGg6IDYgfVxuICAgICAgICApLFxuICAgICAgICBhc3luYyAoZ3JvdXBJZCwgY2hpbGRHdWVzdCwgb3RoZXJNZW1iZXJzKSA9PiB7XG4gICAgICAgICAgLy8gRW5zdXJlIG90aGVyIG1lbWJlcnMgYXJlIGRpZmZlcmVudCBmcm9tIGNoaWxkXG4gICAgICAgICAgY29uc3QgdW5pcXVlT3RoZXJzID0gb3RoZXJNZW1iZXJzLmZpbHRlcigobSkgPT4gbS5pZCAhPT0gY2hpbGRHdWVzdC5pZCk7XG4gICAgICAgICAgZmMucHJlKHVuaXF1ZU90aGVycy5sZW5ndGggPj0gMik7XG5cbiAgICAgICAgICAvLyBBcnJhbmdlOiBDcmVhdGUgbW9jayBjbGllbnQgYW5kIHNldHVwIGRhdGFcbiAgICAgICAgICBjb25zdCBtb2NrQ2xpZW50ID0gY3JlYXRlTW9ja1N1cGFiYXNlQ2xpZW50KCk7XG4gICAgICAgICAgY29uc3QgbW9ja0RhdGEgPSBtb2NrQ2xpZW50Ll9tb2NrRGF0YTtcblxuICAgICAgICAgIC8vIFNldCBjaGlsZCBndWVzdCB3aXRoIGdyb3VwXG4gICAgICAgICAgY29uc3QgY2hpbGQgPSB7IC4uLmNoaWxkR3Vlc3QsIGdyb3VwX2lkOiBncm91cElkIH07XG4gICAgICAgICAgbW9ja0RhdGEuZ3Vlc3RzLnNldChjaGlsZC5pZCwgY2hpbGQpO1xuXG4gICAgICAgICAgLy8gU2V0IG90aGVyIGZhbWlseSBtZW1iZXJzIHdpdGggc2FtZSBncm91cFxuICAgICAgICAgIHVuaXF1ZU90aGVycy5mb3JFYWNoKChtZW1iZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZhbWlseU1lbWJlciA9IHsgLi4ubWVtYmVyLCBncm91cF9pZDogZ3JvdXBJZCB9O1xuICAgICAgICAgICAgbW9ja0RhdGEuZ3Vlc3RzLnNldChmYW1pbHlNZW1iZXIuaWQsIGZhbWlseU1lbWJlcik7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBBY3Q6IENvdW50IGFjY2Vzc2libGUgbWVtYmVycyBmb3IgY2hpbGRcbiAgICAgICAgICBjb25zdCBhY2Nlc3NpYmxlQ291bnQgPSBBcnJheS5mcm9tKG1vY2tEYXRhLmd1ZXN0cy52YWx1ZXMoKSkuZmlsdGVyKFxuICAgICAgICAgICAgKGd1ZXN0OiBhbnkpID0+XG4gICAgICAgICAgICAgIGd1ZXN0Lmdyb3VwX2lkID09PSBncm91cElkICYmIGNhbkNoaWxkQWNjZXNzKGNoaWxkLmlkLCBndWVzdC5pZClcbiAgICAgICAgICApLmxlbmd0aDtcblxuICAgICAgICAgIC8vIEFzc2VydDogQ2hpbGQgc2hvdWxkIG9ubHkgYWNjZXNzIGV4YWN0bHkgMSBtZW1iZXIgKHRoZW1zZWx2ZXMpXG4gICAgICAgICAgZXhwZWN0KGFjY2Vzc2libGVDb3VudCkudG9CZSgxKTtcblxuICAgICAgICAgIC8vIFZlcmlmeSBjaGlsZCBjYW5ub3QgYWNjZXNzIGFueSBvdGhlciBtZW1iZXJcbiAgICAgICAgICB1bmlxdWVPdGhlcnMuZm9yRWFjaCgobWVtYmVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYW5BY2Nlc3MgPSBjYW5DaGlsZEFjY2VzcyhjaGlsZC5pZCwgbWVtYmVyLmlkKTtcbiAgICAgICAgICAgIGV4cGVjdChjYW5BY2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiY3JlYXRlTW9ja1N1cGFiYXNlQ2xpZW50IiwibW9ja0RhdGEiLCJncm91cHMiLCJNYXAiLCJndWVzdHMiLCJ1c2VycyIsImZyb20iLCJ0YWJsZSIsInNlbGVjdCIsImNvbHVtbnMiLCJlcSIsImNvbHVtbiIsInZhbHVlIiwic2luZ2xlIiwiZ3Vlc3QiLCJBcnJheSIsInZhbHVlcyIsImZpbmQiLCJnIiwiZGF0YSIsImVycm9yIiwibWVzc2FnZSIsInRoZW4iLCJyZXNvbHZlIiwiZmlsdGVyIiwidXBkYXRlIiwiZ2V0IiwidXBkYXRlZCIsInNldCIsImluc2VydCIsImlkIiwiRGF0ZSIsIm5vdyIsIk1hdGgiLCJyYW5kb20iLCJyZWNvcmQiLCJhdXRoIiwiZ2V0U2Vzc2lvbiIsInNlc3Npb24iLCJ1c2VyIiwiZW1haWwiLCJfbW9ja0RhdGEiLCJncm91cElkQXJiaXRyYXJ5IiwiZmMiLCJ1dWlkIiwiY2hpbGRHdWVzdEFyYml0cmFyeSIsImdyb3VwX2lkIiwiZmlyc3RfbmFtZSIsInN0cmluZyIsIm1pbkxlbmd0aCIsIm1heExlbmd0aCIsImxhc3RfbmFtZSIsIm9wdGlvbiIsImVtYWlsQWRkcmVzcyIsIm5pbCIsInVuZGVmaW5lZCIsImFnZV90eXBlIiwiY29uc3RhbnQiLCJndWVzdF90eXBlIiwiY29uc3RhbnRGcm9tIiwiY3JlYXRlZF9hdCIsImRhdGUiLCJtYXAiLCJkIiwidG9JU09TdHJpbmciLCJ1cGRhdGVkX2F0IiwiZmFtaWx5TWVtYmVyQXJiaXRyYXJ5IiwiY2FuQ2hpbGRBY2Nlc3MiLCJjaGlsZElkIiwidGFyZ2V0SWQiLCJkZXNjcmliZSIsIml0IiwiYXNzZXJ0IiwiYXN5bmNQcm9wZXJ0eSIsImFycmF5IiwiZ3JvdXBJZCIsImNoaWxkR3Vlc3QiLCJvdGhlckZhbWlseU1lbWJlcnMiLCJtb2NrQ2xpZW50IiwiY2hpbGQiLCJmb3JFYWNoIiwibWVtYmVyIiwiZmFtaWx5TWVtYmVyIiwiYWNjZXNzaWJsZU1lbWJlcnMiLCJleHBlY3QiLCJ0b0hhdmVMZW5ndGgiLCJ0b0JlIiwiY2FuQWNjZXNzIiwibnVtUnVucyIsIm90aGVyTWVtYmVyIiwibmV3Rmlyc3ROYW1lIiwicHJlIiwib3RoZXIiLCJjYW5FZGl0U2VsZiIsInNlbGZVcGRhdGVSZXN1bHQiLCJ0b0JlRGVmaW5lZCIsImNhbkVkaXRPdGhlciIsInBhcmVudEd1ZXN0IiwicGFyZW50IiwiY2FuQWNjZXNzUGFyZW50IiwiY2hpbGRHdWVzdDEiLCJjaGlsZEd1ZXN0MiIsImNoaWxkMSIsImNoaWxkMiIsImNhbkFjY2Vzc1NpYmxpbmciLCJvdGhlck1lbWJlcnMiLCJ1bmlxdWVPdGhlcnMiLCJtIiwibGVuZ3RoIiwiYWNjZXNzaWJsZUNvdW50Il0sIm1hcHBpbmdzIjoiOzs7O21FQUFvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRXBCOzs7Ozs7OztDQVFDLEdBRUQsbUNBQW1DO0FBQ25DLFNBQVNBO0lBQ1AsTUFBTUMsV0FBVztRQUNmQyxRQUFRLElBQUlDO1FBQ1pDLFFBQVEsSUFBSUQ7UUFDWkUsT0FBTyxJQUFJRjtJQUNiO0lBRUEsT0FBTztRQUNMRyxNQUFNLENBQUNDLFFBQW1CLENBQUE7Z0JBQ3hCQyxRQUFRLENBQUNDLFVBQWtCLEdBQUcsR0FBTSxDQUFBO3dCQUNsQ0MsSUFBSSxDQUFDQyxRQUFnQkMsUUFBZ0IsQ0FBQTtnQ0FDbkNDLFFBQVE7b0NBQ04sSUFBSU4sVUFBVSxVQUFVO3dDQUN0QixNQUFNTyxRQUFRQyxNQUFNVCxJQUFJLENBQUNMLFNBQVNHLE1BQU0sQ0FBQ1ksTUFBTSxJQUFJQyxJQUFJLENBQ3JELENBQUNDLElBQVdBLENBQUMsQ0FBQ1AsT0FBTyxLQUFLQzt3Q0FFNUIsT0FBT0UsUUFDSDs0Q0FBRUssTUFBTUw7NENBQU9NLE9BQU87d0NBQUssSUFDM0I7NENBQUVELE1BQU07NENBQU1DLE9BQU87Z0RBQUVDLFNBQVM7NENBQVk7d0NBQUU7b0NBQ3BEO29DQUNBLE9BQU87d0NBQUVGLE1BQU07d0NBQU1DLE9BQU87NENBQUVDLFNBQVM7d0NBQVk7b0NBQUU7Z0NB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