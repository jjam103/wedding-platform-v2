d5c423a67862b29f23453cec634037a2
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _globals = require("@jest/globals");
const _sectionsService = require("./sectionsService");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Mock Supabase before importing services
const mockFrom = _globals.jest.fn();
const mockSupabase = {
    from: mockFrom
};
_globals.jest.mock('../lib/supabase', ()=>({
        supabase: mockSupabase
    }));
// Helper to create properly typed mock chain
function createMockQueryChain(resolvedValue) {
    const mockSingle = _globals.jest.fn().mockResolvedValue(resolvedValue);
    const mockEq = _globals.jest.fn().mockReturnValue({
        single: mockSingle
    });
    const mockSelect = _globals.jest.fn().mockReturnValue({
        eq: mockEq
    });
    return {
        select: mockSelect
    };
}
/**
 * Property 5: Reference Entity Validation
 * 
 * For any reference selection, the system SHALL verify that the referenced entity 
 * exists in the database before allowing the reference to be saved.
 * 
 * Validates: Requirements 2.9
 */ (0, _globals.describe)('Feature: admin-backend-integration-cms, Property 5: Reference Entity Validation', ()=>{
    (0, _globals.beforeEach)(()=>{
        _globals.jest.clearAllMocks();
    });
    (0, _globals.it)('should verify that all referenced entities exist in the database', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.array(_fastcheck.record({
            type: _fastcheck.constantFrom('event', 'activity', 'accommodation', 'location'),
            id: _fastcheck.uuid(),
            label: _fastcheck.option(_fastcheck.string({
                minLength: 1,
                maxLength: 100
            })),
            exists: _fastcheck.boolean()
        }), {
            minLength: 1,
            maxLength: 20
        }), async (testReferences)=>{
            // Mock database lookups for each reference
            for (const ref of testReferences){
                mockFrom.mockReturnValueOnce(createMockQueryChain({
                    data: ref.exists ? {
                        id: ref.id
                    } : null,
                    error: ref.exists ? null : {
                        code: 'PGRST116',
                        message: 'Not found'
                    }
                }));
            }
            const references = testReferences.map((r)=>({
                    type: r.type,
                    id: r.id,
                    label: r.label || undefined
                }));
            const result = await (0, _sectionsService.validateReferences)(references);
            // Property: Validation operation should always succeed
            (0, _globals.expect)(result.success).toBe(true);
            if (!result.success) {
                return true;
            }
            // Property: All non-existent references should be detected as broken
            const expectedBrokenCount = testReferences.filter((r)=>!r.exists).length;
            (0, _globals.expect)(result.data.brokenReferences.length).toBe(expectedBrokenCount);
            // Property: Each broken reference should correspond to a non-existent entity
            for (const broken of result.data.brokenReferences){
                const original = testReferences.find((r)=>r.id === broken.id && r.type === broken.type);
                (0, _globals.expect)(original).toBeDefined();
                (0, _globals.expect)(original?.exists).toBe(false);
            }
            // Property: Validation is valid only when all entities exist
            const allExist = testReferences.every((r)=>r.exists);
            (0, _globals.expect)(result.data.valid).toBe(allExist);
            return true;
        }), {
            numRuns: 100
        });
    });
    (0, _globals.it)('should return valid=true when all referenced entities exist in database', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.array(_fastcheck.record({
            type: _fastcheck.constantFrom('event', 'activity', 'accommodation', 'location'),
            id: _fastcheck.uuid(),
            label: _fastcheck.option(_fastcheck.string({
                minLength: 1,
                maxLength: 100
            }))
        }), {
            minLength: 1,
            maxLength: 15
        }), async (testReferences)=>{
            // Mock all references as existing in database
            for (const ref of testReferences){
                mockFrom.mockReturnValueOnce(createMockQueryChain({
                    data: {
                        id: ref.id
                    },
                    error: null
                }));
            }
            const references = testReferences.map((r)=>({
                    type: r.type,
                    id: r.id,
                    label: r.label || undefined
                }));
            const result = await (0, _sectionsService.validateReferences)(references);
            // Property: Validation should succeed
            (0, _globals.expect)(result.success).toBe(true);
            if (!result.success) {
                return true;
            }
            // Property: All references exist, so validation should be valid
            (0, _globals.expect)(result.data.valid).toBe(true);
            (0, _globals.expect)(result.data.brokenReferences).toHaveLength(0);
            return true;
        }), {
            numRuns: 100
        });
    });
    (0, _globals.it)('should return valid=false and identify broken references when entities do not exist', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
            validRefs: _fastcheck.array(_fastcheck.record({
                type: _fastcheck.constantFrom('event', 'activity', 'accommodation', 'location'),
                id: _fastcheck.uuid(),
                label: _fastcheck.option(_fastcheck.string({
                    minLength: 1,
                    maxLength: 100
                }))
            }), {
                minLength: 0,
                maxLength: 5
            }),
            brokenRefs: _fastcheck.array(_fastcheck.record({
                type: _fastcheck.constantFrom('event', 'activity', 'accommodation', 'location'),
                id: _fastcheck.uuid(),
                label: _fastcheck.option(_fastcheck.string({
                    minLength: 1,
                    maxLength: 100
                }))
            }), {
                minLength: 1,
                maxLength: 5
            })
        }), async (testData)=>{
            // Mock valid references as existing
            for (const ref of testData.validRefs){
                mockFrom.mockReturnValueOnce(createMockQueryChain({
                    data: {
                        id: ref.id
                    },
                    error: null
                }));
            }
            // Mock broken references as not existing
            for (const ref of testData.brokenRefs){
                mockFrom.mockReturnValueOnce(createMockQueryChain({
                    data: null,
                    error: {
                        code: 'PGRST116',
                        message: 'Not found'
                    }
                }));
            }
            const references = [
                ...testData.validRefs.map((r)=>({
                        type: r.type,
                        id: r.id,
                        label: r.label || undefined
                    })),
                ...testData.brokenRefs.map((r)=>({
                        type: r.type,
                        id: r.id,
                        label: r.label || undefined
                    }))
            ];
            const result = await (0, _sectionsService.validateReferences)(references);
            // Property: Validation should succeed
            (0, _globals.expect)(result.success).toBe(true);
            if (!result.success) {
                return true;
            }
            // Property: Should be invalid when any reference is broken
            (0, _globals.expect)(result.data.valid).toBe(false);
            (0, _globals.expect)(result.data.brokenReferences.length).toBe(testData.brokenRefs.length);
            // Property: All broken references should be identified
            for (const brokenRef of testData.brokenRefs){
                const found = result.data.brokenReferences.find((r)=>r.id === brokenRef.id && r.type === brokenRef.type);
                (0, _globals.expect)(found).toBeDefined();
            }
            return true;
        }), {
            numRuns: 50
        });
    });
    (0, _globals.it)('should handle empty reference arrays', async ()=>{
        const result = await (0, _sectionsService.validateReferences)([]);
        // Property: Empty array should be valid
        (0, _globals.expect)(result.success).toBe(true);
        if (result.success) {
            (0, _globals.expect)(result.data.valid).toBe(true);
            (0, _globals.expect)(result.data.brokenReferences).toHaveLength(0);
        }
    });
    (0, _globals.it)('should verify each entity type against its correct database table', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.constantFrom('event', 'activity', 'accommodation', 'location'), _fastcheck.uuid(), _fastcheck.option(_fastcheck.string({
            minLength: 1,
            maxLength: 100
        })), async (type, id, label)=>{
            const expectedTable = type === 'event' ? 'events' : type === 'activity' ? 'activities' : type === 'accommodation' ? 'accommodations' : 'locations';
            mockFrom.mockReturnValueOnce(createMockQueryChain({
                data: {
                    id
                },
                error: null
            }));
            const references = [
                {
                    type,
                    id,
                    label: label || undefined
                }
            ];
            const result = await (0, _sectionsService.validateReferences)(references);
            // Property: Should query the correct table for each entity type
            (0, _globals.expect)(mockFrom).toHaveBeenCalledWith(expectedTable);
            (0, _globals.expect)(result.success).toBe(true);
            return true;
        }), {
            numRuns: 50
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvc2VjdGlvbnNTZXJ2aWNlLnJlZmVyZW5jZVZhbGlkYXRpb24ucHJvcGVydHkudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmYyBmcm9tICdmYXN0LWNoZWNrJztcbmltcG9ydCB7IGplc3QsIGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBiZWZvcmVFYWNoIH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5cbi8vIE1vY2sgU3VwYWJhc2UgYmVmb3JlIGltcG9ydGluZyBzZXJ2aWNlc1xuY29uc3QgbW9ja0Zyb20gPSBqZXN0LmZuKCkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+O1xuY29uc3QgbW9ja1N1cGFiYXNlID0ge1xuICBmcm9tOiBtb2NrRnJvbSxcbn07XG5cbmplc3QubW9jaygnLi4vbGliL3N1cGFiYXNlJywgKCkgPT4gKHtcbiAgc3VwYWJhc2U6IG1vY2tTdXBhYmFzZSxcbn0pKTtcblxuLy8gSW1wb3J0IGFmdGVyIG1vY2tpbmdcbmltcG9ydCB7IHZhbGlkYXRlUmVmZXJlbmNlcyB9IGZyb20gJy4vc2VjdGlvbnNTZXJ2aWNlJztcbmltcG9ydCB0eXBlIHsgUmVmZXJlbmNlIH0gZnJvbSAnLi4vc2NoZW1hcy9jbXNTY2hlbWFzJztcblxuLy8gSGVscGVyIHRvIGNyZWF0ZSBwcm9wZXJseSB0eXBlZCBtb2NrIGNoYWluXG5mdW5jdGlvbiBjcmVhdGVNb2NrUXVlcnlDaGFpbihyZXNvbHZlZFZhbHVlOiB7IGRhdGE6IGFueTsgZXJyb3I6IGFueSB9KSB7XG4gIGNvbnN0IG1vY2tTaW5nbGUgPSAoamVzdC5mbigpIGFzIGFueSkubW9ja1Jlc29sdmVkVmFsdWUocmVzb2x2ZWRWYWx1ZSk7XG4gIGNvbnN0IG1vY2tFcSA9IChqZXN0LmZuKCkgYXMgYW55KS5tb2NrUmV0dXJuVmFsdWUoeyBzaW5nbGU6IG1vY2tTaW5nbGUgfSk7XG4gIGNvbnN0IG1vY2tTZWxlY3QgPSAoamVzdC5mbigpIGFzIGFueSkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcSB9KTtcbiAgcmV0dXJuIHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0gYXMgYW55O1xufVxuXG4vKipcbiAqIFByb3BlcnR5IDU6IFJlZmVyZW5jZSBFbnRpdHkgVmFsaWRhdGlvblxuICogXG4gKiBGb3IgYW55IHJlZmVyZW5jZSBzZWxlY3Rpb24sIHRoZSBzeXN0ZW0gU0hBTEwgdmVyaWZ5IHRoYXQgdGhlIHJlZmVyZW5jZWQgZW50aXR5IFxuICogZXhpc3RzIGluIHRoZSBkYXRhYmFzZSBiZWZvcmUgYWxsb3dpbmcgdGhlIHJlZmVyZW5jZSB0byBiZSBzYXZlZC5cbiAqIFxuICogVmFsaWRhdGVzOiBSZXF1aXJlbWVudHMgMi45XG4gKi9cbmRlc2NyaWJlKCdGZWF0dXJlOiBhZG1pbi1iYWNrZW5kLWludGVncmF0aW9uLWNtcywgUHJvcGVydHkgNTogUmVmZXJlbmNlIEVudGl0eSBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCB2ZXJpZnkgdGhhdCBhbGwgcmVmZXJlbmNlZCBlbnRpdGllcyBleGlzdCBpbiB0aGUgZGF0YWJhc2UnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMuYXJyYXkoXG4gICAgICAgICAgZmMucmVjb3JkKHtcbiAgICAgICAgICAgIHR5cGU6IGZjLmNvbnN0YW50RnJvbSgnZXZlbnQnLCAnYWN0aXZpdHknLCAnYWNjb21tb2RhdGlvbicsICdsb2NhdGlvbicpIGFzIGZjLkFyYml0cmFyeTwnZXZlbnQnIHwgJ2FjdGl2aXR5JyB8ICdhY2NvbW1vZGF0aW9uJyB8ICdsb2NhdGlvbic+LFxuICAgICAgICAgICAgaWQ6IGZjLnV1aWQoKSxcbiAgICAgICAgICAgIGxhYmVsOiBmYy5vcHRpb24oZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwMCB9KSksXG4gICAgICAgICAgICBleGlzdHM6IGZjLmJvb2xlYW4oKSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAyMCB9XG4gICAgICAgICksXG4gICAgICAgIGFzeW5jICh0ZXN0UmVmZXJlbmNlcykgPT4ge1xuICAgICAgICAgIC8vIE1vY2sgZGF0YWJhc2UgbG9va3VwcyBmb3IgZWFjaCByZWZlcmVuY2VcbiAgICAgICAgICBmb3IgKGNvbnN0IHJlZiBvZiB0ZXN0UmVmZXJlbmNlcykge1xuICAgICAgICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlT25jZShjcmVhdGVNb2NrUXVlcnlDaGFpbih7XG4gICAgICAgICAgICAgIGRhdGE6IHJlZi5leGlzdHMgPyB7IGlkOiByZWYuaWQgfSA6IG51bGwsXG4gICAgICAgICAgICAgIGVycm9yOiByZWYuZXhpc3RzID8gbnVsbCA6IHsgY29kZTogJ1BHUlNUMTE2JywgbWVzc2FnZTogJ05vdCBmb3VuZCcgfSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCByZWZlcmVuY2VzOiBSZWZlcmVuY2VbXSA9IHRlc3RSZWZlcmVuY2VzLm1hcChyID0+ICh7XG4gICAgICAgICAgICB0eXBlOiByLnR5cGUsXG4gICAgICAgICAgICBpZDogci5pZCxcbiAgICAgICAgICAgIGxhYmVsOiByLmxhYmVsIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0ZVJlZmVyZW5jZXMocmVmZXJlbmNlcyk7XG5cbiAgICAgICAgICAvLyBQcm9wZXJ0eTogVmFsaWRhdGlvbiBvcGVyYXRpb24gc2hvdWxkIGFsd2F5cyBzdWNjZWVkXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuXG4gICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IEFsbCBub24tZXhpc3RlbnQgcmVmZXJlbmNlcyBzaG91bGQgYmUgZGV0ZWN0ZWQgYXMgYnJva2VuXG4gICAgICAgICAgY29uc3QgZXhwZWN0ZWRCcm9rZW5Db3VudCA9IHRlc3RSZWZlcmVuY2VzLmZpbHRlcihyID0+ICFyLmV4aXN0cykubGVuZ3RoO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5icm9rZW5SZWZlcmVuY2VzLmxlbmd0aCkudG9CZShleHBlY3RlZEJyb2tlbkNvdW50KTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBFYWNoIGJyb2tlbiByZWZlcmVuY2Ugc2hvdWxkIGNvcnJlc3BvbmQgdG8gYSBub24tZXhpc3RlbnQgZW50aXR5XG4gICAgICAgICAgZm9yIChjb25zdCBicm9rZW4gb2YgcmVzdWx0LmRhdGEuYnJva2VuUmVmZXJlbmNlcykge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSB0ZXN0UmVmZXJlbmNlcy5maW5kKHIgPT4gci5pZCA9PT0gYnJva2VuLmlkICYmIHIudHlwZSA9PT0gYnJva2VuLnR5cGUpO1xuICAgICAgICAgICAgZXhwZWN0KG9yaWdpbmFsKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KG9yaWdpbmFsPy5leGlzdHMpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBWYWxpZGF0aW9uIGlzIHZhbGlkIG9ubHkgd2hlbiBhbGwgZW50aXRpZXMgZXhpc3RcbiAgICAgICAgICBjb25zdCBhbGxFeGlzdCA9IHRlc3RSZWZlcmVuY2VzLmV2ZXJ5KHIgPT4gci5leGlzdHMpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS52YWxpZCkudG9CZShhbGxFeGlzdCk7XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHJldHVybiB2YWxpZD10cnVlIHdoZW4gYWxsIHJlZmVyZW5jZWQgZW50aXRpZXMgZXhpc3QgaW4gZGF0YWJhc2UnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMuYXJyYXkoXG4gICAgICAgICAgZmMucmVjb3JkKHtcbiAgICAgICAgICAgIHR5cGU6IGZjLmNvbnN0YW50RnJvbSgnZXZlbnQnLCAnYWN0aXZpdHknLCAnYWNjb21tb2RhdGlvbicsICdsb2NhdGlvbicpIGFzIGZjLkFyYml0cmFyeTwnZXZlbnQnIHwgJ2FjdGl2aXR5JyB8ICdhY2NvbW1vZGF0aW9uJyB8ICdsb2NhdGlvbic+LFxuICAgICAgICAgICAgaWQ6IGZjLnV1aWQoKSxcbiAgICAgICAgICAgIGxhYmVsOiBmYy5vcHRpb24oZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwMCB9KSksXG4gICAgICAgICAgfSksXG4gICAgICAgICAgeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTUgfVxuICAgICAgICApLFxuICAgICAgICBhc3luYyAodGVzdFJlZmVyZW5jZXMpID0+IHtcbiAgICAgICAgICAvLyBNb2NrIGFsbCByZWZlcmVuY2VzIGFzIGV4aXN0aW5nIGluIGRhdGFiYXNlXG4gICAgICAgICAgZm9yIChjb25zdCByZWYgb2YgdGVzdFJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZU9uY2UoY3JlYXRlTW9ja1F1ZXJ5Q2hhaW4oe1xuICAgICAgICAgICAgICBkYXRhOiB7IGlkOiByZWYuaWQgfSxcbiAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcmVmZXJlbmNlczogUmVmZXJlbmNlW10gPSB0ZXN0UmVmZXJlbmNlcy5tYXAociA9PiAoe1xuICAgICAgICAgICAgdHlwZTogci50eXBlLFxuICAgICAgICAgICAgaWQ6IHIuaWQsXG4gICAgICAgICAgICBsYWJlbDogci5sYWJlbCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGVSZWZlcmVuY2VzKHJlZmVyZW5jZXMpO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IFZhbGlkYXRpb24gc2hvdWxkIHN1Y2NlZWRcbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBQcm9wZXJ0eTogQWxsIHJlZmVyZW5jZXMgZXhpc3QsIHNvIHZhbGlkYXRpb24gc2hvdWxkIGJlIHZhbGlkXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnZhbGlkKS50b0JlKHRydWUpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5icm9rZW5SZWZlcmVuY2VzKS50b0hhdmVMZW5ndGgoMCk7XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHJldHVybiB2YWxpZD1mYWxzZSBhbmQgaWRlbnRpZnkgYnJva2VuIHJlZmVyZW5jZXMgd2hlbiBlbnRpdGllcyBkbyBub3QgZXhpc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMucmVjb3JkKHtcbiAgICAgICAgICB2YWxpZFJlZnM6IGZjLmFycmF5KFxuICAgICAgICAgICAgZmMucmVjb3JkKHtcbiAgICAgICAgICAgICAgdHlwZTogZmMuY29uc3RhbnRGcm9tKCdldmVudCcsICdhY3Rpdml0eScsICdhY2NvbW1vZGF0aW9uJywgJ2xvY2F0aW9uJykgYXMgZmMuQXJiaXRyYXJ5PCdldmVudCcgfCAnYWN0aXZpdHknIHwgJ2FjY29tbW9kYXRpb24nIHwgJ2xvY2F0aW9uJz4sXG4gICAgICAgICAgICAgIGlkOiBmYy51dWlkKCksXG4gICAgICAgICAgICAgIGxhYmVsOiBmYy5vcHRpb24oZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwMCB9KSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHsgbWluTGVuZ3RoOiAwLCBtYXhMZW5ndGg6IDUgfVxuICAgICAgICAgICksXG4gICAgICAgICAgYnJva2VuUmVmczogZmMuYXJyYXkoXG4gICAgICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgICAgICB0eXBlOiBmYy5jb25zdGFudEZyb20oJ2V2ZW50JywgJ2FjdGl2aXR5JywgJ2FjY29tbW9kYXRpb24nLCAnbG9jYXRpb24nKSBhcyBmYy5BcmJpdHJhcnk8J2V2ZW50JyB8ICdhY3Rpdml0eScgfCAnYWNjb21tb2RhdGlvbicgfCAnbG9jYXRpb24nPixcbiAgICAgICAgICAgICAgaWQ6IGZjLnV1aWQoKSxcbiAgICAgICAgICAgICAgbGFiZWw6IGZjLm9wdGlvbihmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTAwIH0pKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogNSB9XG4gICAgICAgICAgKSxcbiAgICAgICAgfSksXG4gICAgICAgIGFzeW5jICh0ZXN0RGF0YSkgPT4ge1xuICAgICAgICAgIC8vIE1vY2sgdmFsaWQgcmVmZXJlbmNlcyBhcyBleGlzdGluZ1xuICAgICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHRlc3REYXRhLnZhbGlkUmVmcykge1xuICAgICAgICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlT25jZShjcmVhdGVNb2NrUXVlcnlDaGFpbih7XG4gICAgICAgICAgICAgIGRhdGE6IHsgaWQ6IHJlZi5pZCB9LFxuICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBNb2NrIGJyb2tlbiByZWZlcmVuY2VzIGFzIG5vdCBleGlzdGluZ1xuICAgICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHRlc3REYXRhLmJyb2tlblJlZnMpIHtcbiAgICAgICAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZU9uY2UoY3JlYXRlTW9ja1F1ZXJ5Q2hhaW4oe1xuICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICBlcnJvcjogeyBjb2RlOiAnUEdSU1QxMTYnLCBtZXNzYWdlOiAnTm90IGZvdW5kJyB9LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZXM6IFJlZmVyZW5jZVtdID0gW1xuICAgICAgICAgICAgLi4udGVzdERhdGEudmFsaWRSZWZzLm1hcChyID0+ICh7IHR5cGU6IHIudHlwZSwgaWQ6IHIuaWQsIGxhYmVsOiByLmxhYmVsIHx8IHVuZGVmaW5lZCB9KSksXG4gICAgICAgICAgICAuLi50ZXN0RGF0YS5icm9rZW5SZWZzLm1hcChyID0+ICh7IHR5cGU6IHIudHlwZSwgaWQ6IHIuaWQsIGxhYmVsOiByLmxhYmVsIHx8IHVuZGVmaW5lZCB9KSksXG4gICAgICAgICAgXTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlUmVmZXJlbmNlcyhyZWZlcmVuY2VzKTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBWYWxpZGF0aW9uIHNob3VsZCBzdWNjZWVkXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuXG4gICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IFNob3VsZCBiZSBpbnZhbGlkIHdoZW4gYW55IHJlZmVyZW5jZSBpcyBicm9rZW5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5icm9rZW5SZWZlcmVuY2VzLmxlbmd0aCkudG9CZSh0ZXN0RGF0YS5icm9rZW5SZWZzLmxlbmd0aCk7XG5cbiAgICAgICAgICAvLyBQcm9wZXJ0eTogQWxsIGJyb2tlbiByZWZlcmVuY2VzIHNob3VsZCBiZSBpZGVudGlmaWVkXG4gICAgICAgICAgZm9yIChjb25zdCBicm9rZW5SZWYgb2YgdGVzdERhdGEuYnJva2VuUmVmcykge1xuICAgICAgICAgICAgY29uc3QgZm91bmQgPSByZXN1bHQuZGF0YS5icm9rZW5SZWZlcmVuY2VzLmZpbmQoXG4gICAgICAgICAgICAgIHIgPT4gci5pZCA9PT0gYnJva2VuUmVmLmlkICYmIHIudHlwZSA9PT0gYnJva2VuUmVmLnR5cGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBleHBlY3QoZm91bmQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDUwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGhhbmRsZSBlbXB0eSByZWZlcmVuY2UgYXJyYXlzJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlUmVmZXJlbmNlcyhbXSk7XG5cbiAgICAvLyBQcm9wZXJ0eTogRW1wdHkgYXJyYXkgc2hvdWxkIGJlIHZhbGlkXG4gICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnZhbGlkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmJyb2tlblJlZmVyZW5jZXMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICB9XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgdmVyaWZ5IGVhY2ggZW50aXR5IHR5cGUgYWdhaW5zdCBpdHMgY29ycmVjdCBkYXRhYmFzZSB0YWJsZScsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBmYy5jb25zdGFudEZyb20oJ2V2ZW50JywgJ2FjdGl2aXR5JywgJ2FjY29tbW9kYXRpb24nLCAnbG9jYXRpb24nKSBhcyBmYy5BcmJpdHJhcnk8J2V2ZW50JyB8ICdhY3Rpdml0eScgfCAnYWNjb21tb2RhdGlvbicgfCAnbG9jYXRpb24nPixcbiAgICAgICAgZmMudXVpZCgpLFxuICAgICAgICBmYy5vcHRpb24oZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwMCB9KSksXG4gICAgICAgIGFzeW5jICh0eXBlLCBpZCwgbGFiZWwpID0+IHtcbiAgICAgICAgICBjb25zdCBleHBlY3RlZFRhYmxlID0gXG4gICAgICAgICAgICB0eXBlID09PSAnZXZlbnQnID8gJ2V2ZW50cycgOlxuICAgICAgICAgICAgdHlwZSA9PT0gJ2FjdGl2aXR5JyA/ICdhY3Rpdml0aWVzJyA6XG4gICAgICAgICAgICB0eXBlID09PSAnYWNjb21tb2RhdGlvbicgPyAnYWNjb21tb2RhdGlvbnMnIDpcbiAgICAgICAgICAgICdsb2NhdGlvbnMnO1xuXG4gICAgICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlT25jZShjcmVhdGVNb2NrUXVlcnlDaGFpbih7XG4gICAgICAgICAgICBkYXRhOiB7IGlkIH0sXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjb25zdCByZWZlcmVuY2VzOiBSZWZlcmVuY2VbXSA9IFt7IHR5cGUsIGlkLCBsYWJlbDogbGFiZWwgfHwgdW5kZWZpbmVkIH1dO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlUmVmZXJlbmNlcyhyZWZlcmVuY2VzKTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBTaG91bGQgcXVlcnkgdGhlIGNvcnJlY3QgdGFibGUgZm9yIGVhY2ggZW50aXR5IHR5cGVcbiAgICAgICAgICBleHBlY3QobW9ja0Zyb20pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdGVkVGFibGUpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiA1MCB9XG4gICAgKTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJtb2NrRnJvbSIsImplc3QiLCJmbiIsIm1vY2tTdXBhYmFzZSIsImZyb20iLCJtb2NrIiwic3VwYWJhc2UiLCJjcmVhdGVNb2NrUXVlcnlDaGFpbiIsInJlc29sdmVkVmFsdWUiLCJtb2NrU2luZ2xlIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJtb2NrRXEiLCJtb2NrUmV0dXJuVmFsdWUiLCJzaW5nbGUiLCJtb2NrU2VsZWN0IiwiZXEiLCJzZWxlY3QiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiaXQiLCJmYyIsImFzc2VydCIsImFzeW5jUHJvcGVydHkiLCJhcnJheSIsInJlY29yZCIsInR5cGUiLCJjb25zdGFudEZyb20iLCJpZCIsInV1aWQiLCJsYWJlbCIsIm9wdGlvbiIsInN0cmluZyIsIm1pbkxlbmd0aCIsIm1heExlbmd0aCIsImV4aXN0cyIsImJvb2xlYW4iLCJ0ZXN0UmVmZXJlbmNlcyIsInJlZiIsIm1vY2tSZXR1cm5WYWx1ZU9uY2UiLCJkYXRhIiwiZXJyb3IiLCJjb2RlIiwibWVzc2FnZSIsInJlZmVyZW5jZXMiLCJtYXAiLCJyIiwidW5kZWZpbmVkIiwicmVzdWx0IiwidmFsaWRhdGVSZWZlcmVuY2VzIiwiZXhwZWN0Iiwic3VjY2VzcyIsInRvQmUiLCJleHBlY3RlZEJyb2tlbkNvdW50IiwiZmlsdGVyIiwibGVuZ3RoIiwiYnJva2VuUmVmZXJlbmNlcyIsImJyb2tlbiIsIm9yaWdpbmFsIiwiZmluZCIsInRvQmVEZWZpbmVkIiwiYWxsRXhpc3QiLCJldmVyeSIsInZhbGlkIiwibnVtUnVucyIsInRvSGF2ZUxlbmd0aCIsInZhbGlkUmVmcyIsImJyb2tlblJlZnMiLCJ0ZXN0RGF0YSIsImJyb2tlblJlZiIsImZvdW5kIiwiZXhwZWN0ZWRUYWJsZSIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIl0sIm1hcHBpbmdzIjoiOzs7O21FQUFvQjt5QkFDbUM7aUNBYXBCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFYbkMsMENBQTBDO0FBQzFDLE1BQU1BLFdBQVdDLGFBQUksQ0FBQ0MsRUFBRTtBQUN4QixNQUFNQyxlQUFlO0lBQ25CQyxNQUFNSjtBQUNSO0FBRUFDLGFBQUksQ0FBQ0ksSUFBSSxDQUFDLG1CQUFtQixJQUFPLENBQUE7UUFDbENDLFVBQVVIO0lBQ1osQ0FBQTtBQU1BLDZDQUE2QztBQUM3QyxTQUFTSSxxQkFBcUJDLGFBQXdDO0lBQ3BFLE1BQU1DLGFBQWEsQUFBQ1IsYUFBSSxDQUFDQyxFQUFFLEdBQVdRLGlCQUFpQixDQUFDRjtJQUN4RCxNQUFNRyxTQUFTLEFBQUNWLGFBQUksQ0FBQ0MsRUFBRSxHQUFXVSxlQUFlLENBQUM7UUFBRUMsUUFBUUo7SUFBVztJQUN2RSxNQUFNSyxhQUFhLEFBQUNiLGFBQUksQ0FBQ0MsRUFBRSxHQUFXVSxlQUFlLENBQUM7UUFBRUcsSUFBSUo7SUFBTztJQUNuRSxPQUFPO1FBQUVLLFFBQVFGO0lBQVc7QUFDOUI7QUFFQTs7Ozs7OztDQU9DLEdBQ0RHLElBQUFBLGlCQUFRLEVBQUMsbUZBQW1G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