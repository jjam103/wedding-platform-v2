{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/services/sectionsService.referenceValidation.property.test.ts"],"sourcesContent":["import * as fc from 'fast-check';\nimport { jest, describe, it, expect, beforeEach } from '@jest/globals';\n\n// Mock Supabase before importing services\nconst mockFrom = jest.fn() as jest.MockedFunction<any>;\nconst mockSupabase = {\n  from: mockFrom,\n};\n\njest.mock('../lib/supabase', () => ({\n  supabase: mockSupabase,\n}));\n\n// Import after mocking\nimport { validateReferences } from './sectionsService';\nimport type { Reference } from '../schemas/cmsSchemas';\n\n// Helper to create properly typed mock chain\nfunction createMockQueryChain(resolvedValue: { data: any; error: any }) {\n  const mockSingle = (jest.fn() as any).mockResolvedValue(resolvedValue);\n  const mockEq = (jest.fn() as any).mockReturnValue({ single: mockSingle });\n  const mockSelect = (jest.fn() as any).mockReturnValue({ eq: mockEq });\n  return { select: mockSelect } as any;\n}\n\n/**\n * Property 5: Reference Entity Validation\n * \n * For any reference selection, the system SHALL verify that the referenced entity \n * exists in the database before allowing the reference to be saved.\n * \n * Validates: Requirements 2.9\n */\ndescribe('Feature: admin-backend-integration-cms, Property 5: Reference Entity Validation', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('should verify that all referenced entities exist in the database', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.array(\n          fc.record({\n            type: fc.constantFrom('event', 'activity', 'accommodation', 'location') as fc.Arbitrary<'event' | 'activity' | 'accommodation' | 'location'>,\n            id: fc.uuid(),\n            label: fc.option(fc.string({ minLength: 1, maxLength: 100 })),\n            exists: fc.boolean(),\n          }),\n          { minLength: 1, maxLength: 20 }\n        ),\n        async (testReferences) => {\n          // Mock database lookups for each reference\n          for (const ref of testReferences) {\n            mockFrom.mockReturnValueOnce(createMockQueryChain({\n              data: ref.exists ? { id: ref.id } : null,\n              error: ref.exists ? null : { code: 'PGRST116', message: 'Not found' },\n            }));\n          }\n\n          const references: Reference[] = testReferences.map(r => ({\n            type: r.type,\n            id: r.id,\n            label: r.label || undefined,\n          }));\n\n          const result = await validateReferences(references);\n\n          // Property: Validation operation should always succeed\n          expect(result.success).toBe(true);\n\n          if (!result.success) {\n            return true;\n          }\n\n          // Property: All non-existent references should be detected as broken\n          const expectedBrokenCount = testReferences.filter(r => !r.exists).length;\n          expect(result.data.brokenReferences.length).toBe(expectedBrokenCount);\n\n          // Property: Each broken reference should correspond to a non-existent entity\n          for (const broken of result.data.brokenReferences) {\n            const original = testReferences.find(r => r.id === broken.id && r.type === broken.type);\n            expect(original).toBeDefined();\n            expect(original?.exists).toBe(false);\n          }\n\n          // Property: Validation is valid only when all entities exist\n          const allExist = testReferences.every(r => r.exists);\n          expect(result.data.valid).toBe(allExist);\n\n          return true;\n        }\n      ),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should return valid=true when all referenced entities exist in database', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.array(\n          fc.record({\n            type: fc.constantFrom('event', 'activity', 'accommodation', 'location') as fc.Arbitrary<'event' | 'activity' | 'accommodation' | 'location'>,\n            id: fc.uuid(),\n            label: fc.option(fc.string({ minLength: 1, maxLength: 100 })),\n          }),\n          { minLength: 1, maxLength: 15 }\n        ),\n        async (testReferences) => {\n          // Mock all references as existing in database\n          for (const ref of testReferences) {\n            mockFrom.mockReturnValueOnce(createMockQueryChain({\n              data: { id: ref.id },\n              error: null,\n            }));\n          }\n\n          const references: Reference[] = testReferences.map(r => ({\n            type: r.type,\n            id: r.id,\n            label: r.label || undefined,\n          }));\n\n          const result = await validateReferences(references);\n\n          // Property: Validation should succeed\n          expect(result.success).toBe(true);\n\n          if (!result.success) {\n            return true;\n          }\n\n          // Property: All references exist, so validation should be valid\n          expect(result.data.valid).toBe(true);\n          expect(result.data.brokenReferences).toHaveLength(0);\n\n          return true;\n        }\n      ),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should return valid=false and identify broken references when entities do not exist', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.record({\n          validRefs: fc.array(\n            fc.record({\n              type: fc.constantFrom('event', 'activity', 'accommodation', 'location') as fc.Arbitrary<'event' | 'activity' | 'accommodation' | 'location'>,\n              id: fc.uuid(),\n              label: fc.option(fc.string({ minLength: 1, maxLength: 100 })),\n            }),\n            { minLength: 0, maxLength: 5 }\n          ),\n          brokenRefs: fc.array(\n            fc.record({\n              type: fc.constantFrom('event', 'activity', 'accommodation', 'location') as fc.Arbitrary<'event' | 'activity' | 'accommodation' | 'location'>,\n              id: fc.uuid(),\n              label: fc.option(fc.string({ minLength: 1, maxLength: 100 })),\n            }),\n            { minLength: 1, maxLength: 5 }\n          ),\n        }),\n        async (testData) => {\n          // Mock valid references as existing\n          for (const ref of testData.validRefs) {\n            mockFrom.mockReturnValueOnce(createMockQueryChain({\n              data: { id: ref.id },\n              error: null,\n            }));\n          }\n\n          // Mock broken references as not existing\n          for (const ref of testData.brokenRefs) {\n            mockFrom.mockReturnValueOnce(createMockQueryChain({\n              data: null,\n              error: { code: 'PGRST116', message: 'Not found' },\n            }));\n          }\n\n          const references: Reference[] = [\n            ...testData.validRefs.map(r => ({ type: r.type, id: r.id, label: r.label || undefined })),\n            ...testData.brokenRefs.map(r => ({ type: r.type, id: r.id, label: r.label || undefined })),\n          ];\n\n          const result = await validateReferences(references);\n\n          // Property: Validation should succeed\n          expect(result.success).toBe(true);\n\n          if (!result.success) {\n            return true;\n          }\n\n          // Property: Should be invalid when any reference is broken\n          expect(result.data.valid).toBe(false);\n          expect(result.data.brokenReferences.length).toBe(testData.brokenRefs.length);\n\n          // Property: All broken references should be identified\n          for (const brokenRef of testData.brokenRefs) {\n            const found = result.data.brokenReferences.find(\n              r => r.id === brokenRef.id && r.type === brokenRef.type\n            );\n            expect(found).toBeDefined();\n          }\n\n          return true;\n        }\n      ),\n      { numRuns: 50 }\n    );\n  });\n\n  it('should handle empty reference arrays', async () => {\n    const result = await validateReferences([]);\n\n    // Property: Empty array should be valid\n    expect(result.success).toBe(true);\n    if (result.success) {\n      expect(result.data.valid).toBe(true);\n      expect(result.data.brokenReferences).toHaveLength(0);\n    }\n  });\n\n  it('should verify each entity type against its correct database table', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.constantFrom('event', 'activity', 'accommodation', 'location') as fc.Arbitrary<'event' | 'activity' | 'accommodation' | 'location'>,\n        fc.uuid(),\n        fc.option(fc.string({ minLength: 1, maxLength: 100 })),\n        async (type, id, label) => {\n          const expectedTable = \n            type === 'event' ? 'events' :\n            type === 'activity' ? 'activities' :\n            type === 'accommodation' ? 'accommodations' :\n            'locations';\n\n          mockFrom.mockReturnValueOnce(createMockQueryChain({\n            data: { id },\n            error: null,\n          }));\n\n          const references: Reference[] = [{ type, id, label: label || undefined }];\n          const result = await validateReferences(references);\n\n          // Property: Should query the correct table for each entity type\n          expect(mockFrom).toHaveBeenCalledWith(expectedTable);\n          expect(result.success).toBe(true);\n\n          return true;\n        }\n      ),\n      { numRuns: 50 }\n    );\n  });\n});\n"],"names":["mockFrom","jest","fn","mockSupabase","from","mock","supabase","createMockQueryChain","resolvedValue","mockSingle","mockResolvedValue","mockEq","mockReturnValue","single","mockSelect","eq","select","describe","beforeEach","clearAllMocks","it","fc","assert","asyncProperty","array","record","type","constantFrom","id","uuid","label","option","string","minLength","maxLength","exists","boolean","testReferences","ref","mockReturnValueOnce","data","error","code","message","references","map","r","undefined","result","validateReferences","expect","success","toBe","expectedBrokenCount","filter","length","brokenReferences","broken","original","find","toBeDefined","allExist","every","valid","numRuns","toHaveLength","validRefs","brokenRefs","testData","brokenRef","found","expectedTable","toHaveBeenCalledWith"],"mappings":"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"}