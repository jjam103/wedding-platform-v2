3b04f0ad7e3b4626828013286dc62220
/**
 * Property-Based Test: Payment Balance Updates
 * Feature: destination-wedding-platform, Property 13: Payment Balance Updates
 * 
 * Validates: Requirements 8.8
 * 
 * Property: For any vendor with an outstanding balance, recording a payment should
 * reduce the balance by exactly the payment amount, and the payment status should
 * update appropriately (unpaid → partial → paid).
 */ "use strict";
// Mock Supabase client BEFORE importing the service
jest.mock('@supabase/supabase-js', ()=>({
        createClient: jest.fn(()=>({
                from: (...args)=>mockFrom(...args)
            }))
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _vendorService = require("./vendorService");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Create mock object that will be populated in beforeEach
let mockFrom;
describe('Feature: destination-wedding-platform, Property 13: Payment Balance Updates', ()=>{
    beforeEach(()=>{
        mockFrom = jest.fn();
        jest.clearAllMocks();
    });
    it('should reduce balance by exactly the payment amount', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(// Generate vendor with base cost and current amount paid
        _fastcheck.record({
            id: _fastcheck.uuid(),
            name: _fastcheck.string({
                minLength: 1,
                maxLength: 50
            }).filter((s)=>s.trim().length > 0),
            category: _fastcheck.constantFrom('photography', 'flowers', 'catering'),
            base_cost: _fastcheck.float({
                min: 1000,
                max: 10000,
                noNaN: true
            }),
            amount_paid: _fastcheck.float({
                min: 0,
                max: 5000,
                noNaN: true
            }),
            payment_status: _fastcheck.constantFrom('unpaid', 'partial')
        }), // Generate payment amount
        _fastcheck.float({
            min: 100,
            max: 2000,
            noNaN: true
        }), async (vendor, paymentAmount)=>{
            const baseCost = parseFloat(vendor.base_cost.toFixed(2));
            const currentPaid = parseFloat(vendor.amount_paid.toFixed(2));
            const payment = parseFloat(paymentAmount.toFixed(2));
            // Skip if payment would exceed base cost
            if (currentPaid + payment > baseCost) {
                return true;
            }
            const expectedNewPaid = currentPaid + payment;
            const expectedBalance = baseCost - expectedNewPaid;
            // Determine expected payment status
            let expectedStatus;
            if (expectedNewPaid === 0) {
                expectedStatus = 'unpaid';
            } else if (expectedNewPaid >= baseCost) {
                expectedStatus = 'paid';
            } else {
                expectedStatus = 'partial';
            }
            // Create a fresh mock for each test iteration
            mockFrom = jest.fn();
            // Mock the get vendor call (used by recordPayment)
            mockFrom.mockImplementationOnce(()=>({
                    select: jest.fn().mockReturnValue({
                        eq: jest.fn().mockReturnValue({
                            single: jest.fn().mockResolvedValue({
                                data: {
                                    id: vendor.id,
                                    name: vendor.name,
                                    category: vendor.category,
                                    contact_name: null,
                                    email: null,
                                    phone: null,
                                    pricing_model: 'flat_rate',
                                    base_cost: baseCost.toFixed(2),
                                    amount_paid: currentPaid.toFixed(2),
                                    payment_status: vendor.payment_status,
                                    notes: null,
                                    created_at: new Date().toISOString(),
                                    updated_at: new Date().toISOString()
                                },
                                error: null
                            })
                        })
                    })
                }));
            // Mock the update vendor call (used by recordPayment -> update)
            mockFrom.mockImplementationOnce(()=>({
                    update: jest.fn().mockReturnValue({
                        eq: jest.fn().mockReturnValue({
                            select: jest.fn().mockReturnValue({
                                single: jest.fn().mockResolvedValue({
                                    data: {
                                        id: vendor.id,
                                        name: vendor.name,
                                        category: vendor.category,
                                        contact_name: null,
                                        email: null,
                                        phone: null,
                                        pricing_model: 'flat_rate',
                                        base_cost: baseCost.toFixed(2),
                                        amount_paid: expectedNewPaid.toFixed(2),
                                        payment_status: expectedStatus,
                                        notes: null,
                                        created_at: new Date().toISOString(),
                                        updated_at: new Date().toISOString()
                                    },
                                    error: null
                                })
                            })
                        })
                    })
                }));
            // Record payment
            const result = await (0, _vendorService.recordPayment)({
                vendorId: vendor.id,
                amount: payment
            });
            // Verify the property
            expect(result.success).toBe(true);
            if (result.success) {
                const paymentInfo = result.data;
                // Balance should be reduced by exactly the payment amount
                expect(Math.abs(paymentInfo.balanceDue - expectedBalance)).toBeLessThan(0.01);
                // Amount paid should increase by exactly the payment amount
                expect(Math.abs(paymentInfo.amountPaid - expectedNewPaid)).toBeLessThan(0.01);
                // Payment status should update correctly
                expect(paymentInfo.paymentStatus).toBe(expectedStatus);
            }
        }), {
            numRuns: 100
        });
    });
    it('should transition payment status from unpaid to partial to paid', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.float({
            min: 1000,
            max: 5000,
            noNaN: true
        }), async (baseCost)=>{
            const cost = parseFloat(baseCost.toFixed(2));
            const vendorId = '00000000-0000-4000-8000-000000000000'; // Valid UUID v4
            // Test unpaid → partial
            const partialPayment = parseFloat((cost * 0.5).toFixed(2));
            // Create a fresh mock for each test iteration
            mockFrom = jest.fn();
            // Mock get vendor call for first payment
            mockFrom.mockImplementationOnce(()=>({
                    select: jest.fn().mockReturnValue({
                        eq: jest.fn().mockReturnValue({
                            single: jest.fn().mockResolvedValue({
                                data: {
                                    id: vendorId,
                                    name: 'Test Vendor',
                                    category: 'photography',
                                    contact_name: null,
                                    email: null,
                                    phone: null,
                                    pricing_model: 'flat_rate',
                                    base_cost: cost.toFixed(2),
                                    amount_paid: '0.00',
                                    payment_status: 'unpaid',
                                    notes: null,
                                    created_at: new Date().toISOString(),
                                    updated_at: new Date().toISOString()
                                },
                                error: null
                            })
                        })
                    })
                }));
            // Mock update vendor call for first payment
            mockFrom.mockImplementationOnce(()=>({
                    update: jest.fn().mockReturnValue({
                        eq: jest.fn().mockReturnValue({
                            select: jest.fn().mockReturnValue({
                                single: jest.fn().mockResolvedValue({
                                    data: {
                                        id: vendorId,
                                        name: 'Test Vendor',
                                        category: 'photography',
                                        contact_name: null,
                                        email: null,
                                        phone: null,
                                        pricing_model: 'flat_rate',
                                        base_cost: cost.toFixed(2),
                                        amount_paid: partialPayment.toFixed(2),
                                        payment_status: 'partial',
                                        notes: null,
                                        created_at: new Date().toISOString(),
                                        updated_at: new Date().toISOString()
                                    },
                                    error: null
                                })
                            })
                        })
                    })
                }));
            const result1 = await (0, _vendorService.recordPayment)({
                vendorId,
                amount: partialPayment
            });
            expect(result1.success).toBe(true);
            if (result1.success) {
                expect(result1.data.paymentStatus).toBe('partial');
                expect(Math.abs(result1.data.amountPaid - partialPayment)).toBeLessThan(0.01);
            }
            // Test partial → paid
            const remainingPayment = parseFloat((cost - partialPayment).toFixed(2));
            // Mock get vendor call for second payment
            mockFrom.mockImplementationOnce(()=>({
                    select: jest.fn().mockReturnValue({
                        eq: jest.fn().mockReturnValue({
                            single: jest.fn().mockResolvedValue({
                                data: {
                                    id: vendorId,
                                    name: 'Test Vendor',
                                    category: 'photography',
                                    contact_name: null,
                                    email: null,
                                    phone: null,
                                    pricing_model: 'flat_rate',
                                    base_cost: cost.toFixed(2),
                                    amount_paid: partialPayment.toFixed(2),
                                    payment_status: 'partial',
                                    notes: null,
                                    created_at: new Date().toISOString(),
                                    updated_at: new Date().toISOString()
                                },
                                error: null
                            })
                        })
                    })
                }));
            // Mock update vendor call for second payment
            mockFrom.mockImplementationOnce(()=>({
                    update: jest.fn().mockReturnValue({
                        eq: jest.fn().mockReturnValue({
                            select: jest.fn().mockReturnValue({
                                single: jest.fn().mockResolvedValue({
                                    data: {
                                        id: vendorId,
                                        name: 'Test Vendor',
                                        category: 'photography',
                                        contact_name: null,
                                        email: null,
                                        phone: null,
                                        pricing_model: 'flat_rate',
                                        base_cost: cost.toFixed(2),
                                        amount_paid: cost.toFixed(2),
                                        payment_status: 'paid',
                                        notes: null,
                                        created_at: new Date().toISOString(),
                                        updated_at: new Date().toISOString()
                                    },
                                    error: null
                                })
                            })
                        })
                    })
                }));
            const result2 = await (0, _vendorService.recordPayment)({
                vendorId,
                amount: remainingPayment
            });
            expect(result2.success).toBe(true);
            if (result2.success) {
                expect(result2.data.paymentStatus).toBe('paid');
                expect(Math.abs(result2.data.amountPaid - cost)).toBeLessThan(0.01);
                expect(Math.abs(result2.data.balanceDue)).toBeLessThan(0.01);
            }
        }), {
            numRuns: 50
        });
    });
    it('should reject payments that exceed base cost', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
            baseCost: _fastcheck.float({
                min: 1000,
                max: 5000,
                noNaN: true
            }),
            currentPaid: _fastcheck.float({
                min: 0,
                max: 4000,
                noNaN: true
            })
        }), _fastcheck.float({
            min: 100,
            max: 3000,
            noNaN: true
        }), async (vendor, paymentAmount)=>{
            const baseCost = parseFloat(vendor.baseCost.toFixed(2));
            const currentPaid = parseFloat(vendor.currentPaid.toFixed(2));
            const payment = parseFloat(paymentAmount.toFixed(2));
            // Only test cases where payment would exceed base cost
            if (currentPaid + payment <= baseCost) {
                return true;
            }
            const vendorId = '00000000-0000-4000-8000-000000000000'; // Valid UUID v4
            // Create a fresh mock for each test iteration
            mockFrom = jest.fn();
            // Mock get vendor call
            mockFrom.mockImplementationOnce(()=>({
                    select: jest.fn().mockReturnValue({
                        eq: jest.fn().mockReturnValue({
                            single: jest.fn().mockResolvedValue({
                                data: {
                                    id: vendorId,
                                    name: 'Test Vendor',
                                    category: 'photography',
                                    contact_name: null,
                                    email: null,
                                    phone: null,
                                    pricing_model: 'flat_rate',
                                    base_cost: baseCost.toFixed(2),
                                    amount_paid: currentPaid.toFixed(2),
                                    payment_status: currentPaid > 0 ? 'partial' : 'unpaid',
                                    notes: null,
                                    created_at: new Date().toISOString(),
                                    updated_at: new Date().toISOString()
                                },
                                error: null
                            })
                        })
                    })
                }));
            const result = await (0, _vendorService.recordPayment)({
                vendorId,
                amount: payment
            });
            // Should return validation error
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('VALIDATION_ERROR');
                expect(result.error.message).toContain('exceeds');
            }
        }), {
            numRuns: 50
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvcGF5bWVudEJhbGFuY2VVcGRhdGVzLnByb3BlcnR5LnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQcm9wZXJ0eS1CYXNlZCBUZXN0OiBQYXltZW50IEJhbGFuY2UgVXBkYXRlc1xuICogRmVhdHVyZTogZGVzdGluYXRpb24td2VkZGluZy1wbGF0Zm9ybSwgUHJvcGVydHkgMTM6IFBheW1lbnQgQmFsYW5jZSBVcGRhdGVzXG4gKiBcbiAqIFZhbGlkYXRlczogUmVxdWlyZW1lbnRzIDguOFxuICogXG4gKiBQcm9wZXJ0eTogRm9yIGFueSB2ZW5kb3Igd2l0aCBhbiBvdXRzdGFuZGluZyBiYWxhbmNlLCByZWNvcmRpbmcgYSBwYXltZW50IHNob3VsZFxuICogcmVkdWNlIHRoZSBiYWxhbmNlIGJ5IGV4YWN0bHkgdGhlIHBheW1lbnQgYW1vdW50LCBhbmQgdGhlIHBheW1lbnQgc3RhdHVzIHNob3VsZFxuICogdXBkYXRlIGFwcHJvcHJpYXRlbHkgKHVucGFpZCDihpIgcGFydGlhbCDihpIgcGFpZCkuXG4gKi9cblxuaW1wb3J0ICogYXMgZmMgZnJvbSAnZmFzdC1jaGVjayc7XG5cbi8vIENyZWF0ZSBtb2NrIG9iamVjdCB0aGF0IHdpbGwgYmUgcG9wdWxhdGVkIGluIGJlZm9yZUVhY2hcbmxldCBtb2NrRnJvbTogamVzdC5Nb2NrO1xuXG4vLyBNb2NrIFN1cGFiYXNlIGNsaWVudCBCRUZPUkUgaW1wb3J0aW5nIHRoZSBzZXJ2aWNlXG5qZXN0Lm1vY2soJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcycsICgpID0+ICh7XG4gIGNyZWF0ZUNsaWVudDogamVzdC5mbigoKSA9PiAoe1xuICAgIGZyb206ICguLi5hcmdzOiBhbnlbXSkgPT4gbW9ja0Zyb20oLi4uYXJncyksXG4gIH0pKSxcbn0pKTtcblxuLy8gSW1wb3J0IHNlcnZpY2UgQUZURVIgbW9ja2luZ1xuaW1wb3J0IHsgcmVjb3JkUGF5bWVudCB9IGZyb20gJy4vdmVuZG9yU2VydmljZSc7XG5cbmRlc2NyaWJlKCdGZWF0dXJlOiBkZXN0aW5hdGlvbi13ZWRkaW5nLXBsYXRmb3JtLCBQcm9wZXJ0eSAxMzogUGF5bWVudCBCYWxhbmNlIFVwZGF0ZXMnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIG1vY2tGcm9tID0gamVzdC5mbigpO1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHJlZHVjZSBiYWxhbmNlIGJ5IGV4YWN0bHkgdGhlIHBheW1lbnQgYW1vdW50JywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIC8vIEdlbmVyYXRlIHZlbmRvciB3aXRoIGJhc2UgY29zdCBhbmQgY3VycmVudCBhbW91bnQgcGFpZFxuICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgIGlkOiBmYy51dWlkKCksXG4gICAgICAgICAgbmFtZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLmZpbHRlcihzID0+IHMudHJpbSgpLmxlbmd0aCA+IDApLCAvLyBFbnN1cmUgbm9uLXdoaXRlc3BhY2UgbmFtZXNcbiAgICAgICAgICBjYXRlZ29yeTogZmMuY29uc3RhbnRGcm9tKCdwaG90b2dyYXBoeScsICdmbG93ZXJzJywgJ2NhdGVyaW5nJyksXG4gICAgICAgICAgYmFzZV9jb3N0OiBmYy5mbG9hdCh7IG1pbjogMTAwMCwgbWF4OiAxMDAwMCwgbm9OYU46IHRydWUgfSksXG4gICAgICAgICAgYW1vdW50X3BhaWQ6IGZjLmZsb2F0KHsgbWluOiAwLCBtYXg6IDUwMDAsIG5vTmFOOiB0cnVlIH0pLFxuICAgICAgICAgIHBheW1lbnRfc3RhdHVzOiBmYy5jb25zdGFudEZyb20oJ3VucGFpZCcsICdwYXJ0aWFsJyksXG4gICAgICAgIH0pLFxuICAgICAgICAvLyBHZW5lcmF0ZSBwYXltZW50IGFtb3VudFxuICAgICAgICBmYy5mbG9hdCh7IG1pbjogMTAwLCBtYXg6IDIwMDAsIG5vTmFOOiB0cnVlIH0pLFxuICAgICAgICBhc3luYyAodmVuZG9yLCBwYXltZW50QW1vdW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgYmFzZUNvc3QgPSBwYXJzZUZsb2F0KHZlbmRvci5iYXNlX2Nvc3QudG9GaXhlZCgyKSk7XG4gICAgICAgICAgY29uc3QgY3VycmVudFBhaWQgPSBwYXJzZUZsb2F0KHZlbmRvci5hbW91bnRfcGFpZC50b0ZpeGVkKDIpKTtcbiAgICAgICAgICBjb25zdCBwYXltZW50ID0gcGFyc2VGbG9hdChwYXltZW50QW1vdW50LnRvRml4ZWQoMikpO1xuXG4gICAgICAgICAgLy8gU2tpcCBpZiBwYXltZW50IHdvdWxkIGV4Y2VlZCBiYXNlIGNvc3RcbiAgICAgICAgICBpZiAoY3VycmVudFBhaWQgKyBwYXltZW50ID4gYmFzZUNvc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGV4cGVjdGVkTmV3UGFpZCA9IGN1cnJlbnRQYWlkICsgcGF5bWVudDtcbiAgICAgICAgICBjb25zdCBleHBlY3RlZEJhbGFuY2UgPSBiYXNlQ29zdCAtIGV4cGVjdGVkTmV3UGFpZDtcblxuICAgICAgICAgIC8vIERldGVybWluZSBleHBlY3RlZCBwYXltZW50IHN0YXR1c1xuICAgICAgICAgIGxldCBleHBlY3RlZFN0YXR1czogJ3VucGFpZCcgfCAncGFydGlhbCcgfCAncGFpZCc7XG4gICAgICAgICAgaWYgKGV4cGVjdGVkTmV3UGFpZCA9PT0gMCkge1xuICAgICAgICAgICAgZXhwZWN0ZWRTdGF0dXMgPSAndW5wYWlkJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGV4cGVjdGVkTmV3UGFpZCA+PSBiYXNlQ29zdCkge1xuICAgICAgICAgICAgZXhwZWN0ZWRTdGF0dXMgPSAncGFpZCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cGVjdGVkU3RhdHVzID0gJ3BhcnRpYWwnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENyZWF0ZSBhIGZyZXNoIG1vY2sgZm9yIGVhY2ggdGVzdCBpdGVyYXRpb25cbiAgICAgICAgICBtb2NrRnJvbSA9IGplc3QuZm4oKTtcblxuICAgICAgICAgIC8vIE1vY2sgdGhlIGdldCB2ZW5kb3IgY2FsbCAodXNlZCBieSByZWNvcmRQYXltZW50KVxuICAgICAgICAgIG1vY2tGcm9tLm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UoKCkgPT4gKHtcbiAgICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB2ZW5kb3IuaWQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHZlbmRvci5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeTogdmVuZG9yLmNhdGVnb3J5LFxuICAgICAgICAgICAgICAgICAgICBjb250YWN0X25hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGVtYWlsOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwaG9uZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcHJpY2luZ19tb2RlbDogJ2ZsYXRfcmF0ZScsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VfY29zdDogYmFzZUNvc3QudG9GaXhlZCgyKSxcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50X3BhaWQ6IGN1cnJlbnRQYWlkLnRvRml4ZWQoMiksXG4gICAgICAgICAgICAgICAgICAgIHBheW1lbnRfc3RhdHVzOiB2ZW5kb3IucGF5bWVudF9zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIG5vdGVzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAvLyBNb2NrIHRoZSB1cGRhdGUgdmVuZG9yIGNhbGwgKHVzZWQgYnkgcmVjb3JkUGF5bWVudCAtPiB1cGRhdGUpXG4gICAgICAgICAgbW9ja0Zyb20ubW9ja0ltcGxlbWVudGF0aW9uT25jZSgoKSA9PiAoe1xuICAgICAgICAgICAgdXBkYXRlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZDogdmVuZG9yLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHZlbmRvci5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5OiB2ZW5kb3IuY2F0ZWdvcnksXG4gICAgICAgICAgICAgICAgICAgICAgY29udGFjdF9uYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIGVtYWlsOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHBob25lOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHByaWNpbmdfbW9kZWw6ICdmbGF0X3JhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgIGJhc2VfY29zdDogYmFzZUNvc3QudG9GaXhlZCgyKSxcbiAgICAgICAgICAgICAgICAgICAgICBhbW91bnRfcGFpZDogZXhwZWN0ZWROZXdQYWlkLnRvRml4ZWQoMiksXG4gICAgICAgICAgICAgICAgICAgICAgcGF5bWVudF9zdGF0dXM6IGV4cGVjdGVkU3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgIG5vdGVzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgLy8gUmVjb3JkIHBheW1lbnRcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWNvcmRQYXltZW50KHtcbiAgICAgICAgICAgIHZlbmRvcklkOiB2ZW5kb3IuaWQsXG4gICAgICAgICAgICBhbW91bnQ6IHBheW1lbnQsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBWZXJpZnkgdGhlIHByb3BlcnR5XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgY29uc3QgcGF5bWVudEluZm8gPSByZXN1bHQuZGF0YTtcblxuICAgICAgICAgICAgLy8gQmFsYW5jZSBzaG91bGQgYmUgcmVkdWNlZCBieSBleGFjdGx5IHRoZSBwYXltZW50IGFtb3VudFxuICAgICAgICAgICAgZXhwZWN0KE1hdGguYWJzKHBheW1lbnRJbmZvLmJhbGFuY2VEdWUgLSBleHBlY3RlZEJhbGFuY2UpKS50b0JlTGVzc1RoYW4oMC4wMSk7XG5cbiAgICAgICAgICAgIC8vIEFtb3VudCBwYWlkIHNob3VsZCBpbmNyZWFzZSBieSBleGFjdGx5IHRoZSBwYXltZW50IGFtb3VudFxuICAgICAgICAgICAgZXhwZWN0KE1hdGguYWJzKHBheW1lbnRJbmZvLmFtb3VudFBhaWQgLSBleHBlY3RlZE5ld1BhaWQpKS50b0JlTGVzc1RoYW4oMC4wMSk7XG5cbiAgICAgICAgICAgIC8vIFBheW1lbnQgc3RhdHVzIHNob3VsZCB1cGRhdGUgY29ycmVjdGx5XG4gICAgICAgICAgICBleHBlY3QocGF5bWVudEluZm8ucGF5bWVudFN0YXR1cykudG9CZShleHBlY3RlZFN0YXR1cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgdHJhbnNpdGlvbiBwYXltZW50IHN0YXR1cyBmcm9tIHVucGFpZCB0byBwYXJ0aWFsIHRvIHBhaWQnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMuZmxvYXQoeyBtaW46IDEwMDAsIG1heDogNTAwMCwgbm9OYU46IHRydWUgfSksXG4gICAgICAgIGFzeW5jIChiYXNlQ29zdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvc3QgPSBwYXJzZUZsb2F0KGJhc2VDb3N0LnRvRml4ZWQoMikpO1xuICAgICAgICAgIGNvbnN0IHZlbmRvcklkID0gJzAwMDAwMDAwLTAwMDAtNDAwMC04MDAwLTAwMDAwMDAwMDAwMCc7IC8vIFZhbGlkIFVVSUQgdjRcblxuICAgICAgICAgIC8vIFRlc3QgdW5wYWlkIOKGkiBwYXJ0aWFsXG4gICAgICAgICAgY29uc3QgcGFydGlhbFBheW1lbnQgPSBwYXJzZUZsb2F0KChjb3N0ICogMC41KS50b0ZpeGVkKDIpKTtcblxuICAgICAgICAgIC8vIENyZWF0ZSBhIGZyZXNoIG1vY2sgZm9yIGVhY2ggdGVzdCBpdGVyYXRpb25cbiAgICAgICAgICBtb2NrRnJvbSA9IGplc3QuZm4oKTtcblxuICAgICAgICAgIC8vIE1vY2sgZ2V0IHZlbmRvciBjYWxsIGZvciBmaXJzdCBwYXltZW50XG4gICAgICAgICAgbW9ja0Zyb20ubW9ja0ltcGxlbWVudGF0aW9uT25jZSgoKSA9PiAoe1xuICAgICAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHZlbmRvcklkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnVGVzdCBWZW5kb3InLFxuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeTogJ3Bob3RvZ3JhcGh5JyxcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdF9uYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBlbWFpbDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcGhvbmU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHByaWNpbmdfbW9kZWw6ICdmbGF0X3JhdGUnLFxuICAgICAgICAgICAgICAgICAgICBiYXNlX2Nvc3Q6IGNvc3QudG9GaXhlZCgyKSxcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50X3BhaWQ6ICcwLjAwJyxcbiAgICAgICAgICAgICAgICAgICAgcGF5bWVudF9zdGF0dXM6ICd1bnBhaWQnLFxuICAgICAgICAgICAgICAgICAgICBub3RlczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgLy8gTW9jayB1cGRhdGUgdmVuZG9yIGNhbGwgZm9yIGZpcnN0IHBheW1lbnRcbiAgICAgICAgICBtb2NrRnJvbS5tb2NrSW1wbGVtZW50YXRpb25PbmNlKCgpID0+ICh7XG4gICAgICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgIGlkOiB2ZW5kb3JJZCxcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnVGVzdCBWZW5kb3InLFxuICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5OiAncGhvdG9ncmFwaHknLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRhY3RfbmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBlbWFpbDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBwaG9uZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBwcmljaW5nX21vZGVsOiAnZmxhdF9yYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICBiYXNlX2Nvc3Q6IGNvc3QudG9GaXhlZCgyKSxcbiAgICAgICAgICAgICAgICAgICAgICBhbW91bnRfcGFpZDogcGFydGlhbFBheW1lbnQudG9GaXhlZCgyKSxcbiAgICAgICAgICAgICAgICAgICAgICBwYXltZW50X3N0YXR1czogJ3BhcnRpYWwnLFxuICAgICAgICAgICAgICAgICAgICAgIG5vdGVzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0MSA9IGF3YWl0IHJlY29yZFBheW1lbnQoe1xuICAgICAgICAgICAgdmVuZG9ySWQsXG4gICAgICAgICAgICBhbW91bnQ6IHBhcnRpYWxQYXltZW50LFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdDEuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgICAgICBpZiAocmVzdWx0MS5zdWNjZXNzKSB7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0MS5kYXRhLnBheW1lbnRTdGF0dXMpLnRvQmUoJ3BhcnRpYWwnKTtcbiAgICAgICAgICAgIGV4cGVjdChNYXRoLmFicyhyZXN1bHQxLmRhdGEuYW1vdW50UGFpZCAtIHBhcnRpYWxQYXltZW50KSkudG9CZUxlc3NUaGFuKDAuMDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRlc3QgcGFydGlhbCDihpIgcGFpZFxuICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ1BheW1lbnQgPSBwYXJzZUZsb2F0KChjb3N0IC0gcGFydGlhbFBheW1lbnQpLnRvRml4ZWQoMikpO1xuXG4gICAgICAgICAgLy8gTW9jayBnZXQgdmVuZG9yIGNhbGwgZm9yIHNlY29uZCBwYXltZW50XG4gICAgICAgICAgbW9ja0Zyb20ubW9ja0ltcGxlbWVudGF0aW9uT25jZSgoKSA9PiAoe1xuICAgICAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHZlbmRvcklkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnVGVzdCBWZW5kb3InLFxuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeTogJ3Bob3RvZ3JhcGh5JyxcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdF9uYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBlbWFpbDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcGhvbmU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHByaWNpbmdfbW9kZWw6ICdmbGF0X3JhdGUnLFxuICAgICAgICAgICAgICAgICAgICBiYXNlX2Nvc3Q6IGNvc3QudG9GaXhlZCgyKSxcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50X3BhaWQ6IHBhcnRpYWxQYXltZW50LnRvRml4ZWQoMiksXG4gICAgICAgICAgICAgICAgICAgIHBheW1lbnRfc3RhdHVzOiAncGFydGlhbCcsXG4gICAgICAgICAgICAgICAgICAgIG5vdGVzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAvLyBNb2NrIHVwZGF0ZSB2ZW5kb3IgY2FsbCBmb3Igc2Vjb25kIHBheW1lbnRcbiAgICAgICAgICBtb2NrRnJvbS5tb2NrSW1wbGVtZW50YXRpb25PbmNlKCgpID0+ICh7XG4gICAgICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgIGlkOiB2ZW5kb3JJZCxcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnVGVzdCBWZW5kb3InLFxuICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5OiAncGhvdG9ncmFwaHknLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRhY3RfbmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBlbWFpbDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBwaG9uZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBwcmljaW5nX21vZGVsOiAnZmxhdF9yYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICBiYXNlX2Nvc3Q6IGNvc3QudG9GaXhlZCgyKSxcbiAgICAgICAgICAgICAgICAgICAgICBhbW91bnRfcGFpZDogY29zdC50b0ZpeGVkKDIpLFxuICAgICAgICAgICAgICAgICAgICAgIHBheW1lbnRfc3RhdHVzOiAncGFpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgbm90ZXM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgcmVjb3JkUGF5bWVudCh7XG4gICAgICAgICAgICB2ZW5kb3JJZCxcbiAgICAgICAgICAgIGFtb3VudDogcmVtYWluaW5nUGF5bWVudCxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQyLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgaWYgKHJlc3VsdDIuc3VjY2Vzcykge1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdDIuZGF0YS5wYXltZW50U3RhdHVzKS50b0JlKCdwYWlkJyk7XG4gICAgICAgICAgICBleHBlY3QoTWF0aC5hYnMocmVzdWx0Mi5kYXRhLmFtb3VudFBhaWQgLSBjb3N0KSkudG9CZUxlc3NUaGFuKDAuMDEpO1xuICAgICAgICAgICAgZXhwZWN0KE1hdGguYWJzKHJlc3VsdDIuZGF0YS5iYWxhbmNlRHVlKSkudG9CZUxlc3NUaGFuKDAuMDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogNTAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgcmVqZWN0IHBheW1lbnRzIHRoYXQgZXhjZWVkIGJhc2UgY29zdCcsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgIGJhc2VDb3N0OiBmYy5mbG9hdCh7IG1pbjogMTAwMCwgbWF4OiA1MDAwLCBub05hTjogdHJ1ZSB9KSxcbiAgICAgICAgICBjdXJyZW50UGFpZDogZmMuZmxvYXQoeyBtaW46IDAsIG1heDogNDAwMCwgbm9OYU46IHRydWUgfSksXG4gICAgICAgIH0pLFxuICAgICAgICBmYy5mbG9hdCh7IG1pbjogMTAwLCBtYXg6IDMwMDAsIG5vTmFOOiB0cnVlIH0pLFxuICAgICAgICBhc3luYyAodmVuZG9yLCBwYXltZW50QW1vdW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgYmFzZUNvc3QgPSBwYXJzZUZsb2F0KHZlbmRvci5iYXNlQ29zdC50b0ZpeGVkKDIpKTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50UGFpZCA9IHBhcnNlRmxvYXQodmVuZG9yLmN1cnJlbnRQYWlkLnRvRml4ZWQoMikpO1xuICAgICAgICAgIGNvbnN0IHBheW1lbnQgPSBwYXJzZUZsb2F0KHBheW1lbnRBbW91bnQudG9GaXhlZCgyKSk7XG5cbiAgICAgICAgICAvLyBPbmx5IHRlc3QgY2FzZXMgd2hlcmUgcGF5bWVudCB3b3VsZCBleGNlZWQgYmFzZSBjb3N0XG4gICAgICAgICAgaWYgKGN1cnJlbnRQYWlkICsgcGF5bWVudCA8PSBiYXNlQ29zdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgdmVuZG9ySWQgPSAnMDAwMDAwMDAtMDAwMC00MDAwLTgwMDAtMDAwMDAwMDAwMDAwJzsgLy8gVmFsaWQgVVVJRCB2NFxuXG4gICAgICAgICAgLy8gQ3JlYXRlIGEgZnJlc2ggbW9jayBmb3IgZWFjaCB0ZXN0IGl0ZXJhdGlvblxuICAgICAgICAgIG1vY2tGcm9tID0gamVzdC5mbigpO1xuXG4gICAgICAgICAgLy8gTW9jayBnZXQgdmVuZG9yIGNhbGxcbiAgICAgICAgICBtb2NrRnJvbS5tb2NrSW1wbGVtZW50YXRpb25PbmNlKCgpID0+ICh7XG4gICAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBpZDogdmVuZG9ySWQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdUZXN0IFZlbmRvcicsXG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5OiAncGhvdG9ncmFwaHknLFxuICAgICAgICAgICAgICAgICAgICBjb250YWN0X25hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGVtYWlsOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwaG9uZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcHJpY2luZ19tb2RlbDogJ2ZsYXRfcmF0ZScsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VfY29zdDogYmFzZUNvc3QudG9GaXhlZCgyKSxcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50X3BhaWQ6IGN1cnJlbnRQYWlkLnRvRml4ZWQoMiksXG4gICAgICAgICAgICAgICAgICAgIHBheW1lbnRfc3RhdHVzOiBjdXJyZW50UGFpZCA+IDAgPyAncGFydGlhbCcgOiAndW5wYWlkJyxcbiAgICAgICAgICAgICAgICAgICAgbm90ZXM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlY29yZFBheW1lbnQoe1xuICAgICAgICAgICAgdmVuZG9ySWQsXG4gICAgICAgICAgICBhbW91bnQ6IHBheW1lbnQsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBTaG91bGQgcmV0dXJuIHZhbGlkYXRpb24gZXJyb3JcbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnVkFMSURBVElPTl9FUlJPUicpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ2V4Y2VlZHMnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDUwIH1cbiAgICApO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiY3JlYXRlQ2xpZW50IiwiZm4iLCJmcm9tIiwiYXJncyIsIm1vY2tGcm9tIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIml0IiwiZmMiLCJhc3NlcnQiLCJhc3luY1Byb3BlcnR5IiwicmVjb3JkIiwiaWQiLCJ1dWlkIiwibmFtZSIsInN0cmluZyIsIm1pbkxlbmd0aCIsIm1heExlbmd0aCIsImZpbHRlciIsInMiLCJ0cmltIiwibGVuZ3RoIiwiY2F0ZWdvcnkiLCJjb25zdGFudEZyb20iLCJiYXNlX2Nvc3QiLCJmbG9hdCIsIm1pbiIsIm1heCIsIm5vTmFOIiwiYW1vdW50X3BhaWQiLCJwYXltZW50X3N0YXR1cyIsInZlbmRvciIsInBheW1lbnRBbW91bnQiLCJiYXNlQ29zdCIsInBhcnNlRmxvYXQiLCJ0b0ZpeGVkIiwiY3VycmVudFBhaWQiLCJwYXltZW50IiwiZXhwZWN0ZWROZXdQYWlkIiwiZXhwZWN0ZWRCYWxhbmNlIiwiZXhwZWN0ZWRTdGF0dXMiLCJtb2NrSW1wbGVtZW50YXRpb25PbmNlIiwic2VsZWN0IiwibW9ja1JldHVyblZhbHVlIiwiZXEiLCJzaW5nbGUiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsImRhdGEiLCJjb250YWN0X25hbWUiLCJlbWFpbCIsInBob25lIiwicHJpY2luZ19tb2RlbCIsIm5vdGVzIiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInVwZGF0ZWRfYXQiLCJlcnJvciIsInVwZGF0ZSIsInJlc3VsdCIsInJlY29yZFBheW1lbnQiLCJ2ZW5kb3JJZCIsImFtb3VudCIsImV4cGVjdCIsInN1Y2Nlc3MiLCJ0b0JlIiwicGF5bWVudEluZm8iLCJNYXRoIiwiYWJzIiwiYmFsYW5jZUR1ZSIsInRvQmVMZXNzVGhhbiIsImFtb3VudFBhaWQiLCJwYXltZW50U3RhdHVzIiwibnVtUnVucyIsImNvc3QiLCJwYXJ0aWFsUGF5bWVudCIsInJlc3VsdDEiLCJyZW1haW5pbmdQYXltZW50IiwicmVzdWx0MiIsImNvZGUiLCJtZXNzYWdlIiwidG9Db250YWluIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7O0NBU0M7QUFPRCxvREFBb0Q7QUFDcERBLEtBQUtDLElBQUksQ0FBQyx5QkFBeUIsSUFBTyxDQUFBO1FBQ3hDQyxjQUFjRixLQUFLRyxFQUFFLENBQUMsSUFBTyxDQUFBO2dCQUMzQkMsTUFBTSxDQUFDLEdBQUdDLE9BQWdCQyxZQUFZRDtZQUN4QyxDQUFBO0lBQ0YsQ0FBQTs7OzttRUFWb0I7K0JBYVU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVg5QiwwREFBMEQ7QUFDMUQsSUFBSUM7QUFZSkMsU0FBUywrRUFBK0U7SUFDdEZDLFdBQVc7UUFD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