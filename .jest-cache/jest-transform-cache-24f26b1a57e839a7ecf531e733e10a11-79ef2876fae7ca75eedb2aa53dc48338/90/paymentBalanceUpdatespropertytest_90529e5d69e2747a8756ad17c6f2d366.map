{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/services/paymentBalanceUpdates.property.test.ts"],"sourcesContent":["/**\n * Property-Based Test: Payment Balance Updates\n * Feature: destination-wedding-platform, Property 13: Payment Balance Updates\n * \n * Validates: Requirements 8.8\n * \n * Property: For any vendor with an outstanding balance, recording a payment should\n * reduce the balance by exactly the payment amount, and the payment status should\n * update appropriately (unpaid → partial → paid).\n */\n\nimport * as fc from 'fast-check';\n\n// Create mock object that will be populated in beforeEach\nlet mockFrom: jest.Mock;\n\n// Mock Supabase client BEFORE importing the service\njest.mock('@supabase/supabase-js', () => ({\n  createClient: jest.fn(() => ({\n    from: (...args: any[]) => mockFrom(...args),\n  })),\n}));\n\n// Import service AFTER mocking\nimport { recordPayment } from './vendorService';\n\ndescribe('Feature: destination-wedding-platform, Property 13: Payment Balance Updates', () => {\n  beforeEach(() => {\n    mockFrom = jest.fn();\n    jest.clearAllMocks();\n  });\n\n  it('should reduce balance by exactly the payment amount', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        // Generate vendor with base cost and current amount paid\n        fc.record({\n          id: fc.uuid(),\n          name: fc.string({ minLength: 1, maxLength: 50 }).filter(s => s.trim().length > 0), // Ensure non-whitespace names\n          category: fc.constantFrom('photography', 'flowers', 'catering'),\n          base_cost: fc.float({ min: 1000, max: 10000, noNaN: true }),\n          amount_paid: fc.float({ min: 0, max: 5000, noNaN: true }),\n          payment_status: fc.constantFrom('unpaid', 'partial'),\n        }),\n        // Generate payment amount\n        fc.float({ min: 100, max: 2000, noNaN: true }),\n        async (vendor, paymentAmount) => {\n          const baseCost = parseFloat(vendor.base_cost.toFixed(2));\n          const currentPaid = parseFloat(vendor.amount_paid.toFixed(2));\n          const payment = parseFloat(paymentAmount.toFixed(2));\n\n          // Skip if payment would exceed base cost\n          if (currentPaid + payment > baseCost) {\n            return true;\n          }\n\n          const expectedNewPaid = currentPaid + payment;\n          const expectedBalance = baseCost - expectedNewPaid;\n\n          // Determine expected payment status\n          let expectedStatus: 'unpaid' | 'partial' | 'paid';\n          if (expectedNewPaid === 0) {\n            expectedStatus = 'unpaid';\n          } else if (expectedNewPaid >= baseCost) {\n            expectedStatus = 'paid';\n          } else {\n            expectedStatus = 'partial';\n          }\n\n          // Create a fresh mock for each test iteration\n          mockFrom = jest.fn();\n\n          // Mock the get vendor call (used by recordPayment)\n          mockFrom.mockImplementationOnce(() => ({\n            select: jest.fn().mockReturnValue({\n              eq: jest.fn().mockReturnValue({\n                single: jest.fn().mockResolvedValue({\n                  data: {\n                    id: vendor.id,\n                    name: vendor.name,\n                    category: vendor.category,\n                    contact_name: null,\n                    email: null,\n                    phone: null,\n                    pricing_model: 'flat_rate',\n                    base_cost: baseCost.toFixed(2),\n                    amount_paid: currentPaid.toFixed(2),\n                    payment_status: vendor.payment_status,\n                    notes: null,\n                    created_at: new Date().toISOString(),\n                    updated_at: new Date().toISOString(),\n                  },\n                  error: null,\n                }),\n              }),\n            }),\n          }));\n\n          // Mock the update vendor call (used by recordPayment -> update)\n          mockFrom.mockImplementationOnce(() => ({\n            update: jest.fn().mockReturnValue({\n              eq: jest.fn().mockReturnValue({\n                select: jest.fn().mockReturnValue({\n                  single: jest.fn().mockResolvedValue({\n                    data: {\n                      id: vendor.id,\n                      name: vendor.name,\n                      category: vendor.category,\n                      contact_name: null,\n                      email: null,\n                      phone: null,\n                      pricing_model: 'flat_rate',\n                      base_cost: baseCost.toFixed(2),\n                      amount_paid: expectedNewPaid.toFixed(2),\n                      payment_status: expectedStatus,\n                      notes: null,\n                      created_at: new Date().toISOString(),\n                      updated_at: new Date().toISOString(),\n                    },\n                    error: null,\n                  }),\n                }),\n              }),\n            }),\n          }));\n\n          // Record payment\n          const result = await recordPayment({\n            vendorId: vendor.id,\n            amount: payment,\n          });\n\n          // Verify the property\n          expect(result.success).toBe(true);\n          if (result.success) {\n            const paymentInfo = result.data;\n\n            // Balance should be reduced by exactly the payment amount\n            expect(Math.abs(paymentInfo.balanceDue - expectedBalance)).toBeLessThan(0.01);\n\n            // Amount paid should increase by exactly the payment amount\n            expect(Math.abs(paymentInfo.amountPaid - expectedNewPaid)).toBeLessThan(0.01);\n\n            // Payment status should update correctly\n            expect(paymentInfo.paymentStatus).toBe(expectedStatus);\n          }\n        }\n      ),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should transition payment status from unpaid to partial to paid', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.float({ min: 1000, max: 5000, noNaN: true }),\n        async (baseCost) => {\n          const cost = parseFloat(baseCost.toFixed(2));\n          const vendorId = '00000000-0000-4000-8000-000000000000'; // Valid UUID v4\n\n          // Test unpaid → partial\n          const partialPayment = parseFloat((cost * 0.5).toFixed(2));\n\n          // Create a fresh mock for each test iteration\n          mockFrom = jest.fn();\n\n          // Mock get vendor call for first payment\n          mockFrom.mockImplementationOnce(() => ({\n            select: jest.fn().mockReturnValue({\n              eq: jest.fn().mockReturnValue({\n                single: jest.fn().mockResolvedValue({\n                  data: {\n                    id: vendorId,\n                    name: 'Test Vendor',\n                    category: 'photography',\n                    contact_name: null,\n                    email: null,\n                    phone: null,\n                    pricing_model: 'flat_rate',\n                    base_cost: cost.toFixed(2),\n                    amount_paid: '0.00',\n                    payment_status: 'unpaid',\n                    notes: null,\n                    created_at: new Date().toISOString(),\n                    updated_at: new Date().toISOString(),\n                  },\n                  error: null,\n                }),\n              }),\n            }),\n          }));\n\n          // Mock update vendor call for first payment\n          mockFrom.mockImplementationOnce(() => ({\n            update: jest.fn().mockReturnValue({\n              eq: jest.fn().mockReturnValue({\n                select: jest.fn().mockReturnValue({\n                  single: jest.fn().mockResolvedValue({\n                    data: {\n                      id: vendorId,\n                      name: 'Test Vendor',\n                      category: 'photography',\n                      contact_name: null,\n                      email: null,\n                      phone: null,\n                      pricing_model: 'flat_rate',\n                      base_cost: cost.toFixed(2),\n                      amount_paid: partialPayment.toFixed(2),\n                      payment_status: 'partial',\n                      notes: null,\n                      created_at: new Date().toISOString(),\n                      updated_at: new Date().toISOString(),\n                    },\n                    error: null,\n                  }),\n                }),\n              }),\n            }),\n          }));\n\n          const result1 = await recordPayment({\n            vendorId,\n            amount: partialPayment,\n          });\n\n          expect(result1.success).toBe(true);\n          if (result1.success) {\n            expect(result1.data.paymentStatus).toBe('partial');\n            expect(Math.abs(result1.data.amountPaid - partialPayment)).toBeLessThan(0.01);\n          }\n\n          // Test partial → paid\n          const remainingPayment = parseFloat((cost - partialPayment).toFixed(2));\n\n          // Mock get vendor call for second payment\n          mockFrom.mockImplementationOnce(() => ({\n            select: jest.fn().mockReturnValue({\n              eq: jest.fn().mockReturnValue({\n                single: jest.fn().mockResolvedValue({\n                  data: {\n                    id: vendorId,\n                    name: 'Test Vendor',\n                    category: 'photography',\n                    contact_name: null,\n                    email: null,\n                    phone: null,\n                    pricing_model: 'flat_rate',\n                    base_cost: cost.toFixed(2),\n                    amount_paid: partialPayment.toFixed(2),\n                    payment_status: 'partial',\n                    notes: null,\n                    created_at: new Date().toISOString(),\n                    updated_at: new Date().toISOString(),\n                  },\n                  error: null,\n                }),\n              }),\n            }),\n          }));\n\n          // Mock update vendor call for second payment\n          mockFrom.mockImplementationOnce(() => ({\n            update: jest.fn().mockReturnValue({\n              eq: jest.fn().mockReturnValue({\n                select: jest.fn().mockReturnValue({\n                  single: jest.fn().mockResolvedValue({\n                    data: {\n                      id: vendorId,\n                      name: 'Test Vendor',\n                      category: 'photography',\n                      contact_name: null,\n                      email: null,\n                      phone: null,\n                      pricing_model: 'flat_rate',\n                      base_cost: cost.toFixed(2),\n                      amount_paid: cost.toFixed(2),\n                      payment_status: 'paid',\n                      notes: null,\n                      created_at: new Date().toISOString(),\n                      updated_at: new Date().toISOString(),\n                    },\n                    error: null,\n                  }),\n                }),\n              }),\n            }),\n          }));\n\n          const result2 = await recordPayment({\n            vendorId,\n            amount: remainingPayment,\n          });\n\n          expect(result2.success).toBe(true);\n          if (result2.success) {\n            expect(result2.data.paymentStatus).toBe('paid');\n            expect(Math.abs(result2.data.amountPaid - cost)).toBeLessThan(0.01);\n            expect(Math.abs(result2.data.balanceDue)).toBeLessThan(0.01);\n          }\n        }\n      ),\n      { numRuns: 50 }\n    );\n  });\n\n  it('should reject payments that exceed base cost', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.record({\n          baseCost: fc.float({ min: 1000, max: 5000, noNaN: true }),\n          currentPaid: fc.float({ min: 0, max: 4000, noNaN: true }),\n        }),\n        fc.float({ min: 100, max: 3000, noNaN: true }),\n        async (vendor, paymentAmount) => {\n          const baseCost = parseFloat(vendor.baseCost.toFixed(2));\n          const currentPaid = parseFloat(vendor.currentPaid.toFixed(2));\n          const payment = parseFloat(paymentAmount.toFixed(2));\n\n          // Only test cases where payment would exceed base cost\n          if (currentPaid + payment <= baseCost) {\n            return true;\n          }\n\n          const vendorId = '00000000-0000-4000-8000-000000000000'; // Valid UUID v4\n\n          // Create a fresh mock for each test iteration\n          mockFrom = jest.fn();\n\n          // Mock get vendor call\n          mockFrom.mockImplementationOnce(() => ({\n            select: jest.fn().mockReturnValue({\n              eq: jest.fn().mockReturnValue({\n                single: jest.fn().mockResolvedValue({\n                  data: {\n                    id: vendorId,\n                    name: 'Test Vendor',\n                    category: 'photography',\n                    contact_name: null,\n                    email: null,\n                    phone: null,\n                    pricing_model: 'flat_rate',\n                    base_cost: baseCost.toFixed(2),\n                    amount_paid: currentPaid.toFixed(2),\n                    payment_status: currentPaid > 0 ? 'partial' : 'unpaid',\n                    notes: null,\n                    created_at: new Date().toISOString(),\n                    updated_at: new Date().toISOString(),\n                  },\n                  error: null,\n                }),\n              }),\n            }),\n          }));\n\n          const result = await recordPayment({\n            vendorId,\n            amount: payment,\n          });\n\n          // Should return validation error\n          expect(result.success).toBe(false);\n          if (!result.success) {\n            expect(result.error.code).toBe('VALIDATION_ERROR');\n            expect(result.error.message).toContain('exceeds');\n          }\n        }\n      ),\n      { numRuns: 50 }\n    );\n  });\n});\n"],"names":["jest","mock","createClient","fn","from","args","mockFrom","describe","beforeEach","clearAllMocks","it","fc","assert","asyncProperty","record","id","uuid","name","string","minLength","maxLength","filter","s","trim","length","category","constantFrom","base_cost","float","min","max","noNaN","amount_paid","payment_status","vendor","paymentAmount","baseCost","parseFloat","toFixed","currentPaid","payment","expectedNewPaid","expectedBalance","expectedStatus","mockImplementationOnce","select","mockReturnValue","eq","single","mockResolvedValue","data","contact_name","email","phone","pricing_model","notes","created_at","Date","toISOString","updated_at","error","update","result","recordPayment","vendorId","amount","expect","success","toBe","paymentInfo","Math","abs","balanceDue","toBeLessThan","amountPaid","paymentStatus","numRuns","cost","partialPayment","result1","remainingPayment","result2","code","message","toContain"],"mappings":"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"}