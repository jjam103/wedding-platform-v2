abc0eadad9f87c37032730ec7c0d5c9a
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _settingsService = /*#__PURE__*/ _interop_require_wildcard(require("./settingsService"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Mock Supabase lib
const mockSupabase = {
    from: _globals.jest.fn().mockReturnThis(),
    select: _globals.jest.fn().mockReturnThis(),
    insert: _globals.jest.fn().mockReturnThis(),
    update: _globals.jest.fn().mockReturnThis(),
    eq: _globals.jest.fn().mockReturnThis(),
    single: _globals.jest.fn()
};
_globals.jest.mock('../lib/supabase', ()=>({
        supabase: mockSupabase
    }));
(0, _globals.describe)('settingsService', ()=>{
    (0, _globals.beforeEach)(()=>{
        _globals.jest.clearAllMocks();
    });
    (0, _globals.describe)('getSettings', ()=>{
        (0, _globals.it)('should return success with settings data when settings exist', async ()=>{
            const mockSettings = {
                id: 'settings-1',
                wedding_date: '2024-06-15T00:00:00Z',
                venue_name: 'Dreams Las Mareas',
                couple_name_1: 'John',
                couple_name_2: 'Jane',
                timezone: 'America/Costa_Rica',
                send_rsvp_confirmations: true,
                send_activity_reminders: true,
                send_deadline_reminders: true,
                reminder_days_before: 7,
                require_photo_moderation: true,
                max_photos_per_guest: 20,
                allowed_photo_formats: [
                    'jpg',
                    'jpeg',
                    'png',
                    'heic'
                ],
                home_page_title: 'Welcome to Our Wedding',
                home_page_subtitle: 'Join us in Costa Rica',
                home_page_welcome_message: 'We are excited to celebrate with you!',
                home_page_hero_image_url: 'https://example.com/hero.jpg',
                created_at: '2024-01-01T00:00:00Z',
                updated_at: '2024-01-01T00:00:00Z'
            };
            mockSupabase.single.mockResolvedValue({
                data: mockSettings,
                error: null
            });
            const result = await _settingsService.getSettings();
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.id).toBe('settings-1');
                (0, _globals.expect)(result.data.wedding_date).toBe('2024-06-15T00:00:00Z');
                (0, _globals.expect)(result.data.venue_name).toBe('Dreams Las Mareas');
                (0, _globals.expect)(result.data.couple_name_1).toBe('John');
                (0, _globals.expect)(result.data.couple_name_2).toBe('Jane');
            }
        });
        (0, _globals.it)('should return success with default settings when no settings exist', async ()=>{
            mockSupabase.single.mockResolvedValue({
                data: null,
                error: {
                    code: 'PGRST116'
                }
            });
            const result = await _settingsService.getSettings();
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.id).toBe('');
                (0, _globals.expect)(result.data.wedding_date).toBeNull();
                (0, _globals.expect)(result.data.venue_name).toBeNull();
                (0, _globals.expect)(result.data.timezone).toBe('America/Costa_Rica');
                (0, _globals.expect)(result.data.send_rsvp_confirmations).toBe(true);
                (0, _globals.expect)(result.data.require_photo_moderation).toBe(true);
                (0, _globals.expect)(result.data.max_photos_per_guest).toBe(20);
                (0, _globals.expect)(result.data.allowed_photo_formats).toEqual([
                    'jpg',
                    'jpeg',
                    'png',
                    'heic'
                ]);
            }
        });
        (0, _globals.it)('should return DATABASE_ERROR when database query fails', async ()=>{
            mockSupabase.single.mockResolvedValue({
                data: null,
                error: {
                    message: 'Connection failed',
                    code: 'CONNECTION_ERROR'
                }
            });
            const result = await _settingsService.getSettings();
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('DATABASE_ERROR');
                (0, _globals.expect)(result.error.message).toBe('Connection failed');
            }
        });
        (0, _globals.it)('should return UNKNOWN_ERROR when unexpected error occurs', async ()=>{
            mockSupabase.single.mockRejectedValue(new Error('Unexpected error'));
            const result = await _settingsService.getSettings();
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('UNKNOWN_ERROR');
                (0, _globals.expect)(result.error.message).toBe('Unexpected error');
            }
        });
    });
    (0, _globals.describe)('updateSettings', ()=>{
        const validUpdateData = {
            wedding_date: '2024-06-15T00:00:00Z',
            venue_name: 'Dreams Las Mareas',
            couple_name_1: 'John',
            couple_name_2: 'Jane',
            timezone: 'America/Costa_Rica',
            send_rsvp_confirmations: true,
            reminder_days_before: 7
        };
        (0, _globals.it)('should return success with updated settings when updating existing settings', async ()=>{
            const existingSettings = {
                id: 'settings-1'
            };
            const updatedSettings = {
                id: 'settings-1',
                ...validUpdateData,
                created_at: '2024-01-01T00:00:00Z',
                updated_at: '2024-01-02T00:00:00Z'
            };
            // Mock check for existing settings
            mockSupabase.single.mockResolvedValueOnce({
                data: existingSettings,
                error: null
            });
            // Mock update operation
            mockSupabase.single.mockResolvedValueOnce({
                data: updatedSettings,
                error: null
            });
            const result = await _settingsService.updateSettings(validUpdateData);
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.id).toBe('settings-1');
                (0, _globals.expect)(result.data.wedding_date).toBe('2024-06-15T00:00:00Z');
                (0, _globals.expect)(result.data.venue_name).toBe('Dreams Las Mareas');
            }
            (0, _globals.expect)(mockSupabase.update).toHaveBeenCalledWith(validUpdateData);
            (0, _globals.expect)(mockSupabase.eq).toHaveBeenCalledWith('id', 'settings-1');
        });
        (0, _globals.it)('should return success with created settings when no existing settings', async ()=>{
            const createdSettings = {
                id: 'settings-1',
                ...validUpdateData,
                created_at: '2024-01-01T00:00:00Z',
                updated_at: '2024-01-01T00:00:00Z'
            };
            // Mock check for existing settings (none found)
            mockSupabase.single.mockResolvedValueOnce({
                data: null,
                error: null
            });
            // Mock insert operation
            mockSupabase.single.mockResolvedValueOnce({
                data: createdSettings,
                error: null
            });
            const result = await _settingsService.updateSettings(validUpdateData);
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.id).toBe('settings-1');
                (0, _globals.expect)(result.data.wedding_date).toBe('2024-06-15T00:00:00Z');
            }
            (0, _globals.expect)(mockSupabase.insert).toHaveBeenCalledWith(validUpdateData);
        });
        (0, _globals.it)('should return VALIDATION_ERROR when wedding_date format is invalid', async ()=>{
            const invalidData = {
                ...validUpdateData,
                wedding_date: 'invalid-date'
            };
            const result = await _settingsService.updateSettings(invalidData);
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('VALIDATION_ERROR');
                (0, _globals.expect)(result.error.details).toBeDefined();
            }
        });
        (0, _globals.it)('should return VALIDATION_ERROR when reminder_days_before is negative', async ()=>{
            const invalidData = {
                ...validUpdateData,
                reminder_days_before: -1
            };
            const result = await _settingsService.updateSettings(invalidData);
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        (0, _globals.it)('should return VALIDATION_ERROR when max_photos_per_guest exceeds limit', async ()=>{
            const invalidData = {
                ...validUpdateData,
                max_photos_per_guest: 101
            };
            const result = await _settingsService.updateSettings(invalidData);
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        (0, _globals.it)('should return DATABASE_ERROR when update operation fails', async ()=>{
            const existingSettings = {
                id: 'settings-1'
            };
            // Mock check for existing settings
            mockSupabase.single.mockResolvedValueOnce({
                data: existingSettings,
                error: null
            });
            // Mock update operation failure
            mockSupabase.single.mockResolvedValueOnce({
                data: null,
                error: {
                    message: 'Update failed'
                }
            });
            const result = await _settingsService.updateSettings(validUpdateData);
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('DATABASE_ERROR');
                (0, _globals.expect)(result.error.message).toBe('Update failed');
            }
        });
        (0, _globals.it)('should return DATABASE_ERROR when insert operation fails', async ()=>{
            // Mock check for existing settings (none found)
            mockSupabase.single.mockResolvedValueOnce({
                data: null,
                error: null
            });
            // Mock insert operation failure
            mockSupabase.single.mockResolvedValueOnce({
                data: null,
                error: {
                    message: 'Insert failed'
                }
            });
            const result = await _settingsService.updateSettings(validUpdateData);
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('DATABASE_ERROR');
                (0, _globals.expect)(result.error.message).toBe('Insert failed');
            }
        });
        (0, _globals.it)('should handle partial updates correctly', async ()=>{
            const partialUpdateData = {
                venue_name: 'New Venue Name',
                send_rsvp_confirmations: false
            };
            const existingSettings = {
                id: 'settings-1'
            };
            const updatedSettings = {
                id: 'settings-1',
                venue_name: 'New Venue Name',
                send_rsvp_confirmations: false,
                created_at: '2024-01-01T00:00:00Z',
                updated_at: '2024-01-02T00:00:00Z'
            };
            // Mock check for existing settings
            mockSupabase.single.mockResolvedValueOnce({
                data: existingSettings,
                error: null
            });
            // Mock update operation
            mockSupabase.single.mockResolvedValueOnce({
                data: updatedSettings,
                error: null
            });
            const result = await _settingsService.updateSettings(partialUpdateData);
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.venue_name).toBe('New Venue Name');
                (0, _globals.expect)(result.data.send_rsvp_confirmations).toBe(false);
            }
            (0, _globals.expect)(mockSupabase.update).toHaveBeenCalledWith(partialUpdateData);
        });
        (0, _globals.it)('should handle empty update data correctly', async ()=>{
            const emptyUpdateData = {};
            const existingSettings = {
                id: 'settings-1'
            };
            const unchangedSettings = {
                id: 'settings-1',
                wedding_date: '2024-06-15T00:00:00Z',
                venue_name: 'Dreams Las Mareas',
                created_at: '2024-01-01T00:00:00Z',
                updated_at: '2024-01-01T00:00:00Z'
            };
            // Mock check for existing settings
            mockSupabase.single.mockResolvedValueOnce({
                data: existingSettings,
                error: null
            });
            // Mock update operation
            mockSupabase.single.mockResolvedValueOnce({
                data: unchangedSettings,
                error: null
            });
            const result = await _settingsService.updateSettings(emptyUpdateData);
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.id).toBe('settings-1');
            }
            (0, _globals.expect)(mockSupabase.update).toHaveBeenCalledWith(emptyUpdateData);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvc2V0dGluZ3NTZXJ2aWNlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVzY3JpYmUsIGl0LCBleHBlY3QsIGplc3QsIGJlZm9yZUVhY2ggfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB0eXBlIHsgVXBkYXRlU3lzdGVtU2V0dGluZ3NEVE8gfSBmcm9tICdAL3NjaGVtYXMvc2V0dGluZ3NTY2hlbWFzJztcblxuLy8gTW9jayBTdXBhYmFzZSBsaWJcbmNvbnN0IG1vY2tTdXBhYmFzZSA9IHtcbiAgZnJvbTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gIGluc2VydDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgc2luZ2xlOiBqZXN0LmZuKCksXG59O1xuXG5qZXN0Lm1vY2soJy4uL2xpYi9zdXBhYmFzZScsICgpID0+ICh7XG4gIHN1cGFiYXNlOiBtb2NrU3VwYWJhc2UsXG59KSk7XG5cbi8vIEltcG9ydCBhZnRlciBtb2NraW5nXG5pbXBvcnQgKiBhcyBzZXR0aW5nc1NlcnZpY2UgZnJvbSAnLi9zZXR0aW5nc1NlcnZpY2UnO1xuXG5kZXNjcmliZSgnc2V0dGluZ3NTZXJ2aWNlJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldFNldHRpbmdzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3Mgd2l0aCBzZXR0aW5ncyBkYXRhIHdoZW4gc2V0dGluZ3MgZXhpc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU2V0dGluZ3MgPSB7XG4gICAgICAgIGlkOiAnc2V0dGluZ3MtMScsXG4gICAgICAgIHdlZGRpbmdfZGF0ZTogJzIwMjQtMDYtMTVUMDA6MDA6MDBaJyxcbiAgICAgICAgdmVudWVfbmFtZTogJ0RyZWFtcyBMYXMgTWFyZWFzJyxcbiAgICAgICAgY291cGxlX25hbWVfMTogJ0pvaG4nLFxuICAgICAgICBjb3VwbGVfbmFtZV8yOiAnSmFuZScsXG4gICAgICAgIHRpbWV6b25lOiAnQW1lcmljYS9Db3N0YV9SaWNhJyxcbiAgICAgICAgc2VuZF9yc3ZwX2NvbmZpcm1hdGlvbnM6IHRydWUsXG4gICAgICAgIHNlbmRfYWN0aXZpdHlfcmVtaW5kZXJzOiB0cnVlLFxuICAgICAgICBzZW5kX2RlYWRsaW5lX3JlbWluZGVyczogdHJ1ZSxcbiAgICAgICAgcmVtaW5kZXJfZGF5c19iZWZvcmU6IDcsXG4gICAgICAgIHJlcXVpcmVfcGhvdG9fbW9kZXJhdGlvbjogdHJ1ZSxcbiAgICAgICAgbWF4X3Bob3Rvc19wZXJfZ3Vlc3Q6IDIwLFxuICAgICAgICBhbGxvd2VkX3Bob3RvX2Zvcm1hdHM6IFsnanBnJywgJ2pwZWcnLCAncG5nJywgJ2hlaWMnXSxcbiAgICAgICAgaG9tZV9wYWdlX3RpdGxlOiAnV2VsY29tZSB0byBPdXIgV2VkZGluZycsXG4gICAgICAgIGhvbWVfcGFnZV9zdWJ0aXRsZTogJ0pvaW4gdXMgaW4gQ29zdGEgUmljYScsXG4gICAgICAgIGhvbWVfcGFnZV93ZWxjb21lX21lc3NhZ2U6ICdXZSBhcmUgZXhjaXRlZCB0byBjZWxlYnJhdGUgd2l0aCB5b3UhJyxcbiAgICAgICAgaG9tZV9wYWdlX2hlcm9faW1hZ2VfdXJsOiAnaHR0cHM6Ly9leGFtcGxlLmNvbS9oZXJvLmpwZycsXG4gICAgICAgIGNyZWF0ZWRfYXQ6ICcyMDI0LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgIHVwZGF0ZWRfYXQ6ICcyMDI0LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICB9O1xuXG4gICAgICBtb2NrU3VwYWJhc2Uuc2luZ2xlLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbW9ja1NldHRpbmdzLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXR0aW5nc1NlcnZpY2UuZ2V0U2V0dGluZ3MoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5pZCkudG9CZSgnc2V0dGluZ3MtMScpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEud2VkZGluZ19kYXRlKS50b0JlKCcyMDI0LTA2LTE1VDAwOjAwOjAwWicpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudmVudWVfbmFtZSkudG9CZSgnRHJlYW1zIExhcyBNYXJlYXMnKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmNvdXBsZV9uYW1lXzEpLnRvQmUoJ0pvaG4nKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmNvdXBsZV9uYW1lXzIpLnRvQmUoJ0phbmUnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3Mgd2l0aCBkZWZhdWx0IHNldHRpbmdzIHdoZW4gbm8gc2V0dGluZ3MgZXhpc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2Uuc2luZ2xlLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3I6IHsgY29kZTogJ1BHUlNUMTE2JyB9LCAvLyBObyByb3dzIGZvdW5kXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2V0dGluZ3NTZXJ2aWNlLmdldFNldHRpbmdzKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuaWQpLnRvQmUoJycpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEud2VkZGluZ19kYXRlKS50b0JlTnVsbCgpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudmVudWVfbmFtZSkudG9CZU51bGwoKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnRpbWV6b25lKS50b0JlKCdBbWVyaWNhL0Nvc3RhX1JpY2EnKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnNlbmRfcnN2cF9jb25maXJtYXRpb25zKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEucmVxdWlyZV9waG90b19tb2RlcmF0aW9uKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEubWF4X3Bob3Rvc19wZXJfZ3Vlc3QpLnRvQmUoMjApO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuYWxsb3dlZF9waG90b19mb3JtYXRzKS50b0VxdWFsKFsnanBnJywgJ2pwZWcnLCAncG5nJywgJ2hlaWMnXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBEQVRBQkFTRV9FUlJPUiB3aGVuIGRhdGFiYXNlIHF1ZXJ5IGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N1cGFiYXNlLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6ICdDb25uZWN0aW9uIGZhaWxlZCcsIGNvZGU6ICdDT05ORUNUSU9OX0VSUk9SJyB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNldHRpbmdzU2VydmljZS5nZXRTZXR0aW5ncygpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ0RBVEFCQVNFX0VSUk9SJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9CZSgnQ29ubmVjdGlvbiBmYWlsZWQnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIFVOS05PV05fRVJST1Igd2hlbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5zaW5nbGUubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdVbmV4cGVjdGVkIGVycm9yJykpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXR0aW5nc1NlcnZpY2UuZ2V0U2V0dGluZ3MoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdVTktOT1dOX0VSUk9SJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9CZSgnVW5leHBlY3RlZCBlcnJvcicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgndXBkYXRlU2V0dGluZ3MnLCAoKSA9PiB7XG4gICAgY29uc3QgdmFsaWRVcGRhdGVEYXRhOiBVcGRhdGVTeXN0ZW1TZXR0aW5nc0RUTyA9IHtcbiAgICAgIHdlZGRpbmdfZGF0ZTogJzIwMjQtMDYtMTVUMDA6MDA6MDBaJyxcbiAgICAgIHZlbnVlX25hbWU6ICdEcmVhbXMgTGFzIE1hcmVhcycsXG4gICAgICBjb3VwbGVfbmFtZV8xOiAnSm9obicsXG4gICAgICBjb3VwbGVfbmFtZV8yOiAnSmFuZScsXG4gICAgICB0aW1lem9uZTogJ0FtZXJpY2EvQ29zdGFfUmljYScsXG4gICAgICBzZW5kX3JzdnBfY29uZmlybWF0aW9uczogdHJ1ZSxcbiAgICAgIHJlbWluZGVyX2RheXNfYmVmb3JlOiA3LFxuICAgIH07XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIHdpdGggdXBkYXRlZCBzZXR0aW5ncyB3aGVuIHVwZGF0aW5nIGV4aXN0aW5nIHNldHRpbmdzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmdTZXR0aW5ncyA9IHsgaWQ6ICdzZXR0aW5ncy0xJyB9O1xuICAgICAgY29uc3QgdXBkYXRlZFNldHRpbmdzID0ge1xuICAgICAgICBpZDogJ3NldHRpbmdzLTEnLFxuICAgICAgICAuLi52YWxpZFVwZGF0ZURhdGEsXG4gICAgICAgIGNyZWF0ZWRfYXQ6ICcyMDI0LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgIHVwZGF0ZWRfYXQ6ICcyMDI0LTAxLTAyVDAwOjAwOjAwWicsXG4gICAgICB9O1xuXG4gICAgICAvLyBNb2NrIGNoZWNrIGZvciBleGlzdGluZyBzZXR0aW5nc1xuICAgICAgbW9ja1N1cGFiYXNlLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBkYXRhOiBleGlzdGluZ1NldHRpbmdzLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrIHVwZGF0ZSBvcGVyYXRpb25cbiAgICAgIG1vY2tTdXBhYmFzZS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgZGF0YTogdXBkYXRlZFNldHRpbmdzLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXR0aW5nc1NlcnZpY2UudXBkYXRlU2V0dGluZ3ModmFsaWRVcGRhdGVEYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5pZCkudG9CZSgnc2V0dGluZ3MtMScpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEud2VkZGluZ19kYXRlKS50b0JlKCcyMDI0LTA2LTE1VDAwOjAwOjAwWicpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudmVudWVfbmFtZSkudG9CZSgnRHJlYW1zIExhcyBNYXJlYXMnKTtcbiAgICAgIH1cblxuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZS51cGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHZhbGlkVXBkYXRlRGF0YSk7XG4gICAgICBleHBlY3QobW9ja1N1cGFiYXNlLmVxKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnaWQnLCAnc2V0dGluZ3MtMScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2VzcyB3aXRoIGNyZWF0ZWQgc2V0dGluZ3Mgd2hlbiBubyBleGlzdGluZyBzZXR0aW5ncycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNyZWF0ZWRTZXR0aW5ncyA9IHtcbiAgICAgICAgaWQ6ICdzZXR0aW5ncy0xJyxcbiAgICAgICAgLi4udmFsaWRVcGRhdGVEYXRhLFxuICAgICAgICBjcmVhdGVkX2F0OiAnMjAyNC0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICB1cGRhdGVkX2F0OiAnMjAyNC0wMS0wMVQwMDowMDowMFonLFxuICAgICAgfTtcblxuICAgICAgLy8gTW9jayBjaGVjayBmb3IgZXhpc3Rpbmcgc2V0dGluZ3MgKG5vbmUgZm91bmQpXG4gICAgICBtb2NrU3VwYWJhc2Uuc2luZ2xlLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIE1vY2sgaW5zZXJ0IG9wZXJhdGlvblxuICAgICAgbW9ja1N1cGFiYXNlLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBkYXRhOiBjcmVhdGVkU2V0dGluZ3MsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNldHRpbmdzU2VydmljZS51cGRhdGVTZXR0aW5ncyh2YWxpZFVwZGF0ZURhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmlkKS50b0JlKCdzZXR0aW5ncy0xJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS53ZWRkaW5nX2RhdGUpLnRvQmUoJzIwMjQtMDYtMTVUMDA6MDA6MDBaJyk7XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdChtb2NrU3VwYWJhc2UuaW5zZXJ0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh2YWxpZFVwZGF0ZURhdGEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gVkFMSURBVElPTl9FUlJPUiB3aGVuIHdlZGRpbmdfZGF0ZSBmb3JtYXQgaXMgaW52YWxpZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWREYXRhID0geyAuLi52YWxpZFVwZGF0ZURhdGEsIHdlZGRpbmdfZGF0ZTogJ2ludmFsaWQtZGF0ZScgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2V0dGluZ3NTZXJ2aWNlLnVwZGF0ZVNldHRpbmdzKGludmFsaWREYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdWQUxJREFUSU9OX0VSUk9SJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuZGV0YWlscykudG9CZURlZmluZWQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIFZBTElEQVRJT05fRVJST1Igd2hlbiByZW1pbmRlcl9kYXlzX2JlZm9yZSBpcyBuZWdhdGl2ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWREYXRhID0geyAuLi52YWxpZFVwZGF0ZURhdGEsIHJlbWluZGVyX2RheXNfYmVmb3JlOiAtMSB9O1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXR0aW5nc1NlcnZpY2UudXBkYXRlU2V0dGluZ3MoaW52YWxpZERhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ1ZBTElEQVRJT05fRVJST1InKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIFZBTElEQVRJT05fRVJST1Igd2hlbiBtYXhfcGhvdG9zX3Blcl9ndWVzdCBleGNlZWRzIGxpbWl0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZERhdGEgPSB7IC4uLnZhbGlkVXBkYXRlRGF0YSwgbWF4X3Bob3Rvc19wZXJfZ3Vlc3Q6IDEwMSB9O1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXR0aW5nc1NlcnZpY2UudXBkYXRlU2V0dGluZ3MoaW52YWxpZERhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ1ZBTElEQVRJT05fRVJST1InKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIERBVEFCQVNFX0VSUk9SIHdoZW4gdXBkYXRlIG9wZXJhdGlvbiBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nU2V0dGluZ3MgPSB7IGlkOiAnc2V0dGluZ3MtMScgfTtcblxuICAgICAgLy8gTW9jayBjaGVjayBmb3IgZXhpc3Rpbmcgc2V0dGluZ3NcbiAgICAgIG1vY2tTdXBhYmFzZS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgZGF0YTogZXhpc3RpbmdTZXR0aW5ncyxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgLy8gTW9jayB1cGRhdGUgb3BlcmF0aW9uIGZhaWx1cmVcbiAgICAgIG1vY2tTdXBhYmFzZS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogJ1VwZGF0ZSBmYWlsZWQnIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2V0dGluZ3NTZXJ2aWNlLnVwZGF0ZVNldHRpbmdzKHZhbGlkVXBkYXRlRGF0YSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnREFUQUJBU0VfRVJST1InKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0JlKCdVcGRhdGUgZmFpbGVkJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBEQVRBQkFTRV9FUlJPUiB3aGVuIGluc2VydCBvcGVyYXRpb24gZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGNoZWNrIGZvciBleGlzdGluZyBzZXR0aW5ncyAobm9uZSBmb3VuZClcbiAgICAgIG1vY2tTdXBhYmFzZS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgLy8gTW9jayBpbnNlcnQgb3BlcmF0aW9uIGZhaWx1cmVcbiAgICAgIG1vY2tTdXBhYmFzZS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogJ0luc2VydCBmYWlsZWQnIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2V0dGluZ3NTZXJ2aWNlLnVwZGF0ZVNldHRpbmdzKHZhbGlkVXBkYXRlRGF0YSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnREFUQUJBU0VfRVJST1InKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0JlKCdJbnNlcnQgZmFpbGVkJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBwYXJ0aWFsIHVwZGF0ZXMgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGFydGlhbFVwZGF0ZURhdGEgPSB7XG4gICAgICAgIHZlbnVlX25hbWU6ICdOZXcgVmVudWUgTmFtZScsXG4gICAgICAgIHNlbmRfcnN2cF9jb25maXJtYXRpb25zOiBmYWxzZSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGV4aXN0aW5nU2V0dGluZ3MgPSB7IGlkOiAnc2V0dGluZ3MtMScgfTtcbiAgICAgIGNvbnN0IHVwZGF0ZWRTZXR0aW5ncyA9IHtcbiAgICAgICAgaWQ6ICdzZXR0aW5ncy0xJyxcbiAgICAgICAgdmVudWVfbmFtZTogJ05ldyBWZW51ZSBOYW1lJyxcbiAgICAgICAgc2VuZF9yc3ZwX2NvbmZpcm1hdGlvbnM6IGZhbHNlLFxuICAgICAgICBjcmVhdGVkX2F0OiAnMjAyNC0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICB1cGRhdGVkX2F0OiAnMjAyNC0wMS0wMlQwMDowMDowMFonLFxuICAgICAgfTtcblxuICAgICAgLy8gTW9jayBjaGVjayBmb3IgZXhpc3Rpbmcgc2V0dGluZ3NcbiAgICAgIG1vY2tTdXBhYmFzZS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgZGF0YTogZXhpc3RpbmdTZXR0aW5ncyxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgLy8gTW9jayB1cGRhdGUgb3BlcmF0aW9uXG4gICAgICBtb2NrU3VwYWJhc2Uuc2luZ2xlLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIGRhdGE6IHVwZGF0ZWRTZXR0aW5ncyxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2V0dGluZ3NTZXJ2aWNlLnVwZGF0ZVNldHRpbmdzKHBhcnRpYWxVcGRhdGVEYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS52ZW51ZV9uYW1lKS50b0JlKCdOZXcgVmVudWUgTmFtZScpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuc2VuZF9yc3ZwX2NvbmZpcm1hdGlvbnMpLnRvQmUoZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBleHBlY3QobW9ja1N1cGFiYXNlLnVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgocGFydGlhbFVwZGF0ZURhdGEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgdXBkYXRlIGRhdGEgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZW1wdHlVcGRhdGVEYXRhID0ge307XG5cbiAgICAgIGNvbnN0IGV4aXN0aW5nU2V0dGluZ3MgPSB7IGlkOiAnc2V0dGluZ3MtMScgfTtcbiAgICAgIGNvbnN0IHVuY2hhbmdlZFNldHRpbmdzID0ge1xuICAgICAgICBpZDogJ3NldHRpbmdzLTEnLFxuICAgICAgICB3ZWRkaW5nX2RhdGU6ICcyMDI0LTA2LTE1VDAwOjAwOjAwWicsXG4gICAgICAgIHZlbnVlX25hbWU6ICdEcmVhbXMgTGFzIE1hcmVhcycsXG4gICAgICAgIGNyZWF0ZWRfYXQ6ICcyMDI0LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgIHVwZGF0ZWRfYXQ6ICcyMDI0LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICB9O1xuXG4gICAgICAvLyBNb2NrIGNoZWNrIGZvciBleGlzdGluZyBzZXR0aW5nc1xuICAgICAgbW9ja1N1cGFiYXNlLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBkYXRhOiBleGlzdGluZ1NldHRpbmdzLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrIHVwZGF0ZSBvcGVyYXRpb25cbiAgICAgIG1vY2tTdXBhYmFzZS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgZGF0YTogdW5jaGFuZ2VkU2V0dGluZ3MsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNldHRpbmdzU2VydmljZS51cGRhdGVTZXR0aW5ncyhlbXB0eVVwZGF0ZURhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmlkKS50b0JlKCdzZXR0aW5ncy0xJyk7XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdChtb2NrU3VwYWJhc2UudXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChlbXB0eVVwZGF0ZURhdGEpO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJtb2NrU3VwYWJhc2UiLCJmcm9tIiwiamVzdCIsImZuIiwibW9ja1JldHVyblRoaXMiLCJzZWxlY3QiLCJpbnNlcnQiLCJ1cGRhdGUiLCJlcSIsInNpbmdsZSIsIm1vY2siLCJzdXBhYmFzZSIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJpdCIsIm1vY2tTZXR0aW5ncyIsImlkIiwid2VkZGluZ19kYXRlIiwidmVudWVfbmFtZSIsImNvdXBsZV9uYW1lXzEiLCJjb3VwbGVfbmFtZV8yIiwidGltZXpvbmUiLCJzZW5kX3JzdnBfY29uZmlybWF0aW9ucyIsInNlbmRfYWN0aXZpdHlfcmVtaW5kZXJzIiwic2VuZF9kZWFkbGluZV9yZW1pbmRlcnMiLCJyZW1pbmRlcl9kYXlzX2JlZm9yZSIsInJlcXVpcmVfcGhvdG9fbW9kZXJhdGlvbiIsIm1heF9waG90b3NfcGVyX2d1ZXN0IiwiYWxsb3dlZF9waG90b19mb3JtYXRzIiwiaG9tZV9wYWdlX3RpdGxlIiwiaG9tZV9wYWdlX3N1YnRpdGxlIiwiaG9tZV9wYWdlX3dlbGNvbWVfbWVzc2FnZSIsImhvbWVfcGFnZV9oZXJvX2ltYWdlX3VybCIsImNyZWF0ZWRfYXQiLCJ1cGRhdGVkX2F0IiwibW9ja1Jlc29sdmVkVmFsdWUiLCJkYXRhIiwiZXJyb3IiLCJyZXN1bHQiLCJzZXR0aW5nc1NlcnZpY2UiLCJnZXRTZXR0aW5ncyIsImV4cGVjdCIsInN1Y2Nlc3MiLCJ0b0JlIiwiY29kZSIsInRvQmVOdWxsIiwidG9FcXVhbCIsIm1lc3NhZ2UiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIkVycm9yIiwidmFsaWRVcGRhdGVEYXRhIiwiZXhpc3RpbmdTZXR0aW5ncyIsInVwZGF0ZWRTZXR0aW5ncyIsIm1vY2tSZXNvbHZlZFZhbHVlT25jZSIsInVwZGF0ZVNldHRpbmdzIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJjcmVhdGVkU2V0dGluZ3MiLCJpbnZhbGlkRGF0YSIsImRldGFpbHMiLCJ0b0JlRGVmaW5lZCIsInBhcnRpYWxVcGRhdGVEYXRhIiwiZW1wdHlVcGRhdGVEYXRhIiwi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