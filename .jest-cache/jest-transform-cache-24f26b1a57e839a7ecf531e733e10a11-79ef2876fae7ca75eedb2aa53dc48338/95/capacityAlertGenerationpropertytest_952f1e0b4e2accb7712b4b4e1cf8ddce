18ce67355e155c555fd7b83668094a84
/**
 * Property-Based Test: Capacity Alert Generation
 * Feature: destination-wedding-platform, Property 11: Capacity Alert Generation
 * Validates: Requirements 7.7
 * 
 * Property: For any activity with a defined capacity, when the number of attending RSVPs 
 * reaches or exceeds the capacity threshold (e.g., 90%), the system should generate an 
 * alert for hosts.
 */ "use strict";
jest.mock('@supabase/supabase-js', ()=>({
        createClient: jest.fn(()=>({
                from: (...args)=>mockSupabaseFrom(...args)
            }))
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _rsvpService = /*#__PURE__*/ _interop_require_wildcard(require("./rsvpService"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Create mock Supabase client that will be populated in tests
let mockSupabaseFrom;
describe('Feature: destination-wedding-platform, Property 11: Capacity Alert Generation', ()=>{
    beforeEach(()=>{
        mockSupabaseFrom = jest.fn();
    });
    /**
   * Helper to setup mocks for generateCapacityAlerts
   * This function handles the complex nested query structure
   */ function setupMocksForCapacityAlerts(activities, rsvpsByActivity) {
        mockSupabaseFrom.mockImplementation((table)=>{
            if (table === 'activities') {
                return {
                    select: jest.fn().mockImplementation((columns)=>{
                        // Check if this is the query for all activities with capacity (from generateCapacityAlerts)
                        if (columns === 'id, name, capacity') {
                            return {
                                not: jest.fn().mockReturnValue({
                                    eq: jest.fn().mockResolvedValue({
                                        data: activities,
                                        error: null
                                    })
                                })
                            };
                        }
                        // This is the query for a single activity (from calculateActivityCapacity)
                        if (columns === 'capacity, name') {
                            return {
                                eq: jest.fn().mockImplementation((field, activityId)=>{
                                    return {
                                        single: jest.fn().mockImplementation(()=>{
                                            // Find the activity with this ID
                                            const activity = activities.find((a)=>a.id === activityId);
                                            return Promise.resolve({
                                                data: activity || null,
                                                error: activity ? null : {
                                                    code: 'PGRST116',
                                                    message: 'Not found'
                                                }
                                            });
                                        })
                                    };
                                })
                            };
                        }
                        return {
                            eq: jest.fn().mockResolvedValue({
                                data: [],
                                error: null
                            })
                        };
                    })
                };
            }
            if (table === 'rsvps') {
                // This handles the RSVP count queries
                return {
                    select: jest.fn().mockImplementation((columns)=>{
                        if (columns === 'guest_count') {
                            // Return a chainable object for the RSVP count query
                            return {
                                eq: jest.fn().mockImplementation((field, value)=>{
                                    if (field === 'activity_id') {
                                        const activityId = value;
                                        return {
                                            eq: jest.fn().mockResolvedValue({
                                                data: rsvpsByActivity.get(activityId) || [],
                                                error: null
                                            })
                                        };
                                    }
                                    if (field === 'status') {
                                        // This is the second .eq() call for status = 'attending'
                                        // We need to return the data that was set up for this activity
                                        return Promise.resolve({
                                            data: [],
                                            error: null
                                        });
                                    }
                                    return {
                                        eq: jest.fn().mockResolvedValue({
                                            data: [],
                                            error: null
                                        })
                                    };
                                })
                            };
                        }
                        return {
                            eq: jest.fn().mockResolvedValue({
                                data: [],
                                error: null
                            })
                        };
                    })
                };
            }
            return {
                select: jest.fn().mockResolvedValue({
                    data: [],
                    error: null
                })
            };
        });
    }
    it('should generate alerts when activity capacity reaches or exceeds threshold', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(// Generate activity with capacity
        _fastcheck.record({
            id: _fastcheck.uuid(),
            name: _fastcheck.string({
                minLength: 1,
                maxLength: 100
            }),
            capacity: _fastcheck.integer({
                min: 10,
                max: 100
            })
        }), // Generate attending count as percentage of capacity
        _fastcheck.double({
            min: 0.85,
            max: 1.2
        }), async (activity, utilizationFactor)=>{
            const attendingCount = Math.floor(activity.capacity * utilizationFactor);
            // Calculate ACTUAL utilization based on the floored attending count
            const actualUtilization = attendingCount / activity.capacity;
            // Setup mocks for this test case
            const rsvpsByActivity = new Map();
            rsvpsByActivity.set(activity.id, Array.from({
                length: attendingCount
            }, ()=>({
                    guest_count: 1
                })));
            setupMocksForCapacityAlerts([
                activity
            ], rsvpsByActivity);
            // Test with 90% threshold
            const result = await _rsvpService.generateCapacityAlerts(0.9);
            expect(result.success).toBe(true);
            if (result.success) {
                // If ACTUAL utilization >= 90%, should generate alert
                if (actualUtilization >= 0.9) {
                    expect(result.data.length).toBeGreaterThan(0);
                    const alert = result.data.find((a)=>a.activity_id === activity.id);
                    expect(alert).toBeDefined();
                    if (alert) {
                        expect(alert.capacity).toBe(activity.capacity);
                        expect(alert.attending_count).toBe(attendingCount);
                        expect(alert.utilization_percentage).toBeGreaterThanOrEqual(90);
                        // Check alert level
                        if (attendingCount >= activity.capacity) {
                            expect(alert.alert_level).toBe('full');
                        } else if (actualUtilization >= 0.95) {
                            expect(alert.alert_level).toBe('critical');
                        } else {
                            expect(alert.alert_level).toBe('warning');
                        }
                        // Check message contains activity name and counts
                        expect(alert.message).toContain(activity.name);
                        expect(alert.message).toContain(attendingCount.toString());
                        expect(alert.message).toContain(activity.capacity.toString());
                    }
                } else {
                    // If ACTUAL utilization < 90%, should not generate alert for this activity
                    const alert = result.data.find((a)=>a.activity_id === activity.id);
                    expect(alert).toBeUndefined();
                }
            }
        }), {
            numRuns: 100
        });
    });
    it('should not generate alerts for activities without capacity limits', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
            id: _fastcheck.uuid(),
            name: _fastcheck.string({
                minLength: 1,
                maxLength: 100
            }),
            capacity: _fastcheck.constant(null)
        }), _fastcheck.integer({
            min: 0,
            max: 1000
        }), async (activity, attendingCount)=>{
            // Setup mocks - no activities with capacity limits
            setupMocksForCapacityAlerts([], new Map());
            const result = await _rsvpService.generateCapacityAlerts(0.9);
            expect(result.success).toBe(true);
            if (result.success) {
                // Should not generate alerts for activities without capacity
                expect(result.data.length).toBe(0);
            }
        }), {
            numRuns: 100
        });
    });
    it('should correctly calculate utilization percentage', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.integer({
            min: 10,
            max: 100
        }), _fastcheck.double({
            min: 0.9,
            max: 1.0
        }), async (capacity, utilizationFactor)=>{
            const attendingCount = Math.floor(capacity * utilizationFactor);
            const expectedUtilization = Math.round(attendingCount / capacity * 100);
            const activity = {
                id: 'test-activity-id',
                name: 'Test Activity',
                capacity
            };
            // Setup mocks
            const rsvpsByActivity = new Map();
            rsvpsByActivity.set(activity.id, Array.from({
                length: attendingCount
            }, ()=>({
                    guest_count: 1
                })));
            setupMocksForCapacityAlerts([
                activity
            ], rsvpsByActivity);
            const result = await _rsvpService.generateCapacityAlerts(0.9);
            expect(result.success).toBe(true);
            if (result.success && result.data.length > 0) {
                const alert = result.data[0];
                expect(alert.utilization_percentage).toBe(expectedUtilization);
                expect(alert.utilization_percentage).toBeGreaterThanOrEqual(90);
                expect(alert.utilization_percentage).toBeLessThanOrEqual(100);
            }
        }), {
            numRuns: 100
        });
    });
    it('should generate different alert levels based on utilization', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.integer({
            min: 50,
            max: 100
        }), _fastcheck.constantFrom({
            factor: 0.92,
            expectedLevel: 'warning'
        }, {
            factor: 0.96,
            expectedLevel: 'critical'
        }, {
            factor: 1.0,
            expectedLevel: 'full'
        }, {
            factor: 1.05,
            expectedLevel: 'full'
        }), async (capacity, { factor, expectedLevel })=>{
            const attendingCount = Math.floor(capacity * factor);
            const actualUtilization = attendingCount / capacity;
            const activity = {
                id: 'test-activity-id',
                name: 'Test Activity',
                capacity
            };
            // Setup mocks
            const rsvpsByActivity = new Map();
            rsvpsByActivity.set(activity.id, Array.from({
                length: attendingCount
            }, ()=>({
                    guest_count: 1
                })));
            setupMocksForCapacityAlerts([
                activity
            ], rsvpsByActivity);
            const result = await _rsvpService.generateCapacityAlerts(0.9);
            expect(result.success).toBe(true);
            if (result.success && result.data.length > 0) {
                const alert = result.data[0];
                // Determine expected level based on ACTUAL utilization after flooring
                let correctExpectedLevel;
                if (attendingCount >= capacity) {
                    correctExpectedLevel = 'full';
                } else if (actualUtilization >= 0.95) {
                    correctExpectedLevel = 'critical';
                } else {
                    correctExpectedLevel = 'warning';
                }
                expect(alert.alert_level).toBe(correctExpectedLevel);
            }
        }), {
            numRuns: 100
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvY2FwYWNpdHlBbGVydEdlbmVyYXRpb24ucHJvcGVydHkudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFByb3BlcnR5LUJhc2VkIFRlc3Q6IENhcGFjaXR5IEFsZXJ0IEdlbmVyYXRpb25cbiAqIEZlYXR1cmU6IGRlc3RpbmF0aW9uLXdlZGRpbmctcGxhdGZvcm0sIFByb3BlcnR5IDExOiBDYXBhY2l0eSBBbGVydCBHZW5lcmF0aW9uXG4gKiBWYWxpZGF0ZXM6IFJlcXVpcmVtZW50cyA3LjdcbiAqIFxuICogUHJvcGVydHk6IEZvciBhbnkgYWN0aXZpdHkgd2l0aCBhIGRlZmluZWQgY2FwYWNpdHksIHdoZW4gdGhlIG51bWJlciBvZiBhdHRlbmRpbmcgUlNWUHMgXG4gKiByZWFjaGVzIG9yIGV4Y2VlZHMgdGhlIGNhcGFjaXR5IHRocmVzaG9sZCAoZS5nLiwgOTAlKSwgdGhlIHN5c3RlbSBzaG91bGQgZ2VuZXJhdGUgYW4gXG4gKiBhbGVydCBmb3IgaG9zdHMuXG4gKi9cblxuaW1wb3J0ICogYXMgZmMgZnJvbSAnZmFzdC1jaGVjayc7XG5cbi8vIENyZWF0ZSBtb2NrIFN1cGFiYXNlIGNsaWVudCB0aGF0IHdpbGwgYmUgcG9wdWxhdGVkIGluIHRlc3RzXG5sZXQgbW9ja1N1cGFiYXNlRnJvbTogamVzdC5Nb2NrO1xuXG5qZXN0Lm1vY2soJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcycsICgpID0+ICh7XG4gIGNyZWF0ZUNsaWVudDogamVzdC5mbigoKSA9PiAoe1xuICAgIGZyb206ICguLi5hcmdzOiBhbnlbXSkgPT4gbW9ja1N1cGFiYXNlRnJvbSguLi5hcmdzKSxcbiAgfSkpLFxufSkpO1xuXG4vLyBOT1cgaW1wb3J0IHRoZSBzZXJ2aWNlIGFmdGVyIG1vY2tpbmdcbmltcG9ydCAqIGFzIHJzdnBTZXJ2aWNlIGZyb20gJy4vcnN2cFNlcnZpY2UnO1xuXG5kZXNjcmliZSgnRmVhdHVyZTogZGVzdGluYXRpb24td2VkZGluZy1wbGF0Zm9ybSwgUHJvcGVydHkgMTE6IENhcGFjaXR5IEFsZXJ0IEdlbmVyYXRpb24nLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIG1vY2tTdXBhYmFzZUZyb20gPSBqZXN0LmZuKCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gc2V0dXAgbW9ja3MgZm9yIGdlbmVyYXRlQ2FwYWNpdHlBbGVydHNcbiAgICogVGhpcyBmdW5jdGlvbiBoYW5kbGVzIHRoZSBjb21wbGV4IG5lc3RlZCBxdWVyeSBzdHJ1Y3R1cmVcbiAgICovXG4gIGZ1bmN0aW9uIHNldHVwTW9ja3NGb3JDYXBhY2l0eUFsZXJ0cyhhY3Rpdml0aWVzOiBhbnlbXSwgcnN2cHNCeUFjdGl2aXR5OiBNYXA8c3RyaW5nLCBhbnlbXT4pIHtcbiAgICBtb2NrU3VwYWJhc2VGcm9tLm1vY2tJbXBsZW1lbnRhdGlvbigodGFibGU6IHN0cmluZykgPT4ge1xuICAgICAgaWYgKHRhYmxlID09PSAnYWN0aXZpdGllcycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKGNvbHVtbnM6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyB0aGUgcXVlcnkgZm9yIGFsbCBhY3Rpdml0aWVzIHdpdGggY2FwYWNpdHkgKGZyb20gZ2VuZXJhdGVDYXBhY2l0eUFsZXJ0cylcbiAgICAgICAgICAgIGlmIChjb2x1bW5zID09PSAnaWQsIG5hbWUsIGNhcGFjaXR5Jykge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5vdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogYWN0aXZpdGllcyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgcXVlcnkgZm9yIGEgc2luZ2xlIGFjdGl2aXR5IChmcm9tIGNhbGN1bGF0ZUFjdGl2aXR5Q2FwYWNpdHkpXG4gICAgICAgICAgICBpZiAoY29sdW1ucyA9PT0gJ2NhcGFjaXR5LCBuYW1lJykge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKChmaWVsZDogc3RyaW5nLCBhY3Rpdml0eUlkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgYWN0aXZpdHkgd2l0aCB0aGlzIElEXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWN0aXZpdHkgPSBhY3Rpdml0aWVzLmZpbmQoYSA9PiBhLmlkID09PSBhY3Rpdml0eUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGFjdGl2aXR5IHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogYWN0aXZpdHkgPyBudWxsIDogeyBjb2RlOiAnUEdSU1QxMTYnLCBtZXNzYWdlOiAnTm90IGZvdW5kJyB9LFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICh0YWJsZSA9PT0gJ3JzdnBzJykge1xuICAgICAgICAvLyBUaGlzIGhhbmRsZXMgdGhlIFJTVlAgY291bnQgcXVlcmllc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoY29sdW1uczogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29sdW1ucyA9PT0gJ2d1ZXN0X2NvdW50Jykge1xuICAgICAgICAgICAgICAvLyBSZXR1cm4gYSBjaGFpbmFibGUgb2JqZWN0IGZvciB0aGUgUlNWUCBjb3VudCBxdWVyeVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKChmaWVsZDogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmllbGQgPT09ICdhY3Rpdml0eV9pZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWN0aXZpdHlJZCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcnN2cHNCeUFjdGl2aXR5LmdldChhY3Rpdml0eUlkKSB8fCBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkID09PSAnc3RhdHVzJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBzZWNvbmQgLmVxKCkgY2FsbCBmb3Igc3RhdHVzID0gJ2F0dGVuZGluZydcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byByZXR1cm4gdGhlIGRhdGEgdGhhdCB3YXMgc2V0IHVwIGZvciB0aGlzIGFjdGl2aXR5XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IFtdLCAvLyBUaGlzIHdpbGwgYmUgb3ZlcnJpZGRlbiBieSB0aGUgcHJvcGVyIG1vY2sgY2hhaW5cbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIH0pLFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGl0KCdzaG91bGQgZ2VuZXJhdGUgYWxlcnRzIHdoZW4gYWN0aXZpdHkgY2FwYWNpdHkgcmVhY2hlcyBvciBleGNlZWRzIHRocmVzaG9sZCcsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICAvLyBHZW5lcmF0ZSBhY3Rpdml0eSB3aXRoIGNhcGFjaXR5XG4gICAgICAgIGZjLnJlY29yZCh7XG4gICAgICAgICAgaWQ6IGZjLnV1aWQoKSxcbiAgICAgICAgICBuYW1lOiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTAwIH0pLFxuICAgICAgICAgIGNhcGFjaXR5OiBmYy5pbnRlZ2VyKHsgbWluOiAxMCwgbWF4OiAxMDAgfSksXG4gICAgICAgIH0pLFxuICAgICAgICAvLyBHZW5lcmF0ZSBhdHRlbmRpbmcgY291bnQgYXMgcGVyY2VudGFnZSBvZiBjYXBhY2l0eVxuICAgICAgICBmYy5kb3VibGUoeyBtaW46IDAuODUsIG1heDogMS4yIH0pLCAvLyA4NSUgdG8gMTIwJSBvZiBjYXBhY2l0eVxuICAgICAgICBhc3luYyAoYWN0aXZpdHksIHV0aWxpemF0aW9uRmFjdG9yKSA9PiB7XG4gICAgICAgICAgY29uc3QgYXR0ZW5kaW5nQ291bnQgPSBNYXRoLmZsb29yKGFjdGl2aXR5LmNhcGFjaXR5ICogdXRpbGl6YXRpb25GYWN0b3IpO1xuICAgICAgICAgIC8vIENhbGN1bGF0ZSBBQ1RVQUwgdXRpbGl6YXRpb24gYmFzZWQgb24gdGhlIGZsb29yZWQgYXR0ZW5kaW5nIGNvdW50XG4gICAgICAgICAgY29uc3QgYWN0dWFsVXRpbGl6YXRpb24gPSBhdHRlbmRpbmdDb3VudCAvIGFjdGl2aXR5LmNhcGFjaXR5O1xuXG4gICAgICAgICAgLy8gU2V0dXAgbW9ja3MgZm9yIHRoaXMgdGVzdCBjYXNlXG4gICAgICAgICAgY29uc3QgcnN2cHNCeUFjdGl2aXR5ID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHJzdnBzQnlBY3Rpdml0eS5zZXQoYWN0aXZpdHkuaWQsIEFycmF5LmZyb20oeyBsZW5ndGg6IGF0dGVuZGluZ0NvdW50IH0sICgpID0+ICh7XG4gICAgICAgICAgICBndWVzdF9jb3VudDogMSxcbiAgICAgICAgICB9KSkpO1xuXG4gICAgICAgICAgc2V0dXBNb2Nrc0ZvckNhcGFjaXR5QWxlcnRzKFthY3Rpdml0eV0sIHJzdnBzQnlBY3Rpdml0eSk7XG5cbiAgICAgICAgICAvLyBUZXN0IHdpdGggOTAlIHRocmVzaG9sZFxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBTZXJ2aWNlLmdlbmVyYXRlQ2FwYWNpdHlBbGVydHMoMC45KTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcblxuICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgLy8gSWYgQUNUVUFMIHV0aWxpemF0aW9uID49IDkwJSwgc2hvdWxkIGdlbmVyYXRlIGFsZXJ0XG4gICAgICAgICAgICBpZiAoYWN0dWFsVXRpbGl6YXRpb24gPj0gMC45KSB7XG4gICAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgICAgICAgICAgY29uc3QgYWxlcnQgPSByZXN1bHQuZGF0YS5maW5kKGEgPT4gYS5hY3Rpdml0eV9pZCA9PT0gYWN0aXZpdHkuaWQpO1xuICAgICAgICAgICAgICBleHBlY3QoYWxlcnQpLnRvQmVEZWZpbmVkKCk7XG5cbiAgICAgICAgICAgICAgaWYgKGFsZXJ0KSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KGFsZXJ0LmNhcGFjaXR5KS50b0JlKGFjdGl2aXR5LmNhcGFjaXR5KTtcbiAgICAgICAgICAgICAgICBleHBlY3QoYWxlcnQuYXR0ZW5kaW5nX2NvdW50KS50b0JlKGF0dGVuZGluZ0NvdW50KTtcbiAgICAgICAgICAgICAgICBleHBlY3QoYWxlcnQudXRpbGl6YXRpb25fcGVyY2VudGFnZSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCg5MCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBhbGVydCBsZXZlbFxuICAgICAgICAgICAgICAgIGlmIChhdHRlbmRpbmdDb3VudCA+PSBhY3Rpdml0eS5jYXBhY2l0eSkge1xuICAgICAgICAgICAgICAgICAgZXhwZWN0KGFsZXJ0LmFsZXJ0X2xldmVsKS50b0JlKCdmdWxsJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhY3R1YWxVdGlsaXphdGlvbiA+PSAwLjk1KSB7XG4gICAgICAgICAgICAgICAgICBleHBlY3QoYWxlcnQuYWxlcnRfbGV2ZWwpLnRvQmUoJ2NyaXRpY2FsJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGV4cGVjdChhbGVydC5hbGVydF9sZXZlbCkudG9CZSgnd2FybmluZycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIG1lc3NhZ2UgY29udGFpbnMgYWN0aXZpdHkgbmFtZSBhbmQgY291bnRzXG4gICAgICAgICAgICAgICAgZXhwZWN0KGFsZXJ0Lm1lc3NhZ2UpLnRvQ29udGFpbihhY3Rpdml0eS5uYW1lKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoYWxlcnQubWVzc2FnZSkudG9Db250YWluKGF0dGVuZGluZ0NvdW50LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChhbGVydC5tZXNzYWdlKS50b0NvbnRhaW4oYWN0aXZpdHkuY2FwYWNpdHkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIElmIEFDVFVBTCB1dGlsaXphdGlvbiA8IDkwJSwgc2hvdWxkIG5vdCBnZW5lcmF0ZSBhbGVydCBmb3IgdGhpcyBhY3Rpdml0eVxuICAgICAgICAgICAgICBjb25zdCBhbGVydCA9IHJlc3VsdC5kYXRhLmZpbmQoYSA9PiBhLmFjdGl2aXR5X2lkID09PSBhY3Rpdml0eS5pZCk7XG4gICAgICAgICAgICAgIGV4cGVjdChhbGVydCkudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIG5vdCBnZW5lcmF0ZSBhbGVydHMgZm9yIGFjdGl2aXRpZXMgd2l0aG91dCBjYXBhY2l0eSBsaW1pdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMucmVjb3JkKHtcbiAgICAgICAgICBpZDogZmMudXVpZCgpLFxuICAgICAgICAgIG5hbWU6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxMDAgfSksXG4gICAgICAgICAgY2FwYWNpdHk6IGZjLmNvbnN0YW50KG51bGwpLCAvLyBObyBjYXBhY2l0eSBsaW1pdFxuICAgICAgICB9KSxcbiAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMCwgbWF4OiAxMDAwIH0pLCAvLyBBbnkgbnVtYmVyIG9mIGF0dGVuZGVlc1xuICAgICAgICBhc3luYyAoYWN0aXZpdHksIGF0dGVuZGluZ0NvdW50KSA9PiB7XG4gICAgICAgICAgLy8gU2V0dXAgbW9ja3MgLSBubyBhY3Rpdml0aWVzIHdpdGggY2FwYWNpdHkgbGltaXRzXG4gICAgICAgICAgc2V0dXBNb2Nrc0ZvckNhcGFjaXR5QWxlcnRzKFtdLCBuZXcgTWFwKCkpO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cFNlcnZpY2UuZ2VuZXJhdGVDYXBhY2l0eUFsZXJ0cygwLjkpO1xuXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCBnZW5lcmF0ZSBhbGVydHMgZm9yIGFjdGl2aXRpZXMgd2l0aG91dCBjYXBhY2l0eVxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBjb3JyZWN0bHkgY2FsY3VsYXRlIHV0aWxpemF0aW9uIHBlcmNlbnRhZ2UnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMTAsIG1heDogMTAwIH0pLCAvLyBjYXBhY2l0eVxuICAgICAgICBmYy5kb3VibGUoeyBtaW46IDAuOSwgbWF4OiAxLjAgfSksIC8vIHV0aWxpemF0aW9uIGZhY3RvciAoOTAtMTAwJSlcbiAgICAgICAgYXN5bmMgKGNhcGFjaXR5LCB1dGlsaXphdGlvbkZhY3RvcikgPT4ge1xuICAgICAgICAgIGNvbnN0IGF0dGVuZGluZ0NvdW50ID0gTWF0aC5mbG9vcihjYXBhY2l0eSAqIHV0aWxpemF0aW9uRmFjdG9yKTtcbiAgICAgICAgICBjb25zdCBleHBlY3RlZFV0aWxpemF0aW9uID0gTWF0aC5yb3VuZCgoYXR0ZW5kaW5nQ291bnQgLyBjYXBhY2l0eSkgKiAxMDApO1xuXG4gICAgICAgICAgY29uc3QgYWN0aXZpdHkgPSB7XG4gICAgICAgICAgICBpZDogJ3Rlc3QtYWN0aXZpdHktaWQnLFxuICAgICAgICAgICAgbmFtZTogJ1Rlc3QgQWN0aXZpdHknLFxuICAgICAgICAgICAgY2FwYWNpdHksXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIFNldHVwIG1vY2tzXG4gICAgICAgICAgY29uc3QgcnN2cHNCeUFjdGl2aXR5ID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHJzdnBzQnlBY3Rpdml0eS5zZXQoYWN0aXZpdHkuaWQsIEFycmF5LmZyb20oeyBsZW5ndGg6IGF0dGVuZGluZ0NvdW50IH0sICgpID0+ICh7XG4gICAgICAgICAgICBndWVzdF9jb3VudDogMSxcbiAgICAgICAgICB9KSkpO1xuXG4gICAgICAgICAgc2V0dXBNb2Nrc0ZvckNhcGFjaXR5QWxlcnRzKFthY3Rpdml0eV0sIHJzdnBzQnlBY3Rpdml0eSk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwU2VydmljZS5nZW5lcmF0ZUNhcGFjaXR5QWxlcnRzKDAuOSk7XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGFsZXJ0ID0gcmVzdWx0LmRhdGFbMF07XG4gICAgICAgICAgICBleHBlY3QoYWxlcnQudXRpbGl6YXRpb25fcGVyY2VudGFnZSkudG9CZShleHBlY3RlZFV0aWxpemF0aW9uKTtcbiAgICAgICAgICAgIGV4cGVjdChhbGVydC51dGlsaXphdGlvbl9wZXJjZW50YWdlKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDkwKTtcbiAgICAgICAgICAgIGV4cGVjdChhbGVydC51dGlsaXphdGlvbl9wZXJjZW50YWdlKS50b0JlTGVzc1RoYW5PckVxdWFsKDEwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgZ2VuZXJhdGUgZGlmZmVyZW50IGFsZXJ0IGxldmVscyBiYXNlZCBvbiB1dGlsaXphdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiA1MCwgbWF4OiAxMDAgfSksIC8vIGNhcGFjaXR5XG4gICAgICAgIGZjLmNvbnN0YW50RnJvbShcbiAgICAgICAgICB7IGZhY3RvcjogMC45MiwgZXhwZWN0ZWRMZXZlbDogJ3dhcm5pbmcnIH0sXG4gICAgICAgICAgeyBmYWN0b3I6IDAuOTYsIGV4cGVjdGVkTGV2ZWw6ICdjcml0aWNhbCcgfSxcbiAgICAgICAgICB7IGZhY3RvcjogMS4wLCBleHBlY3RlZExldmVsOiAnZnVsbCcgfSxcbiAgICAgICAgICB7IGZhY3RvcjogMS4wNSwgZXhwZWN0ZWRMZXZlbDogJ2Z1bGwnIH1cbiAgICAgICAgKSxcbiAgICAgICAgYXN5bmMgKGNhcGFjaXR5LCB7IGZhY3RvciwgZXhwZWN0ZWRMZXZlbCB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgYXR0ZW5kaW5nQ291bnQgPSBNYXRoLmZsb29yKGNhcGFjaXR5ICogZmFjdG9yKTtcbiAgICAgICAgICBjb25zdCBhY3R1YWxVdGlsaXphdGlvbiA9IGF0dGVuZGluZ0NvdW50IC8gY2FwYWNpdHk7XG5cbiAgICAgICAgICBjb25zdCBhY3Rpdml0eSA9IHtcbiAgICAgICAgICAgIGlkOiAndGVzdC1hY3Rpdml0eS1pZCcsXG4gICAgICAgICAgICBuYW1lOiAnVGVzdCBBY3Rpdml0eScsXG4gICAgICAgICAgICBjYXBhY2l0eSxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gU2V0dXAgbW9ja3NcbiAgICAgICAgICBjb25zdCByc3Zwc0J5QWN0aXZpdHkgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgcnN2cHNCeUFjdGl2aXR5LnNldChhY3Rpdml0eS5pZCwgQXJyYXkuZnJvbSh7IGxlbmd0aDogYXR0ZW5kaW5nQ291bnQgfSwgKCkgPT4gKHtcbiAgICAgICAgICAgIGd1ZXN0X2NvdW50OiAxLFxuICAgICAgICAgIH0pKSk7XG5cbiAgICAgICAgICBzZXR1cE1vY2tzRm9yQ2FwYWNpdHlBbGVydHMoW2FjdGl2aXR5XSwgcnN2cHNCeUFjdGl2aXR5KTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBTZXJ2aWNlLmdlbmVyYXRlQ2FwYWNpdHlBbGVydHMoMC45KTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MgJiYgcmVzdWx0LmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgYWxlcnQgPSByZXN1bHQuZGF0YVswXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGV4cGVjdGVkIGxldmVsIGJhc2VkIG9uIEFDVFVBTCB1dGlsaXphdGlvbiBhZnRlciBmbG9vcmluZ1xuICAgICAgICAgICAgbGV0IGNvcnJlY3RFeHBlY3RlZExldmVsOiAnd2FybmluZycgfCAnY3JpdGljYWwnIHwgJ2Z1bGwnO1xuICAgICAgICAgICAgaWYgKGF0dGVuZGluZ0NvdW50ID49IGNhcGFjaXR5KSB7XG4gICAgICAgICAgICAgIGNvcnJlY3RFeHBlY3RlZExldmVsID0gJ2Z1bGwnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhY3R1YWxVdGlsaXphdGlvbiA+PSAwLjk1KSB7XG4gICAgICAgICAgICAgIGNvcnJlY3RFeHBlY3RlZExldmVsID0gJ2NyaXRpY2FsJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvcnJlY3RFeHBlY3RlZExldmVsID0gJ3dhcm5pbmcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHBlY3QoYWxlcnQuYWxlcnRfbGV2ZWwpLnRvQmUoY29ycmVjdEV4cGVjdGVkTGV2ZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiY3JlYXRlQ2xpZW50IiwiZm4iLCJmcm9tIiwiYXJncyIsIm1vY2tTdXBhYmFzZUZyb20iLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJzZXR1cE1vY2tzRm9yQ2FwYWNpdHlBbGVydHMiLCJhY3Rpdml0aWVzIiwicnN2cHNCeUFjdGl2aXR5IiwibW9ja0ltcGxlbWVudGF0aW9uIiwidGFibGUiLCJzZWxlY3QiLCJjb2x1bW5zIiwibm90IiwibW9ja1JldHVyblZhbHVlIiwiZXEiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsImRhdGEiLCJlcnJvciIsImZpZWxkIiwiYWN0aXZpdHlJZCIsInNpbmdsZSIsImFjdGl2aXR5IiwiZmluZCIsImEiLCJpZCIsIlByb21pc2UiLCJyZXNvbHZlIiwiY29kZSIsIm1lc3NhZ2UiLCJ2YWx1ZSIsImdldCIsIml0IiwiZmMiLCJhc3NlcnQiLCJhc3luY1Byb3BlcnR5IiwicmVjb3JkIiwidXVpZCIsIm5hbWUiLCJzdHJpbmciLCJtaW5MZW5ndGgiLCJtYXhMZW5ndGgiLCJjYXBhY2l0eSIsImludGVnZXIiLCJtaW4iLCJtYXgiLCJkb3VibGUiLCJ1dGlsaXphdGlvbkZhY3RvciIsImF0dGVuZGluZ0NvdW50IiwiTWF0aCIsImZsb29yIiwiYWN0dWFsVXRpbGl6YXRpb24iLCJNYXAiLCJzZXQiLCJBcnJheSIsImxlbmd0aCIsImd1ZXN0X2NvdW50IiwicmVzdWx0IiwicnN2cFNlcnZpY2UiLCJnZW5lcmF0ZUNhcGFjaXR5QWxlcnRzIiwiZXhwZWN0Iiwic3VjY2VzcyIsInRvQmUiLCJ0b0JlR3JlYXRlclRoYW4iLCJhbGVydCIsImFjdGl2aXR5X2lkIiwidG9CZURlZmluZWQiLCJhdHRlbmRpbmdfY291bnQiLCJ1dGlsaXphdGlvbl9wZXJjZW50YWdlIiwidG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCIsImFsZXJ0X2xldmVsIiwidG9Db250YWluIiwidG9TdHJpbmciLCJ0b0JlVW5kZWZpbmVkIiwibnVtUnVucyIsImNvbnN0YW50IiwiZXhwZWN0ZWRVdGlsaXphdGlvbiIsInJvdW5kIiwidG9CZUxlc3NUaGFuT3JFcXVhbCIsImNvbnN0YW50RnJvbSIsImZhY3RvciIsImV4cGVjdGVkTGV2ZWwiLCJjb3JyZWN0RXhwZWN0ZWRMZXZlbCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0NBUUM7QUFPREEsS0FBS0MsSUFBSSxDQUFDLHlCQUF5QixJQUFPLENBQUE7UUFDeENDLGNBQWNGLEtBQUtHLEVBQUUsQ0FBQyxJQUFPLENBQUE7Z0JBQzNCQyxNQUFNLENBQUMsR0FBR0MsT0FBZ0JDLG9CQUFvQkQ7WUFDaEQsQ0FBQTtJQUNGLENBQUE7Ozs7bUVBVG9CO3FFQVlTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFWN0IsOERBQThEO0FBQzlELElBQUlDO0FBV0pDLFNBQVMsaUZBQWlGO0lBQ3hGQyxXQUFXO1FBQ1RGLG1CQUFtQk4sS0FBS0csRUFBRTtJQUM1QjtJQUVBOzs7R0FHQyxHQUNELFNBQVNNLDRCQUE0QkMsVUFBaUIsRUFBRUMsZUFBbUM7UUFDekZMLGlCQUFpQk0sa0JBQWtCLENBQUMsQ0FBQ0M7WUFDbkMsSUFBSUEsVUFBVSxjQUFjO2dCQUMxQixPQUFPO29CQUNMQyxRQUFRZCxLQUFLRyxFQUFFLEdBQUdTLGtCQUFrQixDQUFDLENBQUNHO3dCQUNwQyw0RkFBNEY7d0JBQzVGLElBQUlBLFlBQVksc0JBQXNCOzRCQUNwQyxPQUFPO2dDQUNMQyxLQUFLaEIsS0FBS0csRUFBRSxHQUFHYyxlQUFlLENBQUM7b0NBQzdCQyxJQUFJbEIsS0FBS0csRUFBRSxHQUFHZ0IsaUJBQWlCLENBQUM7d0NBQzlC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