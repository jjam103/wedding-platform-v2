{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/__tests__/property/magicLinkAuthentication.property.test.ts"],"sourcesContent":["/**\n * Property-Based Tests for Magic Link Authentication\n * \n * Tests business rules and invariants for magic link authentication\n * using property-based testing with fast-check.\n * \n * Requirements: 5.3, 5.9\n * Task: 6.3, 6.4\n */\n\nimport * as fc from 'fast-check';\nimport { testDb } from '../helpers/testDb';\nimport { cleanup } from '../helpers/cleanup';\n\ndescribe('Feature: destination-wedding-platform, Magic Link Authentication Properties', () => {\n  beforeEach(async () => {\n    await cleanup();\n  });\n\n  afterAll(async () => {\n    await cleanup();\n  });\n\n  describe('Property 15: Magic Link Token Expiry', () => {\n    it('should reject any token that has expired', async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.integer({ min: 1, max: 3600 }), // Seconds expired (1 second to 1 hour)\n          async (secondsExpired) => {\n            // Arrange - Create guest and expired token\n            const guest = await testDb.createGuest({\n              email: `expired${Date.now()}@example.com`,\n              auth_method: 'magic_link',\n              first_name: 'Test',\n              last_name: 'User',\n            });\n\n            const expiresAt = new Date(Date.now() - secondsExpired * 1000);\n            const token = await testDb.createMagicLinkToken({\n              guest_id: guest.id,\n              expires_at: expiresAt.toISOString(),\n            });\n\n            // Act - Try to verify expired token\n            const response = await fetch(\n              `http://localhost:3000/api/auth/guest/magic-link/verify?token=${token.token}`,\n              { method: 'GET' }\n            );\n\n            // Assert - Should always be rejected\n            expect(response.status).toBe(410);\n            const data = await response.json();\n            expect(data.success).toBe(false);\n            expect(data.error.code).toBe('TOKEN_EXPIRED');\n\n            // Verify no session was created\n            const sessions = await testDb.getGuestSessions(guest.id);\n            expect(sessions.length).toBe(0);\n\n            // Cleanup\n            await testDb.deleteGuest(guest.id);\n          }\n        ),\n        { numRuns: 20 }\n      );\n    });\n\n    it('should accept any token that has not expired', async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.integer({ min: 1, max: 900 }), // Seconds until expiry (1 second to 15 minutes)\n          async (secondsUntilExpiry) => {\n            // Arrange - Create guest and valid token\n            const guest = await testDb.createGuest({\n              email: `valid${Date.now()}@example.com`,\n              auth_method: 'magic_link',\n              first_name: 'Test',\n              last_name: 'User',\n            });\n\n            const expiresAt = new Date(Date.now() + secondsUntilExpiry * 1000);\n            const token = await testDb.createMagicLinkToken({\n              guest_id: guest.id,\n              expires_at: expiresAt.toISOString(),\n            });\n\n            // Act - Verify valid token\n            const response = await fetch(\n              `http://localhost:3000/api/auth/guest/magic-link/verify?token=${token.token}`,\n              { method: 'GET' }\n            );\n\n            // Assert - Should always succeed\n            expect(response.status).toBe(200);\n            const data = await response.json();\n            expect(data.success).toBe(true);\n            expect(data.data.guestId).toBe(guest.id);\n\n            // Verify session was created\n            const sessions = await testDb.getGuestSessions(guest.id);\n            expect(sessions.length).toBe(1);\n\n            // Cleanup\n            await testDb.deleteGuest(guest.id);\n          }\n        ),\n        { numRuns: 20 }\n      );\n    });\n\n    it('should set token expiration to exactly 15 minutes from creation', async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.emailAddress(),\n          async (email) => {\n            // Arrange - Create guest\n            const guest = await testDb.createGuest({\n              email: email.toLowerCase(),\n              auth_method: 'magic_link',\n              first_name: 'Test',\n              last_name: 'User',\n            });\n\n            const beforeRequest = Date.now();\n\n            // Act - Request magic link\n            const response = await fetch('http://localhost:3000/api/auth/guest/magic-link', {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify({ email: email.toLowerCase() }),\n            });\n\n            const afterRequest = Date.now();\n\n            // Assert\n            if (response.status === 200) {\n              const tokens = await testDb.getMagicLinkTokens(guest.id);\n              expect(tokens.length).toBeGreaterThan(0);\n\n              const token = tokens[tokens.length - 1]; // Get latest token\n              const expiresAt = new Date(token.expires_at).getTime();\n              const expectedMin = beforeRequest + 15 * 60 * 1000;\n              const expectedMax = afterRequest + 15 * 60 * 1000;\n\n              expect(expiresAt).toBeGreaterThanOrEqual(expectedMin);\n              expect(expiresAt).toBeLessThanOrEqual(expectedMax);\n            }\n\n            // Cleanup\n            await testDb.deleteGuest(guest.id);\n          }\n        ),\n        { numRuns: 20 }\n      );\n    });\n  });\n\n  describe('Property 16: Magic Link Single Use', () => {\n    it('should reject any token that has already been used', async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.integer({ min: 1, max: 10 }), // Number of reuse attempts\n          async (attempts) => {\n            // Arrange - Create guest and token\n            const guest = await testDb.createGuest({\n              email: `singleuse${Date.now()}@example.com`,\n              auth_method: 'magic_link',\n              first_name: 'Test',\n              last_name: 'User',\n            });\n\n            const token = await testDb.createMagicLinkToken({\n              guest_id: guest.id,\n              expires_at: new Date(Date.now() + 15 * 60 * 1000).toISOString(),\n            });\n\n            // Act - Verify token first time (should succeed)\n            const firstResponse = await fetch(\n              `http://localhost:3000/api/auth/guest/magic-link/verify?token=${token.token}`,\n              { method: 'GET' }\n            );\n\n            expect(firstResponse.status).toBe(200);\n\n            // Act - Try to reuse token multiple times\n            const reuseResponses = await Promise.all(\n              Array.from({ length: attempts }, () =>\n                fetch(\n                  `http://localhost:3000/api/auth/guest/magic-link/verify?token=${token.token}`,\n                  { method: 'GET' }\n                )\n              )\n            );\n\n            // Assert - All reuse attempts should fail\n            for (const response of reuseResponses) {\n              expect(response.status).toBe(409);\n              const data = await response.json();\n              expect(data.success).toBe(false);\n              expect(data.error.code).toBe('TOKEN_USED');\n            }\n\n            // Verify only one session was created\n            const sessions = await testDb.getGuestSessions(guest.id);\n            expect(sessions.length).toBe(1);\n\n            // Cleanup\n            await testDb.deleteGuest(guest.id);\n          }\n        ),\n        { numRuns: 20 }\n      );\n    });\n\n    it('should mark token as used immediately after successful verification', async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.emailAddress(),\n          async (email) => {\n            // Arrange - Create guest and token\n            const guest = await testDb.createGuest({\n              email: email.toLowerCase(),\n              auth_method: 'magic_link',\n              first_name: 'Test',\n              last_name: 'User',\n            });\n\n            const token = await testDb.createMagicLinkToken({\n              guest_id: guest.id,\n              expires_at: new Date(Date.now() + 15 * 60 * 1000).toISOString(),\n            });\n\n            // Verify token is not used initially\n            const initialToken = await testDb.getMagicLinkToken(token.id);\n            expect(initialToken.used).toBe(false);\n            expect(initialToken.used_at).toBeNull();\n\n            // Act - Verify token\n            const response = await fetch(\n              `http://localhost:3000/api/auth/guest/magic-link/verify?token=${token.token}`,\n              { method: 'GET' }\n            );\n\n            // Assert - Token should be marked as used\n            if (response.status === 200) {\n              const updatedToken = await testDb.getMagicLinkToken(token.id);\n              expect(updatedToken.used).toBe(true);\n              expect(updatedToken.used_at).toBeTruthy();\n\n              // Verify used_at timestamp is recent\n              const usedAt = new Date(updatedToken.used_at!).getTime();\n              const now = Date.now();\n              expect(usedAt).toBeLessThanOrEqual(now);\n              expect(usedAt).toBeGreaterThan(now - 5000); // Within last 5 seconds\n            }\n\n            // Cleanup\n            await testDb.deleteGuest(guest.id);\n          }\n        ),\n        { numRuns: 20 }\n      );\n    });\n  });\n\n  describe('Property 17: Token Generation Uniqueness', () => {\n    it('should generate unique tokens for all requests', async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.integer({ min: 2, max: 5 }), // Number of tokens to generate\n          async (tokenCount) => {\n            // Arrange - Create guest\n            const guest = await testDb.createGuest({\n              email: `unique${Date.now()}@example.com`,\n              auth_method: 'magic_link',\n              first_name: 'Test',\n              last_name: 'User',\n            });\n\n            // Act - Request multiple magic links\n            const responses = await Promise.all(\n              Array.from({ length: tokenCount }, () =>\n                fetch('http://localhost:3000/api/auth/guest/magic-link', {\n                  method: 'POST',\n                  headers: { 'Content-Type': 'application/json' },\n                  body: JSON.stringify({ email: guest.email }),\n                })\n              )\n            );\n\n            // Assert - All requests should succeed\n            responses.forEach(response => {\n              expect(response.status).toBe(200);\n            });\n\n            // Verify all tokens are unique\n            const tokens = await testDb.getMagicLinkTokens(guest.id);\n            expect(tokens.length).toBe(tokenCount);\n\n            const tokenValues = tokens.map(t => t.token);\n            const uniqueTokens = new Set(tokenValues);\n            expect(uniqueTokens.size).toBe(tokenCount);\n\n            // Cleanup\n            await testDb.deleteGuest(guest.id);\n          }\n        ),\n        { numRuns: 20 }\n      );\n    });\n  });\n\n  describe('Property 18: Session Creation on Verification', () => {\n    it('should create exactly one session for each successful token verification', async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.emailAddress(),\n          async (email) => {\n            // Arrange - Create guest and token\n            const guest = await testDb.createGuest({\n              email: email.toLowerCase(),\n              auth_method: 'magic_link',\n              first_name: 'Test',\n              last_name: 'User',\n            });\n\n            const token = await testDb.createMagicLinkToken({\n              guest_id: guest.id,\n              expires_at: new Date(Date.now() + 15 * 60 * 1000).toISOString(),\n            });\n\n            const sessionsBefore = await testDb.getGuestSessions(guest.id);\n            const countBefore = sessionsBefore.length;\n\n            // Act - Verify token\n            const response = await fetch(\n              `http://localhost:3000/api/auth/guest/magic-link/verify?token=${token.token}`,\n              { method: 'GET' }\n            );\n\n            // Assert - Exactly one new session should be created\n            if (response.status === 200) {\n              const sessionsAfter = await testDb.getGuestSessions(guest.id);\n              expect(sessionsAfter.length).toBe(countBefore + 1);\n\n              // Verify session has correct guest_id\n              const newSession = sessionsAfter[sessionsAfter.length - 1];\n              expect(newSession.guest_id).toBe(guest.id);\n            }\n\n            // Cleanup\n            await testDb.deleteGuest(guest.id);\n          }\n        ),\n        { numRuns: 20 }\n      );\n    });\n\n    it('should not create session for failed verification attempts', async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.emailAddress(),\n          async (email) => {\n            // Arrange - Create guest and expired token\n            const guest = await testDb.createGuest({\n              email: email.toLowerCase(),\n              auth_method: 'magic_link',\n              first_name: 'Test',\n              last_name: 'User',\n            });\n\n            const token = await testDb.createMagicLinkToken({\n              guest_id: guest.id,\n              expires_at: new Date(Date.now() - 1000).toISOString(), // Expired\n            });\n\n            const sessionsBefore = await testDb.getGuestSessions(guest.id);\n            const countBefore = sessionsBefore.length;\n\n            // Act - Try to verify expired token\n            const response = await fetch(\n              `http://localhost:3000/api/auth/guest/magic-link/verify?token=${token.token}`,\n              { method: 'GET' }\n            );\n\n            // Assert - No new session should be created\n            expect(response.status).not.toBe(200);\n            const sessionsAfter = await testDb.getGuestSessions(guest.id);\n            expect(sessionsAfter.length).toBe(countBefore);\n\n            // Cleanup\n            await testDb.deleteGuest(guest.id);\n          }\n        ),\n        { numRuns: 20 }\n      );\n    });\n  });\n\n  describe('Property 19: Email Case Normalization', () => {\n    it('should normalize email to lowercase for all requests', async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.string({ minLength: 5, maxLength: 20 }).filter(s => /^[a-zA-Z0-9]+$/.test(s)),\n          async (localPart) => {\n            const email = `${localPart}@example.com`;\n            const mixedCaseEmail = email\n              .split('')\n              .map((char, i) => (i % 2 === 0 ? char.toUpperCase() : char.toLowerCase()))\n              .join('');\n\n            // Arrange - Create guest with lowercase email\n            const guest = await testDb.createGuest({\n              email: email.toLowerCase(),\n              auth_method: 'magic_link',\n              first_name: 'Test',\n              last_name: 'User',\n            });\n\n            // Act - Request magic link with mixed case email\n            const response = await fetch('http://localhost:3000/api/auth/guest/magic-link', {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify({ email: mixedCaseEmail }),\n            });\n\n            // Assert - Should still work (email normalized)\n            expect(response.status).toBe(200);\n            const data = await response.json();\n            expect(data.success).toBe(true);\n\n            // Verify token was created\n            const tokens = await testDb.getMagicLinkTokens(guest.id);\n            expect(tokens.length).toBeGreaterThan(0);\n\n            // Cleanup\n            await testDb.deleteGuest(guest.id);\n          }\n        ),\n        { numRuns: 20 }\n      );\n    });\n  });\n\n  describe('Property 20: Token Security', () => {\n    it('should generate tokens with exactly 64 hexadecimal characters', async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.emailAddress(),\n          async (email) => {\n            // Arrange - Create guest\n            const guest = await testDb.createGuest({\n              email: email.toLowerCase(),\n              auth_method: 'magic_link',\n              first_name: 'Test',\n              last_name: 'User',\n            });\n\n            // Act - Request magic link\n            const response = await fetch('http://localhost:3000/api/auth/guest/magic-link', {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify({ email: email.toLowerCase() }),\n            });\n\n            // Assert\n            if (response.status === 200) {\n              const tokens = await testDb.getMagicLinkTokens(guest.id);\n              expect(tokens.length).toBeGreaterThan(0);\n\n              const token = tokens[tokens.length - 1];\n              \n              // Verify token length (32 bytes = 64 hex characters)\n              expect(token.token).toHaveLength(64);\n              \n              // Verify token contains only hexadecimal characters\n              expect(token.token).toMatch(/^[0-9a-f]{64}$/);\n            }\n\n            // Cleanup\n            await testDb.deleteGuest(guest.id);\n          }\n        ),\n        { numRuns: 20 }\n      );\n    });\n  });\n});\n"],"names":["describe","beforeEach","cleanup","afterAll","it","fc","assert","asyncProperty","integer","min","max","secondsExpired","guest","testDb","createGuest","email","Date","now","auth_method","first_name","last_name","expiresAt","token","createMagicLinkToken","guest_id","id","expires_at","toISOString","response","fetch","method","expect","status","toBe","data","json","success","error","code","sessions","getGuestSessions","length","deleteGuest","numRuns","secondsUntilExpiry","guestId","emailAddress","toLowerCase","beforeRequest","headers","body","JSON","stringify","afterRequest","tokens","getMagicLinkTokens","toBeGreaterThan","getTime","expectedMin","expectedMax","toBeGreaterThanOrEqual","toBeLessThanOrEqual","attempts","firstResponse","reuseResponses","Promise","all","Array","from","initialToken","getMagicLinkToken","used","used_at","toBeNull","updatedToken","toBeTruthy","usedAt","tokenCount","responses","forEach","tokenValues","map","t","uniqueTokens","Set","size","sessionsBefore","countBefore","sessionsAfter","newSession","not","string","minLength","maxLength","filter","s","test","localPart","mixedCaseEmail","split","char","i","toUpperCase","join","toHaveLength","toMatch"],"mappings":"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"}