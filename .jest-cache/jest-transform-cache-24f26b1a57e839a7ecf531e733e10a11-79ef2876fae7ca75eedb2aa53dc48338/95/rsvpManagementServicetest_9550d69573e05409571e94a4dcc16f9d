0fd96b93561bfc4f987cf0c6f18be32d
"use strict";
// Mock Supabase
jest.mock('@supabase/supabase-js', ()=>({
        createClient: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _mockSupabase = require("../__tests__/helpers/mockSupabase");
const _rsvpManagementService = /*#__PURE__*/ _interop_require_wildcard(require("./rsvpManagementService"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('rsvpManagementService', ()=>{
    let mockSupabase;
    beforeEach(()=>{
        mockSupabase = (0, _mockSupabase.createMockSupabaseClient)();
        (0, _mockSupabase.resetMockSupabaseClient)(mockSupabase);
        const { createClient } = require('@supabase/supabase-js');
        createClient.mockReturnValue(mockSupabase);
    });
    describe('listRSVPs', ()=>{
        const mockRSVPData = [
            {
                id: 'rsvp-1',
                guest_id: 'guest-1',
                event_id: 'event-1',
                activity_id: null,
                status: 'attending',
                guest_count: 2,
                dietary_notes: 'Vegetarian',
                special_requirements: null,
                notes: null,
                responded_at: '2024-01-15T10:00:00Z',
                created_at: '2024-01-10T10:00:00Z',
                updated_at: '2024-01-15T10:00:00Z',
                guests: {
                    first_name: 'John',
                    last_name: 'Doe',
                    email: 'john@example.com'
                },
                events: {
                    name: 'Wedding Ceremony'
                },
                activities: null
            },
            {
                id: 'rsvp-2',
                guest_id: 'guest-2',
                event_id: null,
                activity_id: 'activity-1',
                status: 'pending',
                guest_count: 1,
                dietary_notes: null,
                special_requirements: null,
                notes: null,
                responded_at: null,
                created_at: '2024-01-12T10:00:00Z',
                updated_at: '2024-01-12T10:00:00Z',
                guests: {
                    first_name: 'Jane',
                    last_name: 'Smith',
                    email: 'jane@example.com'
                },
                events: null,
                activities: {
                    name: 'Beach Activity'
                }
            }
        ];
        it('should return success with RSVPs when valid filters and pagination', async ()=>{
            // Mock the query chain properly
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.eq.mockReturnValue(mockSupabase);
            mockSupabase.range.mockReturnValue(mockSupabase);
            mockSupabase.order.mockResolvedValue({
                data: mockRSVPData,
                error: null,
                count: 2
            });
            // Mock getRSVPStatistics
            jest.spyOn(_rsvpManagementService, 'getRSVPStatistics').mockResolvedValue({
                success: true,
                data: {
                    totalRSVPs: 2,
                    byStatus: {
                        attending: 1,
                        declined: 0,
                        maybe: 0,
                        pending: 1
                    },
                    totalGuestCount: 2
                }
            });
            const filters = {
                eventId: 'event-1'
            };
            const pagination = {
                page: 1,
                limit: 50
            };
            const result = await _rsvpManagementService.listRSVPs(filters, pagination);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.data).toHaveLength(2);
                expect(result.data.data[0].guestFirstName).toBe('John');
                expect(result.data.data[0].eventName).toBe('Wedding Ceremony');
                expect(result.data.pagination.page).toBe(1);
                expect(result.data.pagination.limit).toBe(50);
                expect(result.data.pagination.total).toBe(2);
                expect(result.data.pagination.totalPages).toBe(1);
            }
        });
        it('should filter by event ID', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.eq.mockReturnValue(mockSupabase);
            mockSupabase.range.mockReturnValue(mockSupabase);
            mockSupabase.order.mockResolvedValue({
                data: [
                    mockRSVPData[0]
                ],
                error: null,
                count: 1
            });
            // Mock getRSVPStatistics
            jest.spyOn(_rsvpManagementService, 'getRSVPStatistics').mockResolvedValue({
                success: true,
                data: {
                    totalRSVPs: 1,
                    byStatus: {
                        attending: 1,
                        declined: 0,
                        maybe: 0,
                        pending: 0
                    },
                    totalGuestCount: 2
                }
            });
            const result = await _rsvpManagementService.listRSVPs({
                eventId: 'event-1'
            }, {
                page: 1,
                limit: 50
            });
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.data).toHaveLength(1);
                expect(result.data.data[0].eventId).toBe('event-1');
            }
            // Verify eq was called with event_id
            expect(mockSupabase.eq).toHaveBeenCalledWith('event_id', 'event-1');
        });
        it('should filter by activity ID', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.eq.mockReturnValue(mockSupabase);
            mockSupabase.range.mockReturnValue(mockSupabase);
            mockSupabase.order.mockResolvedValue({
                data: [
                    mockRSVPData[1]
                ],
                error: null,
                count: 1
            });
            // Mock getRSVPStatistics
            jest.spyOn(_rsvpManagementService, 'getRSVPStatistics').mockResolvedValue({
                success: true,
                data: {
                    totalRSVPs: 1,
                    byStatus: {
                        attending: 0,
                        declined: 0,
                        maybe: 0,
                        pending: 1
                    },
                    totalGuestCount: 0
                }
            });
            const result = await _rsvpManagementService.listRSVPs({
                activityId: 'activity-1'
            }, {
                page: 1,
                limit: 50
            });
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.data).toHaveLength(1);
                expect(result.data.data[0].activityId).toBe('activity-1');
            }
            // Verify eq was called with activity_id
            expect(mockSupabase.eq).toHaveBeenCalledWith('activity_id', 'activity-1');
        });
        it('should filter by status', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.eq.mockReturnValue(mockSupabase);
            mockSupabase.range.mockReturnValue(mockSupabase);
            mockSupabase.order.mockResolvedValue({
                data: [
                    mockRSVPData[0]
                ],
                error: null,
                count: 1
            });
            // Mock getRSVPStatistics
            jest.spyOn(_rsvpManagementService, 'getRSVPStatistics').mockResolvedValue({
                success: true,
                data: {
                    totalRSVPs: 1,
                    byStatus: {
                        attending: 1,
                        declined: 0,
                        maybe: 0,
                        pending: 0
                    },
                    totalGuestCount: 2
                }
            });
            const result = await _rsvpManagementService.listRSVPs({
                status: 'attending'
            }, {
                page: 1,
                limit: 50
            });
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.data).toHaveLength(1);
                expect(result.data.data[0].status).toBe('attending');
            }
            // Verify eq was called with status
            expect(mockSupabase.eq).toHaveBeenCalledWith('status', 'attending');
        });
        it('should filter by guest ID', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.eq.mockReturnValue(mockSupabase);
            mockSupabase.range.mockReturnValue(mockSupabase);
            mockSupabase.order.mockResolvedValue({
                data: [
                    mockRSVPData[0]
                ],
                error: null,
                count: 1
            });
            // Mock getRSVPStatistics
            jest.spyOn(_rsvpManagementService, 'getRSVPStatistics').mockResolvedValue({
                success: true,
                data: {
                    totalRSVPs: 1,
                    byStatus: {
                        attending: 1,
                        declined: 0,
                        maybe: 0,
                        pending: 0
                    },
                    totalGuestCount: 2
                }
            });
            const result = await _rsvpManagementService.listRSVPs({
                guestId: 'guest-1'
            }, {
                page: 1,
                limit: 50
            });
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.data).toHaveLength(1);
                expect(result.data.data[0].guestId).toBe('guest-1');
            }
            // Verify eq was called with guest_id
            expect(mockSupabase.eq).toHaveBeenCalledWith('guest_id', 'guest-1');
        });
        it('should apply pagination correctly', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.range.mockReturnValue(mockSupabase);
            mockSupabase.order.mockResolvedValue({
                data: mockRSVPData,
                error: null,
                count: 100
            });
            // Mock getRSVPStatistics
            jest.spyOn(_rsvpManagementService, 'getRSVPStatistics').mockResolvedValue({
                success: true,
                data: {
                    totalRSVPs: 100,
                    byStatus: {
                        attending: 50,
                        declined: 25,
                        maybe: 15,
                        pending: 10
                    },
                    totalGuestCount: 50
                }
            });
            const result = await _rsvpManagementService.listRSVPs({}, {
                page: 2,
                limit: 25
            });
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.pagination.page).toBe(2);
                expect(result.data.pagination.limit).toBe(25);
                expect(result.data.pagination.total).toBe(100);
                expect(result.data.pagination.totalPages).toBe(4);
            }
            // Verify range was called with correct values (page 2, limit 25 = from 25 to 49)
            expect(mockSupabase.range).toHaveBeenCalledWith(25, 49);
        });
        it('should return VALIDATION_ERROR when invalid filter parameters', async ()=>{
            const result = await _rsvpManagementService.listRSVPs({
                eventId: 'invalid-uuid'
            }, {
                page: 1,
                limit: 50
            });
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        it('should return VALIDATION_ERROR when invalid pagination parameters', async ()=>{
            const result = await _rsvpManagementService.listRSVPs({}, {
                page: -1,
                limit: 50
            });
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        it('should return DATABASE_ERROR when database query fails', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.range.mockReturnValue(mockSupabase);
            mockSupabase.order.mockResolvedValue({
                data: null,
                error: {
                    message: 'Database connection failed'
                },
                count: null
            });
            const result = await _rsvpManagementService.listRSVPs({}, {
                page: 1,
                limit: 50
            });
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('DATABASE_ERROR');
                expect(result.error.message).toBe('Database connection failed');
            }
        });
        it('should apply multiple filters together', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.eq.mockReturnValue(mockSupabase);
            mockSupabase.range.mockReturnValue(mockSupabase);
            mockSupabase.order.mockResolvedValue({
                data: [
                    mockRSVPData[0]
                ],
                error: null,
                count: 1
            });
            // Mock getRSVPStatistics
            jest.spyOn(_rsvpManagementService, 'getRSVPStatistics').mockResolvedValue({
                success: true,
                data: {
                    totalRSVPs: 1,
                    byStatus: {
                        attending: 1,
                        declined: 0,
                        maybe: 0,
                        pending: 0
                    },
                    totalGuestCount: 2
                }
            });
            const result = await _rsvpManagementService.listRSVPs({
                eventId: 'event-1',
                status: 'attending',
                guestId: 'guest-1'
            }, {
                page: 1,
                limit: 50
            });
            expect(result.success).toBe(true);
            // Verify all filters were applied
            expect(mockSupabase.eq).toHaveBeenCalledWith('event_id', 'event-1');
            expect(mockSupabase.eq).toHaveBeenCalledWith('status', 'attending');
            expect(mockSupabase.eq).toHaveBeenCalledWith('guest_id', 'guest-1');
        });
        it('should handle search query filter', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.or.mockReturnValue(mockSupabase);
            mockSupabase.range.mockReturnValue(mockSupabase);
            mockSupabase.order.mockResolvedValue({
                data: [
                    mockRSVPData[0]
                ],
                error: null,
                count: 1
            });
            // Mock getRSVPStatistics
            jest.spyOn(_rsvpManagementService, 'getRSVPStatistics').mockResolvedValue({
                success: true,
                data: {
                    totalRSVPs: 1,
                    byStatus: {
                        attending: 1,
                        declined: 0,
                        maybe: 0,
                        pending: 0
                    },
                    totalGuestCount: 2
                }
            });
            const result = await _rsvpManagementService.listRSVPs({
                searchQuery: 'John'
            }, {
                page: 1,
                limit: 50
            });
            expect(result.success).toBe(true);
            // Verify or was called for search
            expect(mockSupabase.or).toHaveBeenCalled();
        });
        it('should default to page 1 and limit 50 when not specified', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.range.mockReturnValue(mockSupabase);
            mockSupabase.order.mockResolvedValue({
                data: mockRSVPData,
                error: null,
                count: 2
            });
            // Mock getRSVPStatistics
            jest.spyOn(_rsvpManagementService, 'getRSVPStatistics').mockResolvedValue({
                success: true,
                data: {
                    totalRSVPs: 2,
                    byStatus: {
                        attending: 1,
                        declined: 0,
                        maybe: 0,
                        pending: 1
                    },
                    totalGuestCount: 2
                }
            });
            const result = await _rsvpManagementService.listRSVPs();
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.pagination.page).toBe(1);
                expect(result.data.pagination.limit).toBe(50);
            }
            // Verify range was called with default values (page 1, limit 50 = from 0 to 49)
            expect(mockSupabase.range).toHaveBeenCalledWith(0, 49);
        });
    });
    describe('getRSVPStatistics', ()=>{
        const mockStatisticsData = [
            {
                status: 'attending',
                guest_count: 2
            },
            {
                status: 'attending',
                guest_count: 1
            },
            {
                status: 'declined',
                guest_count: 1
            },
            {
                status: 'maybe',
                guest_count: null
            },
            {
                status: 'pending',
                guest_count: 1
            }
        ];
        it('should return success with accurate statistics', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockResolvedValue({
                data: mockStatisticsData,
                error: null
            });
            const result = await _rsvpManagementService.getRSVPStatistics({});
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.totalRSVPs).toBe(5);
                expect(result.data.byStatus.attending).toBe(2);
                expect(result.data.byStatus.declined).toBe(1);
                expect(result.data.byStatus.maybe).toBe(1);
                expect(result.data.byStatus.pending).toBe(1);
                expect(result.data.totalGuestCount).toBe(3); // 2 + 1 from attending
            }
        });
        it('should filter statistics by event ID', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.eq.mockResolvedValue({
                data: [
                    mockStatisticsData[0],
                    mockStatisticsData[1]
                ],
                error: null
            });
            const result = await _rsvpManagementService.getRSVPStatistics({
                eventId: 'event-1'
            });
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.totalRSVPs).toBe(2);
                expect(result.data.byStatus.attending).toBe(2);
            }
            // Verify eq was called with event_id
            expect(mockSupabase.eq).toHaveBeenCalledWith('event_id', 'event-1');
        });
        it('should handle empty results', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockResolvedValue({
                data: [],
                error: null
            });
            const result = await _rsvpManagementService.getRSVPStatistics({});
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.totalRSVPs).toBe(0);
                expect(result.data.byStatus.attending).toBe(0);
                expect(result.data.totalGuestCount).toBe(0);
            }
        });
        it('should return VALIDATION_ERROR when invalid filter parameters', async ()=>{
            const result = await _rsvpManagementService.getRSVPStatistics({
                eventId: 'invalid-uuid'
            });
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        it('should return DATABASE_ERROR when database query fails', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockResolvedValue({
                data: null,
                error: {
                    message: 'Database connection failed'
                }
            });
            const result = await _rsvpManagementService.getRSVPStatistics({});
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('DATABASE_ERROR');
                expect(result.error.message).toBe('Database connection failed');
            }
        });
        it('should filter statistics by multiple criteria', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockReturnValue(mockSupabase);
            mockSupabase.eq.mockResolvedValue({
                data: [
                    mockStatisticsData[0]
                ],
                error: null
            });
            const result = await _rsvpManagementService.getRSVPStatistics({
                eventId: 'event-1',
                status: 'attending'
            });
            expect(result.success).toBe(true);
            // Verify both filters were applied
            expect(mockSupabase.eq).toHaveBeenCalledWith('event_id', 'event-1');
            expect(mockSupabase.eq).toHaveBeenCalledWith('status', 'attending');
        });
        it('should default guest_count to 1 when null for attending RSVPs', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.select.mockResolvedValue({
                data: [
                    {
                        status: 'attending',
                        guest_count: null
                    },
                    {
                        status: 'attending',
                        guest_count: 2
                    }
                ],
                error: null
            });
            const result = await _rsvpManagementService.getRSVPStatistics({});
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.totalGuestCount).toBe(3); // 1 (default) + 2
            }
        });
    });
    describe('bulkUpdateRSVPs', ()=>{
        it('should return success with updated count when valid input', async ()=>{
            const rsvpIds = [
                'rsvp-1',
                'rsvp-2',
                'rsvp-3'
            ];
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.update.mockReturnValue(mockSupabase);
            mockSupabase.in.mockReturnValue(mockSupabase);
            mockSupabase.select.mockResolvedValue({
                data: [
                    {
                        id: 'rsvp-1'
                    },
                    {
                        id: 'rsvp-2'
                    },
                    {
                        id: 'rsvp-3'
                    }
                ],
                error: null
            });
            const result = await _rsvpManagementService.bulkUpdateRSVPs(rsvpIds, 'attending', 'Bulk approved');
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.updatedCount).toBe(3);
            }
            // Verify update was called with correct data
            expect(mockSupabase.update).toHaveBeenCalledWith(expect.objectContaining({
                status: 'attending',
                notes: 'Bulk approved',
                responded_at: expect.any(String),
                updated_at: expect.any(String)
            }));
            // Verify in was called with correct IDs
            expect(mockSupabase.in).toHaveBeenCalledWith('id', rsvpIds);
        });
        it('should update status and set responded_at for non-pending status', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.update.mockReturnValue(mockSupabase);
            mockSupabase.in.mockReturnValue(mockSupabase);
            mockSupabase.select.mockResolvedValue({
                data: [
                    {
                        id: 'rsvp-1'
                    }
                ],
                error: null
            });
            await _rsvpManagementService.bulkUpdateRSVPs([
                'rsvp-1'
            ], 'attending');
            expect(mockSupabase.update).toHaveBeenCalledWith(expect.objectContaining({
                status: 'attending',
                responded_at: expect.any(String)
            }));
        });
        it('should include notes when provided', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.update.mockReturnValue(mockSupabase);
            mockSupabase.in.mockReturnValue(mockSupabase);
            mockSupabase.select.mockResolvedValue({
                data: [
                    {
                        id: 'rsvp-1'
                    }
                ],
                error: null
            });
            await _rsvpManagementService.bulkUpdateRSVPs([
                'rsvp-1'
            ], 'attending', 'Admin approved');
            expect(mockSupabase.update).toHaveBeenCalledWith(expect.objectContaining({
                notes: 'Admin approved'
            }));
        });
        it('should handle partial updates when some RSVPs not found', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.update.mockReturnValue(mockSupabase);
            mockSupabase.in.mockReturnValue(mockSupabase);
            mockSupabase.select.mockResolvedValue({
                data: [
                    {
                        id: 'rsvp-1'
                    },
                    {
                        id: 'rsvp-2'
                    }
                ],
                error: null
            });
            const result = await _rsvpManagementService.bulkUpdateRSVPs([
                'rsvp-1',
                'rsvp-2',
                'rsvp-3'
            ], 'attending');
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.updatedCount).toBe(2);
            }
        });
        it('should return VALIDATION_ERROR when empty rsvpIds array', async ()=>{
            const result = await _rsvpManagementService.bulkUpdateRSVPs([], 'attending');
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        it('should return VALIDATION_ERROR when too many rsvpIds (>100)', async ()=>{
            const tooManyIds = Array.from({
                length: 101
            }, (_, i)=>`rsvp-${i}`);
            const result = await _rsvpManagementService.bulkUpdateRSVPs(tooManyIds, 'attending');
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        it('should return VALIDATION_ERROR when invalid status', async ()=>{
            const result = await _rsvpManagementService.bulkUpdateRSVPs([
                'rsvp-1'
            ], 'invalid-status');
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        it('should return DATABASE_ERROR when database update fails', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.update.mockReturnValue(mockSupabase);
            mockSupabase.in.mockReturnValue(mockSupabase);
            mockSupabase.select.mockResolvedValue({
                data: null,
                error: {
                    message: 'Database connection failed'
                }
            });
            const result = await _rsvpManagementService.bulkUpdateRSVPs([
                'rsvp-1'
            ], 'attending');
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('DATABASE_ERROR');
                expect(result.error.message).toBe('Database connection failed');
            }
        });
        it('should not set responded_at when status is pending', async ()=>{
            mockSupabase.from.mockReturnValue(mockSupabase);
            mockSupabase.update.mockReturnValue(mockSupabase);
            mockSupabase.in.mockReturnValue(mockSupabase);
            mockSupabase.select.mockResolvedValue({
                data: [
                    {
                        id: 'rsvp-1'
                    }
                ],
                error: null
            });
            await _rsvpManagementService.bulkUpdateRSVPs([
                'rsvp-1'
            ], 'pending');
            expect(mockSupabase.update).toHaveBeenCalledWith(expect.objectContaining({
                status: 'pending'
            }));
            // Verify responded_at is NOT in the update data
            const updateCall = mockSupabase.update.mock.calls[0][0];
            expect(updateCall.responded_at).toBeUndefined();
        });
        it('should handle all valid status values', async ()=>{
            const statuses = [
                'pending',
                'attending',
                'declined',
                'maybe'
            ];
            for (const status of statuses){
                (0, _mockSupabase.resetMockSupabaseClient)(mockSupabase);
                mockSupabase.from.mockReturnValue(mockSupabase);
                mockSupabase.update.mockReturnValue(mockSupabase);
                mockSupabase.in.mockReturnValue(mockSupabase);
                mockSupabase.select.mockResolvedValue({
                    data: [
                        {
                            id: 'rsvp-1'
                        }
                    ],
                    error: null
                });
                const result = await _rsvpManagementService.bulkUpdateRSVPs([
                    'rsvp-1'
                ], status);
                expect(result.success).toBe(true);
                expect(mockSupabase.update).toHaveBeenCalledWith(expect.objectContaining({
                    status
                }));
            }
        });
    });
    describe('exportRSVPsToCSV', ()=>{
        it('should return success with CSV string when valid filters', async ()=>{
            const mockRSVPs = [
                {
                    id: 'rsvp-1',
                    guestFirstName: 'John',
                    guestLastName: 'Doe',
                    guestEmail: 'john@example.com',
                    eventName: 'Wedding Ceremony',
                    activityName: null,
                    status: 'attending',
                    guestCount: 2,
                    dietaryNotes: 'Vegetarian',
                    specialRequirements: null,
                    notes: null,
                    respondedAt: '2024-01-15T10:00:00Z',
                    createdAt: '2024-01-10T10:00:00Z',
                    updatedAt: '2024-01-15T10:00:00Z',
                    guestId: 'guest-1',
                    eventId: 'event-1',
                    activityId: null
                }
            ];
            // Mock listRSVPs to return test data
            jest.spyOn(_rsvpManagementService, 'listRSVPs').mockResolvedValue({
                success: true,
                data: {
                    data: mockRSVPs,
                    pagination: {
                        page: 1,
                        limit: 10000,
                        total: 1,
                        totalPages: 1
                    },
                    statistics: {
                        totalRSVPs: 1,
                        byStatus: {
                            attending: 1,
                            declined: 0,
                            maybe: 0,
                            pending: 0
                        },
                        totalGuestCount: 2
                    }
                }
            });
            const result = await _rsvpManagementService.exportRSVPsToCSV({});
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data).toContain('RSVP ID,Guest First Name,Guest Last Name');
                expect(result.data).toContain('rsvp-1,John,Doe');
                expect(result.data).toContain('Wedding Ceremony');
                expect(result.data).toContain('attending');
                expect(result.data).toContain('Vegetarian');
            }
            // Verify listRSVPs was called with correct parameters
            expect(_rsvpManagementService.listRSVPs).toHaveBeenCalledWith({}, {
                page: 1,
                limit: 10000
            });
        });
        it('should escape CSV values with commas', async ()=>{
            const mockRSVPs = [
                {
                    id: 'rsvp-1',
                    guestFirstName: 'John',
                    guestLastName: 'Doe, Jr.',
                    guestEmail: 'john@example.com',
                    eventName: 'Wedding Ceremony',
                    activityName: null,
                    status: 'attending',
                    guestCount: 1,
                    dietaryNotes: 'No nuts, no dairy',
                    specialRequirements: null,
                    notes: null,
                    respondedAt: '2024-01-15T10:00:00Z',
                    createdAt: '2024-01-10T10:00:00Z',
                    updatedAt: '2024-01-15T10:00:00Z',
                    guestId: 'guest-1',
                    eventId: 'event-1',
                    activityId: null
                }
            ];
            jest.spyOn(_rsvpManagementService, 'listRSVPs').mockResolvedValue({
                success: true,
                data: {
                    data: mockRSVPs,
                    pagination: {
                        page: 1,
                        limit: 10000,
                        total: 1,
                        totalPages: 1
                    },
                    statistics: {
                        totalRSVPs: 1,
                        byStatus: {
                            attending: 1,
                            declined: 0,
                            maybe: 0,
                            pending: 0
                        },
                        totalGuestCount: 1
                    }
                }
            });
            const result = await _rsvpManagementService.exportRSVPsToCSV({});
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data).toContain('"Doe, Jr."');
                expect(result.data).toContain('"No nuts, no dairy"');
            }
        });
        it('should escape CSV values with quotes', async ()=>{
            const mockRSVPs = [
                {
                    id: 'rsvp-1',
                    guestFirstName: 'John',
                    guestLastName: 'Doe',
                    guestEmail: 'john@example.com',
                    eventName: 'Wedding Ceremony',
                    activityName: null,
                    status: 'attending',
                    guestCount: 1,
                    dietaryNotes: null,
                    specialRequirements: null,
                    notes: 'Guest said "excited to attend"',
                    respondedAt: '2024-01-15T10:00:00Z',
                    createdAt: '2024-01-10T10:00:00Z',
                    updatedAt: '2024-01-15T10:00:00Z',
                    guestId: 'guest-1',
                    eventId: 'event-1',
                    activityId: null
                }
            ];
            jest.spyOn(_rsvpManagementService, 'listRSVPs').mockResolvedValue({
                success: true,
                data: {
                    data: mockRSVPs,
                    pagination: {
                        page: 1,
                        limit: 10000,
                        total: 1,
                        totalPages: 1
                    },
                    statistics: {
                        totalRSVPs: 1,
                        byStatus: {
                            attending: 1,
                            declined: 0,
                            maybe: 0,
                            pending: 0
                        },
                        totalGuestCount: 1
                    }
                }
            });
            const result = await _rsvpManagementService.exportRSVPsToCSV({});
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data).toContain('""excited to attend""');
            }
        });
        it('should handle empty results', async ()=>{
            jest.spyOn(_rsvpManagementService, 'listRSVPs').mockResolvedValue({
                success: true,
                data: {
                    data: [],
                    pagination: {
                        page: 1,
                        limit: 10000,
                        total: 0,
                        totalPages: 0
                    },
                    statistics: {
                        totalRSVPs: 0,
                        byStatus: {
                            attending: 0,
                            declined: 0,
                            maybe: 0,
                            pending: 0
                        },
                        totalGuestCount: 0
                    }
                }
            });
            const result = await _rsvpManagementService.exportRSVPsToCSV({});
            expect(result.success).toBe(true);
            if (result.success) {
                // Should only have header row
                const lines = result.data.split('\n');
                expect(lines.length).toBe(1);
                expect(lines[0]).toContain('RSVP ID,Guest First Name');
            }
        });
        it('should return VALIDATION_ERROR when invalid filter parameters', async ()=>{
            const result = await _rsvpManagementService.exportRSVPsToCSV({
                eventId: 'invalid-uuid'
            });
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        it('should propagate errors from listRSVPs', async ()=>{
            jest.spyOn(_rsvpManagementService, 'listRSVPs').mockResolvedValue({
                success: false,
                error: {
                    code: 'DATABASE_ERROR',
                    message: 'Database connection failed'
                }
            });
            const result = await _rsvpManagementService.exportRSVPsToCSV({});
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('DATABASE_ERROR');
                expect(result.error.message).toBe('Database connection failed');
            }
        });
        it('should apply filters when exporting', async ()=>{
            jest.spyOn(_rsvpManagementService, 'listRSVPs').mockResolvedValue({
                success: true,
                data: {
                    data: [],
                    pagination: {
                        page: 1,
                        limit: 10000,
                        total: 0,
                        totalPages: 0
                    },
                    statistics: {
                        totalRSVPs: 0,
                        byStatus: {
                            attending: 0,
                            declined: 0,
                            maybe: 0,
                            pending: 0
                        },
                        totalGuestCount: 0
                    }
                }
            });
            const filters = {
                eventId: 'event-1',
                status: 'attending'
            };
            await _rsvpManagementService.exportRSVPsToCSV(filters);
            // Verify listRSVPs was called with the filters
            expect(_rsvpManagementService.listRSVPs).toHaveBeenCalledWith(filters, {
                page: 1,
                limit: 10000
            });
        });
        it('should handle newlines in CSV values', async ()=>{
            const mockRSVPs = [
                {
                    id: 'rsvp-1',
                    guestFirstName: 'John',
                    guestLastName: 'Doe',
                    guestEmail: 'john@example.com',
                    eventName: 'Wedding Ceremony',
                    activityName: null,
                    status: 'attending',
                    guestCount: 1,
                    dietaryNotes: null,
                    specialRequirements: null,
                    notes: 'Line 1\nLine 2',
                    respondedAt: '2024-01-15T10:00:00Z',
                    createdAt: '2024-01-10T10:00:00Z',
                    updatedAt: '2024-01-15T10:00:00Z',
                    guestId: 'guest-1',
                    eventId: 'event-1',
                    activityId: null
                }
            ];
            jest.spyOn(_rsvpManagementService, 'listRSVPs').mockResolvedValue({
                success: true,
                data: {
                    data: mockRSVPs,
                    pagination: {
                        page: 1,
                        limit: 10000,
                        total: 1,
                        totalPages: 1
                    },
                    statistics: {
                        totalRSVPs: 1,
                        byStatus: {
                            attending: 1,
                            declined: 0,
                            maybe: 0,
                            pending: 0
                        },
                        totalGuestCount: 1
                    }
                }
            });
            const result = await _rsvpManagementService.exportRSVPsToCSV({});
            expect(result.success).toBe(true);
            if (result.success) {
                // Newlines should be wrapped in quotes
                expect(result.data).toContain('"Line 1\nLine 2"');
            }
        });
        it('should handle null values in CSV', async ()=>{
            const mockRSVPs = [
                {
                    id: 'rsvp-1',
                    guestFirstName: 'John',
                    guestLastName: 'Doe',
                    guestEmail: null,
                    eventName: null,
                    activityName: null,
                    status: 'pending',
                    guestCount: null,
                    dietaryNotes: null,
                    specialRequirements: null,
                    notes: null,
                    respondedAt: null,
                    createdAt: '2024-01-10T10:00:00Z',
                    updatedAt: '2024-01-10T10:00:00Z',
                    guestId: 'guest-1',
                    eventId: null,
                    activityId: null
                }
            ];
            jest.spyOn(_rsvpManagementService, 'listRSVPs').mockResolvedValue({
                success: true,
                data: {
                    data: mockRSVPs,
                    pagination: {
                        page: 1,
                        limit: 10000,
                        total: 1,
                        totalPages: 1
                    },
                    statistics: {
                        totalRSVPs: 1,
                        byStatus: {
                            attending: 0,
                            declined: 0,
                            maybe: 0,
                            pending: 1
                        },
                        totalGuestCount: 0
                    }
                }
            });
            const result = await _rsvpManagementService.exportRSVPsToCSV({});
            expect(result.success).toBe(true);
            if (result.success) {
                // Null values should be empty strings
                const lines = result.data.split('\n');
                expect(lines[1]).toContain('rsvp-1,John,Doe,,,');
                // Guest count should default to 1
                expect(lines[1]).toContain(',1,');
            }
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlTW9ja1N1cGFiYXNlQ2xpZW50LCByZXNldE1vY2tTdXBhYmFzZUNsaWVudCB9IGZyb20gJ0AvX190ZXN0c19fL2hlbHBlcnMvbW9ja1N1cGFiYXNlJztcbmltcG9ydCAqIGFzIHJzdnBNYW5hZ2VtZW50U2VydmljZSBmcm9tICcuL3JzdnBNYW5hZ2VtZW50U2VydmljZSc7XG5pbXBvcnQgdHlwZSB7IFJTVlBGaWx0ZXJzLCBQYWdpbmF0aW9uUGFyYW1zIH0gZnJvbSAnLi9yc3ZwTWFuYWdlbWVudFNlcnZpY2UnO1xuXG4vLyBNb2NrIFN1cGFiYXNlXG5qZXN0Lm1vY2soJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcycsICgpID0+ICh7XG4gIGNyZWF0ZUNsaWVudDogamVzdC5mbigpLFxufSkpO1xuXG5kZXNjcmliZSgncnN2cE1hbmFnZW1lbnRTZXJ2aWNlJywgKCkgPT4ge1xuICBsZXQgbW9ja1N1cGFiYXNlOiBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVNb2NrU3VwYWJhc2VDbGllbnQ+O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIG1vY2tTdXBhYmFzZSA9IGNyZWF0ZU1vY2tTdXBhYmFzZUNsaWVudCgpO1xuICAgIHJlc2V0TW9ja1N1cGFiYXNlQ2xpZW50KG1vY2tTdXBhYmFzZSk7XG4gICAgY29uc3QgeyBjcmVhdGVDbGllbnQgfSA9IHJlcXVpcmUoJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcycpO1xuICAgIGNyZWF0ZUNsaWVudC5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2xpc3RSU1ZQcycsICgpID0+IHtcbiAgICBjb25zdCBtb2NrUlNWUERhdGEgPSBbXG4gICAgICB7XG4gICAgICAgIGlkOiAncnN2cC0xJyxcbiAgICAgICAgZ3Vlc3RfaWQ6ICdndWVzdC0xJyxcbiAgICAgICAgZXZlbnRfaWQ6ICdldmVudC0xJyxcbiAgICAgICAgYWN0aXZpdHlfaWQ6IG51bGwsXG4gICAgICAgIHN0YXR1czogJ2F0dGVuZGluZycsXG4gICAgICAgIGd1ZXN0X2NvdW50OiAyLFxuICAgICAgICBkaWV0YXJ5X25vdGVzOiAnVmVnZXRhcmlhbicsXG4gICAgICAgIHNwZWNpYWxfcmVxdWlyZW1lbnRzOiBudWxsLFxuICAgICAgICBub3RlczogbnVsbCxcbiAgICAgICAgcmVzcG9uZGVkX2F0OiAnMjAyNC0wMS0xNVQxMDowMDowMFonLFxuICAgICAgICBjcmVhdGVkX2F0OiAnMjAyNC0wMS0xMFQxMDowMDowMFonLFxuICAgICAgICB1cGRhdGVkX2F0OiAnMjAyNC0wMS0xNVQxMDowMDowMFonLFxuICAgICAgICBndWVzdHM6IHtcbiAgICAgICAgICBmaXJzdF9uYW1lOiAnSm9obicsXG4gICAgICAgICAgbGFzdF9uYW1lOiAnRG9lJyxcbiAgICAgICAgICBlbWFpbDogJ2pvaG5AZXhhbXBsZS5jb20nLFxuICAgICAgICB9LFxuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICBuYW1lOiAnV2VkZGluZyBDZXJlbW9ueScsXG4gICAgICAgIH0sXG4gICAgICAgIGFjdGl2aXRpZXM6IG51bGwsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogJ3JzdnAtMicsXG4gICAgICAgIGd1ZXN0X2lkOiAnZ3Vlc3QtMicsXG4gICAgICAgIGV2ZW50X2lkOiBudWxsLFxuICAgICAgICBhY3Rpdml0eV9pZDogJ2FjdGl2aXR5LTEnLFxuICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgICAgZ3Vlc3RfY291bnQ6IDEsXG4gICAgICAgIGRpZXRhcnlfbm90ZXM6IG51bGwsXG4gICAgICAgIHNwZWNpYWxfcmVxdWlyZW1lbnRzOiBudWxsLFxuICAgICAgICBub3RlczogbnVsbCxcbiAgICAgICAgcmVzcG9uZGVkX2F0OiBudWxsLFxuICAgICAgICBjcmVhdGVkX2F0OiAnMjAyNC0wMS0xMlQxMDowMDowMFonLFxuICAgICAgICB1cGRhdGVkX2F0OiAnMjAyNC0wMS0xMlQxMDowMDowMFonLFxuICAgICAgICBndWVzdHM6IHtcbiAgICAgICAgICBmaXJzdF9uYW1lOiAnSmFuZScsXG4gICAgICAgICAgbGFzdF9uYW1lOiAnU21pdGgnLFxuICAgICAgICAgIGVtYWlsOiAnamFuZUBleGFtcGxlLmNvbScsXG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50czogbnVsbCxcbiAgICAgICAgYWN0aXZpdGllczoge1xuICAgICAgICAgIG5hbWU6ICdCZWFjaCBBY3Rpdml0eScsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIF07XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIHdpdGggUlNWUHMgd2hlbiB2YWxpZCBmaWx0ZXJzIGFuZCBwYWdpbmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayB0aGUgcXVlcnkgY2hhaW4gcHJvcGVybHlcbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnNlbGVjdC5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5lcS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5yYW5nZS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5vcmRlci5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG1vY2tSU1ZQRGF0YSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIGNvdW50OiAyLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIE1vY2sgZ2V0UlNWUFN0YXRpc3RpY3NcbiAgICAgIGplc3Quc3B5T24ocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLCAnZ2V0UlNWUFN0YXRpc3RpY3MnKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB0b3RhbFJTVlBzOiAyLFxuICAgICAgICAgIGJ5U3RhdHVzOiB7IGF0dGVuZGluZzogMSwgZGVjbGluZWQ6IDAsIG1heWJlOiAwLCBwZW5kaW5nOiAxIH0sXG4gICAgICAgICAgdG90YWxHdWVzdENvdW50OiAyLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGZpbHRlcnM6IFJTVlBGaWx0ZXJzID0geyBldmVudElkOiAnZXZlbnQtMScgfTtcbiAgICAgIGNvbnN0IHBhZ2luYXRpb246IFBhZ2luYXRpb25QYXJhbXMgPSB7IHBhZ2U6IDEsIGxpbWl0OiA1MCB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UubGlzdFJTVlBzKGZpbHRlcnMsIHBhZ2luYXRpb24pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmRhdGEpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmRhdGFbMF0uZ3Vlc3RGaXJzdE5hbWUpLnRvQmUoJ0pvaG4nKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmRhdGFbMF0uZXZlbnROYW1lKS50b0JlKCdXZWRkaW5nIENlcmVtb255Jyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5wYWdpbmF0aW9uLnBhZ2UpLnRvQmUoMSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5wYWdpbmF0aW9uLmxpbWl0KS50b0JlKDUwKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnBhZ2luYXRpb24udG90YWwpLnRvQmUoMik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5wYWdpbmF0aW9uLnRvdGFsUGFnZXMpLnRvQmUoMSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGZpbHRlciBieSBldmVudCBJRCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnNlbGVjdC5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5lcS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5yYW5nZS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5vcmRlci5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IFttb2NrUlNWUERhdGFbMF1dLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgY291bnQ6IDEsXG4gICAgICB9KTtcblxuICAgICAgLy8gTW9jayBnZXRSU1ZQU3RhdGlzdGljc1xuICAgICAgamVzdC5zcHlPbihyc3ZwTWFuYWdlbWVudFNlcnZpY2UsICdnZXRSU1ZQU3RhdGlzdGljcycpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHRvdGFsUlNWUHM6IDEsXG4gICAgICAgICAgYnlTdGF0dXM6IHsgYXR0ZW5kaW5nOiAxLCBkZWNsaW5lZDogMCwgbWF5YmU6IDAsIHBlbmRpbmc6IDAgfSxcbiAgICAgICAgICB0b3RhbEd1ZXN0Q291bnQ6IDIsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmxpc3RSU1ZQcyhcbiAgICAgICAgeyBldmVudElkOiAnZXZlbnQtMScgfSxcbiAgICAgICAgeyBwYWdlOiAxLCBsaW1pdDogNTAgfVxuICAgICAgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5kYXRhKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5kYXRhWzBdLmV2ZW50SWQpLnRvQmUoJ2V2ZW50LTEnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGVxIHdhcyBjYWxsZWQgd2l0aCBldmVudF9pZFxuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZS5lcSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2V2ZW50X2lkJywgJ2V2ZW50LTEnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZmlsdGVyIGJ5IGFjdGl2aXR5IElEJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLmVxLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnJhbmdlLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLm9yZGVyLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogW21vY2tSU1ZQRGF0YVsxXV0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICBjb3VudDogMSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrIGdldFJTVlBTdGF0aXN0aWNzXG4gICAgICBqZXN0LnNweU9uKHJzdnBNYW5hZ2VtZW50U2VydmljZSwgJ2dldFJTVlBTdGF0aXN0aWNzJykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdG90YWxSU1ZQczogMSxcbiAgICAgICAgICBieVN0YXR1czogeyBhdHRlbmRpbmc6IDAsIGRlY2xpbmVkOiAwLCBtYXliZTogMCwgcGVuZGluZzogMSB9LFxuICAgICAgICAgIHRvdGFsR3Vlc3RDb3VudDogMCxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UubGlzdFJTVlBzKFxuICAgICAgICB7IGFjdGl2aXR5SWQ6ICdhY3Rpdml0eS0xJyB9LFxuICAgICAgICB7IHBhZ2U6IDEsIGxpbWl0OiA1MCB9XG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmRhdGEpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmRhdGFbMF0uYWN0aXZpdHlJZCkudG9CZSgnYWN0aXZpdHktMScpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBWZXJpZnkgZXEgd2FzIGNhbGxlZCB3aXRoIGFjdGl2aXR5X2lkXG4gICAgICBleHBlY3QobW9ja1N1cGFiYXNlLmVxKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnYWN0aXZpdHlfaWQnLCAnYWN0aXZpdHktMScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBmaWx0ZXIgYnkgc3RhdHVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLmVxLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnJhbmdlLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLm9yZGVyLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogW21vY2tSU1ZQRGF0YVswXV0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICBjb3VudDogMSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrIGdldFJTVlBTdGF0aXN0aWNzXG4gICAgICBqZXN0LnNweU9uKHJzdnBNYW5hZ2VtZW50U2VydmljZSwgJ2dldFJTVlBTdGF0aXN0aWNzJykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdG90YWxSU1ZQczogMSxcbiAgICAgICAgICBieVN0YXR1czogeyBhdHRlbmRpbmc6IDEsIGRlY2xpbmVkOiAwLCBtYXliZTogMCwgcGVuZGluZzogMCB9LFxuICAgICAgICAgIHRvdGFsR3Vlc3RDb3VudDogMixcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UubGlzdFJTVlBzKFxuICAgICAgICB7IHN0YXR1czogJ2F0dGVuZGluZycgfSxcbiAgICAgICAgeyBwYWdlOiAxLCBsaW1pdDogNTAgfVxuICAgICAgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5kYXRhKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5kYXRhWzBdLnN0YXR1cykudG9CZSgnYXR0ZW5kaW5nJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBlcSB3YXMgY2FsbGVkIHdpdGggc3RhdHVzXG4gICAgICBleHBlY3QobW9ja1N1cGFiYXNlLmVxKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnc3RhdHVzJywgJ2F0dGVuZGluZycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBmaWx0ZXIgYnkgZ3Vlc3QgSUQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5zZWxlY3QubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2UuZXEubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2UucmFuZ2UubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uub3JkZXIubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBbbW9ja1JTVlBEYXRhWzBdXSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIGNvdW50OiAxLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIE1vY2sgZ2V0UlNWUFN0YXRpc3RpY3NcbiAgICAgIGplc3Quc3B5T24ocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLCAnZ2V0UlNWUFN0YXRpc3RpY3MnKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB0b3RhbFJTVlBzOiAxLFxuICAgICAgICAgIGJ5U3RhdHVzOiB7IGF0dGVuZGluZzogMSwgZGVjbGluZWQ6IDAsIG1heWJlOiAwLCBwZW5kaW5nOiAwIH0sXG4gICAgICAgICAgdG90YWxHdWVzdENvdW50OiAyLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5saXN0UlNWUHMoXG4gICAgICAgIHsgZ3Vlc3RJZDogJ2d1ZXN0LTEnIH0sXG4gICAgICAgIHsgcGFnZTogMSwgbGltaXQ6IDUwIH1cbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuZGF0YSkudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuZGF0YVswXS5ndWVzdElkKS50b0JlKCdndWVzdC0xJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBlcSB3YXMgY2FsbGVkIHdpdGggZ3Vlc3RfaWRcbiAgICAgIGV4cGVjdChtb2NrU3VwYWJhc2UuZXEpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdndWVzdF9pZCcsICdndWVzdC0xJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGFwcGx5IHBhZ2luYXRpb24gY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnJhbmdlLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLm9yZGVyLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbW9ja1JTVlBEYXRhLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgY291bnQ6IDEwMCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrIGdldFJTVlBTdGF0aXN0aWNzXG4gICAgICBqZXN0LnNweU9uKHJzdnBNYW5hZ2VtZW50U2VydmljZSwgJ2dldFJTVlBTdGF0aXN0aWNzJykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdG90YWxSU1ZQczogMTAwLFxuICAgICAgICAgIGJ5U3RhdHVzOiB7IGF0dGVuZGluZzogNTAsIGRlY2xpbmVkOiAyNSwgbWF5YmU6IDE1LCBwZW5kaW5nOiAxMCB9LFxuICAgICAgICAgIHRvdGFsR3Vlc3RDb3VudDogNTAsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmxpc3RSU1ZQcyhcbiAgICAgICAge30sXG4gICAgICAgIHsgcGFnZTogMiwgbGltaXQ6IDI1IH1cbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEucGFnaW5hdGlvbi5wYWdlKS50b0JlKDIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEucGFnaW5hdGlvbi5saW1pdCkudG9CZSgyNSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5wYWdpbmF0aW9uLnRvdGFsKS50b0JlKDEwMCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5wYWdpbmF0aW9uLnRvdGFsUGFnZXMpLnRvQmUoNCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSByYW5nZSB3YXMgY2FsbGVkIHdpdGggY29ycmVjdCB2YWx1ZXMgKHBhZ2UgMiwgbGltaXQgMjUgPSBmcm9tIDI1IHRvIDQ5KVxuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZS5yYW5nZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoMjUsIDQ5KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIFZBTElEQVRJT05fRVJST1Igd2hlbiBpbnZhbGlkIGZpbHRlciBwYXJhbWV0ZXJzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmxpc3RSU1ZQcyhcbiAgICAgICAgeyBldmVudElkOiAnaW52YWxpZC11dWlkJyB9IGFzIGFueSxcbiAgICAgICAgeyBwYWdlOiAxLCBsaW1pdDogNTAgfVxuICAgICAgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdWQUxJREFUSU9OX0VSUk9SJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBWQUxJREFUSU9OX0VSUk9SIHdoZW4gaW52YWxpZCBwYWdpbmF0aW9uIHBhcmFtZXRlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UubGlzdFJTVlBzKFxuICAgICAgICB7fSxcbiAgICAgICAgeyBwYWdlOiAtMSwgbGltaXQ6IDUwIH0gYXMgYW55XG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ1ZBTElEQVRJT05fRVJST1InKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIERBVEFCQVNFX0VSUk9SIHdoZW4gZGF0YWJhc2UgcXVlcnkgZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5zZWxlY3QubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2UucmFuZ2UubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uub3JkZXIubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnIH0sXG4gICAgICAgIGNvdW50OiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5saXN0UlNWUHMoe30sIHsgcGFnZTogMSwgbGltaXQ6IDUwIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ0RBVEFCQVNFX0VSUk9SJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9CZSgnRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYXBwbHkgbXVsdGlwbGUgZmlsdGVycyB0b2dldGhlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnNlbGVjdC5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5lcS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5yYW5nZS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5vcmRlci5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IFttb2NrUlNWUERhdGFbMF1dLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgY291bnQ6IDEsXG4gICAgICB9KTtcblxuICAgICAgLy8gTW9jayBnZXRSU1ZQU3RhdGlzdGljc1xuICAgICAgamVzdC5zcHlPbihyc3ZwTWFuYWdlbWVudFNlcnZpY2UsICdnZXRSU1ZQU3RhdGlzdGljcycpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHRvdGFsUlNWUHM6IDEsXG4gICAgICAgICAgYnlTdGF0dXM6IHsgYXR0ZW5kaW5nOiAxLCBkZWNsaW5lZDogMCwgbWF5YmU6IDAsIHBlbmRpbmc6IDAgfSxcbiAgICAgICAgICB0b3RhbEd1ZXN0Q291bnQ6IDIsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmxpc3RSU1ZQcyhcbiAgICAgICAgeyBldmVudElkOiAnZXZlbnQtMScsIHN0YXR1czogJ2F0dGVuZGluZycsIGd1ZXN0SWQ6ICdndWVzdC0xJyB9LFxuICAgICAgICB7IHBhZ2U6IDEsIGxpbWl0OiA1MCB9XG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBhbGwgZmlsdGVycyB3ZXJlIGFwcGxpZWRcbiAgICAgIGV4cGVjdChtb2NrU3VwYWJhc2UuZXEpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdldmVudF9pZCcsICdldmVudC0xJyk7XG4gICAgICBleHBlY3QobW9ja1N1cGFiYXNlLmVxKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnc3RhdHVzJywgJ2F0dGVuZGluZycpO1xuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZS5lcSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2d1ZXN0X2lkJywgJ2d1ZXN0LTEnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHNlYXJjaCBxdWVyeSBmaWx0ZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5zZWxlY3QubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uub3IubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2UucmFuZ2UubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uub3JkZXIubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBbbW9ja1JTVlBEYXRhWzBdXSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIGNvdW50OiAxLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIE1vY2sgZ2V0UlNWUFN0YXRpc3RpY3NcbiAgICAgIGplc3Quc3B5T24ocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLCAnZ2V0UlNWUFN0YXRpc3RpY3MnKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB0b3RhbFJTVlBzOiAxLFxuICAgICAgICAgIGJ5U3RhdHVzOiB7IGF0dGVuZGluZzogMSwgZGVjbGluZWQ6IDAsIG1heWJlOiAwLCBwZW5kaW5nOiAwIH0sXG4gICAgICAgICAgdG90YWxHdWVzdENvdW50OiAyLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5saXN0UlNWUHMoXG4gICAgICAgIHsgc2VhcmNoUXVlcnk6ICdKb2huJyB9LFxuICAgICAgICB7IHBhZ2U6IDEsIGxpbWl0OiA1MCB9XG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBvciB3YXMgY2FsbGVkIGZvciBzZWFyY2hcbiAgICAgIGV4cGVjdChtb2NrU3VwYWJhc2Uub3IpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGVmYXVsdCB0byBwYWdlIDEgYW5kIGxpbWl0IDUwIHdoZW4gbm90IHNwZWNpZmllZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnNlbGVjdC5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5yYW5nZS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5vcmRlci5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG1vY2tSU1ZQRGF0YSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIGNvdW50OiAyLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIE1vY2sgZ2V0UlNWUFN0YXRpc3RpY3NcbiAgICAgIGplc3Quc3B5T24ocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLCAnZ2V0UlNWUFN0YXRpc3RpY3MnKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB0b3RhbFJTVlBzOiAyLFxuICAgICAgICAgIGJ5U3RhdHVzOiB7IGF0dGVuZGluZzogMSwgZGVjbGluZWQ6IDAsIG1heWJlOiAwLCBwZW5kaW5nOiAxIH0sXG4gICAgICAgICAgdG90YWxHdWVzdENvdW50OiAyLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5saXN0UlNWUHMoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5wYWdpbmF0aW9uLnBhZ2UpLnRvQmUoMSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5wYWdpbmF0aW9uLmxpbWl0KS50b0JlKDUwKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IHJhbmdlIHdhcyBjYWxsZWQgd2l0aCBkZWZhdWx0IHZhbHVlcyAocGFnZSAxLCBsaW1pdCA1MCA9IGZyb20gMCB0byA0OSlcbiAgICAgIGV4cGVjdChtb2NrU3VwYWJhc2UucmFuZ2UpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDAsIDQ5KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldFJTVlBTdGF0aXN0aWNzJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tTdGF0aXN0aWNzRGF0YSA9IFtcbiAgICAgIHsgc3RhdHVzOiAnYXR0ZW5kaW5nJywgZ3Vlc3RfY291bnQ6IDIgfSxcbiAgICAgIHsgc3RhdHVzOiAnYXR0ZW5kaW5nJywgZ3Vlc3RfY291bnQ6IDEgfSxcbiAgICAgIHsgc3RhdHVzOiAnZGVjbGluZWQnLCBndWVzdF9jb3VudDogMSB9LFxuICAgICAgeyBzdGF0dXM6ICdtYXliZScsIGd1ZXN0X2NvdW50OiBudWxsIH0sXG4gICAgICB7IHN0YXR1czogJ3BlbmRpbmcnLCBndWVzdF9jb3VudDogMSB9LFxuICAgIF07XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIHdpdGggYWNjdXJhdGUgc3RhdGlzdGljcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnNlbGVjdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG1vY2tTdGF0aXN0aWNzRGF0YSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmdldFJTVlBTdGF0aXN0aWNzKHt9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS50b3RhbFJTVlBzKS50b0JlKDUpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuYnlTdGF0dXMuYXR0ZW5kaW5nKS50b0JlKDIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuYnlTdGF0dXMuZGVjbGluZWQpLnRvQmUoMSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5ieVN0YXR1cy5tYXliZSkudG9CZSgxKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmJ5U3RhdHVzLnBlbmRpbmcpLnRvQmUoMSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS50b3RhbEd1ZXN0Q291bnQpLnRvQmUoMyk7IC8vIDIgKyAxIGZyb20gYXR0ZW5kaW5nXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGZpbHRlciBzdGF0aXN0aWNzIGJ5IGV2ZW50IElEJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLmVxLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogW21vY2tTdGF0aXN0aWNzRGF0YVswXSwgbW9ja1N0YXRpc3RpY3NEYXRhWzFdXSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmdldFJTVlBTdGF0aXN0aWNzKHtcbiAgICAgICAgZXZlbnRJZDogJ2V2ZW50LTEnLFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudG90YWxSU1ZQcykudG9CZSgyKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmJ5U3RhdHVzLmF0dGVuZGluZykudG9CZSgyKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGVxIHdhcyBjYWxsZWQgd2l0aCBldmVudF9pZFxuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZS5lcSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2V2ZW50X2lkJywgJ2V2ZW50LTEnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVtcHR5IHJlc3VsdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5zZWxlY3QubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmdldFJTVlBTdGF0aXN0aWNzKHt9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS50b3RhbFJTVlBzKS50b0JlKDApO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuYnlTdGF0dXMuYXR0ZW5kaW5nKS50b0JlKDApO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudG90YWxHdWVzdENvdW50KS50b0JlKDApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gVkFMSURBVElPTl9FUlJPUiB3aGVuIGludmFsaWQgZmlsdGVyIHBhcmFtZXRlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UuZ2V0UlNWUFN0YXRpc3RpY3Moe1xuICAgICAgICBldmVudElkOiAnaW52YWxpZC11dWlkJyxcbiAgICAgIH0gYXMgYW55KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdWQUxJREFUSU9OX0VSUk9SJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBEQVRBQkFTRV9FUlJPUiB3aGVuIGRhdGFiYXNlIHF1ZXJ5IGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJyB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5nZXRSU1ZQU3RhdGlzdGljcyh7fSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnREFUQUJBU0VfRVJST1InKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0JlKCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBmaWx0ZXIgc3RhdGlzdGljcyBieSBtdWx0aXBsZSBjcml0ZXJpYScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnNlbGVjdC5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5lcS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IFttb2NrU3RhdGlzdGljc0RhdGFbMF1dLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UuZ2V0UlNWUFN0YXRpc3RpY3Moe1xuICAgICAgICBldmVudElkOiAnZXZlbnQtMScsXG4gICAgICAgIHN0YXR1czogJ2F0dGVuZGluZycsXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgYm90aCBmaWx0ZXJzIHdlcmUgYXBwbGllZFxuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZS5lcSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2V2ZW50X2lkJywgJ2V2ZW50LTEnKTtcbiAgICAgIGV4cGVjdChtb2NrU3VwYWJhc2UuZXEpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdzdGF0dXMnLCAnYXR0ZW5kaW5nJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRlZmF1bHQgZ3Vlc3RfY291bnQgdG8gMSB3aGVuIG51bGwgZm9yIGF0dGVuZGluZyBSU1ZQcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnNlbGVjdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IFtcbiAgICAgICAgICB7IHN0YXR1czogJ2F0dGVuZGluZycsIGd1ZXN0X2NvdW50OiBudWxsIH0sXG4gICAgICAgICAgeyBzdGF0dXM6ICdhdHRlbmRpbmcnLCBndWVzdF9jb3VudDogMiB9LFxuICAgICAgICBdLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UuZ2V0UlNWUFN0YXRpc3RpY3Moe30pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnRvdGFsR3Vlc3RDb3VudCkudG9CZSgzKTsgLy8gMSAoZGVmYXVsdCkgKyAyXG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdidWxrVXBkYXRlUlNWUHMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2VzcyB3aXRoIHVwZGF0ZWQgY291bnQgd2hlbiB2YWxpZCBpbnB1dCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJzdnBJZHMgPSBbJ3JzdnAtMScsICdyc3ZwLTInLCAncnN2cC0zJ107XG4gICAgICBcbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnVwZGF0ZS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5pbi5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5zZWxlY3QubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBbeyBpZDogJ3JzdnAtMScgfSwgeyBpZDogJ3JzdnAtMicgfSwgeyBpZDogJ3JzdnAtMycgfV0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5idWxrVXBkYXRlUlNWUHMoXG4gICAgICAgIHJzdnBJZHMsXG4gICAgICAgICdhdHRlbmRpbmcnLFxuICAgICAgICAnQnVsayBhcHByb3ZlZCdcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudXBkYXRlZENvdW50KS50b0JlKDMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBWZXJpZnkgdXBkYXRlIHdhcyBjYWxsZWQgd2l0aCBjb3JyZWN0IGRhdGFcbiAgICAgIGV4cGVjdChtb2NrU3VwYWJhc2UudXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHN0YXR1czogJ2F0dGVuZGluZycsXG4gICAgICAgICAgbm90ZXM6ICdCdWxrIGFwcHJvdmVkJyxcbiAgICAgICAgICByZXNwb25kZWRfYXQ6IGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgICB1cGRhdGVkX2F0OiBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgaW4gd2FzIGNhbGxlZCB3aXRoIGNvcnJlY3QgSURzXG4gICAgICBleHBlY3QobW9ja1N1cGFiYXNlLmluKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnaWQnLCByc3ZwSWRzKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdXBkYXRlIHN0YXR1cyBhbmQgc2V0IHJlc3BvbmRlZF9hdCBmb3Igbm9uLXBlbmRpbmcgc3RhdHVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2UudXBkYXRlLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLmluLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnNlbGVjdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IFt7IGlkOiAncnN2cC0xJyB9XSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmJ1bGtVcGRhdGVSU1ZQcyhbJ3JzdnAtMSddLCAnYXR0ZW5kaW5nJyk7XG5cbiAgICAgIGV4cGVjdChtb2NrU3VwYWJhc2UudXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHN0YXR1czogJ2F0dGVuZGluZycsXG4gICAgICAgICAgcmVzcG9uZGVkX2F0OiBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBpbmNsdWRlIG5vdGVzIHdoZW4gcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS51cGRhdGUubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2UuaW4ubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogW3sgaWQ6ICdyc3ZwLTEnIH1dLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UuYnVsa1VwZGF0ZVJTVlBzKFxuICAgICAgICBbJ3JzdnAtMSddLFxuICAgICAgICAnYXR0ZW5kaW5nJyxcbiAgICAgICAgJ0FkbWluIGFwcHJvdmVkJ1xuICAgICAgKTtcblxuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZS51cGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgbm90ZXM6ICdBZG1pbiBhcHByb3ZlZCcsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcGFydGlhbCB1cGRhdGVzIHdoZW4gc29tZSBSU1ZQcyBub3QgZm91bmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS51cGRhdGUubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2UuaW4ubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogW3sgaWQ6ICdyc3ZwLTEnIH0sIHsgaWQ6ICdyc3ZwLTInIH1dLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UuYnVsa1VwZGF0ZVJTVlBzKFxuICAgICAgICBbJ3JzdnAtMScsICdyc3ZwLTInLCAncnN2cC0zJ10sXG4gICAgICAgICdhdHRlbmRpbmcnXG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnVwZGF0ZWRDb3VudCkudG9CZSgyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIFZBTElEQVRJT05fRVJST1Igd2hlbiBlbXB0eSByc3ZwSWRzIGFycmF5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmJ1bGtVcGRhdGVSU1ZQcyhcbiAgICAgICAgW10sXG4gICAgICAgICdhdHRlbmRpbmcnXG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ1ZBTElEQVRJT05fRVJST1InKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIFZBTElEQVRJT05fRVJST1Igd2hlbiB0b28gbWFueSByc3ZwSWRzICg+MTAwKScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRvb01hbnlJZHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDEgfSwgKF8sIGkpID0+IGByc3ZwLSR7aX1gKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmJ1bGtVcGRhdGVSU1ZQcyhcbiAgICAgICAgdG9vTWFueUlkcyxcbiAgICAgICAgJ2F0dGVuZGluZydcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnVkFMSURBVElPTl9FUlJPUicpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gVkFMSURBVElPTl9FUlJPUiB3aGVuIGludmFsaWQgc3RhdHVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmJ1bGtVcGRhdGVSU1ZQcyhcbiAgICAgICAgWydyc3ZwLTEnXSxcbiAgICAgICAgJ2ludmFsaWQtc3RhdHVzJyBhcyBhbnlcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnVkFMSURBVElPTl9FUlJPUicpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gREFUQUJBU0VfRVJST1Igd2hlbiBkYXRhYmFzZSB1cGRhdGUgZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS51cGRhdGUubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2UuaW4ubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJyB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5idWxrVXBkYXRlUlNWUHMoXG4gICAgICAgIFsncnN2cC0xJ10sXG4gICAgICAgICdhdHRlbmRpbmcnXG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ0RBVEFCQVNFX0VSUk9SJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9CZSgnRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbm90IHNldCByZXNwb25kZWRfYXQgd2hlbiBzdGF0dXMgaXMgcGVuZGluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xuICAgICAgbW9ja1N1cGFiYXNlLnVwZGF0ZS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5pbi5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgIG1vY2tTdXBhYmFzZS5zZWxlY3QubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBbeyBpZDogJ3JzdnAtMScgfV0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5idWxrVXBkYXRlUlNWUHMoWydyc3ZwLTEnXSwgJ3BlbmRpbmcnKTtcblxuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZS51cGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgc3RhdHVzOiAncGVuZGluZycsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgcmVzcG9uZGVkX2F0IGlzIE5PVCBpbiB0aGUgdXBkYXRlIGRhdGFcbiAgICAgIGNvbnN0IHVwZGF0ZUNhbGwgPSBtb2NrU3VwYWJhc2UudXBkYXRlLm1vY2suY2FsbHNbMF1bMF07XG4gICAgICBleHBlY3QodXBkYXRlQ2FsbC5yZXNwb25kZWRfYXQpLnRvQmVVbmRlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGFsbCB2YWxpZCBzdGF0dXMgdmFsdWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdHVzZXM6IEFycmF5PCdwZW5kaW5nJyB8ICdhdHRlbmRpbmcnIHwgJ2RlY2xpbmVkJyB8ICdtYXliZSc+ID0gW1xuICAgICAgICAncGVuZGluZycsXG4gICAgICAgICdhdHRlbmRpbmcnLFxuICAgICAgICAnZGVjbGluZWQnLFxuICAgICAgICAnbWF5YmUnLFxuICAgICAgXTtcblxuICAgICAgZm9yIChjb25zdCBzdGF0dXMgb2Ygc3RhdHVzZXMpIHtcbiAgICAgICAgcmVzZXRNb2NrU3VwYWJhc2VDbGllbnQobW9ja1N1cGFiYXNlKTtcbiAgICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICAgIG1vY2tTdXBhYmFzZS51cGRhdGUubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG4gICAgICAgIG1vY2tTdXBhYmFzZS5pbi5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcbiAgICAgICAgbW9ja1N1cGFiYXNlLnNlbGVjdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgZGF0YTogW3sgaWQ6ICdyc3ZwLTEnIH1dLFxuICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UuYnVsa1VwZGF0ZVJTVlBzKFsncnN2cC0xJ10sIHN0YXR1cyk7XG5cbiAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QobW9ja1N1cGFiYXNlLnVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdleHBvcnRSU1ZQc1RvQ1NWJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3Mgd2l0aCBDU1Ygc3RyaW5nIHdoZW4gdmFsaWQgZmlsdGVycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tSU1ZQcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAncnN2cC0xJyxcbiAgICAgICAgICBndWVzdEZpcnN0TmFtZTogJ0pvaG4nLFxuICAgICAgICAgIGd1ZXN0TGFzdE5hbWU6ICdEb2UnLFxuICAgICAgICAgIGd1ZXN0RW1haWw6ICdqb2huQGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBldmVudE5hbWU6ICdXZWRkaW5nIENlcmVtb255JyxcbiAgICAgICAgICBhY3Rpdml0eU5hbWU6IG51bGwsXG4gICAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyBhcyBjb25zdCxcbiAgICAgICAgICBndWVzdENvdW50OiAyLFxuICAgICAgICAgIGRpZXRhcnlOb3RlczogJ1ZlZ2V0YXJpYW4nLFxuICAgICAgICAgIHNwZWNpYWxSZXF1aXJlbWVudHM6IG51bGwsXG4gICAgICAgICAgbm90ZXM6IG51bGwsXG4gICAgICAgICAgcmVzcG9uZGVkQXQ6ICcyMDI0LTAxLTE1VDEwOjAwOjAwWicsXG4gICAgICAgICAgY3JlYXRlZEF0OiAnMjAyNC0wMS0xMFQxMDowMDowMFonLFxuICAgICAgICAgIHVwZGF0ZWRBdDogJzIwMjQtMDEtMTVUMTA6MDA6MDBaJyxcbiAgICAgICAgICBndWVzdElkOiAnZ3Vlc3QtMScsXG4gICAgICAgICAgZXZlbnRJZDogJ2V2ZW50LTEnLFxuICAgICAgICAgIGFjdGl2aXR5SWQ6IG51bGwsXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICAvLyBNb2NrIGxpc3RSU1ZQcyB0byByZXR1cm4gdGVzdCBkYXRhXG4gICAgICBqZXN0LnNweU9uKHJzdnBNYW5hZ2VtZW50U2VydmljZSwgJ2xpc3RSU1ZQcycpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGRhdGE6IG1vY2tSU1ZQcyxcbiAgICAgICAgICBwYWdpbmF0aW9uOiB7IHBhZ2U6IDEsIGxpbWl0OiAxMDAwMCwgdG90YWw6IDEsIHRvdGFsUGFnZXM6IDEgfSxcbiAgICAgICAgICBzdGF0aXN0aWNzOiB7XG4gICAgICAgICAgICB0b3RhbFJTVlBzOiAxLFxuICAgICAgICAgICAgYnlTdGF0dXM6IHsgYXR0ZW5kaW5nOiAxLCBkZWNsaW5lZDogMCwgbWF5YmU6IDAsIHBlbmRpbmc6IDAgfSxcbiAgICAgICAgICAgIHRvdGFsR3Vlc3RDb3VudDogMixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5leHBvcnRSU1ZQc1RvQ1NWKHt9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YSkudG9Db250YWluKCdSU1ZQIElELEd1ZXN0IEZpcnN0IE5hbWUsR3Vlc3QgTGFzdCBOYW1lJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YSkudG9Db250YWluKCdyc3ZwLTEsSm9obixEb2UnKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhKS50b0NvbnRhaW4oJ1dlZGRpbmcgQ2VyZW1vbnknKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhKS50b0NvbnRhaW4oJ2F0dGVuZGluZycpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEpLnRvQ29udGFpbignVmVnZXRhcmlhbicpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBWZXJpZnkgbGlzdFJTVlBzIHdhcyBjYWxsZWQgd2l0aCBjb3JyZWN0IHBhcmFtZXRlcnNcbiAgICAgIGV4cGVjdChyc3ZwTWFuYWdlbWVudFNlcnZpY2UubGlzdFJTVlBzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7fSwgeyBwYWdlOiAxLCBsaW1pdDogMTAwMDAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGVzY2FwZSBDU1YgdmFsdWVzIHdpdGggY29tbWFzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1JTVlBzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdyc3ZwLTEnLFxuICAgICAgICAgIGd1ZXN0Rmlyc3ROYW1lOiAnSm9obicsXG4gICAgICAgICAgZ3Vlc3RMYXN0TmFtZTogJ0RvZSwgSnIuJyxcbiAgICAgICAgICBndWVzdEVtYWlsOiAnam9obkBleGFtcGxlLmNvbScsXG4gICAgICAgICAgZXZlbnROYW1lOiAnV2VkZGluZyBDZXJlbW9ueScsXG4gICAgICAgICAgYWN0aXZpdHlOYW1lOiBudWxsLFxuICAgICAgICAgIHN0YXR1czogJ2F0dGVuZGluZycgYXMgY29uc3QsXG4gICAgICAgICAgZ3Vlc3RDb3VudDogMSxcbiAgICAgICAgICBkaWV0YXJ5Tm90ZXM6ICdObyBudXRzLCBubyBkYWlyeScsXG4gICAgICAgICAgc3BlY2lhbFJlcXVpcmVtZW50czogbnVsbCxcbiAgICAgICAgICBub3RlczogbnVsbCxcbiAgICAgICAgICByZXNwb25kZWRBdDogJzIwMjQtMDEtMTVUMTA6MDA6MDBaJyxcbiAgICAgICAgICBjcmVhdGVkQXQ6ICcyMDI0LTAxLTEwVDEwOjAwOjAwWicsXG4gICAgICAgICAgdXBkYXRlZEF0OiAnMjAyNC0wMS0xNVQxMDowMDowMFonLFxuICAgICAgICAgIGd1ZXN0SWQ6ICdndWVzdC0xJyxcbiAgICAgICAgICBldmVudElkOiAnZXZlbnQtMScsXG4gICAgICAgICAgYWN0aXZpdHlJZDogbnVsbCxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIGplc3Quc3B5T24ocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLCAnbGlzdFJTVlBzJykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZGF0YTogbW9ja1JTVlBzLFxuICAgICAgICAgIHBhZ2luYXRpb246IHsgcGFnZTogMSwgbGltaXQ6IDEwMDAwLCB0b3RhbDogMSwgdG90YWxQYWdlczogMSB9LFxuICAgICAgICAgIHN0YXRpc3RpY3M6IHtcbiAgICAgICAgICAgIHRvdGFsUlNWUHM6IDEsXG4gICAgICAgICAgICBieVN0YXR1czogeyBhdHRlbmRpbmc6IDEsIGRlY2xpbmVkOiAwLCBtYXliZTogMCwgcGVuZGluZzogMCB9LFxuICAgICAgICAgICAgdG90YWxHdWVzdENvdW50OiAxLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmV4cG9ydFJTVlBzVG9DU1Yoe30pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhKS50b0NvbnRhaW4oJ1wiRG9lLCBKci5cIicpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEpLnRvQ29udGFpbignXCJObyBudXRzLCBubyBkYWlyeVwiJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGVzY2FwZSBDU1YgdmFsdWVzIHdpdGggcXVvdGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1JTVlBzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdyc3ZwLTEnLFxuICAgICAgICAgIGd1ZXN0Rmlyc3ROYW1lOiAnSm9obicsXG4gICAgICAgICAgZ3Vlc3RMYXN0TmFtZTogJ0RvZScsXG4gICAgICAgICAgZ3Vlc3RFbWFpbDogJ2pvaG5AZXhhbXBsZS5jb20nLFxuICAgICAgICAgIGV2ZW50TmFtZTogJ1dlZGRpbmcgQ2VyZW1vbnknLFxuICAgICAgICAgIGFjdGl2aXR5TmFtZTogbnVsbCxcbiAgICAgICAgICBzdGF0dXM6ICdhdHRlbmRpbmcnIGFzIGNvbnN0LFxuICAgICAgICAgIGd1ZXN0Q291bnQ6IDEsXG4gICAgICAgICAgZGlldGFyeU5vdGVzOiBudWxsLFxuICAgICAgICAgIHNwZWNpYWxSZXF1aXJlbWVudHM6IG51bGwsXG4gICAgICAgICAgbm90ZXM6ICdHdWVzdCBzYWlkIFwiZXhjaXRlZCB0byBhdHRlbmRcIicsXG4gICAgICAgICAgcmVzcG9uZGVkQXQ6ICcyMDI0LTAxLTE1VDEwOjAwOjAwWicsXG4gICAgICAgICAgY3JlYXRlZEF0OiAnMjAyNC0wMS0xMFQxMDowMDowMFonLFxuICAgICAgICAgIHVwZGF0ZWRBdDogJzIwMjQtMDEtMTVUMTA6MDA6MDBaJyxcbiAgICAgICAgICBndWVzdElkOiAnZ3Vlc3QtMScsXG4gICAgICAgICAgZXZlbnRJZDogJ2V2ZW50LTEnLFxuICAgICAgICAgIGFjdGl2aXR5SWQ6IG51bGwsXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICBqZXN0LnNweU9uKHJzdnBNYW5hZ2VtZW50U2VydmljZSwgJ2xpc3RSU1ZQcycpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGRhdGE6IG1vY2tSU1ZQcyxcbiAgICAgICAgICBwYWdpbmF0aW9uOiB7IHBhZ2U6IDEsIGxpbWl0OiAxMDAwMCwgdG90YWw6IDEsIHRvdGFsUGFnZXM6IDEgfSxcbiAgICAgICAgICBzdGF0aXN0aWNzOiB7XG4gICAgICAgICAgICB0b3RhbFJTVlBzOiAxLFxuICAgICAgICAgICAgYnlTdGF0dXM6IHsgYXR0ZW5kaW5nOiAxLCBkZWNsaW5lZDogMCwgbWF5YmU6IDAsIHBlbmRpbmc6IDAgfSxcbiAgICAgICAgICAgIHRvdGFsR3Vlc3RDb3VudDogMSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5leHBvcnRSU1ZQc1RvQ1NWKHt9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YSkudG9Db250YWluKCdcIlwiZXhjaXRlZCB0byBhdHRlbmRcIlwiJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlbXB0eSByZXN1bHRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgamVzdC5zcHlPbihyc3ZwTWFuYWdlbWVudFNlcnZpY2UsICdsaXN0UlNWUHMnKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICBwYWdpbmF0aW9uOiB7IHBhZ2U6IDEsIGxpbWl0OiAxMDAwMCwgdG90YWw6IDAsIHRvdGFsUGFnZXM6IDAgfSxcbiAgICAgICAgICBzdGF0aXN0aWNzOiB7XG4gICAgICAgICAgICB0b3RhbFJTVlBzOiAwLFxuICAgICAgICAgICAgYnlTdGF0dXM6IHsgYXR0ZW5kaW5nOiAwLCBkZWNsaW5lZDogMCwgbWF5YmU6IDAsIHBlbmRpbmc6IDAgfSxcbiAgICAgICAgICAgIHRvdGFsR3Vlc3RDb3VudDogMCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5leHBvcnRSU1ZQc1RvQ1NWKHt9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIC8vIFNob3VsZCBvbmx5IGhhdmUgaGVhZGVyIHJvd1xuICAgICAgICBjb25zdCBsaW5lcyA9IHJlc3VsdC5kYXRhLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgZXhwZWN0KGxpbmVzLmxlbmd0aCkudG9CZSgxKTtcbiAgICAgICAgZXhwZWN0KGxpbmVzWzBdKS50b0NvbnRhaW4oJ1JTVlAgSUQsR3Vlc3QgRmlyc3QgTmFtZScpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gVkFMSURBVElPTl9FUlJPUiB3aGVuIGludmFsaWQgZmlsdGVyIHBhcmFtZXRlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UuZXhwb3J0UlNWUHNUb0NTVih7XG4gICAgICAgIGV2ZW50SWQ6ICdpbnZhbGlkLXV1aWQnLFxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ1ZBTElEQVRJT05fRVJST1InKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcHJvcGFnYXRlIGVycm9ycyBmcm9tIGxpc3RSU1ZQcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGplc3Quc3B5T24ocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLCAnbGlzdFJTVlBzJykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICBjb2RlOiAnREFUQUJBU0VfRVJST1InLFxuICAgICAgICAgIG1lc3NhZ2U6ICdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmV4cG9ydFJTVlBzVG9DU1Yoe30pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ0RBVEFCQVNFX0VSUk9SJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9CZSgnRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYXBwbHkgZmlsdGVycyB3aGVuIGV4cG9ydGluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGplc3Quc3B5T24ocnN2cE1hbmFnZW1lbnRTZXJ2aWNlLCAnbGlzdFJTVlBzJykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgcGFnaW5hdGlvbjogeyBwYWdlOiAxLCBsaW1pdDogMTAwMDAsIHRvdGFsOiAwLCB0b3RhbFBhZ2VzOiAwIH0sXG4gICAgICAgICAgc3RhdGlzdGljczoge1xuICAgICAgICAgICAgdG90YWxSU1ZQczogMCxcbiAgICAgICAgICAgIGJ5U3RhdHVzOiB7IGF0dGVuZGluZzogMCwgZGVjbGluZWQ6IDAsIG1heWJlOiAwLCBwZW5kaW5nOiAwIH0sXG4gICAgICAgICAgICB0b3RhbEd1ZXN0Q291bnQ6IDAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBmaWx0ZXJzOiBSU1ZQRmlsdGVycyA9IHsgZXZlbnRJZDogJ2V2ZW50LTEnLCBzdGF0dXM6ICdhdHRlbmRpbmcnIH07XG4gICAgICBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UuZXhwb3J0UlNWUHNUb0NTVihmaWx0ZXJzKTtcblxuICAgICAgLy8gVmVyaWZ5IGxpc3RSU1ZQcyB3YXMgY2FsbGVkIHdpdGggdGhlIGZpbHRlcnNcbiAgICAgIGV4cGVjdChyc3ZwTWFuYWdlbWVudFNlcnZpY2UubGlzdFJTVlBzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChmaWx0ZXJzLCB7IHBhZ2U6IDEsIGxpbWl0OiAxMDAwMCB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG5ld2xpbmVzIGluIENTViB2YWx1ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUlNWUHMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3JzdnAtMScsXG4gICAgICAgICAgZ3Vlc3RGaXJzdE5hbWU6ICdKb2huJyxcbiAgICAgICAgICBndWVzdExhc3ROYW1lOiAnRG9lJyxcbiAgICAgICAgICBndWVzdEVtYWlsOiAnam9obkBleGFtcGxlLmNvbScsXG4gICAgICAgICAgZXZlbnROYW1lOiAnV2VkZGluZyBDZXJlbW9ueScsXG4gICAgICAgICAgYWN0aXZpdHlOYW1lOiBudWxsLFxuICAgICAgICAgIHN0YXR1czogJ2F0dGVuZGluZycgYXMgY29uc3QsXG4gICAgICAgICAgZ3Vlc3RDb3VudDogMSxcbiAgICAgICAgICBkaWV0YXJ5Tm90ZXM6IG51bGwsXG4gICAgICAgICAgc3BlY2lhbFJlcXVpcmVtZW50czogbnVsbCxcbiAgICAgICAgICBub3RlczogJ0xpbmUgMVxcbkxpbmUgMicsXG4gICAgICAgICAgcmVzcG9uZGVkQXQ6ICcyMDI0LTAxLTE1VDEwOjAwOjAwWicsXG4gICAgICAgICAgY3JlYXRlZEF0OiAnMjAyNC0wMS0xMFQxMDowMDowMFonLFxuICAgICAgICAgIHVwZGF0ZWRBdDogJzIwMjQtMDEtMTVUMTA6MDA6MDBaJyxcbiAgICAgICAgICBndWVzdElkOiAnZ3Vlc3QtMScsXG4gICAgICAgICAgZXZlbnRJZDogJ2V2ZW50LTEnLFxuICAgICAgICAgIGFjdGl2aXR5SWQ6IG51bGwsXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICBqZXN0LnNweU9uKHJzdnBNYW5hZ2VtZW50U2VydmljZSwgJ2xpc3RSU1ZQcycpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGRhdGE6IG1vY2tSU1ZQcyxcbiAgICAgICAgICBwYWdpbmF0aW9uOiB7IHBhZ2U6IDEsIGxpbWl0OiAxMDAwMCwgdG90YWw6IDEsIHRvdGFsUGFnZXM6IDEgfSxcbiAgICAgICAgICBzdGF0aXN0aWNzOiB7XG4gICAgICAgICAgICB0b3RhbFJTVlBzOiAxLFxuICAgICAgICAgICAgYnlTdGF0dXM6IHsgYXR0ZW5kaW5nOiAxLCBkZWNsaW5lZDogMCwgbWF5YmU6IDAsIHBlbmRpbmc6IDAgfSxcbiAgICAgICAgICAgIHRvdGFsR3Vlc3RDb3VudDogMSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBNYW5hZ2VtZW50U2VydmljZS5leHBvcnRSU1ZQc1RvQ1NWKHt9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIC8vIE5ld2xpbmVzIHNob3VsZCBiZSB3cmFwcGVkIGluIHF1b3Rlc1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEpLnRvQ29udGFpbignXCJMaW5lIDFcXG5MaW5lIDJcIicpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbnVsbCB2YWx1ZXMgaW4gQ1NWJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1JTVlBzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdyc3ZwLTEnLFxuICAgICAgICAgIGd1ZXN0Rmlyc3ROYW1lOiAnSm9obicsXG4gICAgICAgICAgZ3Vlc3RMYXN0TmFtZTogJ0RvZScsXG4gICAgICAgICAgZ3Vlc3RFbWFpbDogbnVsbCxcbiAgICAgICAgICBldmVudE5hbWU6IG51bGwsXG4gICAgICAgICAgYWN0aXZpdHlOYW1lOiBudWxsLFxuICAgICAgICAgIHN0YXR1czogJ3BlbmRpbmcnIGFzIGNvbnN0LFxuICAgICAgICAgIGd1ZXN0Q291bnQ6IG51bGwsXG4gICAgICAgICAgZGlldGFyeU5vdGVzOiBudWxsLFxuICAgICAgICAgIHNwZWNpYWxSZXF1aXJlbWVudHM6IG51bGwsXG4gICAgICAgICAgbm90ZXM6IG51bGwsXG4gICAgICAgICAgcmVzcG9uZGVkQXQ6IG51bGwsXG4gICAgICAgICAgY3JlYXRlZEF0OiAnMjAyNC0wMS0xMFQxMDowMDowMFonLFxuICAgICAgICAgIHVwZGF0ZWRBdDogJzIwMjQtMDEtMTBUMTA6MDA6MDBaJyxcbiAgICAgICAgICBndWVzdElkOiAnZ3Vlc3QtMScsXG4gICAgICAgICAgZXZlbnRJZDogbnVsbCxcbiAgICAgICAgICBhY3Rpdml0eUlkOiBudWxsLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgamVzdC5zcHlPbihyc3ZwTWFuYWdlbWVudFNlcnZpY2UsICdsaXN0UlNWUHMnKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBkYXRhOiBtb2NrUlNWUHMsXG4gICAgICAgICAgcGFnaW5hdGlvbjogeyBwYWdlOiAxLCBsaW1pdDogMTAwMDAsIHRvdGFsOiAxLCB0b3RhbFBhZ2VzOiAxIH0sXG4gICAgICAgICAgc3RhdGlzdGljczoge1xuICAgICAgICAgICAgdG90YWxSU1ZQczogMSxcbiAgICAgICAgICAgIGJ5U3RhdHVzOiB7IGF0dGVuZGluZzogMCwgZGVjbGluZWQ6IDAsIG1heWJlOiAwLCBwZW5kaW5nOiAxIH0sXG4gICAgICAgICAgICB0b3RhbEd1ZXN0Q291bnQ6IDAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwTWFuYWdlbWVudFNlcnZpY2UuZXhwb3J0UlNWUHNUb0NTVih7fSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAvLyBOdWxsIHZhbHVlcyBzaG91bGQgYmUgZW1wdHkgc3RyaW5nc1xuICAgICAgICBjb25zdCBsaW5lcyA9IHJlc3VsdC5kYXRhLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgZXhwZWN0KGxpbmVzWzFdKS50b0NvbnRhaW4oJ3JzdnAtMSxKb2huLERvZSwsLCcpO1xuICAgICAgICAvLyBHdWVzdCBjb3VudCBzaG91bGQgZGVmYXVsdCB0byAxXG4gICAgICAgIGV4cGVjdChsaW5lc1sxXSkudG9Db250YWluKCcsMSwnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImNyZWF0ZUNsaWVudCIsImZuIiwiZGVzY3JpYmUiLCJtb2NrU3VwYWJhc2UiLCJiZWZvcmVFYWNoIiwiY3JlYXRlTW9ja1N1cGFiYXNlQ2xpZW50IiwicmVzZXRNb2NrU3VwYWJhc2VDbGllbnQiLCJyZXF1aXJlIiwibW9ja1JldHVyblZhbHVlIiwibW9ja1JTVlBEYXRhIiwiaWQiLCJndWVzdF9pZCIsImV2ZW50X2lkIiwiYWN0aXZpdHlfaWQiLCJzdGF0dXMiLCJndWVzdF9jb3VudCIsImRpZXRhcnlfbm90ZXMiLCJzcGVjaWFsX3JlcXVpcmVtZW50cyIsIm5vdGVzIiwicmVzcG9uZGVkX2F0IiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJndWVzdHMiLCJmaXJzdF9uYW1lIiwibGFzdF9uYW1lIiwiZW1haWwiLCJldmVudHMiLCJuYW1lIiwiYWN0aXZpdGllcyIsIml0IiwiZnJvbSIsInNlbGVjdCIsImVxIiwicmFuZ2UiLCJvcmRlciIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiZGF0YSIsImVycm9yIiwiY291bnQiLCJzcHlPbiIsInJzdnBNYW5hZ2VtZW50U2VydmljZSIsInN1Y2Nlc3MiLCJ0b3RhbFJTVlBzIiwiYnlTdGF0dXMiLCJhdHRlbmRpbmciLCJkZWNsaW5lZCIsIm1heWJlIiwicGVuZGluZyIsInRvdGFsR3Vlc3RDb3VudCIsImZpbHRlcnMiLCJldmVudElkIiwicGFnaW5hdGlvbiIsInBhZ2UiLCJsaW1pdCIsInJlc3VsdCIsImxpc3RSU1ZQcyIsImV4cGVjdCIsInRvQmUiLCJ0b0hhdmVMZW5ndGgiLCJndWVzdEZpcnN0TmFtZSIsImV2ZW50TmFtZSIsInRvdGFsIiwidG90YWxQYWdlcyIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwiYWN0aXZpdHlJZCIsImd1ZXN0SWQiLCJjb2RlIiwibWVzc2FnZSIsIm9yIiwic2VhcmNoUXVlcnkiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwibW9ja1N0YXRpc3RpY3NEYXRhIiwiZ2V0UlNWUFN0YXRpc3RpY3MiLCJyc3ZwSWRzIiwidXBkYXRlIiwiaW4iLCJidWxrVXBkYXRlUlNWUHMiLCJ1cGRhdGVkQ291bnQiLCJvYmplY3RDb250YWluaW5nIiwiYW55IiwiU3RyaW5nIiwidG9vTWFueUlkcyIsIkFycmF5IiwibGVuZ3RoIiwiXyIsImkiLCJ1cGRhdGVDYWxsIiwiY2FsbHMiLCJ0b0JlVW5kZWZpbmVkIiwic3RhdHVzZXMiLCJtb2NrUlNWUHMiLCJndWVzdExhc3ROYW1lIiwiZ3Vlc3RFbWFpbCIsImFjdGl2aXR5TmFtZSIsImd1ZXN0Q291bnQiLCJkaWV0YXJ5Tm90ZXMiLCJzcGVjaWFsUmVxdWlyZW1lbnRzIiwicmVzcG9uZGVkQXQiLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJzdGF0aXN0aWNzIiwiZXhwb3J0UlNWUHNUb0NTViIsInRvQ29udGFpbiIsImxpbmVzIiwic3BsaXQiXSwibWFwcGluZ3MiOiI7QUFJQSxnQkFBZ0I7QUFDaEJBLEtBQUtDLElBQUksQ0FBQyx5QkFBeUIsSUFBTyxDQUFBO1FBQ3hDQyxjQUFjRixLQUFLRyxFQUFFO0lBQ3ZCLENBQUE7Ozs7OEJBUGtFOytFQUMzQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBUXZDQyxTQUFTLHlCQUF5QjtJQUNoQyxJQUFJQztJ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