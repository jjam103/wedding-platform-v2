51048fb1e089cf14bbf8f6085e09e403
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
/**
 * Property 18: Adult Family Member Access
 * 
 * For any adult family member in a guest group, they should have read and edit access
 * to all other members in their family group, including their spouse and children.
 * 
 * Validates: Requirements 14.3
 * Feature: destination-wedding-platform, Property 18: Adult Family Member Access
 */ // Mock Supabase client for testing
function createMockSupabaseClient() {
    const mockData = {
        groups: new Map(),
        guests: new Map(),
        users: new Map()
    };
    return {
        from: (table)=>({
                select: (columns = '*')=>({
                        eq: (column, value)=>({
                                single: async ()=>{
                                    if (table === 'guests') {
                                        const guest = Array.from(mockData.guests.values()).find((g)=>g[column] === value);
                                        return guest ? {
                                            data: guest,
                                            error: null
                                        } : {
                                            data: null,
                                            error: {
                                                message: 'Not found'
                                            }
                                        };
                                    }
                                    return {
                                        data: null,
                                        error: {
                                            message: 'Not found'
                                        }
                                    };
                                },
                                then: async (resolve)=>{
                                    if (table === 'guests') {
                                        const guests = Array.from(mockData.guests.values()).filter((g)=>g[column] === value);
                                        resolve({
                                            data: guests,
                                            error: null
                                        });
                                    } else {
                                        resolve({
                                            data: [],
                                            error: null
                                        });
                                    }
                                }
                            })
                    }),
                update: (data)=>({
                        eq: (column, value)=>({
                                select: ()=>({
                                        single: async ()=>{
                                            if (table === 'guests') {
                                                const guest = mockData.guests.get(value);
                                                if (guest) {
                                                    const updated = {
                                                        ...guest,
                                                        ...data
                                                    };
                                                    mockData.guests.set(value, updated);
                                                    return {
                                                        data: updated,
                                                        error: null
                                                    };
                                                }
                                            }
                                            return {
                                                data: null,
                                                error: {
                                                    message: 'Not found'
                                                }
                                            };
                                        }
                                    })
                            })
                    }),
                insert: (data)=>({
                        select: ()=>({
                                single: async ()=>{
                                    const id = `${table}-${Date.now()}-${Math.random()}`;
                                    const record = {
                                        ...data,
                                        id
                                    };
                                    if (table === 'guests') {
                                        mockData.guests.set(id, record);
                                    } else if (table === 'groups') {
                                        mockData.groups.set(id, record);
                                    }
                                    return {
                                        data: record,
                                        error: null
                                    };
                                }
                            })
                    })
            }),
        auth: {
            getSession: async ()=>({
                    data: {
                        session: {
                            user: {
                                email: 'test@example.com'
                            }
                        }
                    },
                    error: null
                })
        },
        _mockData: mockData
    };
}
// Arbitraries for property-based testing
const groupIdArbitrary = _fastcheck.uuid();
const adultGuestArbitrary = _fastcheck.record({
    id: _fastcheck.uuid(),
    group_id: _fastcheck.uuid(),
    first_name: _fastcheck.string({
        minLength: 1,
        maxLength: 50
    }),
    last_name: _fastcheck.string({
        minLength: 1,
        maxLength: 50
    }),
    email: _fastcheck.emailAddress(),
    age_type: _fastcheck.constant('adult'),
    guest_type: _fastcheck.constantFrom('wedding_party', 'wedding_guest', 'prewedding_only', 'postwedding_only'),
    created_at: _fastcheck.date().map((d)=>d.toISOString()),
    updated_at: _fastcheck.date().map((d)=>d.toISOString())
});
const familyMemberArbitrary = _fastcheck.record({
    id: _fastcheck.uuid(),
    first_name: _fastcheck.string({
        minLength: 1,
        maxLength: 50
    }),
    last_name: _fastcheck.string({
        minLength: 1,
        maxLength: 50
    }),
    email: _fastcheck.option(_fastcheck.emailAddress(), {
        nil: undefined
    }),
    age_type: _fastcheck.constantFrom('adult', 'child', 'senior'),
    guest_type: _fastcheck.constantFrom('wedding_party', 'wedding_guest', 'prewedding_only', 'postwedding_only'),
    created_at: _fastcheck.date().map((d)=>d.toISOString()),
    updated_at: _fastcheck.date().map((d)=>d.toISOString())
});
describe('Feature: destination-wedding-platform, Property 18: Adult Family Member Access', ()=>{
    it('should allow adults to read all family members in their group', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(groupIdArbitrary, adultGuestArbitrary, _fastcheck.array(familyMemberArbitrary, {
            minLength: 1,
            maxLength: 5
        }), async (groupId, adultGuest, familyMembers)=>{
            // Arrange: Create mock client and setup data
            const mockClient = createMockSupabaseClient();
            const mockData = mockClient._mockData;
            // Set adult guest with group
            const adult = {
                ...adultGuest,
                group_id: groupId
            };
            mockData.guests.set(adult.id, adult);
            // Set family members with same group
            familyMembers.forEach((member)=>{
                const familyMember = {
                    ...member,
                    group_id: groupId
                };
                mockData.guests.set(familyMember.id, familyMember);
            });
            // Act: Query for family members as adult
            const result = await mockClient.from('guests').select('*').eq('group_id', groupId);
            // Assert: Adult should be able to read all family members
            expect(result.data).toBeDefined();
            expect(result.error).toBeNull();
            expect(result.data.length).toBeGreaterThanOrEqual(familyMembers.length);
            // Verify all family members are accessible
            const accessibleIds = result.data.map((g)=>g.id);
            familyMembers.forEach((member)=>{
                expect(accessibleIds).toContain(member.id);
            });
        }), {
            numRuns: 100
        });
    });
    it('should allow adults to edit all family members in their group', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(groupIdArbitrary, adultGuestArbitrary, familyMemberArbitrary, _fastcheck.string({
            minLength: 1,
            maxLength: 50
        }), async (groupId, adultGuest, familyMember, newFirstName)=>{
            // Arrange: Create mock client and setup data
            const mockClient = createMockSupabaseClient();
            const mockData = mockClient._mockData;
            // Set adult guest with group
            const adult = {
                ...adultGuest,
                group_id: groupId
            };
            mockData.guests.set(adult.id, adult);
            // Set family member with same group
            const member = {
                ...familyMember,
                group_id: groupId
            };
            mockData.guests.set(member.id, member);
            // Act: Update family member as adult
            const updateResult = await mockClient.from('guests').update({
                first_name: newFirstName
            }).eq('id', member.id).select().single();
            // Assert: Adult should be able to edit family member
            expect(updateResult.data).toBeDefined();
            expect(updateResult.error).toBeNull();
            expect(updateResult.data.first_name).toBe(newFirstName);
            expect(updateResult.data.id).toBe(member.id);
        }), {
            numRuns: 100
        });
    });
    it('should allow adults to access family members regardless of age type', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(groupIdArbitrary, adultGuestArbitrary, _fastcheck.array(_fastcheck.record({
            id: _fastcheck.uuid(),
            first_name: _fastcheck.string({
                minLength: 1,
                maxLength: 50
            }),
            last_name: _fastcheck.string({
                minLength: 1,
                maxLength: 50
            }),
            age_type: _fastcheck.constantFrom('adult', 'child', 'senior'),
            guest_type: _fastcheck.constantFrom('wedding_party', 'wedding_guest'),
            created_at: _fastcheck.date().map((d)=>d.toISOString()),
            updated_at: _fastcheck.date().map((d)=>d.toISOString())
        }), {
            minLength: 2,
            maxLength: 6
        }), async (groupId, adultGuest, mixedAgeMembers)=>{
            // Arrange: Create mock client and setup data
            const mockClient = createMockSupabaseClient();
            const mockData = mockClient._mockData;
            // Set adult guest with group
            const adult = {
                ...adultGuest,
                group_id: groupId
            };
            mockData.guests.set(adult.id, adult);
            // Set family members with mixed ages
            mixedAgeMembers.forEach((member)=>{
                const familyMember = {
                    ...member,
                    group_id: groupId
                };
                mockData.guests.set(familyMember.id, familyMember);
            });
            // Act: Query for all family members
            const result = await mockClient.from('guests').select('*').eq('group_id', groupId);
            // Assert: Adult should access all members regardless of age
            expect(result.data).toBeDefined();
            expect(result.error).toBeNull();
            const childMembers = mixedAgeMembers.filter((m)=>m.age_type === 'child');
            const adultMembers = mixedAgeMembers.filter((m)=>m.age_type === 'adult');
            const seniorMembers = mixedAgeMembers.filter((m)=>m.age_type === 'senior');
            const accessibleIds = result.data.map((g)=>g.id);
            // Verify access to children
            childMembers.forEach((child)=>{
                expect(accessibleIds).toContain(child.id);
            });
            // Verify access to other adults
            adultMembers.forEach((otherAdult)=>{
                expect(accessibleIds).toContain(otherAdult.id);
            });
            // Verify access to seniors
            seniorMembers.forEach((senior)=>{
                expect(accessibleIds).toContain(senior.id);
            });
        }), {
            numRuns: 100
        });
    });
    it('should not allow adults to access family members from different groups', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.uuid(), _fastcheck.uuid(), adultGuestArbitrary, familyMemberArbitrary, async (groupId1, groupId2, adultGuest, otherFamilyMember)=>{
            // Ensure different groups
            _fastcheck.pre(groupId1 !== groupId2);
            // Arrange: Create mock client and setup data
            const mockClient = createMockSupabaseClient();
            const mockData = mockClient._mockData;
            // Set adult guest in group 1
            const adult = {
                ...adultGuest,
                group_id: groupId1
            };
            mockData.guests.set(adult.id, adult);
            // Set other family member in group 2
            const otherMember = {
                ...otherFamilyMember,
                group_id: groupId2
            };
            mockData.guests.set(otherMember.id, otherMember);
            // Act: Query for adult's family members (group 1)
            const result = await mockClient.from('guests').select('*').eq('group_id', groupId1);
            // Assert: Adult should not see members from other groups
            expect(result.data).toBeDefined();
            const accessibleIds = result.data.map((g)=>g.id);
            expect(accessibleIds).not.toContain(otherMember.id);
        }), {
            numRuns: 100
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvYWR1bHRGYW1pbHlNZW1iZXJBY2Nlc3MucHJvcGVydHkudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmYyBmcm9tICdmYXN0LWNoZWNrJztcbmltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5cbi8qKlxuICogUHJvcGVydHkgMTg6IEFkdWx0IEZhbWlseSBNZW1iZXIgQWNjZXNzXG4gKiBcbiAqIEZvciBhbnkgYWR1bHQgZmFtaWx5IG1lbWJlciBpbiBhIGd1ZXN0IGdyb3VwLCB0aGV5IHNob3VsZCBoYXZlIHJlYWQgYW5kIGVkaXQgYWNjZXNzXG4gKiB0byBhbGwgb3RoZXIgbWVtYmVycyBpbiB0aGVpciBmYW1pbHkgZ3JvdXAsIGluY2x1ZGluZyB0aGVpciBzcG91c2UgYW5kIGNoaWxkcmVuLlxuICogXG4gKiBWYWxpZGF0ZXM6IFJlcXVpcmVtZW50cyAxNC4zXG4gKiBGZWF0dXJlOiBkZXN0aW5hdGlvbi13ZWRkaW5nLXBsYXRmb3JtLCBQcm9wZXJ0eSAxODogQWR1bHQgRmFtaWx5IE1lbWJlciBBY2Nlc3NcbiAqL1xuXG4vLyBNb2NrIFN1cGFiYXNlIGNsaWVudCBmb3IgdGVzdGluZ1xuZnVuY3Rpb24gY3JlYXRlTW9ja1N1cGFiYXNlQ2xpZW50KCkge1xuICBjb25zdCBtb2NrRGF0YSA9IHtcbiAgICBncm91cHM6IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCksXG4gICAgZ3Vlc3RzOiBuZXcgTWFwPHN0cmluZywgYW55PigpLFxuICAgIHVzZXJzOiBuZXcgTWFwPHN0cmluZywgYW55PigpLFxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgZnJvbTogKHRhYmxlOiBzdHJpbmcpID0+ICh7XG4gICAgICBzZWxlY3Q6IChjb2x1bW5zOiBzdHJpbmcgPSAnKicpID0+ICh7XG4gICAgICAgIGVxOiAoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+ICh7XG4gICAgICAgICAgc2luZ2xlOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFibGUgPT09ICdndWVzdHMnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGd1ZXN0ID0gQXJyYXkuZnJvbShtb2NrRGF0YS5ndWVzdHMudmFsdWVzKCkpLmZpbmQoXG4gICAgICAgICAgICAgICAgKGc6IGFueSkgPT4gZ1tjb2x1bW5dID09PSB2YWx1ZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4gZ3Vlc3RcbiAgICAgICAgICAgICAgICA/IHsgZGF0YTogZ3Vlc3QsIGVycm9yOiBudWxsIH1cbiAgICAgICAgICAgICAgICA6IHsgZGF0YTogbnVsbCwgZXJyb3I6IHsgbWVzc2FnZTogJ05vdCBmb3VuZCcgfSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHsgbWVzc2FnZTogJ05vdCBmb3VuZCcgfSB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdGhlbjogYXN5bmMgKHJlc29sdmU6IGFueSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRhYmxlID09PSAnZ3Vlc3RzJykge1xuICAgICAgICAgICAgICBjb25zdCBndWVzdHMgPSBBcnJheS5mcm9tKG1vY2tEYXRhLmd1ZXN0cy52YWx1ZXMoKSkuZmlsdGVyKFxuICAgICAgICAgICAgICAgIChnOiBhbnkpID0+IGdbY29sdW1uXSA9PT0gdmFsdWVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh7IGRhdGE6IGd1ZXN0cywgZXJyb3I6IG51bGwgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKHsgZGF0YTogW10sIGVycm9yOiBudWxsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuICAgICAgfSksXG4gICAgICB1cGRhdGU6IChkYXRhOiBhbnkpID0+ICh7XG4gICAgICAgIGVxOiAoY29sdW1uOiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+ICh7XG4gICAgICAgICAgc2VsZWN0OiAoKSA9PiAoe1xuICAgICAgICAgICAgc2luZ2xlOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0YWJsZSA9PT0gJ2d1ZXN0cycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBndWVzdCA9IG1vY2tEYXRhLmd1ZXN0cy5nZXQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChndWVzdCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZCA9IHsgLi4uZ3Vlc3QsIC4uLmRhdGEgfTtcbiAgICAgICAgICAgICAgICAgIG1vY2tEYXRhLmd1ZXN0cy5zZXQodmFsdWUsIHVwZGF0ZWQpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogdXBkYXRlZCwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHsgbWVzc2FnZTogJ05vdCBmb3VuZCcgfSB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICB9KSxcbiAgICAgIGluc2VydDogKGRhdGE6IGFueSkgPT4gKHtcbiAgICAgICAgc2VsZWN0OiAoKSA9PiAoe1xuICAgICAgICAgIHNpbmdsZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBgJHt0YWJsZX0tJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCl9YDtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IHsgLi4uZGF0YSwgaWQgfTtcbiAgICAgICAgICAgIGlmICh0YWJsZSA9PT0gJ2d1ZXN0cycpIHtcbiAgICAgICAgICAgICAgbW9ja0RhdGEuZ3Vlc3RzLnNldChpZCwgcmVjb3JkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFibGUgPT09ICdncm91cHMnKSB7XG4gICAgICAgICAgICAgIG1vY2tEYXRhLmdyb3Vwcy5zZXQoaWQsIHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiByZWNvcmQsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgfSksXG4gICAgICB9KSxcbiAgICB9KSxcbiAgICBhdXRoOiB7XG4gICAgICBnZXRTZXNzaW9uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICBkYXRhOiB7IHNlc3Npb246IHsgdXNlcjogeyBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nIH0gfSB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pLFxuICAgIH0sXG4gICAgX21vY2tEYXRhOiBtb2NrRGF0YSxcbiAgfTtcbn1cblxuLy8gQXJiaXRyYXJpZXMgZm9yIHByb3BlcnR5LWJhc2VkIHRlc3RpbmdcbmNvbnN0IGdyb3VwSWRBcmJpdHJhcnkgPSBmYy51dWlkKCk7XG5cbmNvbnN0IGFkdWx0R3Vlc3RBcmJpdHJhcnkgPSBmYy5yZWNvcmQoe1xuICBpZDogZmMudXVpZCgpLFxuICBncm91cF9pZDogZmMudXVpZCgpLFxuICBmaXJzdF9uYW1lOiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogNTAgfSksXG4gIGxhc3RfbmFtZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLFxuICBlbWFpbDogZmMuZW1haWxBZGRyZXNzKCksXG4gIGFnZV90eXBlOiBmYy5jb25zdGFudCgnYWR1bHQnIGFzIGNvbnN0KSxcbiAgZ3Vlc3RfdHlwZTogZmMuY29uc3RhbnRGcm9tKFxuICAgICd3ZWRkaW5nX3BhcnR5JyxcbiAgICAnd2VkZGluZ19ndWVzdCcsXG4gICAgJ3ByZXdlZGRpbmdfb25seScsXG4gICAgJ3Bvc3R3ZWRkaW5nX29ubHknXG4gICksXG4gIGNyZWF0ZWRfYXQ6IGZjLmRhdGUoKS5tYXAoKGQpID0+IGQudG9JU09TdHJpbmcoKSksXG4gIHVwZGF0ZWRfYXQ6IGZjLmRhdGUoKS5tYXAoKGQpID0+IGQudG9JU09TdHJpbmcoKSksXG59KTtcblxuY29uc3QgZmFtaWx5TWVtYmVyQXJiaXRyYXJ5ID0gZmMucmVjb3JkKHtcbiAgaWQ6IGZjLnV1aWQoKSxcbiAgZmlyc3RfbmFtZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLFxuICBsYXN0X25hbWU6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1MCB9KSxcbiAgZW1haWw6IGZjLm9wdGlvbihmYy5lbWFpbEFkZHJlc3MoKSwgeyBuaWw6IHVuZGVmaW5lZCB9KSxcbiAgYWdlX3R5cGU6IGZjLmNvbnN0YW50RnJvbSgnYWR1bHQnLCAnY2hpbGQnLCAnc2VuaW9yJyksXG4gIGd1ZXN0X3R5cGU6IGZjLmNvbnN0YW50RnJvbShcbiAgICAnd2VkZGluZ19wYXJ0eScsXG4gICAgJ3dlZGRpbmdfZ3Vlc3QnLFxuICAgICdwcmV3ZWRkaW5nX29ubHknLFxuICAgICdwb3N0d2VkZGluZ19vbmx5J1xuICApLFxuICBjcmVhdGVkX2F0OiBmYy5kYXRlKCkubWFwKChkKSA9PiBkLnRvSVNPU3RyaW5nKCkpLFxuICB1cGRhdGVkX2F0OiBmYy5kYXRlKCkubWFwKChkKSA9PiBkLnRvSVNPU3RyaW5nKCkpLFxufSk7XG5cbmRlc2NyaWJlKCdGZWF0dXJlOiBkZXN0aW5hdGlvbi13ZWRkaW5nLXBsYXRmb3JtLCBQcm9wZXJ0eSAxODogQWR1bHQgRmFtaWx5IE1lbWJlciBBY2Nlc3MnLCAoKSA9PiB7XG4gIGl0KCdzaG91bGQgYWxsb3cgYWR1bHRzIHRvIHJlYWQgYWxsIGZhbWlseSBtZW1iZXJzIGluIHRoZWlyIGdyb3VwJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGdyb3VwSWRBcmJpdHJhcnksXG4gICAgICAgIGFkdWx0R3Vlc3RBcmJpdHJhcnksXG4gICAgICAgIGZjLmFycmF5KGZhbWlseU1lbWJlckFyYml0cmFyeSwgeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogNSB9KSxcbiAgICAgICAgYXN5bmMgKGdyb3VwSWQsIGFkdWx0R3Vlc3QsIGZhbWlseU1lbWJlcnMpID0+IHtcbiAgICAgICAgICAvLyBBcnJhbmdlOiBDcmVhdGUgbW9jayBjbGllbnQgYW5kIHNldHVwIGRhdGFcbiAgICAgICAgICBjb25zdCBtb2NrQ2xpZW50ID0gY3JlYXRlTW9ja1N1cGFiYXNlQ2xpZW50KCk7XG4gICAgICAgICAgY29uc3QgbW9ja0RhdGEgPSBtb2NrQ2xpZW50Ll9tb2NrRGF0YTtcblxuICAgICAgICAgIC8vIFNldCBhZHVsdCBndWVzdCB3aXRoIGdyb3VwXG4gICAgICAgICAgY29uc3QgYWR1bHQgPSB7IC4uLmFkdWx0R3Vlc3QsIGdyb3VwX2lkOiBncm91cElkIH07XG4gICAgICAgICAgbW9ja0RhdGEuZ3Vlc3RzLnNldChhZHVsdC5pZCwgYWR1bHQpO1xuXG4gICAgICAgICAgLy8gU2V0IGZhbWlseSBtZW1iZXJzIHdpdGggc2FtZSBncm91cFxuICAgICAgICAgIGZhbWlseU1lbWJlcnMuZm9yRWFjaCgobWVtYmVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmYW1pbHlNZW1iZXIgPSB7IC4uLm1lbWJlciwgZ3JvdXBfaWQ6IGdyb3VwSWQgfTtcbiAgICAgICAgICAgIG1vY2tEYXRhLmd1ZXN0cy5zZXQoZmFtaWx5TWVtYmVyLmlkLCBmYW1pbHlNZW1iZXIpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gQWN0OiBRdWVyeSBmb3IgZmFtaWx5IG1lbWJlcnMgYXMgYWR1bHRcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtb2NrQ2xpZW50XG4gICAgICAgICAgICAuZnJvbSgnZ3Vlc3RzJylcbiAgICAgICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAgICAgLmVxKCdncm91cF9pZCcsIGdyb3VwSWQpO1xuXG4gICAgICAgICAgLy8gQXNzZXJ0OiBBZHVsdCBzaG91bGQgYmUgYWJsZSB0byByZWFkIGFsbCBmYW1pbHkgbWVtYmVyc1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YSkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoZmFtaWx5TWVtYmVycy5sZW5ndGgpO1xuXG4gICAgICAgICAgLy8gVmVyaWZ5IGFsbCBmYW1pbHkgbWVtYmVycyBhcmUgYWNjZXNzaWJsZVxuICAgICAgICAgIGNvbnN0IGFjY2Vzc2libGVJZHMgPSByZXN1bHQuZGF0YS5tYXAoKGc6IGFueSkgPT4gZy5pZCk7XG4gICAgICAgICAgZmFtaWx5TWVtYmVycy5mb3JFYWNoKChtZW1iZXIpID0+IHtcbiAgICAgICAgICAgIGV4cGVjdChhY2Nlc3NpYmxlSWRzKS50b0NvbnRhaW4obWVtYmVyLmlkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGFsbG93IGFkdWx0cyB0byBlZGl0IGFsbCBmYW1pbHkgbWVtYmVycyBpbiB0aGVpciBncm91cCcsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBncm91cElkQXJiaXRyYXJ5LFxuICAgICAgICBhZHVsdEd1ZXN0QXJiaXRyYXJ5LFxuICAgICAgICBmYW1pbHlNZW1iZXJBcmJpdHJhcnksXG4gICAgICAgIGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1MCB9KSxcbiAgICAgICAgYXN5bmMgKGdyb3VwSWQsIGFkdWx0R3Vlc3QsIGZhbWlseU1lbWJlciwgbmV3Rmlyc3ROYW1lKSA9PiB7XG4gICAgICAgICAgLy8gQXJyYW5nZTogQ3JlYXRlIG1vY2sgY2xpZW50IGFuZCBzZXR1cCBkYXRhXG4gICAgICAgICAgY29uc3QgbW9ja0NsaWVudCA9IGNyZWF0ZU1vY2tTdXBhYmFzZUNsaWVudCgpO1xuICAgICAgICAgIGNvbnN0IG1vY2tEYXRhID0gbW9ja0NsaWVudC5fbW9ja0RhdGE7XG5cbiAgICAgICAgICAvLyBTZXQgYWR1bHQgZ3Vlc3Qgd2l0aCBncm91cFxuICAgICAgICAgIGNvbnN0IGFkdWx0ID0geyAuLi5hZHVsdEd1ZXN0LCBncm91cF9pZDogZ3JvdXBJZCB9O1xuICAgICAgICAgIG1vY2tEYXRhLmd1ZXN0cy5zZXQoYWR1bHQuaWQsIGFkdWx0KTtcblxuICAgICAgICAgIC8vIFNldCBmYW1pbHkgbWVtYmVyIHdpdGggc2FtZSBncm91cFxuICAgICAgICAgIGNvbnN0IG1lbWJlciA9IHsgLi4uZmFtaWx5TWVtYmVyLCBncm91cF9pZDogZ3JvdXBJZCB9O1xuICAgICAgICAgIG1vY2tEYXRhLmd1ZXN0cy5zZXQobWVtYmVyLmlkLCBtZW1iZXIpO1xuXG4gICAgICAgICAgLy8gQWN0OiBVcGRhdGUgZmFtaWx5IG1lbWJlciBhcyBhZHVsdFxuICAgICAgICAgIGNvbnN0IHVwZGF0ZVJlc3VsdCA9IGF3YWl0IG1vY2tDbGllbnRcbiAgICAgICAgICAgIC5mcm9tKCdndWVzdHMnKVxuICAgICAgICAgICAgLnVwZGF0ZSh7IGZpcnN0X25hbWU6IG5ld0ZpcnN0TmFtZSB9KVxuICAgICAgICAgICAgLmVxKCdpZCcsIG1lbWJlci5pZClcbiAgICAgICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICAgICAgLy8gQXNzZXJ0OiBBZHVsdCBzaG91bGQgYmUgYWJsZSB0byBlZGl0IGZhbWlseSBtZW1iZXJcbiAgICAgICAgICBleHBlY3QodXBkYXRlUmVzdWx0LmRhdGEpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgZXhwZWN0KHVwZGF0ZVJlc3VsdC5lcnJvcikudG9CZU51bGwoKTtcbiAgICAgICAgICBleHBlY3QodXBkYXRlUmVzdWx0LmRhdGEuZmlyc3RfbmFtZSkudG9CZShuZXdGaXJzdE5hbWUpO1xuICAgICAgICAgIGV4cGVjdCh1cGRhdGVSZXN1bHQuZGF0YS5pZCkudG9CZShtZW1iZXIuaWQpO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgYWxsb3cgYWR1bHRzIHRvIGFjY2VzcyBmYW1pbHkgbWVtYmVycyByZWdhcmRsZXNzIG9mIGFnZSB0eXBlJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGdyb3VwSWRBcmJpdHJhcnksXG4gICAgICAgIGFkdWx0R3Vlc3RBcmJpdHJhcnksXG4gICAgICAgIGZjLmFycmF5KFxuICAgICAgICAgIGZjLnJlY29yZCh7XG4gICAgICAgICAgICBpZDogZmMudXVpZCgpLFxuICAgICAgICAgICAgZmlyc3RfbmFtZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLFxuICAgICAgICAgICAgbGFzdF9uYW1lOiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogNTAgfSksXG4gICAgICAgICAgICBhZ2VfdHlwZTogZmMuY29uc3RhbnRGcm9tKCdhZHVsdCcsICdjaGlsZCcsICdzZW5pb3InKSxcbiAgICAgICAgICAgIGd1ZXN0X3R5cGU6IGZjLmNvbnN0YW50RnJvbSgnd2VkZGluZ19wYXJ0eScsICd3ZWRkaW5nX2d1ZXN0JyksXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBmYy5kYXRlKCkubWFwKChkKSA9PiBkLnRvSVNPU3RyaW5nKCkpLFxuICAgICAgICAgICAgdXBkYXRlZF9hdDogZmMuZGF0ZSgpLm1hcCgoZCkgPT4gZC50b0lTT1N0cmluZygpKSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7IG1pbkxlbmd0aDogMiwgbWF4TGVuZ3RoOiA2IH1cbiAgICAgICAgKSxcbiAgICAgICAgYXN5bmMgKGdyb3VwSWQsIGFkdWx0R3Vlc3QsIG1peGVkQWdlTWVtYmVycykgPT4ge1xuICAgICAgICAgIC8vIEFycmFuZ2U6IENyZWF0ZSBtb2NrIGNsaWVudCBhbmQgc2V0dXAgZGF0YVxuICAgICAgICAgIGNvbnN0IG1vY2tDbGllbnQgPSBjcmVhdGVNb2NrU3VwYWJhc2VDbGllbnQoKTtcbiAgICAgICAgICBjb25zdCBtb2NrRGF0YSA9IG1vY2tDbGllbnQuX21vY2tEYXRhO1xuXG4gICAgICAgICAgLy8gU2V0IGFkdWx0IGd1ZXN0IHdpdGggZ3JvdXBcbiAgICAgICAgICBjb25zdCBhZHVsdCA9IHsgLi4uYWR1bHRHdWVzdCwgZ3JvdXBfaWQ6IGdyb3VwSWQgfTtcbiAgICAgICAgICBtb2NrRGF0YS5ndWVzdHMuc2V0KGFkdWx0LmlkLCBhZHVsdCk7XG5cbiAgICAgICAgICAvLyBTZXQgZmFtaWx5IG1lbWJlcnMgd2l0aCBtaXhlZCBhZ2VzXG4gICAgICAgICAgbWl4ZWRBZ2VNZW1iZXJzLmZvckVhY2goKG1lbWJlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmFtaWx5TWVtYmVyID0geyAuLi5tZW1iZXIsIGdyb3VwX2lkOiBncm91cElkIH07XG4gICAgICAgICAgICBtb2NrRGF0YS5ndWVzdHMuc2V0KGZhbWlseU1lbWJlci5pZCwgZmFtaWx5TWVtYmVyKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIEFjdDogUXVlcnkgZm9yIGFsbCBmYW1pbHkgbWVtYmVyc1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1vY2tDbGllbnRcbiAgICAgICAgICAgIC5mcm9tKCdndWVzdHMnKVxuICAgICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgICAuZXEoJ2dyb3VwX2lkJywgZ3JvdXBJZCk7XG5cbiAgICAgICAgICAvLyBBc3NlcnQ6IEFkdWx0IHNob3VsZCBhY2Nlc3MgYWxsIG1lbWJlcnMgcmVnYXJkbGVzcyBvZiBhZ2VcbiAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9CZU51bGwoKTtcblxuICAgICAgICAgIGNvbnN0IGNoaWxkTWVtYmVycyA9IG1peGVkQWdlTWVtYmVycy5maWx0ZXIoKG0pID0+IG0uYWdlX3R5cGUgPT09ICdjaGlsZCcpO1xuICAgICAgICAgIGNvbnN0IGFkdWx0TWVtYmVycyA9IG1peGVkQWdlTWVtYmVycy5maWx0ZXIoKG0pID0+IG0uYWdlX3R5cGUgPT09ICdhZHVsdCcpO1xuICAgICAgICAgIGNvbnN0IHNlbmlvck1lbWJlcnMgPSBtaXhlZEFnZU1lbWJlcnMuZmlsdGVyKChtKSA9PiBtLmFnZV90eXBlID09PSAnc2VuaW9yJyk7XG5cbiAgICAgICAgICBjb25zdCBhY2Nlc3NpYmxlSWRzID0gcmVzdWx0LmRhdGEubWFwKChnOiBhbnkpID0+IGcuaWQpO1xuXG4gICAgICAgICAgLy8gVmVyaWZ5IGFjY2VzcyB0byBjaGlsZHJlblxuICAgICAgICAgIGNoaWxkTWVtYmVycy5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgZXhwZWN0KGFjY2Vzc2libGVJZHMpLnRvQ29udGFpbihjaGlsZC5pZCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBWZXJpZnkgYWNjZXNzIHRvIG90aGVyIGFkdWx0c1xuICAgICAgICAgIGFkdWx0TWVtYmVycy5mb3JFYWNoKChvdGhlckFkdWx0KSA9PiB7XG4gICAgICAgICAgICBleHBlY3QoYWNjZXNzaWJsZUlkcykudG9Db250YWluKG90aGVyQWR1bHQuaWQpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gVmVyaWZ5IGFjY2VzcyB0byBzZW5pb3JzXG4gICAgICAgICAgc2VuaW9yTWVtYmVycy5mb3JFYWNoKChzZW5pb3IpID0+IHtcbiAgICAgICAgICAgIGV4cGVjdChhY2Nlc3NpYmxlSWRzKS50b0NvbnRhaW4oc2VuaW9yLmlkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIG5vdCBhbGxvdyBhZHVsdHMgdG8gYWNjZXNzIGZhbWlseSBtZW1iZXJzIGZyb20gZGlmZmVyZW50IGdyb3VwcycsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBmYy51dWlkKCksXG4gICAgICAgIGZjLnV1aWQoKSxcbiAgICAgICAgYWR1bHRHdWVzdEFyYml0cmFyeSxcbiAgICAgICAgZmFtaWx5TWVtYmVyQXJiaXRyYXJ5LFxuICAgICAgICBhc3luYyAoZ3JvdXBJZDEsIGdyb3VwSWQyLCBhZHVsdEd1ZXN0LCBvdGhlckZhbWlseU1lbWJlcikgPT4ge1xuICAgICAgICAgIC8vIEVuc3VyZSBkaWZmZXJlbnQgZ3JvdXBzXG4gICAgICAgICAgZmMucHJlKGdyb3VwSWQxICE9PSBncm91cElkMik7XG5cbiAgICAgICAgICAvLyBBcnJhbmdlOiBDcmVhdGUgbW9jayBjbGllbnQgYW5kIHNldHVwIGRhdGFcbiAgICAgICAgICBjb25zdCBtb2NrQ2xpZW50ID0gY3JlYXRlTW9ja1N1cGFiYXNlQ2xpZW50KCk7XG4gICAgICAgICAgY29uc3QgbW9ja0RhdGEgPSBtb2NrQ2xpZW50Ll9tb2NrRGF0YTtcblxuICAgICAgICAgIC8vIFNldCBhZHVsdCBndWVzdCBpbiBncm91cCAxXG4gICAgICAgICAgY29uc3QgYWR1bHQgPSB7IC4uLmFkdWx0R3Vlc3QsIGdyb3VwX2lkOiBncm91cElkMSB9O1xuICAgICAgICAgIG1vY2tEYXRhLmd1ZXN0cy5zZXQoYWR1bHQuaWQsIGFkdWx0KTtcblxuICAgICAgICAgIC8vIFNldCBvdGhlciBmYW1pbHkgbWVtYmVyIGluIGdyb3VwIDJcbiAgICAgICAgICBjb25zdCBvdGhlck1lbWJlciA9IHsgLi4ub3RoZXJGYW1pbHlNZW1iZXIsIGdyb3VwX2lkOiBncm91cElkMiB9O1xuICAgICAgICAgIG1vY2tEYXRhLmd1ZXN0cy5zZXQob3RoZXJNZW1iZXIuaWQsIG90aGVyTWVtYmVyKTtcblxuICAgICAgICAgIC8vIEFjdDogUXVlcnkgZm9yIGFkdWx0J3MgZmFtaWx5IG1lbWJlcnMgKGdyb3VwIDEpXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbW9ja0NsaWVudFxuICAgICAgICAgICAgLmZyb20oJ2d1ZXN0cycpXG4gICAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAgIC5lcSgnZ3JvdXBfaWQnLCBncm91cElkMSk7XG5cbiAgICAgICAgICAvLyBBc3NlcnQ6IEFkdWx0IHNob3VsZCBub3Qgc2VlIG1lbWJlcnMgZnJvbSBvdGhlciBncm91cHNcbiAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgY29uc3QgYWNjZXNzaWJsZUlkcyA9IHJlc3VsdC5kYXRhLm1hcCgoZzogYW55KSA9PiBnLmlkKTtcbiAgICAgICAgICBleHBlY3QoYWNjZXNzaWJsZUlkcykubm90LnRvQ29udGFpbihvdGhlck1lbWJlci5pZCk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJjcmVhdGVNb2NrU3VwYWJhc2VDbGllbnQiLCJtb2NrRGF0YSIsImdyb3VwcyIsIk1hcCIsImd1ZXN0cyIsInVzZXJzIiwiZnJvbSIsInRhYmxlIiwic2VsZWN0IiwiY29sdW1ucyIsImVxIiwiY29sdW1uIiwidmFsdWUiLCJzaW5nbGUiLCJndWVzdCIsIkFycmF5IiwidmFsdWVzIiwiZmluZCIsImciLCJkYXRhIiwiZXJyb3IiLCJtZXNzYWdlIiwidGhlbiIsInJlc29sdmUiLCJmaWx0ZXIiLCJ1cGRhdGUiLCJnZXQiLCJ1cGRhdGVkIiwic2V0IiwiaW5zZXJ0IiwiaWQiLCJEYXRlIiwibm93IiwiTWF0aCIsInJhbmRvbSIsInJlY29yZCIsImF1dGgiLCJnZXRTZXNzaW9uIiwic2Vzc2lvbiIsInVzZXIiLCJlbWFpbCIsIl9tb2NrRGF0YSIsImdyb3VwSWRBcmJpdHJhcnkiLCJmYyIsInV1aWQiLCJhZHVsdEd1ZXN0QXJiaXRyYXJ5IiwiZ3JvdXBfaWQiLCJmaXJzdF9uYW1lIiwic3RyaW5nIiwibWluTGVuZ3RoIiwibWF4TGVuZ3RoIiwibGFzdF9uYW1lIiwiZW1haWxBZGRyZXNzIiwiYWdlX3R5cGUiLCJjb25zdGFudCIsImd1ZXN0X3R5cGUiLCJjb25zdGFudEZyb20iLCJjcmVhdGVkX2F0IiwiZGF0ZSIsIm1hcCIsImQiLCJ0b0lTT1N0cmluZyIsInVwZGF0ZWRfYXQiLCJmYW1pbHlNZW1iZXJBcmJpdHJhcnkiLCJvcHRpb24iLCJuaWwiLCJ1bmRlZmluZWQiLCJkZXNjcmliZSIsIml0IiwiYXNzZXJ0IiwiYXN5bmNQcm9wZXJ0eSIsImFycmF5IiwiZ3JvdXBJZCIsImFkdWx0R3Vlc3QiLCJmYW1pbHlNZW1iZXJzIiwibW9ja0NsaWVudCIsImFkdWx0IiwiZm9yRWFjaCIsIm1lbWJlciIsImZhbWlseU1lbWJlciIsInJlc3VsdCIsImV4cGVjdCIsInRvQmVEZWZpbmVkIiwidG9CZU51bGwiLCJsZW5ndGgiLCJ0b0JlR3JlYXRlclRoYW5PckVxdWFsIiwiYWNjZXNzaWJsZUlkcyIsInRvQ29udGFpbiIsIm51bVJ1bnMiLCJuZXdGaXJzdE5hbWUiLCJ1cGRhdGVSZXN1bHQiLCJ0b0JlIiwibWl4ZWRBZ2VNZW1iZXJzIiwiY2hpbGRNZW1iZXJzIiwibSIsImFkdWx0TWVtYmVycyIsInNlbmlvck1lbWJlcnMiLCJjaGlsZCIsIm90aGVyQWR1bHQiLCJzZW5pb3IiLCJncm91cElkMSIsImdyb3VwSWQyIiwib3RoZXJGYW1pbHlNZW1iZXIiLCJwcmUiLCJvdGhlck1lbWJlciIsIm5vdCJdLCJtYXBwaW5ncyI6Ijs7OzttRUFBb0I7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