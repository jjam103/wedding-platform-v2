{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/lib/caching.ts"],"sourcesContent":["/**\n * Caching Strategy Implementation\n * \n * This module provides caching utilities for optimizing performance.\n * Supports both server-side (Redis) and client-side (React Query) caching.\n * \n * Requirements: 19.6, 18.9\n */\n\n/**\n * Cache TTL (Time To Live) configuration\n */\nexport const CACHE_TTL = {\n  // Dynamic data - 5 minutes\n  RSVPS: 5 * 60, // 300 seconds\n  GUESTS: 5 * 60,\n  ACTIVITIES: 5 * 60,\n  EVENTS: 5 * 60,\n  \n  // Static data - 1 hour\n  CONTENT_PAGES: 60 * 60, // 3600 seconds\n  LOCATIONS: 60 * 60,\n  SETTINGS: 60 * 60,\n  \n  // Semi-static data - 15 minutes\n  PHOTOS: 15 * 60, // 900 seconds\n  ACCOMMODATIONS: 15 * 60,\n  \n  // Analytics data - 10 minutes\n  RSVP_ANALYTICS: 10 * 60, // 600 seconds\n  CAPACITY_STATS: 10 * 60,\n} as const;\n\n/**\n * Cache key generators\n */\nexport const CacheKeys = {\n  // Guest data\n  guest: (id: string) => `guest:${id}`,\n  guestsByGroup: (groupId: string) => `guests:group:${groupId}`,\n  guestRSVPs: (guestId: string) => `guest:${guestId}:rsvps`,\n  \n  // Event data\n  event: (id: string) => `event:${id}`,\n  eventBySlug: (slug: string) => `event:slug:${slug}`,\n  events: (filters?: string) => `events${filters ? `:${filters}` : ''}`,\n  eventActivities: (eventId: string) => `event:${eventId}:activities`,\n  \n  // Activity data\n  activity: (id: string) => `activity:${id}`,\n  activityBySlug: (slug: string) => `activity:slug:${slug}`,\n  activities: (filters?: string) => `activities${filters ? `:${filters}` : ''}`,\n  activityRSVPs: (activityId: string) => `activity:${activityId}:rsvps`,\n  activityCapacity: (activityId: string) => `activity:${activityId}:capacity`,\n  \n  // Content pages\n  contentPage: (id: string) => `content_page:${id}`,\n  contentPageBySlug: (slug: string) => `content_page:slug:${slug}`,\n  contentPages: (status?: string) => `content_pages${status ? `:${status}` : ''}`,\n  pageSections: (pageType: string, pageId: string) => `sections:${pageType}:${pageId}`,\n  \n  // Photos\n  photo: (id: string) => `photo:${id}`,\n  photos: (filters?: string) => `photos${filters ? `:${filters}` : ''}`,\n  photosByPage: (pageType: string, pageId: string) => `photos:${pageType}:${pageId}`,\n  \n  // Analytics\n  rsvpAnalytics: () => 'analytics:rsvps',\n  capacityStats: () => 'analytics:capacity',\n  \n  // Settings\n  settings: () => 'settings',\n  \n  // Locations\n  location: (id: string) => `location:${id}`,\n  locations: () => 'locations',\n  locationHierarchy: (parentId?: string) => `locations:hierarchy${parentId ? `:${parentId}` : ''}`,\n} as const;\n\n/**\n * Cache tags for invalidation\n */\nexport const CacheTags = {\n  GUESTS: 'guests',\n  EVENTS: 'events',\n  ACTIVITIES: 'activities',\n  RSVPS: 'rsvps',\n  CONTENT_PAGES: 'content_pages',\n  SECTIONS: 'sections',\n  PHOTOS: 'photos',\n  LOCATIONS: 'locations',\n  SETTINGS: 'settings',\n  ANALYTICS: 'analytics',\n} as const;\n\n/**\n * Server-side cache interface (Redis)\n * \n * Note: This is a placeholder interface. Actual Redis implementation\n * would require installing and configuring Redis client.\n * \n * For Next.js deployment on Vercel, consider using:\n * - Vercel KV (Redis-compatible)\n * - Upstash Redis\n * - Redis Cloud\n */\nexport interface ServerCache {\n  get<T>(key: string): Promise<T | null>;\n  set<T>(key: string, value: T, ttl?: number): Promise<void>;\n  del(key: string): Promise<void>;\n  delByPattern(pattern: string): Promise<void>;\n  delByTag(tag: string): Promise<void>;\n}\n\n/**\n * In-memory cache implementation (fallback when Redis not available)\n */\nclass InMemoryCache implements ServerCache {\n  private cache = new Map<string, { value: any; expires: number }>();\n  private tags = new Map<string, Set<string>>();\n\n  async get<T>(key: string): Promise<T | null> {\n    const item = this.cache.get(key);\n    \n    if (!item) {\n      return null;\n    }\n    \n    if (Date.now() > item.expires) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return item.value as T;\n  }\n\n  async set<T>(key: string, value: T, ttl: number = 300): Promise<void> {\n    const expires = Date.now() + (ttl * 1000);\n    this.cache.set(key, { value, expires });\n  }\n\n  async del(key: string): Promise<void> {\n    this.cache.delete(key);\n  }\n\n  async delByPattern(pattern: string): Promise<void> {\n    const regex = new RegExp(pattern.replace('*', '.*'));\n    const keysToDelete: string[] = [];\n    \n    for (const key of this.cache.keys()) {\n      if (regex.test(key)) {\n        keysToDelete.push(key);\n      }\n    }\n    \n    for (const key of keysToDelete) {\n      this.cache.delete(key);\n    }\n  }\n\n  async delByTag(tag: string): Promise<void> {\n    const keys = this.tags.get(tag);\n    \n    if (keys) {\n      for (const key of keys) {\n        this.cache.delete(key);\n      }\n      this.tags.delete(tag);\n    }\n  }\n\n  addTag(key: string, tag: string): void {\n    if (!this.tags.has(tag)) {\n      this.tags.set(tag, new Set());\n    }\n    this.tags.get(tag)!.add(key);\n  }\n}\n\n/**\n * Cache instance (singleton)\n */\nlet cacheInstance: ServerCache | null = null;\n\n/**\n * Get cache instance\n */\nexport function getCache(): ServerCache {\n  if (!cacheInstance) {\n    // In production, initialize Redis client here\n    // For now, use in-memory cache as fallback\n    cacheInstance = new InMemoryCache();\n  }\n  \n  return cacheInstance;\n}\n\n/**\n * Cache invalidation helpers\n */\nexport const CacheInvalidation = {\n  /**\n   * Invalidate guest-related caches\n   */\n  async invalidateGuest(guestId: string): Promise<void> {\n    const cache = getCache();\n    await cache.del(CacheKeys.guest(guestId));\n    await cache.del(CacheKeys.guestRSVPs(guestId));\n  },\n\n  /**\n   * Invalidate event-related caches\n   */\n  async invalidateEvent(eventId: string, slug?: string): Promise<void> {\n    const cache = getCache();\n    await cache.del(CacheKeys.event(eventId));\n    if (slug) {\n      await cache.del(CacheKeys.eventBySlug(slug));\n    }\n    await cache.del(CacheKeys.eventActivities(eventId));\n    await cache.delByPattern('events:*');\n  },\n\n  /**\n   * Invalidate activity-related caches\n   */\n  async invalidateActivity(activityId: string, slug?: string): Promise<void> {\n    const cache = getCache();\n    await cache.del(CacheKeys.activity(activityId));\n    if (slug) {\n      await cache.del(CacheKeys.activityBySlug(slug));\n    }\n    await cache.del(CacheKeys.activityRSVPs(activityId));\n    await cache.del(CacheKeys.activityCapacity(activityId));\n    await cache.delByPattern('activities:*');\n  },\n\n  /**\n   * Invalidate RSVP-related caches\n   */\n  async invalidateRSVP(guestId: string, activityId?: string, eventId?: string): Promise<void> {\n    const cache = getCache();\n    await cache.del(CacheKeys.guestRSVPs(guestId));\n    \n    if (activityId) {\n      await cache.del(CacheKeys.activityRSVPs(activityId));\n      await cache.del(CacheKeys.activityCapacity(activityId));\n    }\n    \n    if (eventId) {\n      await cache.del(CacheKeys.eventActivities(eventId));\n    }\n    \n    await cache.del(CacheKeys.rsvpAnalytics());\n    await cache.del(CacheKeys.capacityStats());\n  },\n\n  /**\n   * Invalidate content page caches\n   */\n  async invalidateContentPage(pageId: string, slug?: string): Promise<void> {\n    const cache = getCache();\n    await cache.del(CacheKeys.contentPage(pageId));\n    if (slug) {\n      await cache.del(CacheKeys.contentPageBySlug(slug));\n    }\n    await cache.delByPattern('content_pages:*');\n  },\n\n  /**\n   * Invalidate section caches\n   */\n  async invalidateSections(pageType: string, pageId: string): Promise<void> {\n    const cache = getCache();\n    await cache.del(CacheKeys.pageSections(pageType, pageId));\n  },\n\n  /**\n   * Invalidate photo caches\n   */\n  async invalidatePhotos(pageType?: string, pageId?: string): Promise<void> {\n    const cache = getCache();\n    \n    if (pageType && pageId) {\n      await cache.del(CacheKeys.photosByPage(pageType, pageId));\n    }\n    \n    await cache.delByPattern('photos:*');\n  },\n\n  /**\n   * Invalidate all caches (use sparingly)\n   */\n  async invalidateAll(): Promise<void> {\n    const cache = getCache();\n    await cache.delByPattern('*');\n  },\n};\n\n/**\n * Cache warming helpers\n */\nexport const CacheWarming = {\n  /**\n   * Warm cache for published content pages\n   */\n  async warmContentPages(supabase: any): Promise<void> {\n    const cache = getCache();\n    \n    const { data: pages } = await supabase\n      .from('content_pages')\n      .select('*')\n      .eq('status', 'published');\n    \n    if (pages) {\n      for (const page of pages) {\n        await cache.set(\n          CacheKeys.contentPage(page.id),\n          page,\n          CACHE_TTL.CONTENT_PAGES\n        );\n        \n        if (page.slug) {\n          await cache.set(\n            CacheKeys.contentPageBySlug(page.slug),\n            page,\n            CACHE_TTL.CONTENT_PAGES\n          );\n        }\n      }\n    }\n  },\n\n  /**\n   * Warm cache for active events\n   */\n  async warmEvents(supabase: any): Promise<void> {\n    const cache = getCache();\n    \n    const { data: events } = await supabase\n      .from('events')\n      .select('*')\n      .eq('is_active', true);\n    \n    if (events) {\n      for (const event of events) {\n        await cache.set(\n          CacheKeys.event(event.id),\n          event,\n          CACHE_TTL.EVENTS\n        );\n        \n        if (event.slug) {\n          await cache.set(\n            CacheKeys.eventBySlug(event.slug),\n            event,\n            CACHE_TTL.EVENTS\n          );\n        }\n      }\n    }\n  },\n\n  /**\n   * Warm cache for locations\n   */\n  async warmLocations(supabase: any): Promise<void> {\n    const cache = getCache();\n    \n    const { data: locations } = await supabase\n      .from('locations')\n      .select('*');\n    \n    if (locations) {\n      await cache.set(\n        CacheKeys.locations(),\n        locations,\n        CACHE_TTL.LOCATIONS\n      );\n      \n      for (const location of locations) {\n        await cache.set(\n          CacheKeys.location(location.id),\n          location,\n          CACHE_TTL.LOCATIONS\n        );\n      }\n    }\n  },\n};\n\n/**\n * Client-side caching configuration for React Query\n * \n * Usage in components:\n * \n * import { useQuery } from '@tanstack/react-query';\n * import { CACHE_TTL, CacheKeys } from '@/lib/caching';\n * \n * const { data } = useQuery({\n *   queryKey: [CacheKeys.contentPages('published')],\n *   queryFn: () => fetchContentPages(),\n *   staleTime: CACHE_TTL.CONTENT_PAGES * 1000,\n *   cacheTime: CACHE_TTL.CONTENT_PAGES * 1000 * 2,\n * });\n */\nexport const ReactQueryConfig = {\n  defaultOptions: {\n    queries: {\n      // RSVP data - 5 minutes\n      staleTime: CACHE_TTL.RSVPS * 1000,\n      cacheTime: CACHE_TTL.RSVPS * 1000 * 2,\n      \n      // Retry failed requests\n      retry: 2,\n      retryDelay: (attemptIndex: number) => Math.min(1000 * 2 ** attemptIndex, 30000),\n      \n      // Refetch on window focus for fresh data\n      refetchOnWindowFocus: true,\n      refetchOnReconnect: true,\n      \n      // Don't refetch on mount if data is fresh\n      refetchOnMount: false,\n    },\n    mutations: {\n      // Retry failed mutations\n      retry: 1,\n    },\n  },\n};\n\n/**\n * Caching best practices:\n * \n * 1. Cache frequently accessed data\n * 2. Use appropriate TTL based on data volatility\n * 3. Invalidate cache on mutations\n * 4. Use cache tags for bulk invalidation\n * 5. Warm cache on deployment\n * 6. Monitor cache hit/miss rates\n * 7. Use stale-while-revalidate pattern\n * 8. Implement cache versioning for breaking changes\n * 9. Set cache size limits to prevent memory issues\n * 10. Log cache operations for debugging\n * \n * Performance targets:\n * - Cache hit rate: > 80%\n * - Cache response time: < 10ms\n * - Cache invalidation time: < 100ms\n */\n"],"names":["CACHE_TTL","CacheInvalidation","CacheKeys","CacheTags","CacheWarming","ReactQueryConfig","getCache","RSVPS","GUESTS","ACTIVITIES","EVENTS","CONTENT_PAGES","LOCATIONS","SETTINGS","PHOTOS","ACCOMMODATIONS","RSVP_ANALYTICS","CAPACITY_STATS","guest","id","guestsByGroup","groupId","guestRSVPs","guestId","event","eventBySlug","slug","events","filters","eventActivities","eventId","activity","activityBySlug","activities","activityRSVPs","activityId","activityCapacity","contentPage","contentPageBySlug","contentPages","status","pageSections","pageType","pageId","photo","photos","photosByPage","rsvpAnalytics","capacityStats","settings","location","locations","locationHierarchy","parentId","SECTIONS","ANALYTICS","InMemoryCache","get","key","item","cache","Date","now","expires","delete","value","set","ttl","del","delByPattern","pattern","regex","RegExp","replace","keysToDelete","keys","test","push","delByTag","tag","tags","addTag","has","Set","add","Map","cacheInstance","invalidateGuest","invalidateEvent","invalidateActivity","invalidateRSVP","invalidateContentPage","invalidateSections","invalidatePhotos","invalidateAll","warmContentPages","supabase","data","pages","from","select","eq","page","warmEvents","warmLocations","defaultOptions","queries","staleTime","cacheTime","retry","retryDelay","attemptIndex","Math","min","refetchOnWindowFocus","refetchOnReconnect","refetchOnMount","mutations"],"mappings":"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"}