506ea9f347e628ec6444a84eda7bfc72
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _transportationService = require("./transportationService");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
/**
 * Feature: destination-wedding-platform, Property 29: Vehicle Capacity Calculation
 * 
 * For any transportation manifest with assigned guests, the total guest count
 * should not exceed the combined capacity of assigned vehicles.
 * 
 * Validates: Requirements 20.2
 */ describe('Feature: destination-wedding-platform, Property 29: Vehicle Capacity Calculation', ()=>{
    it('should calculate vehicle requirements that meet or exceed guest count', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(// Generate guest count from 0 to 200
        _fastcheck.integer({
            min: 0,
            max: 200
        }), async (guestCount)=>{
            const result = await (0, _transportationService.calculateVehicleRequirements)(guestCount);
            // Property: Result should be successful
            expect(result.success).toBe(true);
            if (result.success) {
                // Property: Total vehicle capacity should meet or exceed guest count
                const totalCapacity = result.data.reduce((sum, req)=>sum + req.capacity * req.quantity_needed, 0);
                expect(totalCapacity).toBeGreaterThanOrEqual(guestCount);
                // Property: Each vehicle requirement should have positive values
                for (const req of result.data){
                    expect(req.capacity).toBeGreaterThan(0);
                    expect(req.quantity_needed).toBeGreaterThan(0);
                    expect(req.estimated_cost).toBeGreaterThanOrEqual(0);
                }
                // Property: Vehicle types should be valid
                const validTypes = [
                    'sedan',
                    'van',
                    'minibus',
                    'bus'
                ];
                for (const req of result.data){
                    expect(validTypes).toContain(req.vehicle_type);
                }
            }
        }), {
            numRuns: 100
        });
    });
    it('should return empty array for zero guests', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.constant(0), async (guestCount)=>{
            const result = await (0, _transportationService.calculateVehicleRequirements)(guestCount);
            expect(result.success).toBe(true);
            if (result.success) {
                // Property: Zero guests should require no vehicles or minimal vehicles
                const totalVehicles = result.data.reduce((sum, req)=>sum + req.quantity_needed, 0);
                expect(totalVehicles).toBeGreaterThanOrEqual(0);
            }
        }), {
            numRuns: 50
        });
    });
    it('should reject negative guest counts', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.integer({
            min: -100,
            max: -1
        }), async (guestCount)=>{
            const result = await (0, _transportationService.calculateVehicleRequirements)(guestCount);
            // Property: Negative guest counts should return validation error
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('VALIDATION_ERROR');
            }
        }), {
            numRuns: 50
        });
    });
    it('should optimize vehicle allocation efficiently', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.integer({
            min: 1,
            max: 150
        }), async (guestCount)=>{
            const result = await (0, _transportationService.calculateVehicleRequirements)(guestCount);
            expect(result.success).toBe(true);
            if (result.success) {
                // Property: Should not over-allocate by more than one vehicle's capacity
                const totalCapacity = result.data.reduce((sum, req)=>sum + req.capacity * req.quantity_needed, 0);
                // Find the smallest vehicle capacity used
                const smallestCapacity = result.data.length > 0 ? Math.min(...result.data.map((req)=>req.capacity)) : 4; // Default sedan capacity
                // Over-allocation should be less than smallest vehicle capacity
                const overAllocation = totalCapacity - guestCount;
                expect(overAllocation).toBeLessThan(smallestCapacity);
            }
        }), {
            numRuns: 100
        });
    });
    it('should calculate costs proportional to vehicle quantity', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.integer({
            min: 1,
            max: 100
        }), async (guestCount)=>{
            const result = await (0, _transportationService.calculateVehicleRequirements)(guestCount);
            expect(result.success).toBe(true);
            if (result.success) {
                // Property: Cost should be proportional to quantity
                for (const req of result.data){
                    // Cost per vehicle
                    const costPerVehicle = req.estimated_cost / req.quantity_needed;
                    // Should be a positive number
                    expect(costPerVehicle).toBeGreaterThan(0);
                    // Should be consistent (no fractional cents)
                    expect(req.estimated_cost % req.quantity_needed).toBe(0);
                }
                // Property: Total cost should increase with guest count
                const totalCost = result.data.reduce((sum, req)=>sum + req.estimated_cost, 0);
                expect(totalCost).toBeGreaterThan(0);
            }
        }), {
            numRuns: 100
        });
    });
    it('should handle edge case guest counts efficiently', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(// Test exact vehicle capacity boundaries
        _fastcheck.constantFrom(4, 8, 15, 50, 5, 9, 16, 51), async (guestCount)=>{
            const result = await (0, _transportationService.calculateVehicleRequirements)(guestCount);
            expect(result.success).toBe(true);
            if (result.success) {
                const totalCapacity = result.data.reduce((sum, req)=>sum + req.capacity * req.quantity_needed, 0);
                // Property: Should meet capacity exactly or with minimal excess
                expect(totalCapacity).toBeGreaterThanOrEqual(guestCount);
                // Property: Should not waste more than one vehicle worth of capacity
                const wastedCapacity = totalCapacity - guestCount;
                expect(wastedCapacity).toBeLessThan(50); // Max vehicle capacity
            }
        }), {
            numRuns: 100
        });
    });
    it('should maintain consistency across multiple calls with same input', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.integer({
            min: 1,
            max: 100
        }), async (guestCount)=>{
            // Call twice with same input
            const result1 = await (0, _transportationService.calculateVehicleRequirements)(guestCount);
            const result2 = await (0, _transportationService.calculateVehicleRequirements)(guestCount);
            expect(result1.success).toBe(true);
            expect(result2.success).toBe(true);
            if (result1.success && result2.success) {
                // Property: Results should be identical (deterministic)
                expect(result1.data).toEqual(result2.data);
            }
        }), {
            numRuns: 100
        });
    });
    it('should prefer larger vehicles for efficiency', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(// Test with guest counts that could use multiple vehicle types
        _fastcheck.integer({
            min: 20,
            max: 100
        }), async (guestCount)=>{
            const result = await (0, _transportationService.calculateVehicleRequirements)(guestCount);
            expect(result.success).toBe(true);
            if (result.success && result.data.length > 0) {
                // Property: Should use larger vehicles when possible
                // Sort by capacity descending
                const sortedReqs = [
                    ...result.data
                ].sort((a, b)=>b.capacity - a.capacity);
                // If using multiple vehicle types, larger vehicles should be allocated first
                if (sortedReqs.length > 1) {
                    // The largest vehicle type should have the most quantity or be used
                    const largestVehicle = sortedReqs[0];
                    expect(largestVehicle.quantity_needed).toBeGreaterThan(0);
                }
            }
        }), {
            numRuns: 100
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvdmVoaWNsZUNhcGFjaXR5Q2FsY3VsYXRpb24ucHJvcGVydHkudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmYyBmcm9tICdmYXN0LWNoZWNrJztcbmltcG9ydCB7IGNhbGN1bGF0ZVZlaGljbGVSZXF1aXJlbWVudHMgfSBmcm9tICcuL3RyYW5zcG9ydGF0aW9uU2VydmljZSc7XG5cbi8qKlxuICogRmVhdHVyZTogZGVzdGluYXRpb24td2VkZGluZy1wbGF0Zm9ybSwgUHJvcGVydHkgMjk6IFZlaGljbGUgQ2FwYWNpdHkgQ2FsY3VsYXRpb25cbiAqIFxuICogRm9yIGFueSB0cmFuc3BvcnRhdGlvbiBtYW5pZmVzdCB3aXRoIGFzc2lnbmVkIGd1ZXN0cywgdGhlIHRvdGFsIGd1ZXN0IGNvdW50XG4gKiBzaG91bGQgbm90IGV4Y2VlZCB0aGUgY29tYmluZWQgY2FwYWNpdHkgb2YgYXNzaWduZWQgdmVoaWNsZXMuXG4gKiBcbiAqIFZhbGlkYXRlczogUmVxdWlyZW1lbnRzIDIwLjJcbiAqL1xuZGVzY3JpYmUoJ0ZlYXR1cmU6IGRlc3RpbmF0aW9uLXdlZGRpbmctcGxhdGZvcm0sIFByb3BlcnR5IDI5OiBWZWhpY2xlIENhcGFjaXR5IENhbGN1bGF0aW9uJywgKCkgPT4ge1xuICBpdCgnc2hvdWxkIGNhbGN1bGF0ZSB2ZWhpY2xlIHJlcXVpcmVtZW50cyB0aGF0IG1lZXQgb3IgZXhjZWVkIGd1ZXN0IGNvdW50JywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIC8vIEdlbmVyYXRlIGd1ZXN0IGNvdW50IGZyb20gMCB0byAyMDBcbiAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMCwgbWF4OiAyMDAgfSksXG4gICAgICAgIGFzeW5jIChndWVzdENvdW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FsY3VsYXRlVmVoaWNsZVJlcXVpcmVtZW50cyhndWVzdENvdW50KTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBSZXN1bHQgc2hvdWxkIGJlIHN1Y2Nlc3NmdWxcbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG5cbiAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIC8vIFByb3BlcnR5OiBUb3RhbCB2ZWhpY2xlIGNhcGFjaXR5IHNob3VsZCBtZWV0IG9yIGV4Y2VlZCBndWVzdCBjb3VudFxuICAgICAgICAgICAgY29uc3QgdG90YWxDYXBhY2l0eSA9IHJlc3VsdC5kYXRhLnJlZHVjZShcbiAgICAgICAgICAgICAgKHN1bSwgcmVxKSA9PiBzdW0gKyAocmVxLmNhcGFjaXR5ICogcmVxLnF1YW50aXR5X25lZWRlZCksXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGV4cGVjdCh0b3RhbENhcGFjaXR5KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKGd1ZXN0Q291bnQpO1xuXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eTogRWFjaCB2ZWhpY2xlIHJlcXVpcmVtZW50IHNob3VsZCBoYXZlIHBvc2l0aXZlIHZhbHVlc1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXEgb2YgcmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgZXhwZWN0KHJlcS5jYXBhY2l0eSkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgICAgICAgICBleHBlY3QocmVxLnF1YW50aXR5X25lZWRlZCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgICAgICAgICBleHBlY3QocmVxLmVzdGltYXRlZF9jb3N0KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eTogVmVoaWNsZSB0eXBlcyBzaG91bGQgYmUgdmFsaWRcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkVHlwZXMgPSBbJ3NlZGFuJywgJ3ZhbicsICdtaW5pYnVzJywgJ2J1cyddO1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXEgb2YgcmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgZXhwZWN0KHZhbGlkVHlwZXMpLnRvQ29udGFpbihyZXEudmVoaWNsZV90eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCByZXR1cm4gZW1wdHkgYXJyYXkgZm9yIHplcm8gZ3Vlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGZjLmNvbnN0YW50KDApLFxuICAgICAgICBhc3luYyAoZ3Vlc3RDb3VudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhbGN1bGF0ZVZlaGljbGVSZXF1aXJlbWVudHMoZ3Vlc3RDb3VudCk7XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG5cbiAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIC8vIFByb3BlcnR5OiBaZXJvIGd1ZXN0cyBzaG91bGQgcmVxdWlyZSBubyB2ZWhpY2xlcyBvciBtaW5pbWFsIHZlaGljbGVzXG4gICAgICAgICAgICBjb25zdCB0b3RhbFZlaGljbGVzID0gcmVzdWx0LmRhdGEucmVkdWNlKFxuICAgICAgICAgICAgICAoc3VtLCByZXEpID0+IHN1bSArIHJlcS5xdWFudGl0eV9uZWVkZWQsXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBleHBlY3QodG90YWxWZWhpY2xlcykudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDUwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHJlamVjdCBuZWdhdGl2ZSBndWVzdCBjb3VudHMnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogLTEwMCwgbWF4OiAtMSB9KSxcbiAgICAgICAgYXN5bmMgKGd1ZXN0Q291bnQpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWxjdWxhdGVWZWhpY2xlUmVxdWlyZW1lbnRzKGd1ZXN0Q291bnQpO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IE5lZ2F0aXZlIGd1ZXN0IGNvdW50cyBzaG91bGQgcmV0dXJuIHZhbGlkYXRpb24gZXJyb3JcbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuXG4gICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdWQUxJREFUSU9OX0VSUk9SJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiA1MCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBvcHRpbWl6ZSB2ZWhpY2xlIGFsbG9jYXRpb24gZWZmaWNpZW50bHknLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMSwgbWF4OiAxNTAgfSksXG4gICAgICAgIGFzeW5jIChndWVzdENvdW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FsY3VsYXRlVmVoaWNsZVJlcXVpcmVtZW50cyhndWVzdENvdW50KTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcblxuICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgLy8gUHJvcGVydHk6IFNob3VsZCBub3Qgb3Zlci1hbGxvY2F0ZSBieSBtb3JlIHRoYW4gb25lIHZlaGljbGUncyBjYXBhY2l0eVxuICAgICAgICAgICAgY29uc3QgdG90YWxDYXBhY2l0eSA9IHJlc3VsdC5kYXRhLnJlZHVjZShcbiAgICAgICAgICAgICAgKHN1bSwgcmVxKSA9PiBzdW0gKyAocmVxLmNhcGFjaXR5ICogcmVxLnF1YW50aXR5X25lZWRlZCksXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHNtYWxsZXN0IHZlaGljbGUgY2FwYWNpdHkgdXNlZFxuICAgICAgICAgICAgY29uc3Qgc21hbGxlc3RDYXBhY2l0eSA9IHJlc3VsdC5kYXRhLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgPyBNYXRoLm1pbiguLi5yZXN1bHQuZGF0YS5tYXAocmVxID0+IHJlcS5jYXBhY2l0eSkpXG4gICAgICAgICAgICAgIDogNDsgLy8gRGVmYXVsdCBzZWRhbiBjYXBhY2l0eVxuXG4gICAgICAgICAgICAvLyBPdmVyLWFsbG9jYXRpb24gc2hvdWxkIGJlIGxlc3MgdGhhbiBzbWFsbGVzdCB2ZWhpY2xlIGNhcGFjaXR5XG4gICAgICAgICAgICBjb25zdCBvdmVyQWxsb2NhdGlvbiA9IHRvdGFsQ2FwYWNpdHkgLSBndWVzdENvdW50O1xuICAgICAgICAgICAgZXhwZWN0KG92ZXJBbGxvY2F0aW9uKS50b0JlTGVzc1RoYW4oc21hbGxlc3RDYXBhY2l0eSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgY2FsY3VsYXRlIGNvc3RzIHByb3BvcnRpb25hbCB0byB2ZWhpY2xlIHF1YW50aXR5JywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGZjLmludGVnZXIoeyBtaW46IDEsIG1heDogMTAwIH0pLFxuICAgICAgICBhc3luYyAoZ3Vlc3RDb3VudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhbGN1bGF0ZVZlaGljbGVSZXF1aXJlbWVudHMoZ3Vlc3RDb3VudCk7XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG5cbiAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIC8vIFByb3BlcnR5OiBDb3N0IHNob3VsZCBiZSBwcm9wb3J0aW9uYWwgdG8gcXVhbnRpdHlcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVxIG9mIHJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICAgIC8vIENvc3QgcGVyIHZlaGljbGVcbiAgICAgICAgICAgICAgY29uc3QgY29zdFBlclZlaGljbGUgPSByZXEuZXN0aW1hdGVkX2Nvc3QgLyByZXEucXVhbnRpdHlfbmVlZGVkO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gU2hvdWxkIGJlIGEgcG9zaXRpdmUgbnVtYmVyXG4gICAgICAgICAgICAgIGV4cGVjdChjb3N0UGVyVmVoaWNsZSkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gU2hvdWxkIGJlIGNvbnNpc3RlbnQgKG5vIGZyYWN0aW9uYWwgY2VudHMpXG4gICAgICAgICAgICAgIGV4cGVjdChyZXEuZXN0aW1hdGVkX2Nvc3QgJSByZXEucXVhbnRpdHlfbmVlZGVkKS50b0JlKDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eTogVG90YWwgY29zdCBzaG91bGQgaW5jcmVhc2Ugd2l0aCBndWVzdCBjb3VudFxuICAgICAgICAgICAgY29uc3QgdG90YWxDb3N0ID0gcmVzdWx0LmRhdGEucmVkdWNlKFxuICAgICAgICAgICAgICAoc3VtLCByZXEpID0+IHN1bSArIHJlcS5lc3RpbWF0ZWRfY29zdCxcbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGV4cGVjdCh0b3RhbENvc3QpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBoYW5kbGUgZWRnZSBjYXNlIGd1ZXN0IGNvdW50cyBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICAvLyBUZXN0IGV4YWN0IHZlaGljbGUgY2FwYWNpdHkgYm91bmRhcmllc1xuICAgICAgICBmYy5jb25zdGFudEZyb20oNCwgOCwgMTUsIDUwLCA1LCA5LCAxNiwgNTEpLFxuICAgICAgICBhc3luYyAoZ3Vlc3RDb3VudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhbGN1bGF0ZVZlaGljbGVSZXF1aXJlbWVudHMoZ3Vlc3RDb3VudCk7XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG5cbiAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsQ2FwYWNpdHkgPSByZXN1bHQuZGF0YS5yZWR1Y2UoXG4gICAgICAgICAgICAgIChzdW0sIHJlcSkgPT4gc3VtICsgKHJlcS5jYXBhY2l0eSAqIHJlcS5xdWFudGl0eV9uZWVkZWQpLFxuICAgICAgICAgICAgICAwXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eTogU2hvdWxkIG1lZXQgY2FwYWNpdHkgZXhhY3RseSBvciB3aXRoIG1pbmltYWwgZXhjZXNzXG4gICAgICAgICAgICBleHBlY3QodG90YWxDYXBhY2l0eSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbChndWVzdENvdW50KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUHJvcGVydHk6IFNob3VsZCBub3Qgd2FzdGUgbW9yZSB0aGFuIG9uZSB2ZWhpY2xlIHdvcnRoIG9mIGNhcGFjaXR5XG4gICAgICAgICAgICBjb25zdCB3YXN0ZWRDYXBhY2l0eSA9IHRvdGFsQ2FwYWNpdHkgLSBndWVzdENvdW50O1xuICAgICAgICAgICAgZXhwZWN0KHdhc3RlZENhcGFjaXR5KS50b0JlTGVzc1RoYW4oNTApOyAvLyBNYXggdmVoaWNsZSBjYXBhY2l0eVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIG1haW50YWluIGNvbnNpc3RlbmN5IGFjcm9zcyBtdWx0aXBsZSBjYWxscyB3aXRoIHNhbWUgaW5wdXQnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMSwgbWF4OiAxMDAgfSksXG4gICAgICAgIGFzeW5jIChndWVzdENvdW50KSA9PiB7XG4gICAgICAgICAgLy8gQ2FsbCB0d2ljZSB3aXRoIHNhbWUgaW5wdXRcbiAgICAgICAgICBjb25zdCByZXN1bHQxID0gYXdhaXQgY2FsY3VsYXRlVmVoaWNsZVJlcXVpcmVtZW50cyhndWVzdENvdW50KTtcbiAgICAgICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgY2FsY3VsYXRlVmVoaWNsZVJlcXVpcmVtZW50cyhndWVzdENvdW50KTtcblxuICAgICAgICAgIGV4cGVjdChyZXN1bHQxLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdDIuc3VjY2VzcykudG9CZSh0cnVlKTtcblxuICAgICAgICAgIGlmIChyZXN1bHQxLnN1Y2Nlc3MgJiYgcmVzdWx0Mi5zdWNjZXNzKSB7XG4gICAgICAgICAgICAvLyBQcm9wZXJ0eTogUmVzdWx0cyBzaG91bGQgYmUgaWRlbnRpY2FsIChkZXRlcm1pbmlzdGljKVxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdDEuZGF0YSkudG9FcXVhbChyZXN1bHQyLmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHByZWZlciBsYXJnZXIgdmVoaWNsZXMgZm9yIGVmZmljaWVuY3knLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgLy8gVGVzdCB3aXRoIGd1ZXN0IGNvdW50cyB0aGF0IGNvdWxkIHVzZSBtdWx0aXBsZSB2ZWhpY2xlIHR5cGVzXG4gICAgICAgIGZjLmludGVnZXIoeyBtaW46IDIwLCBtYXg6IDEwMCB9KSxcbiAgICAgICAgYXN5bmMgKGd1ZXN0Q291bnQpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWxjdWxhdGVWZWhpY2xlUmVxdWlyZW1lbnRzKGd1ZXN0Q291bnQpO1xuXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuXG4gICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIFByb3BlcnR5OiBTaG91bGQgdXNlIGxhcmdlciB2ZWhpY2xlcyB3aGVuIHBvc3NpYmxlXG4gICAgICAgICAgICAvLyBTb3J0IGJ5IGNhcGFjaXR5IGRlc2NlbmRpbmdcbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZFJlcXMgPSBbLi4ucmVzdWx0LmRhdGFdLnNvcnQoKGEsIGIpID0+IGIuY2FwYWNpdHkgLSBhLmNhcGFjaXR5KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgdXNpbmcgbXVsdGlwbGUgdmVoaWNsZSB0eXBlcywgbGFyZ2VyIHZlaGljbGVzIHNob3VsZCBiZSBhbGxvY2F0ZWQgZmlyc3RcbiAgICAgICAgICAgIGlmIChzb3J0ZWRSZXFzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgLy8gVGhlIGxhcmdlc3QgdmVoaWNsZSB0eXBlIHNob3VsZCBoYXZlIHRoZSBtb3N0IHF1YW50aXR5IG9yIGJlIHVzZWRcbiAgICAgICAgICAgICAgY29uc3QgbGFyZ2VzdFZlaGljbGUgPSBzb3J0ZWRSZXFzWzBdO1xuICAgICAgICAgICAgICBleHBlY3QobGFyZ2VzdFZlaGljbGUucXVhbnRpdHlfbmVlZGVkKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJpdCIsImZjIiwiYXNzZXJ0IiwiYXN5bmNQcm9wZXJ0eSIsImludGVnZXIiLCJtaW4iLCJtYXgiLCJndWVzdENvdW50IiwicmVzdWx0IiwiY2FsY3VsYXRlVmVoaWNsZVJlcXVpcmVtZW50cyIsImV4cGVjdCIsInN1Y2Nlc3MiLCJ0b0JlIiwidG90YWxDYXBhY2l0eSIsImRhdGEiLCJyZWR1Y2UiLCJzdW0iLCJyZXEiLCJjYXBhY2l0eSIsInF1YW50aXR5X25lZWRlZCIsInRvQmVHcmVhdGVyVGhhbk9yRXF1YWwiLCJ0b0JlR3JlYXRlclRoYW4iLCJlc3RpbWF0ZWRfY29zdCIsInZhbGlkVHlwZXMiLCJ0b0NvbnRhaW4iLCJ2ZWhpY2xlX3R5cGUiLCJudW1SdW5zIiwiY29uc3RhbnQiLCJ0b3RhbFZlaGljbGVzIiwiZXJyb3IiLCJjb2RlIiwic21hbGxlc3RDYXBhY2l0eSIsImxlbmd0aCIsIk1hdGgiLCJtYXAiLCJvdmVyQWxsb2NhdGlvbiIsInRvQmVMZXNzVGhhbiIsImNvc3RQZXJWZWhpY2xlIiwidG90YWxDb3N0IiwiY29uc3RhbnRGcm9tIiwid2FzdGVkQ2FwYWNpdHkiLCJyZXN1bHQxIiwicmVzdWx0MiIsInRvRXF1YWwiLCJzb3J0ZWRSZXFzIiwic29ydCIsImEiLCJiIiwibGFyZ2VzdFZlaGljbGUiXSwibWFwcGluZ3MiOiI7Ozs7bUVBQW9CO3VDQUN5Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRTdDOzs7Ozs7O0NBT0MsR0FDREEsU0FBUyxvRkFBb0Y7SUFDM0ZDLEdBQUcseUVBQXlFO1FBQzFFLE1BQU1DLFdBQUdDLE1BQU0sQ0FDYkQsV0FBR0UsYUFBYSxDQUNkLHFDQUFxQztRQUNyQ0YsV0FBR0csT0FBTyxDQUFDO1lBQUVDLEtBQUs7WUFBR0MsS0FBSztRQUFJLElBQzlCLE9BQU9DO1lBQ0wsTUFBTUMsU0FBUyxNQUFNQyxJQUFBQSxtREFBNEIsRUFBQ0Y7WUFFbEQsd0NBQXdDO1lBQ3hDRyxPQUFPRixPQUFPRyxPQUFPLEVBQUVDLElBQUksQ0FBQztZQUU1QixJQUFJSixPQUFPRyxPQUFPLEVBQUU7Z0JBQ2xCLHFFQUFxRTtnQkFDckUsTUFBTUUsZ0JBQWdCTCxPQUFPTSxJQUFJLENBQUNDLE1BQU0sQ0FDdEMsQ0FBQ0MsS0FBS0MsTUFBUUQsTUFBT0MsSUFBSUMsUUFBUSxHQUFHRCxJQUFJRSxlQUFlLEVBQ3ZEO2dCQUdGVCxPQUFPRyxlQUFlTyxzQkFBc0IsQ0FBQ2I7Z0JBRTdDLGlFQUFpRTtnQkFDakUsS0FBSyxNQUFNVSxPQUFPVCxPQUFPTSxJQUFJLENBQUU7b0JBQzdCSixPQUFPTyxJQUFJQyxRQUFRLEVBQUVHLGVBQWUsQ0FBQztvQkFDckNYLE9BQU9PLElBQUlFLGVBQWUsRUFBRUUsZUFBZSxDQUFDO29CQUM1Q1gsT0FBT08sSUFBSUssY0FBYyxFQUFFRixzQkFBc0IsQ0FBQztnQkFDcEQ7Z0JBRUEsMENBQTBDO2dCQUMxQyxNQUFNRyxhQUFhO29CQUFDO29CQUFTO29CQUFPO29CQUFX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