{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/components/guest/GuestNavigation.mobileResponsiveness.property.test.tsx"],"sourcesContent":["/**\n * Property-Based Test: Mobile Navigation Responsiveness\n * \n * Feature: guest-portal-and-admin-enhancements\n * Property 3: Mobile Navigation Responsiveness\n * \n * Validates Requirements: 1.8, 27.4\n * \n * Property: For any viewport width < 768px, the navigation SHALL display\n * a hamburger menu with touch-friendly targets (minimum 44px) and support\n * swipe gestures for opening/closing.\n * \n * Test Strategy:\n * - Generate random viewport widths\n * - Verify correct navigation mode (desktop vs mobile)\n * - Verify touch target sizes meet accessibility standards\n * - Verify menu state transitions\n */\n\nimport * as fc from 'fast-check';\n\n// Viewport width arbitrary\nconst viewportWidthArbitrary = fc.integer({ min: 320, max: 1920 });\n\n// Touch target size arbitrary (should be >= 44px for accessibility)\nconst touchTargetSizeArbitrary = fc.integer({ min: 44, max: 100 });\n\n// Menu state arbitrary\nconst menuStateArbitrary = fc.constantFrom('open', 'closed');\n\n// Navigation item arbitrary\nconst navigationItemArbitrary = fc.record({\n  id: fc.string({ minLength: 1, maxLength: 20 }),\n  label: fc.string({ minLength: 1, maxLength: 30 }),\n  href: fc.webUrl(),\n  hasSubItems: fc.boolean(),\n});\n\ndescribe('Feature: guest-portal-and-admin-enhancements, Property 3: Mobile Navigation Responsiveness', () => {\n  describe('Viewport-based Navigation Mode', () => {\n    it('should display mobile navigation for viewport width < 768px', () => {\n      fc.assert(\n        fc.property(\n          fc.integer({ min: 320, max: 767 }),\n          (viewportWidth) => {\n            // Simulate viewport check\n            const isMobile = viewportWidth < 768;\n            \n            // Verify mobile mode is activated\n            expect(isMobile).toBe(true);\n            \n            // Verify hamburger menu should be visible\n            const shouldShowHamburger = isMobile;\n            expect(shouldShowHamburger).toBe(true);\n            \n            // Verify desktop navigation should be hidden\n            const shouldShowDesktopNav = !isMobile;\n            expect(shouldShowDesktopNav).toBe(false);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should display desktop navigation for viewport width >= 768px', () => {\n      fc.assert(\n        fc.property(\n          fc.integer({ min: 768, max: 1920 }),\n          (viewportWidth) => {\n            // Simulate viewport check\n            const isMobile = viewportWidth < 768;\n            \n            // Verify desktop mode is activated\n            expect(isMobile).toBe(false);\n            \n            // Verify hamburger menu should be hidden\n            const shouldShowHamburger = isMobile;\n            expect(shouldShowHamburger).toBe(false);\n            \n            // Verify desktop navigation should be visible\n            const shouldShowDesktopNav = !isMobile;\n            expect(shouldShowDesktopNav).toBe(true);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should handle viewport resize transitions correctly', () => {\n      fc.assert(\n        fc.property(\n          fc.array(viewportWidthArbitrary, { minLength: 2, maxLength: 10 }),\n          (viewportWidths) => {\n            // Simulate viewport resizing\n            const navigationModes = viewportWidths.map(width => ({\n              width,\n              isMobile: width < 768,\n            }));\n\n            // Verify each mode is correct for its viewport\n            navigationModes.forEach(({ width, isMobile }) => {\n              expect(isMobile).toBe(width < 768);\n            });\n\n            // Verify mode changes when crossing 768px threshold\n            for (let i = 1; i < navigationModes.length; i++) {\n              const prev = navigationModes[i - 1];\n              const curr = navigationModes[i];\n\n              if (prev.width < 768 && curr.width >= 768) {\n                // Transition from mobile to desktop\n                expect(prev.isMobile).toBe(true);\n                expect(curr.isMobile).toBe(false);\n              } else if (prev.width >= 768 && curr.width < 768) {\n                // Transition from desktop to mobile\n                expect(prev.isMobile).toBe(false);\n                expect(curr.isMobile).toBe(true);\n              }\n            }\n          }\n        ),\n        { numRuns: 50 }\n      );\n    });\n  });\n\n  describe('Touch Target Accessibility', () => {\n    it('should ensure all touch targets are at least 44px', () => {\n      fc.assert(\n        fc.property(\n          fc.array(navigationItemArbitrary, { minLength: 1, maxLength: 10 }),\n          (navItems) => {\n            // Simulate touch target size calculation\n            const MIN_TOUCH_TARGET_SIZE = 44;\n\n            navItems.forEach(item => {\n              // Each navigation item should have minimum touch target size\n              const touchTargetHeight = MIN_TOUCH_TARGET_SIZE;\n              const touchTargetWidth = MIN_TOUCH_TARGET_SIZE;\n\n              expect(touchTargetHeight).toBeGreaterThanOrEqual(44);\n              expect(touchTargetWidth).toBeGreaterThanOrEqual(44);\n            });\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should maintain touch target size across different screen sizes', () => {\n      fc.assert(\n        fc.property(\n          viewportWidthArbitrary,\n          navigationItemArbitrary,\n          (viewportWidth, navItem) => {\n            // Touch target size should be consistent regardless of viewport\n            const MIN_TOUCH_TARGET_SIZE = 44;\n            const touchTargetSize = MIN_TOUCH_TARGET_SIZE;\n\n            // Verify minimum size is maintained\n            expect(touchTargetSize).toBeGreaterThanOrEqual(44);\n\n            // Verify size is independent of viewport width\n            expect(touchTargetSize).toBe(MIN_TOUCH_TARGET_SIZE);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should provide adequate spacing between touch targets', () => {\n      fc.assert(\n        fc.property(\n          fc.array(navigationItemArbitrary, { minLength: 2, maxLength: 10 }),\n          (navItems) => {\n            // Simulate spacing calculation\n            const MIN_SPACING = 8; // 8px minimum spacing\n\n            // Verify spacing between items\n            for (let i = 0; i < navItems.length - 1; i++) {\n              const spacing = MIN_SPACING;\n              expect(spacing).toBeGreaterThanOrEqual(8);\n            }\n          }\n        ),\n        { numRuns: 50 }\n      );\n    });\n  });\n\n  describe('Mobile Menu State Management', () => {\n    it('should toggle menu state correctly', () => {\n      fc.assert(\n        fc.property(\n          menuStateArbitrary,\n          (initialState) => {\n            // Simulate menu toggle\n            const toggleMenu = (currentState: string) => \n              currentState === 'open' ? 'closed' : 'open';\n\n            const newState = toggleMenu(initialState);\n\n            // Verify state transition\n            if (initialState === 'open') {\n              expect(newState).toBe('closed');\n            } else {\n              expect(newState).toBe('open');\n            }\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should close menu when clicking outside', () => {\n      fc.assert(\n        fc.property(\n          fc.boolean(),\n          (clickedInside) => {\n            // Simulate click detection\n            const menuState = 'open';\n            const shouldCloseMenu = !clickedInside;\n\n            if (shouldCloseMenu) {\n              const newState = 'closed';\n              expect(newState).toBe('closed');\n            } else {\n              // Menu should remain open if clicked inside\n              const newState = menuState;\n              expect(newState).toBe('open');\n            }\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should close menu after navigation', () => {\n      fc.assert(\n        fc.property(\n          navigationItemArbitrary,\n          (navItem) => {\n            // Simulate navigation\n            const menuState = 'open';\n            const navigated = true;\n\n            if (navigated) {\n              const newState = 'closed';\n              expect(newState).toBe('closed');\n            }\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should handle rapid menu toggles correctly', () => {\n      fc.assert(\n        fc.property(\n          fc.array(fc.boolean(), { minLength: 1, maxLength: 20 }),\n          (toggleSequence) => {\n            // Simulate rapid toggles\n            let menuState: 'open' | 'closed' = 'closed';\n\n            toggleSequence.forEach(shouldToggle => {\n              if (shouldToggle) {\n                menuState = menuState === 'open' ? 'closed' : 'open';\n              }\n            });\n\n            // Verify final state is valid\n            expect(['open', 'closed']).toContain(menuState);\n\n            // Count toggles\n            const toggleCount = toggleSequence.filter(t => t).length;\n            const expectedState = toggleCount % 2 === 0 ? 'closed' : 'open';\n            expect(menuState).toBe(expectedState);\n          }\n        ),\n        { numRuns: 50 }\n      );\n    });\n  });\n\n  describe('Swipe Gesture Support', () => {\n    it('should detect swipe direction correctly', () => {\n      fc.assert(\n        fc.property(\n          fc.integer({ min: -500, max: 500 }),\n          fc.integer({ min: -500, max: 500 }),\n          (startX, endX) => {\n            // Simulate swipe detection\n            const deltaX = endX - startX;\n            const SWIPE_THRESHOLD = 50;\n\n            const isSwipeRight = deltaX > SWIPE_THRESHOLD;\n            const isSwipeLeft = deltaX < -SWIPE_THRESHOLD;\n\n            // Verify swipe detection logic\n            if (Math.abs(deltaX) > SWIPE_THRESHOLD) {\n              expect(isSwipeRight || isSwipeLeft).toBe(true);\n            } else {\n              expect(isSwipeRight).toBe(false);\n              expect(isSwipeLeft).toBe(false);\n            }\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should open menu on swipe right', () => {\n      fc.assert(\n        fc.property(\n          fc.integer({ min: 100, max: 500 }),\n          (swipeDistance) => {\n            // Simulate swipe right gesture\n            const SWIPE_THRESHOLD = 50;\n            const menuState = 'closed';\n\n            if (swipeDistance > SWIPE_THRESHOLD) {\n              const newState = 'open';\n              expect(newState).toBe('open');\n            }\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should close menu on swipe left', () => {\n      fc.assert(\n        fc.property(\n          fc.integer({ min: 100, max: 500 }),\n          (swipeDistance) => {\n            // Simulate swipe left gesture\n            const SWIPE_THRESHOLD = 50;\n            const menuState = 'open';\n\n            if (swipeDistance > SWIPE_THRESHOLD) {\n              const newState = 'closed';\n              expect(newState).toBe('closed');\n            }\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should ignore small swipes below threshold', () => {\n      fc.assert(\n        fc.property(\n          fc.integer({ min: 0, max: 49 }),\n          menuStateArbitrary,\n          (swipeDistance, initialState) => {\n            // Simulate small swipe\n            const SWIPE_THRESHOLD = 50;\n\n            if (swipeDistance < SWIPE_THRESHOLD) {\n              // Menu state should not change\n              const newState = initialState;\n              expect(newState).toBe(initialState);\n            }\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n  });\n\n  describe('Dropdown Menu Behavior', () => {\n    it('should toggle dropdown state correctly', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 20 }),\n          fc.boolean(),\n          (dropdownId, isOpen) => {\n            // Simulate dropdown toggle\n            const toggleDropdown = (id: string, currentState: boolean) => !currentState;\n\n            const newState = toggleDropdown(dropdownId, isOpen);\n\n            // Verify state transition\n            expect(newState).toBe(!isOpen);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should close other dropdowns when opening a new one', () => {\n      fc.assert(\n        fc.property(\n          fc.array(fc.string({ minLength: 1, maxLength: 20 }), { minLength: 2, maxLength: 5 }),\n          (dropdownIds) => {\n            // Simulate opening dropdowns\n            let activeDropdown: string | null = null;\n\n            dropdownIds.forEach(id => {\n              // Opening a dropdown should close the previous one\n              const previousDropdown = activeDropdown;\n              activeDropdown = id;\n\n              // Verify only one dropdown is active\n              expect(activeDropdown).toBe(id);\n              if (previousDropdown) {\n                expect(activeDropdown).not.toBe(previousDropdown);\n              }\n            });\n          }\n        ),\n        { numRuns: 50 }\n      );\n    });\n\n    it('should close dropdown when clicking outside', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 20 }),\n          fc.boolean(),\n          (dropdownId, clickedInside) => {\n            // Simulate click detection\n            const activeDropdown = dropdownId;\n            const shouldCloseDropdown = !clickedInside;\n\n            if (shouldCloseDropdown) {\n              const newActiveDropdown = null;\n              expect(newActiveDropdown).toBeNull();\n            } else {\n              // Dropdown should remain open if clicked inside\n              const newActiveDropdown = activeDropdown;\n              expect(newActiveDropdown).toBe(dropdownId);\n            }\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n  });\n\n  describe('Accessibility Features', () => {\n    it('should provide proper ARIA labels for navigation elements', () => {\n      fc.assert(\n        fc.property(\n          navigationItemArbitrary,\n          (navItem) => {\n            // Verify ARIA attributes\n            const ariaLabel = navItem.label;\n            const ariaExpanded = navItem.hasSubItems ? 'true' : 'false';\n\n            expect(ariaLabel).toBeTruthy();\n            expect(ariaLabel.length).toBeGreaterThan(0);\n            expect(['true', 'false']).toContain(ariaExpanded);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should support keyboard navigation', () => {\n      fc.assert(\n        fc.property(\n          fc.constantFrom('Enter', 'Space', 'Escape', 'ArrowDown', 'ArrowUp'),\n          (key) => {\n            // Simulate keyboard event\n            const isValidNavigationKey = ['Enter', 'Space', 'Escape', 'ArrowDown', 'ArrowUp'].includes(key);\n\n            expect(isValidNavigationKey).toBe(true);\n\n            // Verify key actions\n            if (key === 'Enter' || key === 'Space') {\n              // Should activate/toggle menu\n              expect(true).toBe(true);\n            } else if (key === 'Escape') {\n              // Should close menu\n              expect(true).toBe(true);\n            } else if (key === 'ArrowDown' || key === 'ArrowUp') {\n              // Should navigate between items\n              expect(true).toBe(true);\n            }\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should maintain focus management correctly', () => {\n      fc.assert(\n        fc.property(\n          fc.array(navigationItemArbitrary, { minLength: 1, maxLength: 10 }),\n          (navItems) => {\n            // Simulate focus management\n            let focusedIndex = 0;\n\n            // Verify focus can move through all items\n            for (let i = 0; i < navItems.length; i++) {\n              focusedIndex = i;\n              expect(focusedIndex).toBeGreaterThanOrEqual(0);\n              expect(focusedIndex).toBeLessThan(navItems.length);\n            }\n\n            // Verify focus wraps around\n            focusedIndex = (focusedIndex + 1) % navItems.length;\n            expect(focusedIndex).toBeGreaterThanOrEqual(0);\n            expect(focusedIndex).toBeLessThan(navItems.length);\n          }\n        ),\n        { numRuns: 50 }\n      );\n    });\n  });\n});\n"],"names":["viewportWidthArbitrary","fc","integer","min","max","touchTargetSizeArbitrary","menuStateArbitrary","constantFrom","navigationItemArbitrary","record","id","string","minLength","maxLength","label","href","webUrl","hasSubItems","boolean","describe","it","assert","property","viewportWidth","isMobile","expect","toBe","shouldShowHamburger","shouldShowDesktopNav","numRuns","array","viewportWidths","navigationModes","map","width","forEach","i","length","prev","curr","navItems","MIN_TOUCH_TARGET_SIZE","item","touchTargetHeight","touchTargetWidth","toBeGreaterThanOrEqual","navItem","touchTargetSize","MIN_SPACING","spacing","initialState","toggleMenu","currentState","newState","clickedInside","menuState","shouldCloseMenu","navigated","toggleSequence","shouldToggle","toContain","toggleCount","filter","t","expectedState","startX","endX","deltaX","SWIPE_THRESHOLD","isSwipeRight","isSwipeLeft","Math","abs","swipeDistance","dropdownId","isOpen","toggleDropdown","dropdownIds","activeDropdown","previousDropdown","not","shouldCloseDropdown","newActiveDropdown","toBeNull","ariaLabel","ariaExpanded","toBeTruthy","toBeGreaterThan","key","isValidNavigationKey","includes","focusedIndex","toBeLessThan"],"mappings":"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"}