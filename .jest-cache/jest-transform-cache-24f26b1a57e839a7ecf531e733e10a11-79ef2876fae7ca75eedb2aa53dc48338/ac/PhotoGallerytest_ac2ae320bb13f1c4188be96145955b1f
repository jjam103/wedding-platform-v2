d92ba22f951b7c2fe57ba9f982d61aaf
"use strict";
// Mock Next.js Image component
jest.mock('next/image', ()=>({
        __esModule: true,
        default: ({ src, alt, fill, className, ...props })=>// eslint-disable-next-line @next/next/no-img-element
            /*#__PURE__*/ (0, _jsxruntime.jsx)("img", {
                src: src,
                alt: alt,
                className: className,
                ...props
            })
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = require("@testing-library/react");
const _PhotoGallery = require("./PhotoGallery");
// Mock fetch
global.fetch = jest.fn();
const mockPhotos = [
    {
        id: 'photo-1',
        photo_url: 'https://example.com/photo1.jpg',
        caption: 'Beautiful sunset',
        alt_text: 'Sunset over the ocean'
    },
    {
        id: 'photo-2',
        photo_url: 'https://example.com/photo2.jpg',
        caption: 'Mountain view',
        alt_text: 'Mountains at dawn'
    },
    {
        id: 'photo-3',
        photo_url: 'https://example.com/photo3.jpg',
        caption: 'Beach scene',
        alt_text: 'Sandy beach'
    }
];
describe('PhotoGallery', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        jest.useFakeTimers();
    });
    afterEach(()=>{
        jest.runOnlyPendingTimers();
        jest.useRealTimers();
    });
    describe('Loading State', ()=>{
        it('should show loading skeleton while fetching photos', ()=>{
            global.fetch.mockImplementation(()=>new Promise(()=>{}) // Never resolves
            );
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1'
                ]
            }));
            expect(_react.screen.getByRole('generic')).toHaveClass('animate-pulse');
        });
    });
    describe('Error State', ()=>{
        it('should display error message when fetch fails', async ()=>{
            global.fetch.mockRejectedValue(new Error('Network error'));
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1'
                ]
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByText('Failed to load photos')).toBeInTheDocument();
            });
        });
        it('should handle individual photo fetch failures gracefully', async ()=>{
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockPhotos[0]
                    })
            }).mockResolvedValueOnce({
                ok: false,
                json: async ()=>({
                        success: false
                    })
            });
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1',
                    'photo-2'
                ]
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByAltText('Sunset over the ocean')).toBeInTheDocument();
            });
            // Should only show the successfully fetched photo
            expect(_react.screen.queryByAltText('Mountains at dawn')).not.toBeInTheDocument();
        });
    });
    describe('Empty State', ()=>{
        it('should render nothing when photoIds is empty', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: []
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByRole('img')).not.toBeInTheDocument();
            });
        });
        it('should render nothing when no photoIds provided', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: []
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByRole('img')).not.toBeInTheDocument();
            });
        });
    });
    describe('Gallery Mode', ()=>{
        beforeEach(()=>{
            global.fetch.mockImplementation((url)=>{
                const photoId = url.split('/').pop();
                const photo = mockPhotos.find((p)=>p.id === photoId);
                return Promise.resolve({
                    ok: true,
                    json: async ()=>({
                            success: true,
                            data: photo
                        })
                });
            });
        });
        it('should display photos in grid layout', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1',
                    'photo-2',
                    'photo-3'
                ],
                displayMode: "gallery"
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByAltText('Sunset over the ocean')).toBeInTheDocument();
                expect(_react.screen.getByAltText('Mountains at dawn')).toBeInTheDocument();
                expect(_react.screen.getByAltText('Sandy beach')).toBeInTheDocument();
            });
        });
        it('should display captions for photos', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1'
                ],
                displayMode: "gallery"
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByText('Beautiful sunset')).toBeInTheDocument();
            });
        });
        it('should use alt text when provided', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1'
                ],
                displayMode: "gallery"
            }));
            await (0, _react.waitFor)(()=>{
                const img = _react.screen.getByAltText('Sunset over the ocean');
                expect(img).toBeInTheDocument();
            });
        });
    });
    describe('Carousel Mode', ()=>{
        beforeEach(()=>{
            global.fetch.mockImplementation((url)=>{
                const photoId = url.split('/').pop();
                const photo = mockPhotos.find((p)=>p.id === photoId);
                return Promise.resolve({
                    ok: true,
                    json: async ()=>({
                            success: true,
                            data: photo
                        })
                });
            });
        });
        it('should display first photo initially', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1',
                    'photo-2'
                ],
                displayMode: "carousel"
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByAltText('Sunset over the ocean')).toBeInTheDocument();
            });
            expect(_react.screen.queryByAltText('Mountains at dawn')).not.toBeInTheDocument();
        });
        it('should show navigation buttons when multiple photos', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1',
                    'photo-2'
                ],
                displayMode: "carousel"
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByLabelText('Previous photo')).toBeInTheDocument();
                expect(_react.screen.getByLabelText('Next photo')).toBeInTheDocument();
            });
        });
        it('should navigate to next photo when next button clicked', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1',
                    'photo-2'
                ],
                displayMode: "carousel"
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByAltText('Sunset over the ocean')).toBeInTheDocument();
            });
            const nextButton = _react.screen.getByLabelText('Next photo');
            _react.fireEvent.click(nextButton);
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByAltText('Mountains at dawn')).toBeInTheDocument();
            });
        });
        it('should navigate to previous photo when previous button clicked', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1',
                    'photo-2'
                ],
                displayMode: "carousel"
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByAltText('Sunset over the ocean')).toBeInTheDocument();
            });
            const prevButton = _react.screen.getByLabelText('Previous photo');
            _react.fireEvent.click(prevButton);
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByAltText('Mountains at dawn')).toBeInTheDocument();
            });
        });
        it('should show dot indicators for navigation', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1',
                    'photo-2',
                    'photo-3'
                ],
                displayMode: "carousel"
            }));
            await (0, _react.waitFor)(()=>{
                const dots = _react.screen.getAllByLabelText(/Go to photo \d+/);
                expect(dots).toHaveLength(3);
            });
        });
        it('should navigate to specific photo when dot clicked', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1',
                    'photo-2',
                    'photo-3'
                ],
                displayMode: "carousel"
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByAltText('Sunset over the ocean')).toBeInTheDocument();
            });
            const thirdDot = _react.screen.getByLabelText('Go to photo 3');
            _react.fireEvent.click(thirdDot);
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByAltText('Sandy beach')).toBeInTheDocument();
            });
        });
    });
    describe('Loop Mode', ()=>{
        beforeEach(()=>{
            global.fetch.mockImplementation((url)=>{
                const photoId = url.split('/').pop();
                const photo = mockPhotos.find((p)=>p.id === photoId);
                return Promise.resolve({
                    ok: true,
                    json: async ()=>({
                            success: true,
                            data: photo
                        })
                });
            });
        });
        it('should display first photo initially', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1',
                    'photo-2'
                ],
                displayMode: "loop"
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByAltText('Sunset over the ocean')).toBeInTheDocument();
            });
        });
        it('should auto-advance to next photo after 3 seconds', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1',
                    'photo-2'
                ],
                displayMode: "loop"
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByAltText('Sunset over the ocean')).toBeInTheDocument();
            });
            // Fast-forward 3 seconds
            jest.advanceTimersByTime(3000);
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByAltText('Mountains at dawn')).toBeInTheDocument();
            });
        });
        it('should loop back to first photo after last photo', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1',
                    'photo-2'
                ],
                displayMode: "loop"
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByAltText('Sunset over the ocean')).toBeInTheDocument();
            });
            // Advance through all photos
            jest.advanceTimersByTime(3000); // Photo 2
            jest.advanceTimersByTime(3000); // Back to photo 1
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByAltText('Sunset over the ocean')).toBeInTheDocument();
            });
        });
        it('should show progress indicators', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1',
                    'photo-2',
                    'photo-3'
                ],
                displayMode: "loop"
            }));
            await (0, _react.waitFor)(()=>{
                const indicators = _react.screen.getByRole('generic').querySelectorAll('.h-1');
                expect(indicators).toHaveLength(3);
            });
        });
        it('should not auto-advance with single photo', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1'
                ],
                displayMode: "loop"
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByAltText('Sunset over the ocean')).toBeInTheDocument();
            });
            jest.advanceTimersByTime(5000);
            // Should still show the same photo
            expect(_react.screen.getByAltText('Sunset over the ocean')).toBeInTheDocument();
        });
    });
    describe('Photo Fetching', ()=>{
        it('should fetch photos from correct API endpoint', async ()=>{
            global.fetch.mockResolvedValue({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockPhotos[0]
                    })
            });
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1'
                ]
            }));
            await (0, _react.waitFor)(()=>{
                expect(global.fetch).toHaveBeenCalledWith('/api/admin/photos/photo-1');
            });
        });
        it('should fetch multiple photos in parallel', async ()=>{
            global.fetch.mockResolvedValue({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockPhotos[0]
                    })
            });
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1',
                    'photo-2',
                    'photo-3'
                ]
            }));
            await (0, _react.waitFor)(()=>{
                expect(global.fetch).toHaveBeenCalledTimes(3);
            });
        });
        it('should filter out failed photo fetches', async ()=>{
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockPhotos[0]
                    })
            }).mockResolvedValueOnce({
                ok: false
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockPhotos[2]
                    })
            });
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1',
                    'photo-2',
                    'photo-3'
                ],
                displayMode: "gallery"
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByAltText('Sunset over the ocean')).toBeInTheDocument();
                expect(_react.screen.getByAltText('Sandy beach')).toBeInTheDocument();
            });
            expect(_react.screen.queryByAltText('Mountains at dawn')).not.toBeInTheDocument();
        });
    });
    describe('Accessibility', ()=>{
        beforeEach(()=>{
            global.fetch.mockImplementation((url)=>{
                const photoId = url.split('/').pop();
                const photo = mockPhotos.find((p)=>p.id === photoId);
                return Promise.resolve({
                    ok: true,
                    json: async ()=>({
                            success: true,
                            data: photo
                        })
                });
            });
        });
        it('should have accessible navigation buttons in carousel mode', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1',
                    'photo-2'
                ],
                displayMode: "carousel"
            }));
            await (0, _react.waitFor)(()=>{
                const prevButton = _react.screen.getByLabelText('Previous photo');
                const nextButton = _react.screen.getByLabelText('Next photo');
                expect(prevButton).toBeInTheDocument();
                expect(nextButton).toBeInTheDocument();
            });
        });
        it('should have accessible dot navigation in carousel mode', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1',
                    'photo-2'
                ],
                displayMode: "carousel"
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByLabelText('Go to photo 1')).toBeInTheDocument();
                expect(_react.screen.getByLabelText('Go to photo 2')).toBeInTheDocument();
            });
        });
        it('should use alt text for images', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-1'
                ]
            }));
            await (0, _react.waitFor)(()=>{
                const img = _react.screen.getByAltText('Sunset over the ocean');
                expect(img).toHaveAttribute('alt', 'Sunset over the ocean');
            });
        });
        it('should fallback to caption for alt text when alt_text not provided', async ()=>{
            const photoWithoutAlt = {
                id: 'photo-4',
                photo_url: 'https://example.com/photo4.jpg',
                caption: 'Test caption'
            };
            global.fetch.mockResolvedValue({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: photoWithoutAlt
                    })
            });
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_PhotoGallery.PhotoGallery, {
                photoIds: [
                    'photo-4'
                ]
            }));
            await (0, _react.waitFor)(()=>{
                const img = _react.screen.getByAltText('Test caption');
                expect(img).toBeInTheDocument();
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvY29tcG9uZW50cy9ndWVzdC9QaG90b0dhbGxlcnkudGVzdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVuZGVyLCBzY3JlZW4sIHdhaXRGb3IsIGZpcmVFdmVudCB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xuaW1wb3J0IHsgUGhvdG9HYWxsZXJ5IH0gZnJvbSAnLi9QaG90b0dhbGxlcnknO1xuXG4vLyBNb2NrIE5leHQuanMgSW1hZ2UgY29tcG9uZW50XG5qZXN0Lm1vY2soJ25leHQvaW1hZ2UnLCAoKSA9PiAoe1xuICBfX2VzTW9kdWxlOiB0cnVlLFxuICBkZWZhdWx0OiAoeyBzcmMsIGFsdCwgZmlsbCwgY2xhc3NOYW1lLCAuLi5wcm9wcyB9OiBhbnkpID0+IChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQG5leHQvbmV4dC9uby1pbWctZWxlbWVudFxuICAgIDxpbWcgc3JjPXtzcmN9IGFsdD17YWx0fSBjbGFzc05hbWU9e2NsYXNzTmFtZX0gey4uLnByb3BzfSAvPlxuICApLFxufSkpO1xuXG4vLyBNb2NrIGZldGNoXG5nbG9iYWwuZmV0Y2ggPSBqZXN0LmZuKCk7XG5cbmNvbnN0IG1vY2tQaG90b3MgPSBbXG4gIHtcbiAgICBpZDogJ3Bob3RvLTEnLFxuICAgIHBob3RvX3VybDogJ2h0dHBzOi8vZXhhbXBsZS5jb20vcGhvdG8xLmpwZycsXG4gICAgY2FwdGlvbjogJ0JlYXV0aWZ1bCBzdW5zZXQnLFxuICAgIGFsdF90ZXh0OiAnU3Vuc2V0IG92ZXIgdGhlIG9jZWFuJyxcbiAgfSxcbiAge1xuICAgIGlkOiAncGhvdG8tMicsXG4gICAgcGhvdG9fdXJsOiAnaHR0cHM6Ly9leGFtcGxlLmNvbS9waG90bzIuanBnJyxcbiAgICBjYXB0aW9uOiAnTW91bnRhaW4gdmlldycsXG4gICAgYWx0X3RleHQ6ICdNb3VudGFpbnMgYXQgZGF3bicsXG4gIH0sXG4gIHtcbiAgICBpZDogJ3Bob3RvLTMnLFxuICAgIHBob3RvX3VybDogJ2h0dHBzOi8vZXhhbXBsZS5jb20vcGhvdG8zLmpwZycsXG4gICAgY2FwdGlvbjogJ0JlYWNoIHNjZW5lJyxcbiAgICBhbHRfdGV4dDogJ1NhbmR5IGJlYWNoJyxcbiAgfSxcbl07XG5cbmRlc2NyaWJlKCdQaG90b0dhbGxlcnknLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIGplc3QudXNlRmFrZVRpbWVycygpO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGplc3QucnVuT25seVBlbmRpbmdUaW1lcnMoKTtcbiAgICBqZXN0LnVzZVJlYWxUaW1lcnMoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0xvYWRpbmcgU3RhdGUnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzaG93IGxvYWRpbmcgc2tlbGV0b24gd2hpbGUgZmV0Y2hpbmcgcGhvdG9zJywgKCkgPT4ge1xuICAgICAgKGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spLm1vY2tJbXBsZW1lbnRhdGlvbihcbiAgICAgICAgKCkgPT4gbmV3IFByb21pc2UoKCkgPT4ge30pIC8vIE5ldmVyIHJlc29sdmVzXG4gICAgICApO1xuXG4gICAgICByZW5kZXIoPFBob3RvR2FsbGVyeSBwaG90b0lkcz17WydwaG90by0xJ119IC8+KTtcblxuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVJvbGUoJ2dlbmVyaWMnKSkudG9IYXZlQ2xhc3MoJ2FuaW1hdGUtcHVsc2UnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIFN0YXRlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZGlzcGxheSBlcnJvciBtZXNzYWdlIHdoZW4gZmV0Y2ggZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdOZXR3b3JrIGVycm9yJykpO1xuXG4gICAgICByZW5kZXIoPFBob3RvR2FsbGVyeSBwaG90b0lkcz17WydwaG90by0xJ119IC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdGYWlsZWQgdG8gbG9hZCBwaG90b3MnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgaW5kaXZpZHVhbCBwaG90byBmZXRjaCBmYWlsdXJlcyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgKGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IG1vY2tQaG90b3NbMF0gfSksXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiBmYWxzZSB9KSxcbiAgICAgICAgfSk7XG5cbiAgICAgIHJlbmRlcig8UGhvdG9HYWxsZXJ5IHBob3RvSWRzPXtbJ3Bob3RvLTEnLCAncGhvdG8tMiddfSAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5QWx0VGV4dCgnU3Vuc2V0IG92ZXIgdGhlIG9jZWFuJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2hvdWxkIG9ubHkgc2hvdyB0aGUgc3VjY2Vzc2Z1bGx5IGZldGNoZWQgcGhvdG9cbiAgICAgIGV4cGVjdChzY3JlZW4ucXVlcnlCeUFsdFRleHQoJ01vdW50YWlucyBhdCBkYXduJykpLm5vdC50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRW1wdHkgU3RhdGUnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZW5kZXIgbm90aGluZyB3aGVuIHBob3RvSWRzIGlzIGVtcHR5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxQaG90b0dhbGxlcnkgcGhvdG9JZHM9e1tdfSAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlSb2xlKCdpbWcnKSkubm90LnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVuZGVyIG5vdGhpbmcgd2hlbiBubyBwaG90b0lkcyBwcm92aWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8UGhvdG9HYWxsZXJ5IHBob3RvSWRzPXtbXX0gLz4pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5Um9sZSgnaW1nJykpLm5vdC50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdHYWxsZXJ5IE1vZGUnLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja0ltcGxlbWVudGF0aW9uKCh1cmw6IHN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCBwaG90b0lkID0gdXJsLnNwbGl0KCcvJykucG9wKCk7XG4gICAgICAgIGNvbnN0IHBob3RvID0gbW9ja1Bob3Rvcy5maW5kKChwKSA9PiBwLmlkID09PSBwaG90b0lkKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcGhvdG8gfSksXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRpc3BsYXkgcGhvdG9zIGluIGdyaWQgbGF5b3V0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxQaG90b0dhbGxlcnkgcGhvdG9JZHM9e1sncGhvdG8tMScsICdwaG90by0yJywgJ3Bob3RvLTMnXX0gZGlzcGxheU1vZGU9XCJnYWxsZXJ5XCIgLz4pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeUFsdFRleHQoJ1N1bnNldCBvdmVyIHRoZSBvY2VhbicpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5QWx0VGV4dCgnTW91bnRhaW5zIGF0IGRhd24nKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeUFsdFRleHQoJ1NhbmR5IGJlYWNoJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGlzcGxheSBjYXB0aW9ucyBmb3IgcGhvdG9zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxQaG90b0dhbGxlcnkgcGhvdG9JZHM9e1sncGhvdG8tMSddfSBkaXNwbGF5TW9kZT1cImdhbGxlcnlcIiAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnQmVhdXRpZnVsIHN1bnNldCcpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHVzZSBhbHQgdGV4dCB3aGVuIHByb3ZpZGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxQaG90b0dhbGxlcnkgcGhvdG9JZHM9e1sncGhvdG8tMSddfSBkaXNwbGF5TW9kZT1cImdhbGxlcnlcIiAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBjb25zdCBpbWcgPSBzY3JlZW4uZ2V0QnlBbHRUZXh0KCdTdW5zZXQgb3ZlciB0aGUgb2NlYW4nKTtcbiAgICAgICAgZXhwZWN0KGltZykudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ2Fyb3VzZWwgTW9kZScsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrSW1wbGVtZW50YXRpb24oKHVybDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHBob3RvSWQgPSB1cmwuc3BsaXQoJy8nKS5wb3AoKTtcbiAgICAgICAgY29uc3QgcGhvdG8gPSBtb2NrUGhvdG9zLmZpbmQoKHApID0+IHAuaWQgPT09IHBob3RvSWQpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBwaG90byB9KSxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGlzcGxheSBmaXJzdCBwaG90byBpbml0aWFsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFBob3RvR2FsbGVyeSBwaG90b0lkcz17WydwaG90by0xJywgJ3Bob3RvLTInXX0gZGlzcGxheU1vZGU9XCJjYXJvdXNlbFwiIC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlBbHRUZXh0KCdTdW5zZXQgb3ZlciB0aGUgb2NlYW4nKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlBbHRUZXh0KCdNb3VudGFpbnMgYXQgZGF3bicpKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc2hvdyBuYXZpZ2F0aW9uIGJ1dHRvbnMgd2hlbiBtdWx0aXBsZSBwaG90b3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFBob3RvR2FsbGVyeSBwaG90b0lkcz17WydwaG90by0xJywgJ3Bob3RvLTInXX0gZGlzcGxheU1vZGU9XCJjYXJvdXNlbFwiIC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlMYWJlbFRleHQoJ1ByZXZpb3VzIHBob3RvJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlMYWJlbFRleHQoJ05leHQgcGhvdG8nKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBuYXZpZ2F0ZSB0byBuZXh0IHBob3RvIHdoZW4gbmV4dCBidXR0b24gY2xpY2tlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8UGhvdG9HYWxsZXJ5IHBob3RvSWRzPXtbJ3Bob3RvLTEnLCAncGhvdG8tMiddfSBkaXNwbGF5TW9kZT1cImNhcm91c2VsXCIgLz4pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeUFsdFRleHQoJ1N1bnNldCBvdmVyIHRoZSBvY2VhbicpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG5leHRCdXR0b24gPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoJ05leHQgcGhvdG8nKTtcbiAgICAgIGZpcmVFdmVudC5jbGljayhuZXh0QnV0dG9uKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlBbHRUZXh0KCdNb3VudGFpbnMgYXQgZGF3bicpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG5hdmlnYXRlIHRvIHByZXZpb3VzIHBob3RvIHdoZW4gcHJldmlvdXMgYnV0dG9uIGNsaWNrZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFBob3RvR2FsbGVyeSBwaG90b0lkcz17WydwaG90by0xJywgJ3Bob3RvLTInXX0gZGlzcGxheU1vZGU9XCJjYXJvdXNlbFwiIC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlBbHRUZXh0KCdTdW5zZXQgb3ZlciB0aGUgb2NlYW4nKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBwcmV2QnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KCdQcmV2aW91cyBwaG90bycpO1xuICAgICAgZmlyZUV2ZW50LmNsaWNrKHByZXZCdXR0b24pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeUFsdFRleHQoJ01vdW50YWlucyBhdCBkYXduJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc2hvdyBkb3QgaW5kaWNhdG9ycyBmb3IgbmF2aWdhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8UGhvdG9HYWxsZXJ5IHBob3RvSWRzPXtbJ3Bob3RvLTEnLCAncGhvdG8tMicsICdwaG90by0zJ119IGRpc3BsYXlNb2RlPVwiY2Fyb3VzZWxcIiAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBjb25zdCBkb3RzID0gc2NyZWVuLmdldEFsbEJ5TGFiZWxUZXh0KC9HbyB0byBwaG90byBcXGQrLyk7XG4gICAgICAgIGV4cGVjdChkb3RzKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbmF2aWdhdGUgdG8gc3BlY2lmaWMgcGhvdG8gd2hlbiBkb3QgY2xpY2tlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8UGhvdG9HYWxsZXJ5IHBob3RvSWRzPXtbJ3Bob3RvLTEnLCAncGhvdG8tMicsICdwaG90by0zJ119IGRpc3BsYXlNb2RlPVwiY2Fyb3VzZWxcIiAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5QWx0VGV4dCgnU3Vuc2V0IG92ZXIgdGhlIG9jZWFuJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdGhpcmREb3QgPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoJ0dvIHRvIHBob3RvIDMnKTtcbiAgICAgIGZpcmVFdmVudC5jbGljayh0aGlyZERvdCk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5QWx0VGV4dCgnU2FuZHkgYmVhY2gnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTG9vcCBNb2RlJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgKGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spLm1vY2tJbXBsZW1lbnRhdGlvbigodXJsOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgcGhvdG9JZCA9IHVybC5zcGxpdCgnLycpLnBvcCgpO1xuICAgICAgICBjb25zdCBwaG90byA9IG1vY2tQaG90b3MuZmluZCgocCkgPT4gcC5pZCA9PT0gcGhvdG9JZCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHBob3RvIH0pLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBkaXNwbGF5IGZpcnN0IHBob3RvIGluaXRpYWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8UGhvdG9HYWxsZXJ5IHBob3RvSWRzPXtbJ3Bob3RvLTEnLCAncGhvdG8tMiddfSBkaXNwbGF5TW9kZT1cImxvb3BcIiAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5QWx0VGV4dCgnU3Vuc2V0IG92ZXIgdGhlIG9jZWFuJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYXV0by1hZHZhbmNlIHRvIG5leHQgcGhvdG8gYWZ0ZXIgMyBzZWNvbmRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxQaG90b0dhbGxlcnkgcGhvdG9JZHM9e1sncGhvdG8tMScsICdwaG90by0yJ119IGRpc3BsYXlNb2RlPVwibG9vcFwiIC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlBbHRUZXh0KCdTdW5zZXQgb3ZlciB0aGUgb2NlYW4nKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBGYXN0LWZvcndhcmQgMyBzZWNvbmRzXG4gICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMzAwMCk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5QWx0VGV4dCgnTW91bnRhaW5zIGF0IGRhd24nKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBsb29wIGJhY2sgdG8gZmlyc3QgcGhvdG8gYWZ0ZXIgbGFzdCBwaG90bycsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8UGhvdG9HYWxsZXJ5IHBob3RvSWRzPXtbJ3Bob3RvLTEnLCAncGhvdG8tMiddfSBkaXNwbGF5TW9kZT1cImxvb3BcIiAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5QWx0VGV4dCgnU3Vuc2V0IG92ZXIgdGhlIG9jZWFuJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQWR2YW5jZSB0aHJvdWdoIGFsbCBwaG90b3NcbiAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgzMDAwKTsgLy8gUGhvdG8gMlxuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDMwMDApOyAvLyBCYWNrIHRvIHBob3RvIDFcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlBbHRUZXh0KCdTdW5zZXQgb3ZlciB0aGUgb2NlYW4nKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzaG93IHByb2dyZXNzIGluZGljYXRvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFBob3RvR2FsbGVyeSBwaG90b0lkcz17WydwaG90by0xJywgJ3Bob3RvLTInLCAncGhvdG8tMyddfSBkaXNwbGF5TW9kZT1cImxvb3BcIiAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBjb25zdCBpbmRpY2F0b3JzID0gc2NyZWVuLmdldEJ5Um9sZSgnZ2VuZXJpYycpLnF1ZXJ5U2VsZWN0b3JBbGwoJy5oLTEnKTtcbiAgICAgICAgZXhwZWN0KGluZGljYXRvcnMpLnRvSGF2ZUxlbmd0aCgzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBub3QgYXV0by1hZHZhbmNlIHdpdGggc2luZ2xlIHBob3RvJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxQaG90b0dhbGxlcnkgcGhvdG9JZHM9e1sncGhvdG8tMSddfSBkaXNwbGF5TW9kZT1cImxvb3BcIiAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5QWx0VGV4dCgnU3Vuc2V0IG92ZXIgdGhlIG9jZWFuJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDUwMDApO1xuXG4gICAgICAvLyBTaG91bGQgc3RpbGwgc2hvdyB0aGUgc2FtZSBwaG90b1xuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeUFsdFRleHQoJ1N1bnNldCBvdmVyIHRoZSBvY2VhbicpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUGhvdG8gRmV0Y2hpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBmZXRjaCBwaG90b3MgZnJvbSBjb3JyZWN0IEFQSSBlbmRwb2ludCcsIGFzeW5jICgpID0+IHtcbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBtb2NrUGhvdG9zWzBdIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIHJlbmRlcig8UGhvdG9HYWxsZXJ5IHBob3RvSWRzPXtbJ3Bob3RvLTEnXX0gLz4pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KGdsb2JhbC5mZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJy9hcGkvYWRtaW4vcGhvdG9zL3Bob3RvLTEnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBmZXRjaCBtdWx0aXBsZSBwaG90b3MgaW4gcGFyYWxsZWwnLCBhc3luYyAoKSA9PiB7XG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogbW9ja1Bob3Rvc1swXSB9KSxcbiAgICAgIH0pO1xuXG4gICAgICByZW5kZXIoPFBob3RvR2FsbGVyeSBwaG90b0lkcz17WydwaG90by0xJywgJ3Bob3RvLTInLCAncGhvdG8tMyddfSAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QoZ2xvYmFsLmZldGNoKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZmlsdGVyIG91dCBmYWlsZWQgcGhvdG8gZmV0Y2hlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBtb2NrUGhvdG9zWzBdIH0pLFxuICAgICAgICB9KVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IG1vY2tQaG90b3NbMl0gfSksXG4gICAgICAgIH0pO1xuXG4gICAgICByZW5kZXIoPFBob3RvR2FsbGVyeSBwaG90b0lkcz17WydwaG90by0xJywgJ3Bob3RvLTInLCAncGhvdG8tMyddfSBkaXNwbGF5TW9kZT1cImdhbGxlcnlcIiAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5QWx0VGV4dCgnU3Vuc2V0IG92ZXIgdGhlIG9jZWFuJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlBbHRUZXh0KCdTYW5keSBiZWFjaCcpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChzY3JlZW4ucXVlcnlCeUFsdFRleHQoJ01vdW50YWlucyBhdCBkYXduJykpLm5vdC50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQWNjZXNzaWJpbGl0eScsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrSW1wbGVtZW50YXRpb24oKHVybDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHBob3RvSWQgPSB1cmwuc3BsaXQoJy8nKS5wb3AoKTtcbiAgICAgICAgY29uc3QgcGhvdG8gPSBtb2NrUGhvdG9zLmZpbmQoKHApID0+IHAuaWQgPT09IHBob3RvSWQpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBwaG90byB9KSxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGF2ZSBhY2Nlc3NpYmxlIG5hdmlnYXRpb24gYnV0dG9ucyBpbiBjYXJvdXNlbCBtb2RlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxQaG90b0dhbGxlcnkgcGhvdG9JZHM9e1sncGhvdG8tMScsICdwaG90by0yJ119IGRpc3BsYXlNb2RlPVwiY2Fyb3VzZWxcIiAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBjb25zdCBwcmV2QnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KCdQcmV2aW91cyBwaG90bycpO1xuICAgICAgICBjb25zdCBuZXh0QnV0dG9uID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KCdOZXh0IHBob3RvJyk7XG4gICAgICAgIGV4cGVjdChwcmV2QnV0dG9uKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgICBleHBlY3QobmV4dEJ1dHRvbikudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYXZlIGFjY2Vzc2libGUgZG90IG5hdmlnYXRpb24gaW4gY2Fyb3VzZWwgbW9kZScsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8UGhvdG9HYWxsZXJ5IHBob3RvSWRzPXtbJ3Bob3RvLTEnLCAncGhvdG8tMiddfSBkaXNwbGF5TW9kZT1cImNhcm91c2VsXCIgLz4pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgnR28gdG8gcGhvdG8gMScpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5TGFiZWxUZXh0KCdHbyB0byBwaG90byAyJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdXNlIGFsdCB0ZXh0IGZvciBpbWFnZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPFBob3RvR2FsbGVyeSBwaG90b0lkcz17WydwaG90by0xJ119IC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGltZyA9IHNjcmVlbi5nZXRCeUFsdFRleHQoJ1N1bnNldCBvdmVyIHRoZSBvY2VhbicpO1xuICAgICAgICBleHBlY3QoaW1nKS50b0hhdmVBdHRyaWJ1dGUoJ2FsdCcsICdTdW5zZXQgb3ZlciB0aGUgb2NlYW4nKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBmYWxsYmFjayB0byBjYXB0aW9uIGZvciBhbHQgdGV4dCB3aGVuIGFsdF90ZXh0IG5vdCBwcm92aWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBob3RvV2l0aG91dEFsdCA9IHtcbiAgICAgICAgaWQ6ICdwaG90by00JyxcbiAgICAgICAgcGhvdG9fdXJsOiAnaHR0cHM6Ly9leGFtcGxlLmNvbS9waG90bzQuanBnJyxcbiAgICAgICAgY2FwdGlvbjogJ1Rlc3QgY2FwdGlvbicsXG4gICAgICB9O1xuXG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcGhvdG9XaXRob3V0QWx0IH0pLFxuICAgICAgfSk7XG5cbiAgICAgIHJlbmRlcig8UGhvdG9HYWxsZXJ5IHBob3RvSWRzPXtbJ3Bob3RvLTQnXX0gLz4pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgY29uc3QgaW1nID0gc2NyZWVuLmdldEJ5QWx0VGV4dCgnVGVzdCBjYXB0aW9uJyk7XG4gICAgICAgIGV4cGVjdChpbWcpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0Iiwic3JjIiwiYWx0IiwiZmlsbCIsImNsYXNzTmFtZSIsInByb3BzIiwiaW1nIiwiZ2xvYmFsIiwiZmV0Y2giLCJmbiIsIm1vY2tQaG90b3MiLCJpZCIsInBob3RvX3VybCIsImNhcHRpb24iLCJhbHRfdGV4dCIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJ1c2VGYWtlVGltZXJzIiwiYWZ0ZXJFYWNoIiwicnVuT25seVBlbmRpbmdUaW1lcnMiLCJ1c2VSZWFsVGltZXJzIiwiaXQiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJQcm9taXNlIiwicmVuZGVyIiwiUGhvdG9HYWxsZXJ5IiwicGhvdG9JZHMiLCJleHBlY3QiLCJzY3JlZW4iLCJnZXRCeVJvbGUiLCJ0b0hhdmVDbGFzcyIsIm1vY2tSZWplY3RlZFZhbHVlIiwiRXJyb3IiLCJ3YWl0Rm9yIiwiZ2V0QnlUZXh0IiwidG9CZUluVGhlRG9jdW1lbnQiLCJtb2NrUmVzb2x2ZWRWYWx1ZU9uY2UiLCJvayIsImpzb24iLCJzdWNjZXNzIiwiZGF0YSIsImdldEJ5QWx0VGV4dCIsInF1ZXJ5QnlBbHRUZXh0Iiwibm90IiwicXVlcnlCeVJvbGUiLCJ1cmwiLCJwaG90b0lkIiwic3BsaXQiLCJwb3AiLCJwaG90byIsImZpbmQiLCJwIiwicmVzb2x2ZSIsImRpc3BsYXlNb2RlIiwiZ2V0QnlMYWJlbFRleHQiLCJuZXh0QnV0dG9uIiwiZmlyZUV2ZW50IiwiY2xpY2siLCJwcmV2QnV0dG9uIiwiZG90cyIsImdldEFsbEJ5TGFiZWxUZXh0IiwidG9IYXZlTGVuZ3RoIiwidGhpcmREb3QiLCJhZHZhbmNlVGltZXJzQnlUaW1lIiwiaW5kaWNhdG9ycyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwidG9IYXZlQmVlbkNhbGxlZFRpbWVzIiwidG9IYXZlQXR0cmlidXRlIiwicGhvdG9XaXRob3V0QWx0Il0sIm1hcHBpbmdzIjoiO0FBR0EsK0JBQStCO0FBQy9CQSxLQUFLQyxJQUFJLENBQUMsY0FBYyxJQUFPLENBQUE7UUFDN0JDLFlBQVk7UUFDWkMsU0FBUyxDQUFDLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxJQUFJLEVBQUVDLFNBQVMsRUFBRSxHQUFHQyxPQUFZLEdBQ3BELHFEQUFxRDswQkFDckQscUJBQUNDO2dCQUFJ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