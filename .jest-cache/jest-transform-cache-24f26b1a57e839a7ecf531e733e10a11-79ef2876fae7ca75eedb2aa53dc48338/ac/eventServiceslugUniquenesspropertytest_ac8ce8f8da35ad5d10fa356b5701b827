3feb90d1c86b7924da9702f405b15744
/**
 * Property-Based Tests for Event Service Slug Uniqueness
 * 
 * **Property 24: Slug Uniqueness**
 * **Validates: Requirements 24.3, 24.4, 24.5**
 * 
 * Tests that slugs are unique across all events and conflicts are resolved with numeric suffixes.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _eventService = require("./eventService");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('Feature: guest-portal-and-admin-enhancements, Property 24: Slug Uniqueness', ()=>{
    // Clean up test events after each test
    const createdEventIds = [];
    afterEach(async ()=>{
        // Clean up all created events
        for (const id of createdEventIds){
            await (0, _eventService.deleteEvent)(id);
        }
        createdEventIds.length = 0;
    });
    /**
   * Property: Creating multiple events with the same name generates unique slugs
   * 
   * When multiple events have the same name, the system should append numeric
   * suffixes (-2, -3, etc.) to ensure uniqueness.
   */ it('should generate unique slugs for events with duplicate names', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.string({
            minLength: 3,
            maxLength: 30
        }).filter((s)=>/[a-zA-Z0-9]/.test(s)), _fastcheck.integer({
            min: 2,
            max: 5
        }), _fastcheck.date(), async (baseName, count, startDate)=>{
            const slugs = new Set();
            // Create multiple events with the same name
            for(let i = 0; i < count; i++){
                const result = await (0, _eventService.create)({
                    name: baseName,
                    eventType: 'ceremony',
                    startDate: new Date(startDate.getTime() + i * 3600000).toISOString()
                });
                if (!result.success) {
                    continue;
                }
                createdEventIds.push(result.data.id);
                const slug = result.data.slug;
                // Each slug must be unique
                expect(slugs.has(slug)).toBe(false);
                slugs.add(slug);
                // First event should have base slug, subsequent should have -2, -3, etc.
                if (i === 0) {
                    expect(slug).not.toMatch(/-\d+$/);
                } else {
                    expect(slug).toMatch(/-\d+$/);
                }
            }
            // Verify we got the expected number of unique slugs
            expect(slugs.size).toBe(count);
            return true;
        }), {
            numRuns: 20
        });
    });
    /**
   * Property: Slug uniqueness is maintained across different event types
   */ it('should ensure slug uniqueness across all event types', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.string({
            minLength: 3,
            maxLength: 30
        }).filter((s)=>/[a-zA-Z0-9]/.test(s)), _fastcheck.date(), async (name, startDate)=>{
            const eventTypes = [
                'ceremony',
                'reception',
                'meal',
                'transport',
                'activity'
            ];
            const slugs = new Set();
            // Create events with same name but different types
            for (const eventType of eventTypes){
                const result = await (0, _eventService.create)({
                    name,
                    eventType,
                    startDate: startDate.toISOString()
                });
                if (!result.success) {
                    continue;
                }
                createdEventIds.push(result.data.id);
                const slug = result.data.slug;
                // Each slug must be unique even across different event types
                expect(slugs.has(slug)).toBe(false);
                slugs.add(slug);
            }
            return true;
        }), {
            numRuns: 15
        });
    });
    /**
   * Property: Numeric suffix increments correctly for multiple duplicates
   */ it('should increment numeric suffixes correctly for multiple duplicates', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.string({
            minLength: 3,
            maxLength: 20
        }).filter((s)=>/[a-zA-Z0-9]/.test(s)), _fastcheck.date(), async (name, startDate)=>{
            const events = [];
            // Create 5 events with the same name
            for(let i = 0; i < 5; i++){
                const result = await (0, _eventService.create)({
                    name,
                    eventType: 'ceremony',
                    startDate: new Date(startDate.getTime() + i * 3600000).toISOString()
                });
                if (!result.success) {
                    continue;
                }
                createdEventIds.push(result.data.id);
                events.push({
                    id: result.data.id,
                    slug: result.data.slug
                });
            }
            if (events.length < 2) {
                return true; // Skip if we couldn't create enough events
            }
            // Verify slug pattern
            const baseSlug = events[0].slug;
            expect(baseSlug).not.toMatch(/-\d+$/);
            for(let i = 1; i < events.length; i++){
                const expectedSuffix = i + 1;
                expect(events[i].slug).toBe(`${baseSlug}-${expectedSuffix}`);
            }
            return true;
        }), {
            numRuns: 10
        });
    });
    /**
   * Property: Slug uniqueness handles edge cases with similar names
   */ it('should maintain uniqueness for names that differ only in special characters', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.string({
            minLength: 3,
            maxLength: 20
        }).filter((s)=>/[a-zA-Z0-9]/.test(s)), _fastcheck.constantFrom('!', '@', '#', '-', '_', ' '), _fastcheck.date(), async (baseName, separator, startDate)=>{
            const names = [
                baseName,
                `${baseName}${separator}${baseName}`,
                `${baseName}${separator}${separator}${baseName}`
            ];
            const slugs = new Set();
            for (const name of names){
                const result = await (0, _eventService.create)({
                    name,
                    eventType: 'reception',
                    startDate: startDate.toISOString()
                });
                if (!result.success) {
                    continue;
                }
                createdEventIds.push(result.data.id);
                const slug = result.data.slug;
                // Each slug must be unique
                expect(slugs.has(slug)).toBe(false);
                slugs.add(slug);
            }
            return true;
        }), {
            numRuns: 15
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvZXZlbnRTZXJ2aWNlLnNsdWdVbmlxdWVuZXNzLnByb3BlcnR5LnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQcm9wZXJ0eS1CYXNlZCBUZXN0cyBmb3IgRXZlbnQgU2VydmljZSBTbHVnIFVuaXF1ZW5lc3NcbiAqIFxuICogKipQcm9wZXJ0eSAyNDogU2x1ZyBVbmlxdWVuZXNzKipcbiAqICoqVmFsaWRhdGVzOiBSZXF1aXJlbWVudHMgMjQuMywgMjQuNCwgMjQuNSoqXG4gKiBcbiAqIFRlc3RzIHRoYXQgc2x1Z3MgYXJlIHVuaXF1ZSBhY3Jvc3MgYWxsIGV2ZW50cyBhbmQgY29uZmxpY3RzIGFyZSByZXNvbHZlZCB3aXRoIG51bWVyaWMgc3VmZml4ZXMuXG4gKi9cblxuaW1wb3J0ICogYXMgZmMgZnJvbSAnZmFzdC1jaGVjayc7XG5pbXBvcnQgeyBjcmVhdGUsIGRlbGV0ZUV2ZW50IH0gZnJvbSAnLi9ldmVudFNlcnZpY2UnO1xuXG5kZXNjcmliZSgnRmVhdHVyZTogZ3Vlc3QtcG9ydGFsLWFuZC1hZG1pbi1lbmhhbmNlbWVudHMsIFByb3BlcnR5IDI0OiBTbHVnIFVuaXF1ZW5lc3MnLCAoKSA9PiB7XG4gIC8vIENsZWFuIHVwIHRlc3QgZXZlbnRzIGFmdGVyIGVhY2ggdGVzdFxuICBjb25zdCBjcmVhdGVkRXZlbnRJZHM6IHN0cmluZ1tdID0gW107XG5cbiAgYWZ0ZXJFYWNoKGFzeW5jICgpID0+IHtcbiAgICAvLyBDbGVhbiB1cCBhbGwgY3JlYXRlZCBldmVudHNcbiAgICBmb3IgKGNvbnN0IGlkIG9mIGNyZWF0ZWRFdmVudElkcykge1xuICAgICAgYXdhaXQgZGVsZXRlRXZlbnQoaWQpO1xuICAgIH1cbiAgICBjcmVhdGVkRXZlbnRJZHMubGVuZ3RoID0gMDtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFByb3BlcnR5OiBDcmVhdGluZyBtdWx0aXBsZSBldmVudHMgd2l0aCB0aGUgc2FtZSBuYW1lIGdlbmVyYXRlcyB1bmlxdWUgc2x1Z3NcbiAgICogXG4gICAqIFdoZW4gbXVsdGlwbGUgZXZlbnRzIGhhdmUgdGhlIHNhbWUgbmFtZSwgdGhlIHN5c3RlbSBzaG91bGQgYXBwZW5kIG51bWVyaWNcbiAgICogc3VmZml4ZXMgKC0yLCAtMywgZXRjLikgdG8gZW5zdXJlIHVuaXF1ZW5lc3MuXG4gICAqL1xuICBpdCgnc2hvdWxkIGdlbmVyYXRlIHVuaXF1ZSBzbHVncyBmb3IgZXZlbnRzIHdpdGggZHVwbGljYXRlIG5hbWVzJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMywgbWF4TGVuZ3RoOiAzMCB9KS5maWx0ZXIocyA9PiAvW2EtekEtWjAtOV0vLnRlc3QocykpLFxuICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAyLCBtYXg6IDUgfSksXG4gICAgICAgIGZjLmRhdGUoKSxcbiAgICAgICAgYXN5bmMgKGJhc2VOYW1lLCBjb3VudCwgc3RhcnREYXRlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2x1Z3MgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgICAgICAgIC8vIENyZWF0ZSBtdWx0aXBsZSBldmVudHMgd2l0aCB0aGUgc2FtZSBuYW1lXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcmVhdGUoe1xuICAgICAgICAgICAgICBuYW1lOiBiYXNlTmFtZSxcbiAgICAgICAgICAgICAgZXZlbnRUeXBlOiAnY2VyZW1vbnknLFxuICAgICAgICAgICAgICBzdGFydERhdGU6IG5ldyBEYXRlKHN0YXJ0RGF0ZS5nZXRUaW1lKCkgKyBpICogMzYwMDAwMCkudG9JU09TdHJpbmcoKSwgLy8gT2Zmc2V0IGJ5IGhvdXJzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAvLyBJZiBjcmVhdGlvbiBmYWlsZWQsIHNraXAgdGhpcyBpdGVyYXRpb25cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNyZWF0ZWRFdmVudElkcy5wdXNoKHJlc3VsdC5kYXRhLmlkKTtcbiAgICAgICAgICAgIGNvbnN0IHNsdWcgPSByZXN1bHQuZGF0YS5zbHVnO1xuXG4gICAgICAgICAgICAvLyBFYWNoIHNsdWcgbXVzdCBiZSB1bmlxdWVcbiAgICAgICAgICAgIGV4cGVjdChzbHVncy5oYXMoc2x1ZykpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgICAgc2x1Z3MuYWRkKHNsdWcpO1xuXG4gICAgICAgICAgICAvLyBGaXJzdCBldmVudCBzaG91bGQgaGF2ZSBiYXNlIHNsdWcsIHN1YnNlcXVlbnQgc2hvdWxkIGhhdmUgLTIsIC0zLCBldGMuXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICBleHBlY3Qoc2x1Zykubm90LnRvTWF0Y2goLy1cXGQrJC8pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXhwZWN0KHNsdWcpLnRvTWF0Y2goLy1cXGQrJC8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFZlcmlmeSB3ZSBnb3QgdGhlIGV4cGVjdGVkIG51bWJlciBvZiB1bmlxdWUgc2x1Z3NcbiAgICAgICAgICBleHBlY3Qoc2x1Z3Muc2l6ZSkudG9CZShjb3VudCk7XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMjAgfVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQcm9wZXJ0eTogU2x1ZyB1bmlxdWVuZXNzIGlzIG1haW50YWluZWQgYWNyb3NzIGRpZmZlcmVudCBldmVudCB0eXBlc1xuICAgKi9cbiAgaXQoJ3Nob3VsZCBlbnN1cmUgc2x1ZyB1bmlxdWVuZXNzIGFjcm9zcyBhbGwgZXZlbnQgdHlwZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAzLCBtYXhMZW5ndGg6IDMwIH0pLmZpbHRlcihzID0+IC9bYS16QS1aMC05XS8udGVzdChzKSksXG4gICAgICAgIGZjLmRhdGUoKSxcbiAgICAgICAgYXN5bmMgKG5hbWUsIHN0YXJ0RGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGV2ZW50VHlwZXMgPSBbJ2NlcmVtb255JywgJ3JlY2VwdGlvbicsICdtZWFsJywgJ3RyYW5zcG9ydCcsICdhY3Rpdml0eSddIGFzIGNvbnN0O1xuICAgICAgICAgIGNvbnN0IHNsdWdzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgICAgICAgICAvLyBDcmVhdGUgZXZlbnRzIHdpdGggc2FtZSBuYW1lIGJ1dCBkaWZmZXJlbnQgdHlwZXNcbiAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50VHlwZSBvZiBldmVudFR5cGVzKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcmVhdGUoe1xuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBldmVudFR5cGUsXG4gICAgICAgICAgICAgIHN0YXJ0RGF0ZTogc3RhcnREYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3JlYXRlZEV2ZW50SWRzLnB1c2gocmVzdWx0LmRhdGEuaWQpO1xuICAgICAgICAgICAgY29uc3Qgc2x1ZyA9IHJlc3VsdC5kYXRhLnNsdWc7XG5cbiAgICAgICAgICAgIC8vIEVhY2ggc2x1ZyBtdXN0IGJlIHVuaXF1ZSBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXZlbnQgdHlwZXNcbiAgICAgICAgICAgIGV4cGVjdChzbHVncy5oYXMoc2x1ZykpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgICAgc2x1Z3MuYWRkKHNsdWcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxNSB9XG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFByb3BlcnR5OiBOdW1lcmljIHN1ZmZpeCBpbmNyZW1lbnRzIGNvcnJlY3RseSBmb3IgbXVsdGlwbGUgZHVwbGljYXRlc1xuICAgKi9cbiAgaXQoJ3Nob3VsZCBpbmNyZW1lbnQgbnVtZXJpYyBzdWZmaXhlcyBjb3JyZWN0bHkgZm9yIG11bHRpcGxlIGR1cGxpY2F0ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAzLCBtYXhMZW5ndGg6IDIwIH0pLmZpbHRlcihzID0+IC9bYS16QS1aMC05XS8udGVzdChzKSksXG4gICAgICAgIGZjLmRhdGUoKSxcbiAgICAgICAgYXN5bmMgKG5hbWUsIHN0YXJ0RGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGV2ZW50czogQXJyYXk8eyBpZDogc3RyaW5nOyBzbHVnOiBzdHJpbmcgfT4gPSBbXTtcblxuICAgICAgICAgIC8vIENyZWF0ZSA1IGV2ZW50cyB3aXRoIHRoZSBzYW1lIG5hbWVcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3JlYXRlKHtcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgZXZlbnRUeXBlOiAnY2VyZW1vbnknLFxuICAgICAgICAgICAgICBzdGFydERhdGU6IG5ldyBEYXRlKHN0YXJ0RGF0ZS5nZXRUaW1lKCkgKyBpICogMzYwMDAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjcmVhdGVkRXZlbnRJZHMucHVzaChyZXN1bHQuZGF0YS5pZCk7XG4gICAgICAgICAgICBldmVudHMucHVzaCh7IGlkOiByZXN1bHQuZGF0YS5pZCwgc2x1ZzogcmVzdWx0LmRhdGEuc2x1ZyB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZXZlbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBTa2lwIGlmIHdlIGNvdWxkbid0IGNyZWF0ZSBlbm91Z2ggZXZlbnRzXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVmVyaWZ5IHNsdWcgcGF0dGVyblxuICAgICAgICAgIGNvbnN0IGJhc2VTbHVnID0gZXZlbnRzWzBdLnNsdWc7XG4gICAgICAgICAgZXhwZWN0KGJhc2VTbHVnKS5ub3QudG9NYXRjaCgvLVxcZCskLyk7XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRTdWZmaXggPSBpICsgMTtcbiAgICAgICAgICAgIGV4cGVjdChldmVudHNbaV0uc2x1ZykudG9CZShgJHtiYXNlU2x1Z30tJHtleHBlY3RlZFN1ZmZpeH1gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAgfVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQcm9wZXJ0eTogU2x1ZyB1bmlxdWVuZXNzIGhhbmRsZXMgZWRnZSBjYXNlcyB3aXRoIHNpbWlsYXIgbmFtZXNcbiAgICovXG4gIGl0KCdzaG91bGQgbWFpbnRhaW4gdW5pcXVlbmVzcyBmb3IgbmFtZXMgdGhhdCBkaWZmZXIgb25seSBpbiBzcGVjaWFsIGNoYXJhY3RlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAzLCBtYXhMZW5ndGg6IDIwIH0pLmZpbHRlcihzID0+IC9bYS16QS1aMC05XS8udGVzdChzKSksXG4gICAgICAgIGZjLmNvbnN0YW50RnJvbSgnIScsICdAJywgJyMnLCAnLScsICdfJywgJyAnKSxcbiAgICAgICAgZmMuZGF0ZSgpLFxuICAgICAgICBhc3luYyAoYmFzZU5hbWUsIHNlcGFyYXRvciwgc3RhcnREYXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgbmFtZXMgPSBbXG4gICAgICAgICAgICBiYXNlTmFtZSxcbiAgICAgICAgICAgIGAke2Jhc2VOYW1lfSR7c2VwYXJhdG9yfSR7YmFzZU5hbWV9YCxcbiAgICAgICAgICAgIGAke2Jhc2VOYW1lfSR7c2VwYXJhdG9yfSR7c2VwYXJhdG9yfSR7YmFzZU5hbWV9YCxcbiAgICAgICAgICBdO1xuXG4gICAgICAgICAgY29uc3Qgc2x1Z3MgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3JlYXRlKHtcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgZXZlbnRUeXBlOiAncmVjZXB0aW9uJyxcbiAgICAgICAgICAgICAgc3RhcnREYXRlOiBzdGFydERhdGUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjcmVhdGVkRXZlbnRJZHMucHVzaChyZXN1bHQuZGF0YS5pZCk7XG4gICAgICAgICAgICBjb25zdCBzbHVnID0gcmVzdWx0LmRhdGEuc2x1ZztcblxuICAgICAgICAgICAgLy8gRWFjaCBzbHVnIG11c3QgYmUgdW5pcXVlXG4gICAgICAgICAgICBleHBlY3Qoc2x1Z3MuaGFzKHNsdWcpKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICAgIHNsdWdzLmFkZChzbHVnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTUgfVxuICAgICk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJjcmVhdGVkRXZlbnRJZHMiLCJhZnRlckVhY2giLCJpZCIsImRlbGV0ZUV2ZW50IiwibGVuZ3RoIiwiaXQiLCJmYyIsImFzc2VydCIsImFzeW5jUHJvcGVydHkiLCJzdHJpbmciLCJtaW5MZW5ndGgiLCJtYXhMZW5ndGgiLCJmaWx0ZXIiLCJzIiwidGVzdCIsImludGVnZXIiLCJtaW4iLCJtYXgiLCJkYXRlIiwiYmFzZU5hbWUiLCJjb3VudCIsInN0YXJ0RGF0ZSIsInNsdWdzIiwiU2V0IiwiaSIsInJlc3VsdCIsImNyZWF0ZSIsIm5hbWUiLCJldmVudFR5cGUiLCJEYXRlIiwiZ2V0VGltZSIsInRvSVNPU3RyaW5nIiwic3VjY2VzcyIsInB1c2giLCJkYXRhIiwic2x1ZyIsImV4cGVjdCIsImhhcyIsInRvQmUiLCJhZGQiLCJub3QiLCJ0b01hdGNoIiwic2l6ZSIsIm51bVJ1bnMiLCJldmVudFR5cGVzIiwiZXZlbnRzIiwiYmFzZVNsdWciLCJleHBlY3RlZFN1ZmZpeCIsImNvbnN0YW50RnJvbSIsInNlcGFyYXRvciIsIm5hbWVzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztDQU9DOzs7O21FQUVtQjs4QkFDZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVwQ0EsU0FBUyw4RUFBOEU7SUFDckYs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