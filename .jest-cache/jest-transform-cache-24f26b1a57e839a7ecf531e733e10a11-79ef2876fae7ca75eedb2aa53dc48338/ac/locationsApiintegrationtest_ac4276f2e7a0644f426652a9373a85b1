cbe1530dd2070797af7dfe2ac6ddcd87
/**
 * Integration Test: Locations API
 * 
 * Tests authenticated requests, validation errors, CRUD operations,
 * circular reference detection, and error responses for locations API endpoints.
 */ // Polyfill Web APIs for Next.js server components
"use strict";
// Mock location service BEFORE importing route handlers
jest.mock('@/services/locationService', ()=>({
        create: jest.fn(),
        get: jest.fn(),
        update: jest.fn(),
        deleteLocation: jest.fn(),
        getHierarchy: jest.fn(),
        list: jest.fn()
    }));
// Mock Next.js server module
jest.mock('next/server', ()=>({
        NextResponse: {
            json: (data, init)=>({
                    json: async ()=>data,
                    status: init?.status || 200
                })
        },
        NextRequest: jest.fn()
    }));
// Mock Next.js headers and cookies
jest.mock('next/headers', ()=>({
        cookies: jest.fn(()=>({
                get: jest.fn(),
                getAll: jest.fn(()=>[]),
                set: jest.fn(),
                delete: jest.fn()
            }))
    }));
jest.mock('@supabase/ssr', ()=>({
        createServerClient: jest.fn(()=>mockSupabaseClient)
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _util = require("util");
const _route = require("../../app/api/admin/locations/route");
const _route1 = require("../../app/api/admin/locations/[id]/route");
const _route2 = require("../../app/api/admin/locations/[id]/validate-parent/route");
const _locationService = /*#__PURE__*/ _interop_require_wildcard(require("../../services/locationService"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
global.TextEncoder = _util.TextEncoder;
global.TextDecoder = _util.TextDecoder;
// Mock Supabase SSR client
const mockGetUser = jest.fn();
const mockGetSession = jest.fn();
const mockSupabaseClient = {
    auth: {
        getUser: mockGetUser,
        getSession: mockGetSession
    },
    from: jest.fn()
};
describe('Locations API Integration Tests', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        // Default: authenticated user
        mockGetUser.mockResolvedValue({
            data: {
                user: {
                    id: 'user-1',
                    email: 'admin@example.com'
                }
            },
            error: null
        });
        // Default: valid session
        mockGetSession.mockResolvedValue({
            data: {
                session: {
                    user: {
                        id: 'user-1',
                        email: 'admin@example.com'
                    }
                }
            },
            error: null
        });
    });
    describe('GET /api/admin/locations', ()=>{
        it('should return location hierarchy when authenticated', async ()=>{
            const mockHierarchy = [
                {
                    id: 'loc-1',
                    name: 'Costa Rica',
                    parentLocationId: null,
                    address: null,
                    coordinates: null,
                    description: null,
                    createdAt: '2025-01-01T00:00:00Z',
                    children: []
                }
            ];
            _locationService.getHierarchy.mockResolvedValue({
                success: true,
                data: mockHierarchy
            });
            const request = {
                url: 'http://localhost:3000/api/admin/locations'
            };
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(200);
            expect(data.success).toBe(true);
            expect(data.data).toEqual(mockHierarchy);
        });
        it('should return 500 when service fails', async ()=>{
            _locationService.getHierarchy.mockResolvedValue({
                success: false,
                error: {
                    code: 'DATABASE_ERROR',
                    message: 'Database error'
                }
            });
            const request = {
                url: 'http://localhost:3000/api/admin/locations'
            };
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(500);
            expect(data.success).toBe(false);
        });
    });
    describe('POST /api/admin/locations', ()=>{
        it('should create location with valid data', async ()=>{
            const newLocation = {
                id: 'loc-1',
                name: 'Costa Rica',
                parentLocationId: null,
                address: null,
                coordinates: null,
                description: null,
                createdAt: '2025-01-01T00:00:00Z'
            };
            _locationService.create.mockResolvedValue({
                success: true,
                data: newLocation
            });
            const request = {
                json: async ()=>({
                        name: 'Costa Rica'
                    }),
                url: 'http://localhost:3000/api/admin/locations'
            };
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(201);
            expect(data.success).toBe(true);
            expect(data.data).toEqual(newLocation);
        });
        it('should return 400 for validation errors', async ()=>{
            const request = {
                json: async ()=>({
                        name: ''
                    }),
                url: 'http://localhost:3000/api/admin/locations'
            };
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('VALIDATION_ERROR');
        });
        it('should return 400 for invalid parent location ID format', async ()=>{
            const request = {
                json: async ()=>({
                        name: 'New Location',
                        parentLocationId: 'invalid-id'
                    }),
                url: 'http://localhost:3000/api/admin/locations'
            };
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('VALIDATION_ERROR');
        });
        it('should return 409 for circular reference from service', async ()=>{
            _locationService.create.mockResolvedValue({
                success: false,
                error: {
                    code: 'CIRCULAR_REFERENCE',
                    message: 'This would create a circular reference'
                }
            });
            const request = {
                json: async ()=>({
                        name: 'New Location',
                        parentLocationId: '123e4567-e89b-12d3-a456-426614174000'
                    }),
                url: 'http://localhost:3000/api/admin/locations'
            };
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(409);
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('CIRCULAR_REFERENCE');
        });
    });
    describe('GET /api/admin/locations/:id', ()=>{
        it('should return location by ID', async ()=>{
            const mockLocation = {
                id: 'loc-1',
                name: 'Costa Rica',
                parentLocationId: null,
                address: null,
                coordinates: null,
                description: null,
                createdAt: '2025-01-01T00:00:00Z'
            };
            _locationService.get.mockResolvedValue({
                success: true,
                data: mockLocation
            });
            const request = {
                url: 'http://localhost:3000/api/admin/locations/loc-1'
            };
            const response = await (0, _route1.GET)(request, {
                params: Promise.resolve({
                    id: 'loc-1'
                })
            });
            const data = await response.json();
            expect(response.status).toBe(200);
            expect(data.success).toBe(true);
            expect(data.data).toEqual(mockLocation);
        });
        it('should return 404 when location not found', async ()=>{
            _locationService.get.mockResolvedValue({
                success: false,
                error: {
                    code: 'NOT_FOUND',
                    message: 'Location not found'
                }
            });
            const request = {
                url: 'http://localhost:3000/api/admin/locations/invalid-id'
            };
            const response = await (0, _route1.GET)(request, {
                params: Promise.resolve({
                    id: 'invalid-id'
                })
            });
            const data = await response.json();
            expect(response.status).toBe(404);
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('NOT_FOUND');
        });
    });
    describe('PUT /api/admin/locations/:id', ()=>{
        it('should update location with valid data', async ()=>{
            const updatedLocation = {
                id: 'loc-1',
                name: 'Updated Name',
                parentLocationId: null,
                address: 'New Address',
                coordinates: null,
                description: null,
                createdAt: '2025-01-01T00:00:00Z'
            };
            _locationService.update.mockResolvedValue({
                success: true,
                data: updatedLocation
            });
            const request = {
                json: async ()=>({
                        name: 'Updated Name',
                        address: 'New Address'
                    }),
                url: 'http://localhost:3000/api/admin/locations/loc-1'
            };
            const response = await (0, _route1.PUT)(request, {
                params: Promise.resolve({
                    id: 'loc-1'
                })
            });
            const data = await response.json();
            expect(response.status).toBe(200);
            expect(data.success).toBe(true);
            expect(data.data).toEqual(updatedLocation);
        });
        it('should return 404 when location not found', async ()=>{
            _locationService.update.mockResolvedValue({
                success: false,
                error: {
                    code: 'NOT_FOUND',
                    message: 'Location not found'
                }
            });
            const request = {
                json: async ()=>({
                        name: 'Updated Name'
                    }),
                url: 'http://localhost:3000/api/admin/locations/invalid-id'
            };
            const response = await (0, _route1.PUT)(request, {
                params: Promise.resolve({
                    id: 'invalid-id'
                })
            });
            const data = await response.json();
            expect(response.status).toBe(404);
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('NOT_FOUND');
        });
        it('should return 409 for circular reference from service', async ()=>{
            _locationService.update.mockResolvedValue({
                success: false,
                error: {
                    code: 'CIRCULAR_REFERENCE',
                    message: 'This would create a circular reference'
                }
            });
            const request = {
                json: async ()=>({
                        parentLocationId: '123e4567-e89b-12d3-a456-426614174000'
                    }),
                url: 'http://localhost:3000/api/admin/locations/loc-1'
            };
            const response = await (0, _route1.PUT)(request, {
                params: Promise.resolve({
                    id: 'loc-1'
                })
            });
            const data = await response.json();
            expect(response.status).toBe(409);
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('CIRCULAR_REFERENCE');
        });
    });
    describe('DELETE /api/admin/locations/:id', ()=>{
        it('should delete location successfully', async ()=>{
            _locationService.deleteLocation.mockResolvedValue({
                success: true,
                data: undefined
            });
            const request = {
                url: 'http://localhost:3000/api/admin/locations/loc-1'
            };
            const response = await (0, _route1.DELETE)(request, {
                params: Promise.resolve({
                    id: 'loc-1'
                })
            });
            const data = await response.json();
            expect(response.status).toBe(200);
            expect(data.success).toBe(true);
        });
        it('should return 500 when deletion fails', async ()=>{
            _locationService.deleteLocation.mockResolvedValue({
                success: false,
                error: {
                    code: 'DATABASE_ERROR',
                    message: 'Failed to delete'
                }
            });
            const request = {
                url: 'http://localhost:3000/api/admin/locations/loc-1'
            };
            const response = await (0, _route1.DELETE)(request, {
                params: Promise.resolve({
                    id: 'loc-1'
                })
            });
            const data = await response.json();
            expect(response.status).toBe(500);
            expect(data.success).toBe(false);
        });
    });
    describe('POST /api/admin/locations/:id/validate-parent', ()=>{
        it('should validate parent successfully when no circular reference', async ()=>{
            const request = {
                json: async ()=>({
                        parentLocationId: 'loc-3'
                    }),
                url: 'http://localhost:3000/api/admin/locations/loc-1/validate-parent'
            };
            const response = await (0, _route2.POST)(request, {
                params: Promise.resolve({
                    id: 'loc-1'
                })
            });
            const data = await response.json();
            expect(response.status).toBe(200);
            expect(data.success).toBe(true);
            expect(data.data.valid).toBe(true);
        });
        it('should return 409 when circular reference detected', async ()=>{
            const request = {
                json: async ()=>({
                        parentLocationId: 'loc-1'
                    }),
                url: 'http://localhost:3000/api/admin/locations/loc-1/validate-parent'
            };
            const response = await (0, _route2.POST)(request, {
                params: Promise.resolve({
                    id: 'loc-1'
                })
            });
            const data = await response.json();
            expect(response.status).toBe(409);
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('CIRCULAR_REFERENCE');
        });
        it('should return 400 when parentLocationId missing', async ()=>{
            const request = {
                json: async ()=>({}),
                url: 'http://localhost:3000/api/admin/locations/loc-1/validate-parent'
            };
            const response = await (0, _route2.POST)(request, {
                params: Promise.resolve({
                    id: 'loc-1'
                })
            });
            const data = await response.json();
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('VALIDATION_ERROR');
        });
    });
    describe('Tree Structure Retrieval', ()=>{
        it('should return hierarchical tree structure', async ()=>{
            const mockHierarchy = [
                {
                    id: 'loc-1',
                    name: 'Costa Rica',
                    parentLocationId: null,
                    address: null,
                    coordinates: null,
                    description: null,
                    createdAt: '2025-01-01T00:00:00Z',
                    children: [
                        {
                            id: 'loc-2',
                            name: 'Guanacaste',
                            parentLocationId: 'loc-1',
                            address: null,
                            coordinates: null,
                            description: null,
                            createdAt: '2025-01-01T00:00:00Z',
                            children: []
                        }
                    ]
                }
            ];
            _locationService.getHierarchy.mockResolvedValue({
                success: true,
                data: mockHierarchy
            });
            const request = {
                url: 'http://localhost:3000/api/admin/locations'
            };
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(200);
            expect(data.success).toBe(true);
            expect(data.data[0].children).toBeDefined();
            expect(data.data[0].children.length).toBe(1);
        });
    });
    describe('Cascade Deletion', ()=>{
        it('should handle cascade deletion (children become orphans)', async ()=>{
            // This is handled by the database trigger, but we test the API behavior
            _locationService.deleteLocation.mockResolvedValue({
                success: true,
                data: undefined
            });
            const request = {
                url: 'http://localhost:3000/api/admin/locations/loc-1'
            };
            const response = await (0, _route1.DELETE)(request, {
                params: Promise.resolve({
                    id: 'loc-1'
                })
            });
            const data = await response.json();
            expect(response.status).toBe(200);
            expect(data.success).toBe(true);
            expect(_locationService.deleteLocation).toHaveBeenCalledWith('loc-1');
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvX190ZXN0c19fL2ludGVncmF0aW9uL2xvY2F0aW9uc0FwaS5pbnRlZ3JhdGlvbi50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW50ZWdyYXRpb24gVGVzdDogTG9jYXRpb25zIEFQSVxuICogXG4gKiBUZXN0cyBhdXRoZW50aWNhdGVkIHJlcXVlc3RzLCB2YWxpZGF0aW9uIGVycm9ycywgQ1JVRCBvcGVyYXRpb25zLFxuICogY2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGlvbiwgYW5kIGVycm9yIHJlc3BvbnNlcyBmb3IgbG9jYXRpb25zIEFQSSBlbmRwb2ludHMuXG4gKi9cblxuLy8gUG9seWZpbGwgV2ViIEFQSXMgZm9yIE5leHQuanMgc2VydmVyIGNvbXBvbmVudHNcbmltcG9ydCB7IFRleHRFbmNvZGVyLCBUZXh0RGVjb2RlciB9IGZyb20gJ3V0aWwnO1xuZ2xvYmFsLlRleHRFbmNvZGVyID0gVGV4dEVuY29kZXI7XG5nbG9iYWwuVGV4dERlY29kZXIgPSBUZXh0RGVjb2RlciBhcyBhbnk7XG5cbi8vIE1vY2sgbG9jYXRpb24gc2VydmljZSBCRUZPUkUgaW1wb3J0aW5nIHJvdXRlIGhhbmRsZXJzXG5qZXN0Lm1vY2soJ0Avc2VydmljZXMvbG9jYXRpb25TZXJ2aWNlJywgKCkgPT4gKHtcbiAgY3JlYXRlOiBqZXN0LmZuKCksXG4gIGdldDogamVzdC5mbigpLFxuICB1cGRhdGU6IGplc3QuZm4oKSxcbiAgZGVsZXRlTG9jYXRpb246IGplc3QuZm4oKSxcbiAgZ2V0SGllcmFyY2h5OiBqZXN0LmZuKCksXG4gIGxpc3Q6IGplc3QuZm4oKSxcbn0pKTtcblxuLy8gTW9jayBOZXh0LmpzIHNlcnZlciBtb2R1bGVcbmplc3QubW9jaygnbmV4dC9zZXJ2ZXInLCAoKSA9PiAoe1xuICBOZXh0UmVzcG9uc2U6IHtcbiAgICBqc29uOiAoZGF0YTogYW55LCBpbml0PzogYW55KSA9PiAoe1xuICAgICAganNvbjogYXN5bmMgKCkgPT4gZGF0YSxcbiAgICAgIHN0YXR1czogaW5pdD8uc3RhdHVzIHx8IDIwMCxcbiAgICB9KSxcbiAgfSxcbiAgTmV4dFJlcXVlc3Q6IGplc3QuZm4oKSxcbn0pKTtcblxuLy8gTW9jayBOZXh0LmpzIGhlYWRlcnMgYW5kIGNvb2tpZXNcbmplc3QubW9jaygnbmV4dC9oZWFkZXJzJywgKCkgPT4gKHtcbiAgY29va2llczogamVzdC5mbigoKSA9PiAoe1xuICAgIGdldDogamVzdC5mbigpLFxuICAgIGdldEFsbDogamVzdC5mbigoKSA9PiBbXSksXG4gICAgc2V0OiBqZXN0LmZuKCksXG4gICAgZGVsZXRlOiBqZXN0LmZuKCksXG4gIH0pKSxcbn0pKTtcblxuLy8gTW9jayBTdXBhYmFzZSBTU1IgY2xpZW50XG5jb25zdCBtb2NrR2V0VXNlciA9IGplc3QuZm4oKTtcbmNvbnN0IG1vY2tHZXRTZXNzaW9uID0gamVzdC5mbigpO1xuY29uc3QgbW9ja1N1cGFiYXNlQ2xpZW50ID0ge1xuICBhdXRoOiB7XG4gICAgZ2V0VXNlcjogbW9ja0dldFVzZXIsXG4gICAgZ2V0U2Vzc2lvbjogbW9ja0dldFNlc3Npb24sXG4gIH0sXG4gIGZyb206IGplc3QuZm4oKSxcbn07XG5cbmplc3QubW9jaygnQHN1cGFiYXNlL3NzcicsICgpID0+ICh7XG4gIGNyZWF0ZVNlcnZlckNsaWVudDogamVzdC5mbigoKSA9PiBtb2NrU3VwYWJhc2VDbGllbnQpLFxufSkpO1xuXG5pbXBvcnQgeyBHRVQsIFBPU1QgfSBmcm9tICdAL2FwcC9hcGkvYWRtaW4vbG9jYXRpb25zL3JvdXRlJztcbmltcG9ydCB7XG4gIEdFVCBhcyBHRVRfQllfSUQsXG4gIFBVVCxcbiAgREVMRVRFLFxufSBmcm9tICdAL2FwcC9hcGkvYWRtaW4vbG9jYXRpb25zL1tpZF0vcm91dGUnO1xuaW1wb3J0IHsgUE9TVCBhcyBWQUxJREFURV9QQVJFTlQgfSBmcm9tICdAL2FwcC9hcGkvYWRtaW4vbG9jYXRpb25zL1tpZF0vdmFsaWRhdGUtcGFyZW50L3JvdXRlJztcbmltcG9ydCAqIGFzIGxvY2F0aW9uU2VydmljZSBmcm9tICdAL3NlcnZpY2VzL2xvY2F0aW9uU2VydmljZSc7XG5cbmRlc2NyaWJlKCdMb2NhdGlvbnMgQVBJIEludGVncmF0aW9uIFRlc3RzJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBcbiAgICAvLyBEZWZhdWx0OiBhdXRoZW50aWNhdGVkIHVzZXJcbiAgICBtb2NrR2V0VXNlci5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIHVzZXI6IHsgaWQ6ICd1c2VyLTEnLCBlbWFpbDogJ2FkbWluQGV4YW1wbGUuY29tJyB9LFxuICAgICAgfSxcbiAgICAgIGVycm9yOiBudWxsLFxuICAgIH0gYXMgYW55KTtcbiAgICBcbiAgICAvLyBEZWZhdWx0OiB2YWxpZCBzZXNzaW9uXG4gICAgbW9ja0dldFNlc3Npb24ubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgZGF0YToge1xuICAgICAgICBzZXNzaW9uOiB7IHVzZXI6IHsgaWQ6ICd1c2VyLTEnLCBlbWFpbDogJ2FkbWluQGV4YW1wbGUuY29tJyB9IH0sXG4gICAgICB9LFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgfSBhcyBhbnkpO1xuICB9KTtcblxuICBkZXNjcmliZSgnR0VUIC9hcGkvYWRtaW4vbG9jYXRpb25zJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIGxvY2F0aW9uIGhpZXJhcmNoeSB3aGVuIGF1dGhlbnRpY2F0ZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrSGllcmFyY2h5ID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdsb2MtMScsXG4gICAgICAgICAgbmFtZTogJ0Nvc3RhIFJpY2EnLFxuICAgICAgICAgIHBhcmVudExvY2F0aW9uSWQ6IG51bGwsXG4gICAgICAgICAgYWRkcmVzczogbnVsbCxcbiAgICAgICAgICBjb29yZGluYXRlczogbnVsbCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogbnVsbCxcbiAgICAgICAgICBjcmVhdGVkQXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgKGxvY2F0aW9uU2VydmljZS5nZXRIaWVyYXJjaHkgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IG1vY2tIaWVyYXJjaHksXG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIHVybDogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vbG9jYXRpb25zJyxcbiAgICAgIH0gYXMgYW55O1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IEdFVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoZGF0YS5kYXRhKS50b0VxdWFsKG1vY2tIaWVyYXJjaHkpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gNTAwIHdoZW4gc2VydmljZSBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgIChsb2NhdGlvblNlcnZpY2UuZ2V0SGllcmFyY2h5IGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IHsgY29kZTogJ0RBVEFCQVNFX0VSUk9SJywgbWVzc2FnZTogJ0RhdGFiYXNlIGVycm9yJyB9LFxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICB1cmw6ICdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL2xvY2F0aW9ucycsXG4gICAgICB9IGFzIGFueTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBHRVQocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDUwMCk7XG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BPU1QgL2FwaS9hZG1pbi9sb2NhdGlvbnMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgbG9jYXRpb24gd2l0aCB2YWxpZCBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbmV3TG9jYXRpb24gPSB7XG4gICAgICAgIGlkOiAnbG9jLTEnLFxuICAgICAgICBuYW1lOiAnQ29zdGEgUmljYScsXG4gICAgICAgIHBhcmVudExvY2F0aW9uSWQ6IG51bGwsXG4gICAgICAgIGFkZHJlc3M6IG51bGwsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBudWxsLFxuICAgICAgICBkZXNjcmlwdGlvbjogbnVsbCxcbiAgICAgICAgY3JlYXRlZEF0OiAnMjAyNS0wMS0wMVQwMDowMDowMFonLFxuICAgICAgfTtcblxuICAgICAgKGxvY2F0aW9uU2VydmljZS5jcmVhdGUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IG5ld0xvY2F0aW9uLFxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBuYW1lOiAnQ29zdGEgUmljYScgfSksXG4gICAgICAgIHVybDogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vbG9jYXRpb25zJyxcbiAgICAgIH0gYXMgYW55O1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMSk7XG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGRhdGEuZGF0YSkudG9FcXVhbChuZXdMb2NhdGlvbik7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiA0MDAgZm9yIHZhbGlkYXRpb24gZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgbmFtZTogJycgfSksIC8vIEludmFsaWQ6IGVtcHR5IG5hbWVcbiAgICAgICAgdXJsOiAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9sb2NhdGlvbnMnLFxuICAgICAgfSBhcyBhbnk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IuY29kZSkudG9CZSgnVkFMSURBVElPTl9FUlJPUicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAwIGZvciBpbnZhbGlkIHBhcmVudCBsb2NhdGlvbiBJRCBmb3JtYXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgIG5hbWU6ICdOZXcgTG9jYXRpb24nLFxuICAgICAgICAgIHBhcmVudExvY2F0aW9uSWQ6ICdpbnZhbGlkLWlkJywgLy8gSW52YWxpZCBVVUlEIGZvcm1hdFxuICAgICAgICB9KSxcbiAgICAgICAgdXJsOiAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9sb2NhdGlvbnMnLFxuICAgICAgfSBhcyBhbnk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IuY29kZSkudG9CZSgnVkFMSURBVElPTl9FUlJPUicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gNDA5IGZvciBjaXJjdWxhciByZWZlcmVuY2UgZnJvbSBzZXJ2aWNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgKGxvY2F0aW9uU2VydmljZS5jcmVhdGUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgIGNvZGU6ICdDSVJDVUxBUl9SRUZFUkVOQ0UnLFxuICAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIHdvdWxkIGNyZWF0ZSBhIGNpcmN1bGFyIHJlZmVyZW5jZScsXG4gICAgICAgIH0sXG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgbmFtZTogJ05ldyBMb2NhdGlvbicsXG4gICAgICAgICAgcGFyZW50TG9jYXRpb25JZDogJzEyM2U0NTY3LWU4OWItMTJkMy1hNDU2LTQyNjYxNDE3NDAwMCcsIC8vIFZhbGlkIFVVSURcbiAgICAgICAgfSksXG4gICAgICAgIHVybDogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vbG9jYXRpb25zJyxcbiAgICAgIH0gYXMgYW55O1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwOSk7XG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yLmNvZGUpLnRvQmUoJ0NJUkNVTEFSX1JFRkVSRU5DRScpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnR0VUIC9hcGkvYWRtaW4vbG9jYXRpb25zLzppZCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBsb2NhdGlvbiBieSBJRCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tMb2NhdGlvbiA9IHtcbiAgICAgICAgaWQ6ICdsb2MtMScsXG4gICAgICAgIG5hbWU6ICdDb3N0YSBSaWNhJyxcbiAgICAgICAgcGFyZW50TG9jYXRpb25JZDogbnVsbCxcbiAgICAgICAgYWRkcmVzczogbnVsbCxcbiAgICAgICAgY29vcmRpbmF0ZXM6IG51bGwsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBudWxsLFxuICAgICAgICBjcmVhdGVkQXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICB9O1xuXG4gICAgICAobG9jYXRpb25TZXJ2aWNlLmdldCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YTogbW9ja0xvY2F0aW9uLFxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICB1cmw6ICdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL2xvY2F0aW9ucy9sb2MtMScsXG4gICAgICB9IGFzIGFueTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBHRVRfQllfSUQocmVxdWVzdCwgeyBwYXJhbXM6IFByb21pc2UucmVzb2x2ZSh7IGlkOiAnbG9jLTEnIH0pIH0pO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChkYXRhLmRhdGEpLnRvRXF1YWwobW9ja0xvY2F0aW9uKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwNCB3aGVuIGxvY2F0aW9uIG5vdCBmb3VuZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIChsb2NhdGlvblNlcnZpY2UuZ2V0IGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IHsgY29kZTogJ05PVF9GT1VORCcsIG1lc3NhZ2U6ICdMb2NhdGlvbiBub3QgZm91bmQnIH0sXG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIHVybDogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vbG9jYXRpb25zL2ludmFsaWQtaWQnLFxuICAgICAgfSBhcyBhbnk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUX0JZX0lEKHJlcXVlc3QsIHsgcGFyYW1zOiBQcm9taXNlLnJlc29sdmUoeyBpZDogJ2ludmFsaWQtaWQnIH0pIH0pO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDQpO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5jb2RlKS50b0JlKCdOT1RfRk9VTkQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BVVCAvYXBpL2FkbWluL2xvY2F0aW9ucy86aWQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB1cGRhdGUgbG9jYXRpb24gd2l0aCB2YWxpZCBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZExvY2F0aW9uID0ge1xuICAgICAgICBpZDogJ2xvYy0xJyxcbiAgICAgICAgbmFtZTogJ1VwZGF0ZWQgTmFtZScsXG4gICAgICAgIHBhcmVudExvY2F0aW9uSWQ6IG51bGwsXG4gICAgICAgIGFkZHJlc3M6ICdOZXcgQWRkcmVzcycsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBudWxsLFxuICAgICAgICBkZXNjcmlwdGlvbjogbnVsbCxcbiAgICAgICAgY3JlYXRlZEF0OiAnMjAyNS0wMS0wMVQwMDowMDowMFonLFxuICAgICAgfTtcblxuICAgICAgKGxvY2F0aW9uU2VydmljZS51cGRhdGUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHVwZGF0ZWRMb2NhdGlvbixcbiAgICAgIH0gYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgbmFtZTogJ1VwZGF0ZWQgTmFtZScsIGFkZHJlc3M6ICdOZXcgQWRkcmVzcycgfSksXG4gICAgICAgIHVybDogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vbG9jYXRpb25zL2xvYy0xJyxcbiAgICAgIH0gYXMgYW55O1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBVVChyZXF1ZXN0LCB7IHBhcmFtczogUHJvbWlzZS5yZXNvbHZlKHsgaWQ6ICdsb2MtMScgfSkgfSk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGRhdGEuZGF0YSkudG9FcXVhbCh1cGRhdGVkTG9jYXRpb24pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gNDA0IHdoZW4gbG9jYXRpb24gbm90IGZvdW5kJywgYXN5bmMgKCkgPT4ge1xuICAgICAgKGxvY2F0aW9uU2VydmljZS51cGRhdGUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogeyBjb2RlOiAnTk9UX0ZPVU5EJywgbWVzc2FnZTogJ0xvY2F0aW9uIG5vdCBmb3VuZCcgfSxcbiAgICAgIH0gYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgbmFtZTogJ1VwZGF0ZWQgTmFtZScgfSksXG4gICAgICAgIHVybDogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vbG9jYXRpb25zL2ludmFsaWQtaWQnLFxuICAgICAgfSBhcyBhbnk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUFVUKHJlcXVlc3QsIHsgcGFyYW1zOiBQcm9taXNlLnJlc29sdmUoeyBpZDogJ2ludmFsaWQtaWQnIH0pIH0pO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDQpO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5jb2RlKS50b0JlKCdOT1RfRk9VTkQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwOSBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlIGZyb20gc2VydmljZScsIGFzeW5jICgpID0+IHtcbiAgICAgIChsb2NhdGlvblNlcnZpY2UudXBkYXRlIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICBjb2RlOiAnQ0lSQ1VMQVJfUkVGRVJFTkNFJyxcbiAgICAgICAgICBtZXNzYWdlOiAnVGhpcyB3b3VsZCBjcmVhdGUgYSBjaXJjdWxhciByZWZlcmVuY2UnLFxuICAgICAgICB9LFxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBwYXJlbnRMb2NhdGlvbklkOiAnMTIzZTQ1NjctZTg5Yi0xMmQzLWE0NTYtNDI2NjE0MTc0MDAwJyB9KSwgLy8gVmFsaWQgVVVJRFxuICAgICAgICB1cmw6ICdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL2xvY2F0aW9ucy9sb2MtMScsXG4gICAgICB9IGFzIGFueTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQVVQocmVxdWVzdCwgeyBwYXJhbXM6IFByb21pc2UucmVzb2x2ZSh7IGlkOiAnbG9jLTEnIH0pIH0pO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDkpO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5jb2RlKS50b0JlKCdDSVJDVUxBUl9SRUZFUkVOQ0UnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0RFTEVURSAvYXBpL2FkbWluL2xvY2F0aW9ucy86aWQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBkZWxldGUgbG9jYXRpb24gc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgKGxvY2F0aW9uU2VydmljZS5kZWxldGVMb2NhdGlvbiBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICB1cmw6ICdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL2xvY2F0aW9ucy9sb2MtMScsXG4gICAgICB9IGFzIGFueTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBERUxFVEUocmVxdWVzdCwgeyBwYXJhbXM6IFByb21pc2UucmVzb2x2ZSh7IGlkOiAnbG9jLTEnIH0pIH0pO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIDUwMCB3aGVuIGRlbGV0aW9uIGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgKGxvY2F0aW9uU2VydmljZS5kZWxldGVMb2NhdGlvbiBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiB7IGNvZGU6ICdEQVRBQkFTRV9FUlJPUicsIG1lc3NhZ2U6ICdGYWlsZWQgdG8gZGVsZXRlJyB9LFxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICB1cmw6ICdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL2xvY2F0aW9ucy9sb2MtMScsXG4gICAgICB9IGFzIGFueTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBERUxFVEUocmVxdWVzdCwgeyBwYXJhbXM6IFByb21pc2UucmVzb2x2ZSh7IGlkOiAnbG9jLTEnIH0pIH0pO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg1MDApO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQT1NUIC9hcGkvYWRtaW4vbG9jYXRpb25zLzppZC92YWxpZGF0ZS1wYXJlbnQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBwYXJlbnQgc3VjY2Vzc2Z1bGx5IHdoZW4gbm8gY2lyY3VsYXIgcmVmZXJlbmNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgcGFyZW50TG9jYXRpb25JZDogJ2xvYy0zJyB9KSxcbiAgICAgICAgdXJsOiAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9sb2NhdGlvbnMvbG9jLTEvdmFsaWRhdGUtcGFyZW50JyxcbiAgICAgIH0gYXMgYW55O1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFZBTElEQVRFX1BBUkVOVChyZXF1ZXN0LCB7IHBhcmFtczogUHJvbWlzZS5yZXNvbHZlKHsgaWQ6ICdsb2MtMScgfSkgfSk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGRhdGEuZGF0YS52YWxpZCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwOSB3aGVuIGNpcmN1bGFyIHJlZmVyZW5jZSBkZXRlY3RlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IHBhcmVudExvY2F0aW9uSWQ6ICdsb2MtMScgfSksIC8vIFNlbGYgYXMgcGFyZW50XG4gICAgICAgIHVybDogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vbG9jYXRpb25zL2xvYy0xL3ZhbGlkYXRlLXBhcmVudCcsXG4gICAgICB9IGFzIGFueTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBWQUxJREFURV9QQVJFTlQocmVxdWVzdCwgeyBwYXJhbXM6IFByb21pc2UucmVzb2x2ZSh7IGlkOiAnbG9jLTEnIH0pIH0pO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDkpO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5jb2RlKS50b0JlKCdDSVJDVUxBUl9SRUZFUkVOQ0UnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMCB3aGVuIHBhcmVudExvY2F0aW9uSWQgbWlzc2luZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7fSksXG4gICAgICAgIHVybDogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vbG9jYXRpb25zL2xvYy0xL3ZhbGlkYXRlLXBhcmVudCcsXG4gICAgICB9IGFzIGFueTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBWQUxJREFURV9QQVJFTlQocmVxdWVzdCwgeyBwYXJhbXM6IFByb21pc2UucmVzb2x2ZSh7IGlkOiAnbG9jLTEnIH0pIH0pO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5jb2RlKS50b0JlKCdWQUxJREFUSU9OX0VSUk9SJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdUcmVlIFN0cnVjdHVyZSBSZXRyaWV2YWwnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gaGllcmFyY2hpY2FsIHRyZWUgc3RydWN0dXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0hpZXJhcmNoeSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAnbG9jLTEnLFxuICAgICAgICAgIG5hbWU6ICdDb3N0YSBSaWNhJyxcbiAgICAgICAgICBwYXJlbnRMb2NhdGlvbklkOiBudWxsLFxuICAgICAgICAgIGFkZHJlc3M6IG51bGwsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IG51bGwsXG4gICAgICAgICAgZGVzY3JpcHRpb246IG51bGwsXG4gICAgICAgICAgY3JlYXRlZEF0OiAnMjAyNS0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlkOiAnbG9jLTInLFxuICAgICAgICAgICAgICBuYW1lOiAnR3VhbmFjYXN0ZScsXG4gICAgICAgICAgICAgIHBhcmVudExvY2F0aW9uSWQ6ICdsb2MtMScsXG4gICAgICAgICAgICAgIGFkZHJlc3M6IG51bGwsXG4gICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBudWxsLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgY3JlYXRlZEF0OiAnMjAyNS0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICAobG9jYXRpb25TZXJ2aWNlLmdldEhpZXJhcmNoeSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YTogbW9ja0hpZXJhcmNoeSxcbiAgICAgIH0gYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgdXJsOiAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9sb2NhdGlvbnMnLFxuICAgICAgfSBhcyBhbnk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChkYXRhLmRhdGFbMF0uY2hpbGRyZW4pLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZGF0YS5kYXRhWzBdLmNoaWxkcmVuLmxlbmd0aCkudG9CZSgxKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Nhc2NhZGUgRGVsZXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY2FzY2FkZSBkZWxldGlvbiAoY2hpbGRyZW4gYmVjb21lIG9ycGhhbnMpJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gVGhpcyBpcyBoYW5kbGVkIGJ5IHRoZSBkYXRhYmFzZSB0cmlnZ2VyLCBidXQgd2UgdGVzdCB0aGUgQVBJIGJlaGF2aW9yXG4gICAgICAobG9jYXRpb25TZXJ2aWNlLmRlbGV0ZUxvY2F0aW9uIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIHVybDogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vbG9jYXRpb25zL2xvYy0xJyxcbiAgICAgIH0gYXMgYW55O1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IERFTEVURShyZXF1ZXN0LCB7IHBhcmFtczogUHJvbWlzZS5yZXNvbHZlKHsgaWQ6ICdsb2MtMScgfSkgfSk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGxvY2F0aW9uU2VydmljZS5kZWxldGVMb2NhdGlvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2xvYy0xJyk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJjcmVhdGUiLCJmbiIsImdldCIsInVwZGF0ZSIsImRlbGV0ZUxvY2F0aW9uIiwiZ2V0SGllcmFyY2h5IiwibGlzdCIsIk5leHRSZXNwb25zZSIsImpzb24iLCJkYXRhIiwiaW5pdCIsInN0YXR1cyIsIk5leHRSZXF1ZXN0IiwiY29va2llcyIsImdldEFsbCIsInNldCIsImRlbGV0ZSIsImNyZWF0ZVNlcnZlckNsaWVudCIsIm1vY2tTdXBhYmFzZUNsaWVudCIsImdsb2JhbCIsIlRleHRFbmNvZGVyIiwiVGV4dERlY29kZXIiLCJtb2NrR2V0VXNlciIsIm1vY2tHZXRTZXNzaW9uIiwiYXV0aCIsImdldFVzZXIiLCJnZXRTZXNzaW9uIiwiZnJvbSIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInVzZXIiLCJpZCIsImVtYWlsIiwiZXJyb3IiLCJzZXNzaW9uIiwiaXQiLCJtb2NrSGllcmFyY2h5IiwibmFtZSIsInBhcmVudExvY2F0aW9uSWQiLCJhZGRyZXNzIiwiY29vcmRpbmF0ZXMiLCJkZXNjcmlwdGlvbiIsImNyZWF0ZWRBdCIsImNoaWxkcmVuIiwibG9jYXRpb25TZXJ2aWNlIiwic3VjY2VzcyIsInJlcXVlc3QiLCJ1cmwiLCJyZXNwb25zZSIsIkdFVCIsImV4cGVjdCIsInRvQmUiLCJ0b0VxdWFsIiwiY29kZSIsIm1lc3NhZ2UiLCJuZXdMb2NhdGlvbiIsIlBPU1QiLCJtb2NrTG9jYXRpb24iLCJHRVRfQllfSUQiLCJwYXJhbXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInVwZGF0ZWRMb2NhdGlvbiIsIlBVVCIsInVuZGVmaW5lZCIsIkRFTEVURSIsIlZBTElEQVRFX1BBUkVOVCIsInZhbGlkIiwidG9CZURlZmluZWQiLCJsZW5ndGgiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0MsR0FFRCxrREFBa0Q7O0FBS2xELHdEQUF3RDtBQUN4REEsS0FBS0MsSUFBSSxDQUFDLDhCQUE4QixJQUFPLENBQUE7UUFDN0NDLFFBQVFGLEtBQUtHLEVBQUU7UUFDZkMsS0FBS0osS0FBS0csRUFBRTtRQUNaRSxRQUFRTCxLQUFLRyxFQUFFO1FBQ2ZHLGdCQUFnQk4sS0FBS0csRUFBRTtRQUN2QkksY0FBY1AsS0FBS0csRUFBRTtRQUNyQkssTUFBTVIsS0FBS0csRUFBRTtJQUNmLENBQUE7QUFFQSw2QkFBNkI7QUFDN0JILEtBQUtDLElBQUksQ0FBQyxlQUFlLElBQU8sQ0FBQTtRQUM5QlEsY0FBYztZQUNaQyxNQUFNLENBQUNDLE1BQVdDLE9BQWdCLENBQUE7b0JBQ2hDRixNQUFNLFVBQVlDO29CQUNsQkUsUUFBUUQsTUFBTUMsVUFBVTtnQkFDMUIsQ0FBQTtRQUNGO1FBQ0FDLGFBQWFkLEtBQUtHLEVBQUU7SUFDdEIsQ0FBQTtBQUVBLG1DQUFtQztBQUNuQ0gsS0FBS0MsSUFBSSxDQUFDLGdCQUFnQixJQUFPLENBQUE7UUFDL0JjLFNBQVNmLEtBQUtHLEVBQUUsQ0FBQyxJQUFPLENBQUE7Z0JBQ3RCQyxLQUFLSixLQUFLRyxFQUFFO2dCQUNa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