{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/services/sectionsService.circularReferenceDetection.property.test.ts"],"sourcesContent":["import * as fc from 'fast-check';\nimport * as sectionsService from './sectionsService';\n\n// Mock supabase\njest.mock('../lib/supabase', () => ({\n  supabase: {\n    from: jest.fn(),\n  },\n}));\n\nconst { supabase } = require('../lib/supabase');\n\ndescribe('Feature: destination-wedding-platform, Property 28: Circular Reference Detection', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  const referenceTypeArbitrary = fc.constantFrom('event', 'activity', 'content_page', 'accommodation');\n  \n  const referenceArbitrary = fc.record({\n    type: referenceTypeArbitrary,\n    id: fc.uuid(),\n    name: fc.string({ minLength: 1, maxLength: 100 }),\n  });\n\n  it('should detect direct self-reference (page references itself)', async () => {\n    await fc.assert(\n      fc.asyncProperty(fc.uuid(), referenceTypeArbitrary, async (pageId, pageType) => {\n        const selfReference = { type: pageType, id: pageId, name: 'Self' };\n\n        const result = await sectionsService.detectCircularReferences(pageId, [selfReference]);\n\n        expect(result.success).toBe(true);\n        if (result.success) {\n          // Direct self-reference should be detected\n          expect(result.data).toBe(true);\n        }\n      }),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should not detect circular reference when no references exist', async () => {\n    await fc.assert(\n      fc.asyncProperty(fc.uuid(), async (pageId) => {\n        const result = await sectionsService.detectCircularReferences(pageId, []);\n\n        expect(result.success).toBe(true);\n        if (result.success) {\n          expect(result.data).toBe(false);\n        }\n      }),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should not detect circular reference for simple non-circular references', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.uuid(),\n        fc.array(referenceArbitrary, { minLength: 1, maxLength: 5 }),\n        async (pageId, references) => {\n          // Ensure none of the references point back to the page\n          const nonCircularRefs = references.filter(ref => ref.id !== pageId);\n          \n          if (nonCircularRefs.length === 0) {\n            return; // Skip if all references were filtered out\n          }\n\n          // Mock: no sections found for referenced pages (no further references)\n          const mockFrom = jest.fn().mockReturnValue({\n            select: jest.fn().mockReturnValue({\n              eq: jest.fn().mockReturnValue({\n                eq: jest.fn().mockResolvedValue({ data: [], error: null }),\n              }),\n            }),\n          });\n          supabase.from = mockFrom;\n\n          const result = await sectionsService.detectCircularReferences(pageId, nonCircularRefs);\n\n          expect(result.success).toBe(true);\n          if (result.success) {\n            expect(result.data).toBe(false);\n          }\n        }\n      ),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should detect two-level circular reference (A -> B -> A)', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.uuid(),\n        fc.uuid(),\n        referenceTypeArbitrary,\n        async (pageAId, pageBId, pageType) => {\n          // Ensure A and B are different\n          fc.pre(pageAId !== pageBId);\n\n          // Page A references Page B\n          const refToB = { type: pageType, id: pageBId, name: 'Page B' };\n\n          // Mock: Page B has sections that reference back to Page A\n          let callCount = 0;\n          const mockFrom = jest.fn().mockImplementation((table) => {\n            if (table === 'sections') {\n              callCount++;\n              if (callCount === 1) {\n                // First call: Page B has sections\n                return {\n                  select: jest.fn().mockReturnValue({\n                    eq: jest.fn().mockReturnValue({\n                      eq: jest.fn().mockResolvedValue({\n                        data: [{ id: 'section-1' }],\n                        error: null,\n                      }),\n                    }),\n                  }),\n                };\n              }\n            } else if (table === 'columns') {\n              // Page B's columns reference back to Page A\n              return {\n                select: jest.fn().mockReturnValue({\n                  in: jest.fn().mockReturnValue({\n                    eq: jest.fn().mockResolvedValue({\n                      data: [\n                        {\n                          content_data: {\n                            references: [{ type: pageType, id: pageAId, name: 'Page A' }],\n                          },\n                        },\n                      ],\n                      error: null,\n                    }),\n                  }),\n                }),\n              };\n            }\n            return {\n              select: jest.fn().mockReturnValue({\n                eq: jest.fn().mockReturnValue({\n                  eq: jest.fn().mockResolvedValue({ data: [], error: null }),\n                }),\n              }),\n            };\n          });\n          supabase.from = mockFrom;\n\n          const result = await sectionsService.detectCircularReferences(pageAId, [refToB]);\n\n          expect(result.success).toBe(true);\n          if (result.success) {\n            // Circular reference A -> B -> A should be detected\n            expect(result.data).toBe(true);\n          }\n        }\n      ),\n      { numRuns: 50 } // Fewer runs for complex async test\n    );\n  });\n\n  it('should detect three-level circular reference (A -> B -> C -> A)', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.uuid(),\n        fc.uuid(),\n        fc.uuid(),\n        referenceTypeArbitrary,\n        async (pageAId, pageBId, pageCId, pageType) => {\n          // Ensure all pages are different\n          fc.pre(pageAId !== pageBId && pageBId !== pageCId && pageAId !== pageCId);\n\n          // Page A references Page B\n          const refToB = { type: pageType, id: pageBId, name: 'Page B' };\n\n          // Mock complex reference chain: A -> B -> C -> A\n          let sectionCallCount = 0;\n          const mockFrom = jest.fn().mockImplementation((table) => {\n            if (table === 'sections') {\n              sectionCallCount++;\n              return {\n                select: jest.fn().mockReturnValue({\n                  eq: jest.fn().mockReturnValue({\n                    eq: jest.fn().mockResolvedValue({\n                      data: [{ id: `section-${sectionCallCount}` }],\n                      error: null,\n                    }),\n                  }),\n                }),\n              };\n            } else if (table === 'columns') {\n              return {\n                select: jest.fn().mockReturnValue({\n                  in: jest.fn().mockReturnValue({\n                    eq: jest.fn().mockImplementation(() => {\n                      if (sectionCallCount === 1) {\n                        // Page B references Page C\n                        return Promise.resolve({\n                          data: [\n                            {\n                              content_data: {\n                                references: [{ type: pageType, id: pageCId, name: 'Page C' }],\n                              },\n                            },\n                          ],\n                          error: null,\n                        });\n                      } else if (sectionCallCount === 2) {\n                        // Page C references Page A (circular!)\n                        return Promise.resolve({\n                          data: [\n                            {\n                              content_data: {\n                                references: [{ type: pageType, id: pageAId, name: 'Page A' }],\n                              },\n                            },\n                          ],\n                          error: null,\n                        });\n                      }\n                      return Promise.resolve({ data: [], error: null });\n                    }),\n                  }),\n                }),\n              };\n            }\n            return {\n              select: jest.fn().mockReturnValue({\n                eq: jest.fn().mockReturnValue({\n                  eq: jest.fn().mockResolvedValue({ data: [], error: null }),\n                }),\n              }),\n            };\n          });\n          supabase.from = mockFrom;\n\n          const result = await sectionsService.detectCircularReferences(pageAId, [refToB]);\n\n          expect(result.success).toBe(true);\n          if (result.success) {\n            // Circular reference A -> B -> C -> A should be detected\n            expect(result.data).toBe(true);\n          }\n        }\n      ),\n      { numRuns: 30 } // Fewer runs for very complex async test\n    );\n  });\n\n  it('should handle multiple references without circular dependency', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.uuid(),\n        fc.array(referenceArbitrary, { minLength: 2, maxLength: 5 }),\n        async (pageId, references) => {\n          // Filter out any self-references\n          const nonCircularRefs = references.filter(ref => ref.id !== pageId);\n          \n          if (nonCircularRefs.length < 2) {\n            return; // Skip if not enough references\n          }\n\n          // Mock: all referenced pages have no further references\n          const mockFrom = jest.fn().mockReturnValue({\n            select: jest.fn().mockReturnValue({\n              eq: jest.fn().mockReturnValue({\n                eq: jest.fn().mockResolvedValue({ data: [], error: null }),\n              }),\n              in: jest.fn().mockReturnValue({\n                eq: jest.fn().mockResolvedValue({ data: [], error: null }),\n              }),\n            }),\n          });\n          supabase.from = mockFrom;\n\n          const result = await sectionsService.detectCircularReferences(pageId, nonCircularRefs);\n\n          expect(result.success).toBe(true);\n          if (result.success) {\n            expect(result.data).toBe(false);\n          }\n        }\n      ),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should handle database errors gracefully', async () => {\n    await fc.assert(\n      fc.asyncProperty(fc.uuid(), referenceArbitrary, async (pageId, reference) => {\n        // Mock database error\n        const mockFrom = jest.fn().mockReturnValue({\n          select: jest.fn().mockReturnValue({\n            eq: jest.fn().mockReturnValue({\n              eq: jest.fn().mockRejectedValue(new Error('Database connection failed')),\n            }),\n          }),\n        });\n        supabase.from = mockFrom;\n\n        const result = await sectionsService.detectCircularReferences(pageId, [reference]);\n\n        expect(result.success).toBe(false);\n        if (!result.success) {\n          expect(result.error.code).toBe('UNKNOWN_ERROR');\n          expect(result.error.message).toContain('Database connection failed');\n        }\n      }),\n      { numRuns: 50 }\n    );\n  });\n\n  it('should correctly identify visited nodes to avoid infinite loops', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.uuid(),\n        fc.uuid(),\n        referenceTypeArbitrary,\n        async (pageAId, pageBId, pageType) => {\n          fc.pre(pageAId !== pageBId);\n\n          // Page A references Page B\n          const refToB = { type: pageType, id: pageBId, name: 'Page B' };\n\n          // Mock: Page B references itself (but not back to A)\n          const mockFrom = jest.fn().mockImplementation((table) => {\n            if (table === 'sections') {\n              return {\n                select: jest.fn().mockReturnValue({\n                  eq: jest.fn().mockReturnValue({\n                    eq: jest.fn().mockResolvedValue({\n                      data: [{ id: 'section-1' }],\n                      error: null,\n                    }),\n                  }),\n                }),\n              };\n            } else if (table === 'columns') {\n              return {\n                select: jest.fn().mockReturnValue({\n                  in: jest.fn().mockReturnValue({\n                    eq: jest.fn().mockResolvedValue({\n                      data: [\n                        {\n                          content_data: {\n                            references: [{ type: pageType, id: pageBId, name: 'Page B' }],\n                          },\n                        },\n                      ],\n                      error: null,\n                    }),\n                  }),\n                }),\n              };\n            }\n            return {\n              select: jest.fn().mockReturnValue({\n                eq: jest.fn().mockReturnValue({\n                  eq: jest.fn().mockResolvedValue({ data: [], error: null }),\n                }),\n              }),\n            };\n          });\n          supabase.from = mockFrom;\n\n          const result = await sectionsService.detectCircularReferences(pageAId, [refToB]);\n\n          expect(result.success).toBe(true);\n          // Page B referencing itself is circular, but doesn't create a cycle back to A\n          // The algorithm should detect the self-reference in B\n        }\n      ),\n      { numRuns: 50 }\n    );\n  });\n});\n"],"names":["jest","mock","supabase","from","fn","require","describe","beforeEach","clearAllMocks","referenceTypeArbitrary","fc","constantFrom","referenceArbitrary","record","type","id","uuid","name","string","minLength","maxLength","it","assert","asyncProperty","pageId","pageType","selfReference","result","sectionsService","detectCircularReferences","expect","success","toBe","data","numRuns","array","references","nonCircularRefs","filter","ref","length","mockFrom","mockReturnValue","select","eq","mockResolvedValue","error","pageAId","pageBId","pre","refToB","callCount","mockImplementation","table","in","content_data","pageCId","sectionCallCount","Promise","resolve","reference","mockRejectedValue","Error","code","message","toContain"],"mappings":"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"}