64a8f804cfc5bfb6e30d2da9e26c78cf
/**
 * TypeScript Build Validation Tests
 * 
 * These tests validate that TypeScript compiles without errors.
 * They catch type errors that might not be caught by unit tests.
 * 
 * Why this exists:
 * - Unit tests use ts-jest which is more lenient than tsc
 * - Type errors can slip through if not explicitly checked
 * - Production build uses strict TypeScript compilation
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _child_process = require("child_process");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe.skip('TypeScript Compilation', ()=>{
    it('should compile without errors', ()=>{
        expect(()=>{
            (0, _child_process.execSync)('npx tsc --noEmit', {
                stdio: 'pipe',
                encoding: 'utf-8'
            });
        }).not.toThrow();
    }, 30000); // 30 second timeout for compilation
    it('should have 0 TypeScript errors', ()=>{
        try {
            const output = (0, _child_process.execSync)('npx tsc --noEmit', {
                encoding: 'utf-8',
                stdio: 'pipe'
            });
            // If there are errors, tsc will output them
            expect(output).not.toContain('error TS');
            expect(output).not.toContain('Found');
        } catch (error) {
            // If tsc exits with error code, fail the test with the output
            fail(`TypeScript compilation failed:\n${error.stdout || error.message}`);
        }
    }, 30000);
    it('should use strict mode', async ()=>{
        const { readFile } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("node:fs/promises")));
        const tsconfig = JSON.parse(await readFile('tsconfig.json', 'utf-8'));
        expect(tsconfig.compilerOptions.strict).toBe(true);
    });
    it('should not have any type assertions', async ()=>{
        // This is a stricter check - we want to minimize 'as any' usage
        const { execSync } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("child_process")));
        try {
            const output = execSync('grep -r "as any" app/ components/ services/ lib/ hooks/ --include="*.ts" --include="*.tsx" || true', {
                encoding: 'utf-8'
            });
            // Allow some 'as any' but warn if there are too many
            const count = output.split('\n').filter((line)=>line.trim()).length;
            if (count > 10) {
                console.warn(`Warning: Found ${count} instances of 'as any'. Consider reducing type assertions.`);
            }
            // This is a soft check - we don't fail the test, just warn
            expect(count).toBeLessThan(50);
        } catch (error) {
        // grep returns non-zero if no matches, which is good
        }
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvX190ZXN0c19fL2J1aWxkL3R5cGVzY3JpcHQuYnVpbGQudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFR5cGVTY3JpcHQgQnVpbGQgVmFsaWRhdGlvbiBUZXN0c1xuICogXG4gKiBUaGVzZSB0ZXN0cyB2YWxpZGF0ZSB0aGF0IFR5cGVTY3JpcHQgY29tcGlsZXMgd2l0aG91dCBlcnJvcnMuXG4gKiBUaGV5IGNhdGNoIHR5cGUgZXJyb3JzIHRoYXQgbWlnaHQgbm90IGJlIGNhdWdodCBieSB1bml0IHRlc3RzLlxuICogXG4gKiBXaHkgdGhpcyBleGlzdHM6XG4gKiAtIFVuaXQgdGVzdHMgdXNlIHRzLWplc3Qgd2hpY2ggaXMgbW9yZSBsZW5pZW50IHRoYW4gdHNjXG4gKiAtIFR5cGUgZXJyb3JzIGNhbiBzbGlwIHRocm91Z2ggaWYgbm90IGV4cGxpY2l0bHkgY2hlY2tlZFxuICogLSBQcm9kdWN0aW9uIGJ1aWxkIHVzZXMgc3RyaWN0IFR5cGVTY3JpcHQgY29tcGlsYXRpb25cbiAqL1xuXG5pbXBvcnQgeyBleGVjU3luYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuXG5kZXNjcmliZS5za2lwKCdUeXBlU2NyaXB0IENvbXBpbGF0aW9uJywgKCkgPT4ge1xuICBpdCgnc2hvdWxkIGNvbXBpbGUgd2l0aG91dCBlcnJvcnMnLCAoKSA9PiB7XG4gICAgZXhwZWN0KCgpID0+IHtcbiAgICAgIGV4ZWNTeW5jKCducHggdHNjIC0tbm9FbWl0JywgeyBcbiAgICAgICAgc3RkaW86ICdwaXBlJyxcbiAgICAgICAgZW5jb2Rpbmc6ICd1dGYtOCcgXG4gICAgICB9KTtcbiAgICB9KS5ub3QudG9UaHJvdygpO1xuICB9LCAzMDAwMCk7IC8vIDMwIHNlY29uZCB0aW1lb3V0IGZvciBjb21waWxhdGlvblxuXG4gIGl0KCdzaG91bGQgaGF2ZSAwIFR5cGVTY3JpcHQgZXJyb3JzJywgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBleGVjU3luYygnbnB4IHRzYyAtLW5vRW1pdCcsIHsgXG4gICAgICAgIGVuY29kaW5nOiAndXRmLTgnLFxuICAgICAgICBzdGRpbzogJ3BpcGUnXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gSWYgdGhlcmUgYXJlIGVycm9ycywgdHNjIHdpbGwgb3V0cHV0IHRoZW1cbiAgICAgIGV4cGVjdChvdXRwdXQpLm5vdC50b0NvbnRhaW4oJ2Vycm9yIFRTJyk7XG4gICAgICBleHBlY3Qob3V0cHV0KS5ub3QudG9Db250YWluKCdGb3VuZCcpO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIC8vIElmIHRzYyBleGl0cyB3aXRoIGVycm9yIGNvZGUsIGZhaWwgdGhlIHRlc3Qgd2l0aCB0aGUgb3V0cHV0XG4gICAgICBmYWlsKGBUeXBlU2NyaXB0IGNvbXBpbGF0aW9uIGZhaWxlZDpcXG4ke2Vycm9yLnN0ZG91dCB8fCBlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfSwgMzAwMDApO1xuXG4gIGl0KCdzaG91bGQgdXNlIHN0cmljdCBtb2RlJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHsgcmVhZEZpbGUgfSA9IGF3YWl0IGltcG9ydCgnZnMvcHJvbWlzZXMnKTtcbiAgICBjb25zdCB0c2NvbmZpZyA9IEpTT04ucGFyc2UoXG4gICAgICBhd2FpdCByZWFkRmlsZSgndHNjb25maWcuanNvbicsICd1dGYtOCcpXG4gICAgKTtcbiAgICBcbiAgICBleHBlY3QodHNjb25maWcuY29tcGlsZXJPcHRpb25zLnN0cmljdCkudG9CZSh0cnVlKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBub3QgaGF2ZSBhbnkgdHlwZSBhc3NlcnRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgIC8vIFRoaXMgaXMgYSBzdHJpY3RlciBjaGVjayAtIHdlIHdhbnQgdG8gbWluaW1pemUgJ2FzIGFueScgdXNhZ2VcbiAgICBjb25zdCB7IGV4ZWNTeW5jIH0gPSBhd2FpdCBpbXBvcnQoJ2NoaWxkX3Byb2Nlc3MnKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gZXhlY1N5bmMoXG4gICAgICAgICdncmVwIC1yIFwiYXMgYW55XCIgYXBwLyBjb21wb25lbnRzLyBzZXJ2aWNlcy8gbGliLyBob29rcy8gLS1pbmNsdWRlPVwiKi50c1wiIC0taW5jbHVkZT1cIioudHN4XCIgfHwgdHJ1ZScsXG4gICAgICAgIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gQWxsb3cgc29tZSAnYXMgYW55JyBidXQgd2FybiBpZiB0aGVyZSBhcmUgdG9vIG1hbnlcbiAgICAgIGNvbnN0IGNvdW50ID0gb3V0cHV0LnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiBsaW5lLnRyaW0oKSkubGVuZ3RoO1xuICAgICAgXG4gICAgICBpZiAoY291bnQgPiAxMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6IEZvdW5kICR7Y291bnR9IGluc3RhbmNlcyBvZiAnYXMgYW55Jy4gQ29uc2lkZXIgcmVkdWNpbmcgdHlwZSBhc3NlcnRpb25zLmApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBUaGlzIGlzIGEgc29mdCBjaGVjayAtIHdlIGRvbid0IGZhaWwgdGhlIHRlc3QsIGp1c3Qgd2FyblxuICAgICAgZXhwZWN0KGNvdW50KS50b0JlTGVzc1RoYW4oNTApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBncmVwIHJldHVybnMgbm9uLXplcm8gaWYgbm8gbWF0Y2hlcywgd2hpY2ggaXMgZ29vZFxuICAgIH1cbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJkZXNjcmliZSIsInNraXAiLCJpdCIsImV4cGVjdCIsImV4ZWNTeW5jIiwic3RkaW8iLCJlbmNvZGluZyIsIm5vdCIsInRvVGhyb3ciLCJvdXRwdXQiLCJ0b0NvbnRhaW4iLCJlcnJvciIsImZhaWwiLCJzdGRvdXQiLCJtZXNzYWdlIiwicmVhZEZpbGUiLCJ0c2NvbmZpZyIsIkpTT04iLCJwYXJzZSIsImNvbXBpbGVyT3B0aW9ucyIsInN0cmljdCIsInRvQmUiLCJjb3VudCIsInNwbGl0IiwiZmlsdGVyIiwibGluZSIsInRyaW0iLCJsZW5ndGgiLCJjb25zb2xlIiwid2FybiIsInRvQmVMZXNzVGhhbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Q0FVQzs7OzsrQkFFd0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUV6QkEsU0FBU0MsSUFBSSxDQUFDLDBCQUEwQjtJQUN0Q0MsR0FBRyxpQ0FBaUM7UUFDbENDLE9BQU87WUFDTEMsSUFBQUEsdUJBQVEsRUFBQyxvQkFBb0I7Z0JBQzNCQyxPQUFPO2dCQUNQQyxVQUFVO1lBQ1o7UUFDRixHQUFHQyxHQUFHLENBQUNDLE9BQU87SUFDaEIsR0FBRyxRQUFRLG9DQUFvQztJQUUvQ04sR0FBRyxtQ0FBbUM7UUFDcEMsSUFBSTtZQUNGLE1BQU1PLFNBQVNMLElBQUFBLHVCQUFRLEVBQUMsb0JBQW9CO2dCQUMxQ0UsVUFBVTtnQkFDVkQsT0FBTztZQUNUO1lBRUEsNENBQTRDO1lBQzVDRixPQUFPTSxRQUFRRixHQUFHLENBQUNHLFNBQVMsQ0FBQztZQUM3QlAsT0FBT00sUUFBUUYsR0FBRyxDQUFDRyxTQUFTLENBQUM7UUFDL0IsRUFBRSxPQUFPQyxPQUFZO1lBQ25CLDhEQUE4RDtZQUM5REMsS0FBSyxDQUFDLGdDQUFnQyxFQUFFRCxNQUFNRSxNQUFNLElBQUlGLE1BQU1HLE9BQU8sRUFBRTtRQUN6RTtJQUNGLEdBQUc7SUFFSFosR0FBRywwQkFBMEI7UUFDM0IsTUFBTSxFQUFFYSxRQUFRLEVBQUUsR0FBRyxNQUFNLG1FQUFBLFFBQU87UUFDbEMsTUFBTUMsV0FBV0MsS0FBS0MsS0FBSyxDQUN6QixNQUFNSCxTQUFTLGlCQUFpQjtRQUdsQ1osT0FBT2EsU0FBU0csZUFBZSxDQUFDQyxNQUFNLEVBQUVDLElBQUksQ0FBQztJQUMvQztJQUVBbkIsR0FBRyx1Q0FBdUM7UUFDeEMsZ0VBQWdFO1FBQ2hFLE1BQU0sRUFBRUUsUUFBUSxFQUFFLEdBQUcsTUFBTSxtRUFBQSxRQUFPO1FBRWxDLElBQUk7WUFDRixNQUFNSyxTQUFTTCxTQUNiLHNHQUNBO2dCQUFFRSxVQUFVO1lBQVE7WUFHdEIscURBQXFEO1lBQ3JELE1BQU1nQixRQUFRYixPQUFPYyxLQUFLLENBQUMsTUFBTUMsTUFBTSxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLQyxJQUFJLElBQUlDLE1BQU07WUFFbkUsSUFBSUwsUUFBUSxJQUFJO2dCQUNkTSxRQUFRQyxJQUFJLENBQUMsQ0FBQyxlQUFlLEVBQUVQLE1BQU0sMERBQTBELENBQUM7WUFDbEc7WUFFQSwyREFBMkQ7WUFDM0RuQixPQUFPbUIsT0FBT1EsWUFBWSxDQUFDO1FBQzdCLEVBQUUsT0FBT25CLE9BQU87UUFDZCxxREFBcUQ7UUFDdkQ7SUFDRjtBQUNGIn0=