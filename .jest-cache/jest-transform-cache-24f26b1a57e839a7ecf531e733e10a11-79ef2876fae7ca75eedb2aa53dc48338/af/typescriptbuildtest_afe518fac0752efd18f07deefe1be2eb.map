{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/__tests__/build/typescript.build.test.ts"],"sourcesContent":["/**\n * TypeScript Build Validation Tests\n * \n * These tests validate that TypeScript compiles without errors.\n * They catch type errors that might not be caught by unit tests.\n * \n * Why this exists:\n * - Unit tests use ts-jest which is more lenient than tsc\n * - Type errors can slip through if not explicitly checked\n * - Production build uses strict TypeScript compilation\n */\n\nimport { execSync } from 'child_process';\n\ndescribe.skip('TypeScript Compilation', () => {\n  it('should compile without errors', () => {\n    expect(() => {\n      execSync('npx tsc --noEmit', { \n        stdio: 'pipe',\n        encoding: 'utf-8' \n      });\n    }).not.toThrow();\n  }, 30000); // 30 second timeout for compilation\n\n  it('should have 0 TypeScript errors', () => {\n    try {\n      const output = execSync('npx tsc --noEmit', { \n        encoding: 'utf-8',\n        stdio: 'pipe'\n      });\n      \n      // If there are errors, tsc will output them\n      expect(output).not.toContain('error TS');\n      expect(output).not.toContain('Found');\n    } catch (error: any) {\n      // If tsc exits with error code, fail the test with the output\n      fail(`TypeScript compilation failed:\\n${error.stdout || error.message}`);\n    }\n  }, 30000);\n\n  it('should use strict mode', async () => {\n    const { readFile } = await import('fs/promises');\n    const tsconfig = JSON.parse(\n      await readFile('tsconfig.json', 'utf-8')\n    );\n    \n    expect(tsconfig.compilerOptions.strict).toBe(true);\n  });\n\n  it('should not have any type assertions', async () => {\n    // This is a stricter check - we want to minimize 'as any' usage\n    const { execSync } = await import('child_process');\n    \n    try {\n      const output = execSync(\n        'grep -r \"as any\" app/ components/ services/ lib/ hooks/ --include=\"*.ts\" --include=\"*.tsx\" || true',\n        { encoding: 'utf-8' }\n      );\n      \n      // Allow some 'as any' but warn if there are too many\n      const count = output.split('\\n').filter(line => line.trim()).length;\n      \n      if (count > 10) {\n        console.warn(`Warning: Found ${count} instances of 'as any'. Consider reducing type assertions.`);\n      }\n      \n      // This is a soft check - we don't fail the test, just warn\n      expect(count).toBeLessThan(50);\n    } catch (error) {\n      // grep returns non-zero if no matches, which is good\n    }\n  });\n});\n"],"names":["describe","skip","it","expect","execSync","stdio","encoding","not","toThrow","output","toContain","error","fail","stdout","message","readFile","tsconfig","JSON","parse","compilerOptions","strict","toBe","count","split","filter","line","trim","length","console","warn","toBeLessThan"],"mappings":"AAAA;;;;;;;;;;CAUC;;;;+BAEwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEzBA,SAASC,IAAI,CAAC,0BAA0B;IACtCC,GAAG,iCAAiC;QAClCC,OAAO;YACLC,IAAAA,uBAAQ,EAAC,oBAAoB;gBAC3BC,OAAO;gBACPC,UAAU;YACZ;QACF,GAAGC,GAAG,CAACC,OAAO;IAChB,GAAG,QAAQ,oCAAoC;IAE/CN,GAAG,mCAAmC;QACpC,IAAI;YACF,MAAMO,SAASL,IAAAA,uBAAQ,EAAC,oBAAoB;gBAC1CE,UAAU;gBACVD,OAAO;YACT;YAEA,4CAA4C;YAC5CF,OAAOM,QAAQF,GAAG,CAACG,SAAS,CAAC;YAC7BP,OAAOM,QAAQF,GAAG,CAACG,SAAS,CAAC;QAC/B,EAAE,OAAOC,OAAY;YACnB,8DAA8D;YAC9DC,KAAK,CAAC,gCAAgC,EAAED,MAAME,MAAM,IAAIF,MAAMG,OAAO,EAAE;QACzE;IACF,GAAG;IAEHZ,GAAG,0BAA0B;QAC3B,MAAM,EAAEa,QAAQ,EAAE,GAAG,MAAM,mEAAA,QAAO;QAClC,MAAMC,WAAWC,KAAKC,KAAK,CACzB,MAAMH,SAAS,iBAAiB;QAGlCZ,OAAOa,SAASG,eAAe,CAACC,MAAM,EAAEC,IAAI,CAAC;IAC/C;IAEAnB,GAAG,uCAAuC;QACxC,gEAAgE;QAChE,MAAM,EAAEE,QAAQ,EAAE,GAAG,MAAM,mEAAA,QAAO;QAElC,IAAI;YACF,MAAMK,SAASL,SACb,sGACA;gBAAEE,UAAU;YAAQ;YAGtB,qDAAqD;YACrD,MAAMgB,QAAQb,OAAOc,KAAK,CAAC,MAAMC,MAAM,CAACC,CAAAA,OAAQA,KAAKC,IAAI,IAAIC,MAAM;YAEnE,IAAIL,QAAQ,IAAI;gBACdM,QAAQC,IAAI,CAAC,CAAC,eAAe,EAAEP,MAAM,0DAA0D,CAAC;YAClG;YAEA,2DAA2D;YAC3DnB,OAAOmB,OAAOQ,YAAY,CAAC;QAC7B,EAAE,OAAOnB,OAAO;QACd,qDAAqD;QACvD;IACF;AACF"}