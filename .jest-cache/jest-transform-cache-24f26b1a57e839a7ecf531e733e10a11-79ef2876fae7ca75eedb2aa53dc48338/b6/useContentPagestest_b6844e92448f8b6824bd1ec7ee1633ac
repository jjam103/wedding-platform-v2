0f6221c3b77f230bbd4edd4133514a7a
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useContentPages = require("./useContentPages");
// Mock fetch globally
global.fetch = jest.fn();
describe('useContentPages', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        global.fetch.mockClear();
    });
    afterEach(()=>{
        jest.restoreAllMocks();
    });
    describe('loading states', ()=>{
        it('should start with loading true', ()=>{
            global.fetch.mockImplementation(()=>new Promise(()=>{}) // Never resolves
            );
            const { result } = (0, _react.renderHook)(()=>(0, _useContentPages.useContentPages)());
            expect(result.current.loading).toBe(true);
            expect(result.current.data).toEqual([]);
            expect(result.current.error).toBeNull();
        });
        it('should set loading false after successful fetch', async ()=>{
            const mockData = [
                {
                    id: 'page-1',
                    slug: 'test-page',
                    title: 'Test Page',
                    status: 'published',
                    createdAt: '2025-01-01T00:00:00Z',
                    updatedAt: '2025-01-01T00:00:00Z'
                }
            ];
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockData
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useContentPages.useContentPages)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(result.current.data).toEqual(mockData);
            expect(result.current.error).toBeNull();
        });
        it('should set loading false after failed fetch', async ()=>{
            global.fetch.mockResolvedValueOnce({
                ok: false,
                json: async ()=>({
                        success: false,
                        error: {
                            message: 'Failed to fetch'
                        }
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useContentPages.useContentPages)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(result.current.data).toEqual([]);
            expect(result.current.error).toBeInstanceOf(Error);
        });
    });
    describe('error handling', ()=>{
        it('should handle network errors', async ()=>{
            global.fetch.mockRejectedValueOnce(new Error('Network error'));
            const { result } = (0, _react.renderHook)(()=>(0, _useContentPages.useContentPages)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.error).toBeInstanceOf(Error);
            });
            expect(result.current.error?.message).toBe('Network error');
            expect(result.current.loading).toBe(false);
            expect(result.current.data).toEqual([]);
        });
        it('should handle API error responses', async ()=>{
            global.fetch.mockResolvedValueOnce({
                ok: false,
                json: async ()=>({
                        success: false,
                        error: {
                            message: 'Unauthorized'
                        }
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useContentPages.useContentPages)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.error).toBeInstanceOf(Error);
            });
            expect(result.current.error?.message).toBe('Unauthorized');
        });
        it('should handle malformed response', async ()=>{
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: false
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useContentPages.useContentPages)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.error).toBeInstanceOf(Error);
            });
            expect(result.current.error?.message).toBe('Failed to fetch content pages');
        });
    });
    describe('data refetching', ()=>{
        it('should refetch data when refetch is called', async ()=>{
            const initialData = [
                {
                    id: 'page-1',
                    slug: 'initial',
                    title: 'Initial',
                    status: 'draft',
                    createdAt: '2025-01-01T00:00:00Z',
                    updatedAt: '2025-01-01T00:00:00Z'
                }
            ];
            const updatedData = [
                ...initialData,
                {
                    id: 'page-2',
                    slug: 'new-page',
                    title: 'New Page',
                    status: 'published',
                    createdAt: '2025-01-02T00:00:00Z',
                    updatedAt: '2025-01-02T00:00:00Z'
                }
            ];
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: initialData
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: updatedData
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useContentPages.useContentPages)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.data).toEqual(initialData);
            });
            await result.current.refetch();
            await (0, _react.waitFor)(()=>{
                expect(result.current.data).toEqual(updatedData);
            });
        });
        it('should reset error state on refetch', async ()=>{
            global.fetch.mockRejectedValueOnce(new Error('Initial error')).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: []
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useContentPages.useContentPages)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.error).toBeInstanceOf(Error);
            });
            await result.current.refetch();
            await (0, _react.waitFor)(()=>{
                expect(result.current.error).toBeNull();
            });
        });
    });
    describe('optimistic updates', ()=>{
        it('should optimistically add new page on create', async ()=>{
            const existingData = [
                {
                    id: 'page-1',
                    slug: 'existing',
                    title: 'Existing',
                    status: 'published',
                    createdAt: '2025-01-01T00:00:00Z',
                    updatedAt: '2025-01-01T00:00:00Z'
                }
            ];
            const newPage = {
                id: 'page-2',
                slug: 'new-page',
                title: 'New Page',
                status: 'draft',
                createdAt: '2025-01-02T00:00:00Z',
                updatedAt: '2025-01-02T00:00:00Z'
            };
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: existingData
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: newPage
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useContentPages.useContentPages)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.data).toEqual(existingData);
            });
            const createResult = await result.current.create({
                title: 'New Page',
                slug: 'new-page'
            });
            expect(createResult.success).toBe(true);
            await (0, _react.waitFor)(()=>{
                expect(result.current.data).toHaveLength(2);
            });
            expect(result.current.data[1]).toEqual(newPage);
        });
        it('should optimistically update existing page', async ()=>{
            const initialData = [
                {
                    id: 'page-1',
                    slug: 'test-page',
                    title: 'Original Title',
                    status: 'draft',
                    createdAt: '2025-01-01T00:00:00Z',
                    updatedAt: '2025-01-01T00:00:00Z'
                }
            ];
            const updatedPage = {
                ...initialData[0],
                title: 'Updated Title',
                updatedAt: '2025-01-02T00:00:00Z'
            };
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: initialData
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: updatedPage
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useContentPages.useContentPages)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.data[0].title).toBe('Original Title');
            });
            const updateResult = await result.current.update('page-1', {
                title: 'Updated Title'
            });
            expect(updateResult.success).toBe(true);
            await (0, _react.waitFor)(()=>{
                expect(result.current.data[0].title).toBe('Updated Title');
            });
        });
        it('should optimistically remove page on delete', async ()=>{
            const initialData = [
                {
                    id: 'page-1',
                    slug: 'page-1',
                    title: 'Page 1',
                    status: 'published',
                    createdAt: '2025-01-01T00:00:00Z',
                    updatedAt: '2025-01-01T00:00:00Z'
                },
                {
                    id: 'page-2',
                    slug: 'page-2',
                    title: 'Page 2',
                    status: 'draft',
                    createdAt: '2025-01-02T00:00:00Z',
                    updatedAt: '2025-01-02T00:00:00Z'
                }
            ];
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: initialData
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useContentPages.useContentPages)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.data).toHaveLength(2);
            });
            const deleteResult = await result.current.remove('page-1');
            expect(deleteResult.success).toBe(true);
            await (0, _react.waitFor)(()=>{
                expect(result.current.data).toHaveLength(1);
            });
            expect(result.current.data[0].id).toBe('page-2');
        });
        it('should not update state on failed create', async ()=>{
            const initialData = [
                {
                    id: 'page-1',
                    slug: 'existing',
                    title: 'Existing',
                    status: 'published',
                    createdAt: '2025-01-01T00:00:00Z',
                    updatedAt: '2025-01-01T00:00:00Z'
                }
            ];
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: initialData
                    })
            }).mockResolvedValueOnce({
                ok: false,
                json: async ()=>({
                        success: false,
                        error: {
                            message: 'Validation error'
                        }
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useContentPages.useContentPages)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.data).toEqual(initialData);
            });
            const createResult = await result.current.create({
                title: 'New Page'
            });
            expect(createResult.success).toBe(false);
            expect(createResult.error).toBe('Validation error');
            expect(result.current.data).toEqual(initialData);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvaG9va3MvdXNlQ29udGVudFBhZ2VzLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVuZGVySG9vaywgd2FpdEZvciB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xuaW1wb3J0IHsgdXNlQ29udGVudFBhZ2VzIH0gZnJvbSAnLi91c2VDb250ZW50UGFnZXMnO1xuXG4vLyBNb2NrIGZldGNoIGdsb2JhbGx5XG5nbG9iYWwuZmV0Y2ggPSBqZXN0LmZuKCk7XG5cbmRlc2NyaWJlKCd1c2VDb250ZW50UGFnZXMnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrQ2xlYXIoKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBqZXN0LnJlc3RvcmVBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnbG9hZGluZyBzdGF0ZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzdGFydCB3aXRoIGxvYWRpbmcgdHJ1ZScsICgpID0+IHtcbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT5cbiAgICAgICAgbmV3IFByb21pc2UoKCkgPT4ge30pIC8vIE5ldmVyIHJlc29sdmVzXG4gICAgICApO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VDb250ZW50UGFnZXMoKSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGEpLnRvRXF1YWwoW10pO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzZXQgbG9hZGluZyBmYWxzZSBhZnRlciBzdWNjZXNzZnVsIGZldGNoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0RhdGEgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3BhZ2UtMScsXG4gICAgICAgICAgc2x1ZzogJ3Rlc3QtcGFnZScsXG4gICAgICAgICAgdGl0bGU6ICdUZXN0IFBhZ2UnLFxuICAgICAgICAgIHN0YXR1czogJ3B1Ymxpc2hlZCcgYXMgY29uc3QsXG4gICAgICAgICAgY3JlYXRlZEF0OiAnMjAyNS0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICAgIHVwZGF0ZWRBdDogJzIwMjUtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogbW9ja0RhdGEgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlQ29udGVudFBhZ2VzKCkpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhKS50b0VxdWFsKG1vY2tEYXRhKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZU51bGwoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc2V0IGxvYWRpbmcgZmFsc2UgYWZ0ZXIgZmFpbGVkIGZldGNoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgKGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnRmFpbGVkIHRvIGZldGNoJyB9LFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VDb250ZW50UGFnZXMoKSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGEpLnRvRXF1YWwoW10pO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlSW5zdGFuY2VPZihFcnJvcik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdlcnJvciBoYW5kbGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBuZXR3b3JrIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UoXG4gICAgICAgIG5ldyBFcnJvcignTmV0d29yayBlcnJvcicpXG4gICAgICApO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VDb250ZW50UGFnZXMoKSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3IpLnRvQmVJbnN0YW5jZU9mKEVycm9yKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3I/Lm1lc3NhZ2UpLnRvQmUoJ05ldHdvcmsgZXJyb3InKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhKS50b0VxdWFsKFtdKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIEFQSSBlcnJvciByZXNwb25zZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6ICdVbmF1dGhvcml6ZWQnIH0sXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZUNvbnRlbnRQYWdlcygpKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZUluc3RhbmNlT2YoRXJyb3IpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcj8ubWVzc2FnZSkudG9CZSgnVW5hdXRob3JpemVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtYWxmb3JtZWQgcmVzcG9uc2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IHN1Y2Nlc3M6IGZhbHNlIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZUNvbnRlbnRQYWdlcygpKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZUluc3RhbmNlT2YoRXJyb3IpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcj8ubWVzc2FnZSkudG9CZSgnRmFpbGVkIHRvIGZldGNoIGNvbnRlbnQgcGFnZXMnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2RhdGEgcmVmZXRjaGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJlZmV0Y2ggZGF0YSB3aGVuIHJlZmV0Y2ggaXMgY2FsbGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW5pdGlhbERhdGEgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3BhZ2UtMScsXG4gICAgICAgICAgc2x1ZzogJ2luaXRpYWwnLFxuICAgICAgICAgIHRpdGxlOiAnSW5pdGlhbCcsXG4gICAgICAgICAgc3RhdHVzOiAnZHJhZnQnIGFzIGNvbnN0LFxuICAgICAgICAgIGNyZWF0ZWRBdDogJzIwMjUtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgICAgICB1cGRhdGVkQXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCB1cGRhdGVkRGF0YSA9IFtcbiAgICAgICAgLi4uaW5pdGlhbERhdGEsXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3BhZ2UtMicsXG4gICAgICAgICAgc2x1ZzogJ25ldy1wYWdlJyxcbiAgICAgICAgICB0aXRsZTogJ05ldyBQYWdlJyxcbiAgICAgICAgICBzdGF0dXM6ICdwdWJsaXNoZWQnIGFzIGNvbnN0LFxuICAgICAgICAgIGNyZWF0ZWRBdDogJzIwMjUtMDEtMDJUMDA6MDA6MDBaJyxcbiAgICAgICAgICB1cGRhdGVkQXQ6ICcyMDI1LTAxLTAyVDAwOjAwOjAwWicsXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaylcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogaW5pdGlhbERhdGEgfSksXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHVwZGF0ZWREYXRhIH0pLFxuICAgICAgICB9KTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlQ29udGVudFBhZ2VzKCkpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGEpLnRvRXF1YWwoaW5pdGlhbERhdGEpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LnJlZmV0Y2goKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhKS50b0VxdWFsKHVwZGF0ZWREYXRhKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXNldCBlcnJvciBzdGF0ZSBvbiByZWZldGNoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgKGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spXG4gICAgICAgIC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKCdJbml0aWFsIGVycm9yJykpXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IFtdIH0pLFxuICAgICAgICB9KTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlQ29udGVudFBhZ2VzKCkpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlSW5zdGFuY2VPZihFcnJvcik7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnQucmVmZXRjaCgpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdvcHRpbWlzdGljIHVwZGF0ZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBvcHRpbWlzdGljYWxseSBhZGQgbmV3IHBhZ2Ugb24gY3JlYXRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmdEYXRhID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdwYWdlLTEnLFxuICAgICAgICAgIHNsdWc6ICdleGlzdGluZycsXG4gICAgICAgICAgdGl0bGU6ICdFeGlzdGluZycsXG4gICAgICAgICAgc3RhdHVzOiAncHVibGlzaGVkJyBhcyBjb25zdCxcbiAgICAgICAgICBjcmVhdGVkQXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgICAgdXBkYXRlZEF0OiAnMjAyNS0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgY29uc3QgbmV3UGFnZSA9IHtcbiAgICAgICAgaWQ6ICdwYWdlLTInLFxuICAgICAgICBzbHVnOiAnbmV3LXBhZ2UnLFxuICAgICAgICB0aXRsZTogJ05ldyBQYWdlJyxcbiAgICAgICAgc3RhdHVzOiAnZHJhZnQnIGFzIGNvbnN0LFxuICAgICAgICBjcmVhdGVkQXQ6ICcyMDI1LTAxLTAyVDAwOjAwOjAwWicsXG4gICAgICAgIHVwZGF0ZWRBdDogJzIwMjUtMDEtMDJUMDA6MDA6MDBaJyxcbiAgICAgIH07XG5cbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBleGlzdGluZ0RhdGEgfSksXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IG5ld1BhZ2UgfSksXG4gICAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VDb250ZW50UGFnZXMoKSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YSkudG9FcXVhbChleGlzdGluZ0RhdGEpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGNyZWF0ZVJlc3VsdCA9IGF3YWl0IHJlc3VsdC5jdXJyZW50LmNyZWF0ZSh7XG4gICAgICAgIHRpdGxlOiAnTmV3IFBhZ2UnLFxuICAgICAgICBzbHVnOiAnbmV3LXBhZ2UnLFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChjcmVhdGVSZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIFxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGFbMV0pLnRvRXF1YWwobmV3UGFnZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG9wdGltaXN0aWNhbGx5IHVwZGF0ZSBleGlzdGluZyBwYWdlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW5pdGlhbERhdGEgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3BhZ2UtMScsXG4gICAgICAgICAgc2x1ZzogJ3Rlc3QtcGFnZScsXG4gICAgICAgICAgdGl0bGU6ICdPcmlnaW5hbCBUaXRsZScsXG4gICAgICAgICAgc3RhdHVzOiAnZHJhZnQnIGFzIGNvbnN0LFxuICAgICAgICAgIGNyZWF0ZWRBdDogJzIwMjUtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgICAgICB1cGRhdGVkQXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCB1cGRhdGVkUGFnZSA9IHtcbiAgICAgICAgLi4uaW5pdGlhbERhdGFbMF0sXG4gICAgICAgIHRpdGxlOiAnVXBkYXRlZCBUaXRsZScsXG4gICAgICAgIHVwZGF0ZWRBdDogJzIwMjUtMDEtMDJUMDA6MDA6MDBaJyxcbiAgICAgIH07XG5cbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBpbml0aWFsRGF0YSB9KSxcbiAgICAgICAgfSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogdXBkYXRlZFBhZ2UgfSksXG4gICAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VDb250ZW50UGFnZXMoKSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YVswXS50aXRsZSkudG9CZSgnT3JpZ2luYWwgVGl0bGUnKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB1cGRhdGVSZXN1bHQgPSBhd2FpdCByZXN1bHQuY3VycmVudC51cGRhdGUoJ3BhZ2UtMScsIHtcbiAgICAgICAgdGl0bGU6ICdVcGRhdGVkIFRpdGxlJyxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QodXBkYXRlUmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YVswXS50aXRsZSkudG9CZSgnVXBkYXRlZCBUaXRsZScpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG9wdGltaXN0aWNhbGx5IHJlbW92ZSBwYWdlIG9uIGRlbGV0ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGluaXRpYWxEYXRhID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdwYWdlLTEnLFxuICAgICAgICAgIHNsdWc6ICdwYWdlLTEnLFxuICAgICAgICAgIHRpdGxlOiAnUGFnZSAxJyxcbiAgICAgICAgICBzdGF0dXM6ICdwdWJsaXNoZWQnIGFzIGNvbnN0LFxuICAgICAgICAgIGNyZWF0ZWRBdDogJzIwMjUtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgICAgICB1cGRhdGVkQXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3BhZ2UtMicsXG4gICAgICAgICAgc2x1ZzogJ3BhZ2UtMicsXG4gICAgICAgICAgdGl0bGU6ICdQYWdlIDInLFxuICAgICAgICAgIHN0YXR1czogJ2RyYWZ0JyBhcyBjb25zdCxcbiAgICAgICAgICBjcmVhdGVkQXQ6ICcyMDI1LTAxLTAyVDAwOjAwOjAwWicsXG4gICAgICAgICAgdXBkYXRlZEF0OiAnMjAyNS0wMS0wMlQwMDowMDowMFonLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgKGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IGluaXRpYWxEYXRhIH0pLFxuICAgICAgICB9KVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlIH0pLFxuICAgICAgICB9KTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlQ29udGVudFBhZ2VzKCkpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGEpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBkZWxldGVSZXN1bHQgPSBhd2FpdCByZXN1bHQuY3VycmVudC5yZW1vdmUoJ3BhZ2UtMScpO1xuXG4gICAgICBleHBlY3QoZGVsZXRlUmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YSkudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhWzBdLmlkKS50b0JlKCdwYWdlLTInKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbm90IHVwZGF0ZSBzdGF0ZSBvbiBmYWlsZWQgY3JlYXRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW5pdGlhbERhdGEgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3BhZ2UtMScsXG4gICAgICAgICAgc2x1ZzogJ2V4aXN0aW5nJyxcbiAgICAgICAgICB0aXRsZTogJ0V4aXN0aW5nJyxcbiAgICAgICAgICBzdGF0dXM6ICdwdWJsaXNoZWQnIGFzIGNvbnN0LFxuICAgICAgICAgIGNyZWF0ZWRBdDogJzIwMjUtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgICAgICB1cGRhdGVkQXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaylcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogaW5pdGlhbERhdGEgfSksXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnVmFsaWRhdGlvbiBlcnJvcicgfSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZUNvbnRlbnRQYWdlcygpKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhKS50b0VxdWFsKGluaXRpYWxEYXRhKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjcmVhdGVSZXN1bHQgPSBhd2FpdCByZXN1bHQuY3VycmVudC5jcmVhdGUoe1xuICAgICAgICB0aXRsZTogJ05ldyBQYWdlJyxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoY3JlYXRlUmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGNyZWF0ZVJlc3VsdC5lcnJvcikudG9CZSgnVmFsaWRhdGlvbiBlcnJvcicpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGEpLnRvRXF1YWwoaW5pdGlhbERhdGEpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImdsb2JhbCIsImZldGNoIiwiamVzdCIsImZuIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tDbGVhciIsImFmdGVyRWFjaCIsInJlc3RvcmVBbGxNb2NrcyIsIml0IiwibW9ja0ltcGxlbWVudGF0aW9uIiwiUHJvbWlzZSIsInJlc3VsdCIsInJlbmRlckhvb2siLCJ1c2VDb250ZW50UGFnZXMiLCJleHBlY3QiLCJjdXJyZW50IiwibG9hZGluZyIsInRvQmUiLCJkYXRhIiwidG9FcXVhbCIsImVycm9yIiwidG9CZU51bGwiLCJtb2NrRGF0YSIsImlkIiwic2x1ZyIsInRpdGxlIiwic3RhdHVzIiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwib2siLCJqc29uIiwic3VjY2VzcyIsIndhaXRGb3IiLCJtZXNzYWdlIiwidG9CZUluc3RhbmNlT2YiLCJFcnJvciIsIm1vY2tSZWplY3RlZFZhbHVlT25jZSIsImluaXRpYWxEYXRhIiwidXBkYXRlZERhdGEiLCJyZWZldGNoIiwiZXhpc3RpbmdEYXRhIiwibmV3UGFnZSIsImNyZWF0ZVJlc3VsdCIsImNyZWF0ZSIsInRvSGF2ZUxlbmd0aCIsInVwZGF0ZWRQYWdlIiwidXBkYXRlUmVzdWx0IiwidXBkYXRlIiwiZGVsZXRlUmVzdWx0IiwicmVtb3ZlIl0sIm1hcHBpbmdzIjoiOzs7O3VCQUFvQztpQ0FDSjtBQUVoQyxzQkFBc0I7QUFDdEJBLE9BQU9DLEtBQUssR0FBR0MsS0FBS0MsRUFBRTtBQUV0QkMsU0FBUyxtQkFBbUI7SUFDMUJDLFdBQVc7UUFDVEgsS0FBS0ksYUFBYTtRQUNqQk4sT0FBT0MsS0FBSyxDQUFl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