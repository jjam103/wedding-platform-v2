46bada1da318fe69e674db6eb0d3b7d4
"use strict";
// Mock Supabase
jest.mock('@supabase/supabase-js');
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _authService = /*#__PURE__*/ _interop_require_wildcard(require("./authService"));
const _supabasejs = require("@supabase/supabase-js");
const _types = require("../types");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('authService', ()=>{
    let mockSupabase;
    beforeEach(()=>{
        // Reset mocks
        jest.clearAllMocks();
        // Setup mock Supabase client
        mockSupabase = {
            auth: {
                signInWithPassword: jest.fn(),
                signInWithOtp: jest.fn(),
                getSession: jest.fn(),
                refreshSession: jest.fn(),
                signOut: jest.fn()
            },
            from: jest.fn().mockReturnThis(),
            select: jest.fn().mockReturnThis(),
            eq: jest.fn().mockReturnThis(),
            single: jest.fn()
        };
        _supabasejs.createClient.mockReturnValue(mockSupabase);
        // Set environment variables
        process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://test.supabase.co';
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY = 'test-anon-key';
    });
    describe('loginWithPassword', ()=>{
        it('should return success with session when valid credentials provided', async ()=>{
            const mockSession = {
                access_token: 'mock-access-token',
                refresh_token: 'mock-refresh-token',
                expires_at: 1234567890
            };
            const mockUser = {
                id: 'user-123',
                email: 'test@example.com'
            };
            mockSupabase.auth.signInWithPassword.mockResolvedValue({
                data: {
                    session: mockSession,
                    user: mockUser
                },
                error: null
            });
            mockSupabase.single.mockResolvedValue({
                data: {
                    role: 'host'
                },
                error: null
            });
            const result = await _authService.loginWithPassword({
                email: 'test@example.com',
                password: 'password123'
            });
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.user.id).toBe('user-123');
                expect(result.data.user.email).toBe('test@example.com');
                expect(result.data.user.role).toBe('host');
                expect(result.data.accessToken).toBe('mock-access-token');
                expect(result.data.refreshToken).toBe('mock-refresh-token');
            }
        });
        it('should return INVALID_CREDENTIALS when credentials are wrong', async ()=>{
            mockSupabase.auth.signInWithPassword.mockResolvedValue({
                data: {
                    session: null,
                    user: null
                },
                error: {
                    message: 'Invalid login credentials'
                }
            });
            const result = await _authService.loginWithPassword({
                email: 'test@example.com',
                password: 'wrongpassword'
            });
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe(_types.ERROR_CODES.INVALID_CREDENTIALS);
                expect(result.error.message).toBe('Invalid email or password');
            }
        });
        it('should default to guest role when user record does not exist', async ()=>{
            const mockSession = {
                access_token: 'mock-access-token',
                refresh_token: 'mock-refresh-token',
                expires_at: 1234567890
            };
            const mockUser = {
                id: 'user-123',
                email: 'test@example.com'
            };
            mockSupabase.auth.signInWithPassword.mockResolvedValue({
                data: {
                    session: mockSession,
                    user: mockUser
                },
                error: null
            });
            mockSupabase.single.mockResolvedValue({
                data: null,
                error: {
                    message: 'User not found'
                }
            });
            const result = await _authService.loginWithPassword({
                email: 'test@example.com',
                password: 'password123'
            });
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.user.role).toBe('guest');
            }
        });
        it('should return UNAUTHORIZED when session creation fails', async ()=>{
            mockSupabase.auth.signInWithPassword.mockResolvedValue({
                data: {
                    session: null,
                    user: null
                },
                error: null
            });
            const result = await _authService.loginWithPassword({
                email: 'test@example.com',
                password: 'password123'
            });
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe(_types.ERROR_CODES.UNAUTHORIZED);
            }
        });
    });
    describe('sendMagicLink', ()=>{
        it('should return success when magic link is sent', async ()=>{
            mockSupabase.auth.signInWithOtp.mockResolvedValue({
                data: {},
                error: null
            });
            const result = await _authService.sendMagicLink({
                email: 'test@example.com',
                redirectTo: 'https://example.com/dashboard'
            });
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.message).toContain('Magic link sent successfully');
            }
            expect(mockSupabase.auth.signInWithOtp).toHaveBeenCalledWith({
                email: 'test@example.com',
                options: {
                    emailRedirectTo: 'https://example.com/dashboard'
                }
            });
        });
        it('should return EXTERNAL_SERVICE_ERROR when magic link fails', async ()=>{
            mockSupabase.auth.signInWithOtp.mockResolvedValue({
                data: null,
                error: {
                    message: 'Email service unavailable'
                }
            });
            const result = await _authService.sendMagicLink({
                email: 'test@example.com'
            });
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe(_types.ERROR_CODES.EXTERNAL_SERVICE_ERROR);
                expect(result.error.message).toBe('Failed to send magic link');
            }
        });
    });
    describe('getSession', ()=>{
        it('should return success with session when valid session exists', async ()=>{
            const mockSession = {
                access_token: 'mock-access-token',
                refresh_token: 'mock-refresh-token',
                expires_at: 1234567890,
                user: {
                    id: 'user-123',
                    email: 'test@example.com'
                }
            };
            mockSupabase.auth.getSession.mockResolvedValue({
                data: {
                    session: mockSession
                },
                error: null
            });
            mockSupabase.single.mockResolvedValue({
                data: {
                    role: 'super_admin'
                },
                error: null
            });
            const result = await _authService.getSession();
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.user.id).toBe('user-123');
                expect(result.data.user.role).toBe('super_admin');
            }
        });
        it('should return SESSION_EXPIRED when session is invalid', async ()=>{
            mockSupabase.auth.getSession.mockResolvedValue({
                data: {
                    session: null
                },
                error: {
                    message: 'Session expired'
                }
            });
            const result = await _authService.getSession();
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe(_types.ERROR_CODES.SESSION_EXPIRED);
            }
        });
        it('should return UNAUTHORIZED when no active session', async ()=>{
            mockSupabase.auth.getSession.mockResolvedValue({
                data: {
                    session: null
                },
                error: null
            });
            const result = await _authService.getSession();
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe(_types.ERROR_CODES.UNAUTHORIZED);
                expect(result.error.message).toBe('No active session');
            }
        });
    });
    describe('refreshSession', ()=>{
        it('should return success with new session when refresh succeeds', async ()=>{
            const mockSession = {
                access_token: 'new-access-token',
                refresh_token: 'new-refresh-token',
                expires_at: 9999999999
            };
            const mockUser = {
                id: 'user-123',
                email: 'test@example.com'
            };
            mockSupabase.auth.refreshSession.mockResolvedValue({
                data: {
                    session: mockSession,
                    user: mockUser
                },
                error: null
            });
            mockSupabase.single.mockResolvedValue({
                data: {
                    role: 'host'
                },
                error: null
            });
            const result = await _authService.refreshSession('old-refresh-token');
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.accessToken).toBe('new-access-token');
                expect(result.data.refreshToken).toBe('new-refresh-token');
            }
        });
        it('should return SESSION_EXPIRED when refresh fails', async ()=>{
            mockSupabase.auth.refreshSession.mockResolvedValue({
                data: {
                    session: null,
                    user: null
                },
                error: {
                    message: 'Invalid refresh token'
                }
            });
            const result = await _authService.refreshSession('invalid-token');
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe(_types.ERROR_CODES.SESSION_EXPIRED);
            }
        });
    });
    describe('logout', ()=>{
        it('should return success when logout succeeds', async ()=>{
            mockSupabase.auth.signOut.mockResolvedValue({
                error: null
            });
            const result = await _authService.logout();
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.message).toBe('Logged out successfully');
            }
        });
        it('should return UNKNOWN_ERROR when logout fails', async ()=>{
            mockSupabase.auth.signOut.mockResolvedValue({
                error: {
                    message: 'Logout failed'
                }
            });
            const result = await _authService.logout();
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe(_types.ERROR_CODES.UNKNOWN_ERROR);
            }
        });
    });
    describe('isSessionExpired', ()=>{
        it('should return true when session is expired', ()=>{
            const pastTimestamp = Math.floor(Date.now() / 1000) - 3600; // 1 hour ago
            expect(_authService.isSessionExpired(pastTimestamp)).toBe(true);
        });
        it('should return false when session is not expired', ()=>{
            const futureTimestamp = Math.floor(Date.now() / 1000) + 3600; // 1 hour from now
            expect(_authService.isSessionExpired(futureTimestamp)).toBe(false);
        });
    });
    describe('getCurrentUser', ()=>{
        it('should return user data when session is valid', async ()=>{
            const mockSession = {
                access_token: 'mock-access-token',
                refresh_token: 'mock-refresh-token',
                expires_at: 9999999999,
                user: {
                    id: 'user-123',
                    email: 'test@example.com'
                }
            };
            const mockUserData = {
                id: 'user-123',
                email: 'test@example.com',
                role: 'host',
                created_at: '2025-01-01T00:00:00Z',
                last_login: '2025-01-25T00:00:00Z'
            };
            mockSupabase.auth.getSession.mockResolvedValue({
                data: {
                    session: mockSession
                },
                error: null
            });
            // First call for getSession role lookup
            mockSupabase.single.mockResolvedValueOnce({
                data: {
                    role: 'host'
                },
                error: null
            })// Second call for getCurrentUser full user data
            .mockResolvedValueOnce({
                data: mockUserData,
                error: null
            });
            const result = await _authService.getCurrentUser();
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.id).toBe('user-123');
                expect(result.data.email).toBe('test@example.com');
                expect(result.data.role).toBe('host');
            }
        });
        it('should return error when no session exists', async ()=>{
            mockSupabase.auth.getSession.mockResolvedValue({
                data: {
                    session: null
                },
                error: null
            });
            const result = await _authService.getCurrentUser();
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe(_types.ERROR_CODES.UNAUTHORIZED);
            }
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvYXV0aFNlcnZpY2UudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhdXRoU2VydmljZSBmcm9tICcuL2F1dGhTZXJ2aWNlJztcbmltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5pbXBvcnQgeyBFUlJPUl9DT0RFUyB9IGZyb20gJ0AvdHlwZXMnO1xuXG4vLyBNb2NrIFN1cGFiYXNlXG5qZXN0Lm1vY2soJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcycpO1xuXG5kZXNjcmliZSgnYXV0aFNlcnZpY2UnLCAoKSA9PiB7XG4gIGxldCBtb2NrU3VwYWJhc2U6IGFueTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAvLyBSZXNldCBtb2Nrc1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuXG4gICAgLy8gU2V0dXAgbW9jayBTdXBhYmFzZSBjbGllbnRcbiAgICBtb2NrU3VwYWJhc2UgPSB7XG4gICAgICBhdXRoOiB7XG4gICAgICAgIHNpZ25JbldpdGhQYXNzd29yZDogamVzdC5mbigpLFxuICAgICAgICBzaWduSW5XaXRoT3RwOiBqZXN0LmZuKCksXG4gICAgICAgIGdldFNlc3Npb246IGplc3QuZm4oKSxcbiAgICAgICAgcmVmcmVzaFNlc3Npb246IGplc3QuZm4oKSxcbiAgICAgICAgc2lnbk91dDogamVzdC5mbigpLFxuICAgICAgfSxcbiAgICAgIGZyb206IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICAgIHNpbmdsZTogamVzdC5mbigpLFxuICAgIH07XG5cbiAgICAoY3JlYXRlQ2xpZW50IGFzIGplc3QuTW9jaykubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XG5cbiAgICAvLyBTZXQgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMID0gJ2h0dHBzOi8vdGVzdC5zdXBhYmFzZS5jbyc7XG4gICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkgPSAndGVzdC1hbm9uLWtleSc7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdsb2dpbldpdGhQYXNzd29yZCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIHdpdGggc2Vzc2lvbiB3aGVuIHZhbGlkIGNyZWRlbnRpYWxzIHByb3ZpZGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1Nlc3Npb24gPSB7XG4gICAgICAgIGFjY2Vzc190b2tlbjogJ21vY2stYWNjZXNzLXRva2VuJyxcbiAgICAgICAgcmVmcmVzaF90b2tlbjogJ21vY2stcmVmcmVzaC10b2tlbicsXG4gICAgICAgIGV4cGlyZXNfYXQ6IDEyMzQ1Njc4OTAsXG4gICAgICB9O1xuICAgICAgY29uc3QgbW9ja1VzZXIgPSB7XG4gICAgICAgIGlkOiAndXNlci0xMjMnLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgfTtcblxuICAgICAgbW9ja1N1cGFiYXNlLmF1dGguc2lnbkluV2l0aFBhc3N3b3JkLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogeyBzZXNzaW9uOiBtb2NrU2Vzc2lvbiwgdXNlcjogbW9ja1VzZXIgfSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IHJvbGU6ICdob3N0JyB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0gYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aFNlcnZpY2UubG9naW5XaXRoUGFzc3dvcmQoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBwYXNzd29yZDogJ3Bhc3N3b3JkMTIzJyxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnVzZXIuaWQpLnRvQmUoJ3VzZXItMTIzJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS51c2VyLmVtYWlsKS50b0JlKCd0ZXN0QGV4YW1wbGUuY29tJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS51c2VyLnJvbGUpLnRvQmUoJ2hvc3QnKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmFjY2Vzc1Rva2VuKS50b0JlKCdtb2NrLWFjY2Vzcy10b2tlbicpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEucmVmcmVzaFRva2VuKS50b0JlKCdtb2NrLXJlZnJlc2gtdG9rZW4nKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIElOVkFMSURfQ1JFREVOVElBTFMgd2hlbiBjcmVkZW50aWFscyBhcmUgd3JvbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2UuYXV0aC5zaWduSW5XaXRoUGFzc3dvcmQubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IHNlc3Npb246IG51bGwsIHVzZXI6IG51bGwgfSxcbiAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogJ0ludmFsaWQgbG9naW4gY3JlZGVudGlhbHMnIH0sXG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhTZXJ2aWNlLmxvZ2luV2l0aFBhc3N3b3JkKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgcGFzc3dvcmQ6ICd3cm9uZ3Bhc3N3b3JkJyxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoRVJST1JfQ09ERVMuSU5WQUxJRF9DUkVERU5USUFMUyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9CZSgnSW52YWxpZCBlbWFpbCBvciBwYXNzd29yZCcpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBkZWZhdWx0IHRvIGd1ZXN0IHJvbGUgd2hlbiB1c2VyIHJlY29yZCBkb2VzIG5vdCBleGlzdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTZXNzaW9uID0ge1xuICAgICAgICBhY2Nlc3NfdG9rZW46ICdtb2NrLWFjY2Vzcy10b2tlbicsXG4gICAgICAgIHJlZnJlc2hfdG9rZW46ICdtb2NrLXJlZnJlc2gtdG9rZW4nLFxuICAgICAgICBleHBpcmVzX2F0OiAxMjM0NTY3ODkwLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IG1vY2tVc2VyID0ge1xuICAgICAgICBpZDogJ3VzZXItMTIzJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tTdXBhYmFzZS5hdXRoLnNpZ25JbldpdGhQYXNzd29yZC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgc2Vzc2lvbjogbW9ja1Nlc3Npb24sIHVzZXI6IG1vY2tVc2VyIH0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICBtb2NrU3VwYWJhc2Uuc2luZ2xlLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogJ1VzZXIgbm90IGZvdW5kJyB9LFxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoU2VydmljZS5sb2dpbldpdGhQYXNzd29yZCh7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHBhc3N3b3JkOiAncGFzc3dvcmQxMjMnLFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudXNlci5yb2xlKS50b0JlKCdndWVzdCcpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gVU5BVVRIT1JJWkVEIHdoZW4gc2Vzc2lvbiBjcmVhdGlvbiBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5hdXRoLnNpZ25JbldpdGhQYXNzd29yZC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgdXNlcjogbnVsbCB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0gYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aFNlcnZpY2UubG9naW5XaXRoUGFzc3dvcmQoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBwYXNzd29yZDogJ3Bhc3N3b3JkMTIzJyxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoRVJST1JfQ09ERVMuVU5BVVRIT1JJWkVEKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3NlbmRNYWdpY0xpbmsnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2VzcyB3aGVuIG1hZ2ljIGxpbmsgaXMgc2VudCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5hdXRoLnNpZ25JbldpdGhPdHAubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhTZXJ2aWNlLnNlbmRNYWdpY0xpbmsoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICByZWRpcmVjdFRvOiAnaHR0cHM6Ly9leGFtcGxlLmNvbS9kYXNoYm9hcmQnLFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEubWVzc2FnZSkudG9Db250YWluKCdNYWdpYyBsaW5rIHNlbnQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdChtb2NrU3VwYWJhc2UuYXV0aC5zaWduSW5XaXRoT3RwKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBlbWFpbFJlZGlyZWN0VG86ICdodHRwczovL2V4YW1wbGUuY29tL2Rhc2hib2FyZCcsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIEVYVEVSTkFMX1NFUlZJQ0VfRVJST1Igd2hlbiBtYWdpYyBsaW5rIGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N1cGFiYXNlLmF1dGguc2lnbkluV2l0aE90cC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6ICdFbWFpbCBzZXJ2aWNlIHVuYXZhaWxhYmxlJyB9LFxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoU2VydmljZS5zZW5kTWFnaWNMaW5rKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoRVJST1JfQ09ERVMuRVhURVJOQUxfU0VSVklDRV9FUlJPUik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9CZSgnRmFpbGVkIHRvIHNlbmQgbWFnaWMgbGluaycpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0U2Vzc2lvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIHdpdGggc2Vzc2lvbiB3aGVuIHZhbGlkIHNlc3Npb24gZXhpc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1Nlc3Npb24gPSB7XG4gICAgICAgIGFjY2Vzc190b2tlbjogJ21vY2stYWNjZXNzLXRva2VuJyxcbiAgICAgICAgcmVmcmVzaF90b2tlbjogJ21vY2stcmVmcmVzaC10b2tlbicsXG4gICAgICAgIGV4cGlyZXNfYXQ6IDEyMzQ1Njc4OTAsXG4gICAgICAgIHVzZXI6IHtcbiAgICAgICAgICBpZDogJ3VzZXItMTIzJyxcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgbW9ja1N1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbi5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgc2Vzc2lvbjogbW9ja1Nlc3Npb24gfSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IHJvbGU6ICdzdXBlcl9hZG1pbicgfSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGF1dGhTZXJ2aWNlLmdldFNlc3Npb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS51c2VyLmlkKS50b0JlKCd1c2VyLTEyMycpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudXNlci5yb2xlKS50b0JlKCdzdXBlcl9hZG1pbicpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gU0VTU0lPTl9FWFBJUkVEIHdoZW4gc2Vzc2lvbiBpcyBpbnZhbGlkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbi5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgc2Vzc2lvbjogbnVsbCB9LFxuICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnU2Vzc2lvbiBleHBpcmVkJyB9LFxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoU2VydmljZS5nZXRTZXNzaW9uKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZShFUlJPUl9DT0RFUy5TRVNTSU9OX0VYUElSRUQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gVU5BVVRIT1JJWkVEIHdoZW4gbm8gYWN0aXZlIHNlc3Npb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogeyBzZXNzaW9uOiBudWxsIH0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoU2VydmljZS5nZXRTZXNzaW9uKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZShFUlJPUl9DT0RFUy5VTkFVVEhPUklaRUQpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQmUoJ05vIGFjdGl2ZSBzZXNzaW9uJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdyZWZyZXNoU2Vzc2lvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIHdpdGggbmV3IHNlc3Npb24gd2hlbiByZWZyZXNoIHN1Y2NlZWRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1Nlc3Npb24gPSB7XG4gICAgICAgIGFjY2Vzc190b2tlbjogJ25ldy1hY2Nlc3MtdG9rZW4nLFxuICAgICAgICByZWZyZXNoX3Rva2VuOiAnbmV3LXJlZnJlc2gtdG9rZW4nLFxuICAgICAgICBleHBpcmVzX2F0OiA5OTk5OTk5OTk5LFxuICAgICAgfTtcbiAgICAgIGNvbnN0IG1vY2tVc2VyID0ge1xuICAgICAgICBpZDogJ3VzZXItMTIzJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tTdXBhYmFzZS5hdXRoLnJlZnJlc2hTZXNzaW9uLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogeyBzZXNzaW9uOiBtb2NrU2Vzc2lvbiwgdXNlcjogbW9ja1VzZXIgfSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IHJvbGU6ICdob3N0JyB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0gYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aFNlcnZpY2UucmVmcmVzaFNlc3Npb24oJ29sZC1yZWZyZXNoLXRva2VuJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuYWNjZXNzVG9rZW4pLnRvQmUoJ25ldy1hY2Nlc3MtdG9rZW4nKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnJlZnJlc2hUb2tlbikudG9CZSgnbmV3LXJlZnJlc2gtdG9rZW4nKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIFNFU1NJT05fRVhQSVJFRCB3aGVuIHJlZnJlc2ggZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2UuYXV0aC5yZWZyZXNoU2Vzc2lvbi5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgdXNlcjogbnVsbCB9LFxuICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnSW52YWxpZCByZWZyZXNoIHRva2VuJyB9LFxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoU2VydmljZS5yZWZyZXNoU2Vzc2lvbignaW52YWxpZC10b2tlbicpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoRVJST1JfQ09ERVMuU0VTU0lPTl9FWFBJUkVEKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2xvZ291dCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIHdoZW4gbG9nb3V0IHN1Y2NlZWRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N1cGFiYXNlLmF1dGguc2lnbk91dC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoU2VydmljZS5sb2dvdXQoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5tZXNzYWdlKS50b0JlKCdMb2dnZWQgb3V0IHN1Y2Nlc3NmdWxseScpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gVU5LTk9XTl9FUlJPUiB3aGVuIGxvZ291dCBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5hdXRoLnNpZ25PdXQubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnTG9nb3V0IGZhaWxlZCcgfSxcbiAgICAgIH0gYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aFNlcnZpY2UubG9nb3V0KCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZShFUlJPUl9DT0RFUy5VTktOT1dOX0VSUk9SKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2lzU2Vzc2lvbkV4cGlyZWQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIHNlc3Npb24gaXMgZXhwaXJlZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHBhc3RUaW1lc3RhbXAgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSAtIDM2MDA7IC8vIDEgaG91ciBhZ29cbiAgICAgIGV4cGVjdChhdXRoU2VydmljZS5pc1Nlc3Npb25FeHBpcmVkKHBhc3RUaW1lc3RhbXApKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZmFsc2Ugd2hlbiBzZXNzaW9uIGlzIG5vdCBleHBpcmVkJywgKCkgPT4ge1xuICAgICAgY29uc3QgZnV0dXJlVGltZXN0YW1wID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgKyAzNjAwOyAvLyAxIGhvdXIgZnJvbSBub3dcbiAgICAgIGV4cGVjdChhdXRoU2VydmljZS5pc1Nlc3Npb25FeHBpcmVkKGZ1dHVyZVRpbWVzdGFtcCkpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0Q3VycmVudFVzZXInLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdXNlciBkYXRhIHdoZW4gc2Vzc2lvbiBpcyB2YWxpZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTZXNzaW9uID0ge1xuICAgICAgICBhY2Nlc3NfdG9rZW46ICdtb2NrLWFjY2Vzcy10b2tlbicsXG4gICAgICAgIHJlZnJlc2hfdG9rZW46ICdtb2NrLXJlZnJlc2gtdG9rZW4nLFxuICAgICAgICBleHBpcmVzX2F0OiA5OTk5OTk5OTk5LFxuICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgaWQ6ICd1c2VyLTEyMycsXG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1vY2tVc2VyRGF0YSA9IHtcbiAgICAgICAgaWQ6ICd1c2VyLTEyMycsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHJvbGU6ICdob3N0JyxcbiAgICAgICAgY3JlYXRlZF9hdDogJzIwMjUtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgICAgbGFzdF9sb2dpbjogJzIwMjUtMDEtMjVUMDA6MDA6MDBaJyxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tTdXBhYmFzZS5hdXRoLmdldFNlc3Npb24ubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IHNlc3Npb246IG1vY2tTZXNzaW9uIH0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICAvLyBGaXJzdCBjYWxsIGZvciBnZXRTZXNzaW9uIHJvbGUgbG9va3VwXG4gICAgICBtb2NrU3VwYWJhc2Uuc2luZ2xlXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIGRhdGE6IHsgcm9sZTogJ2hvc3QnIH0sXG4gICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIH0pXG4gICAgICAgIC8vIFNlY29uZCBjYWxsIGZvciBnZXRDdXJyZW50VXNlciBmdWxsIHVzZXIgZGF0YVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBkYXRhOiBtb2NrVXNlckRhdGEsXG4gICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoU2VydmljZS5nZXRDdXJyZW50VXNlcigpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmlkKS50b0JlKCd1c2VyLTEyMycpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuZW1haWwpLnRvQmUoJ3Rlc3RAZXhhbXBsZS5jb20nKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnJvbGUpLnRvQmUoJ2hvc3QnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGVycm9yIHdoZW4gbm8gc2Vzc2lvbiBleGlzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogeyBzZXNzaW9uOiBudWxsIH0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhdXRoU2VydmljZS5nZXRDdXJyZW50VXNlcigpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoRVJST1JfQ09ERVMuVU5BVVRIT1JJWkVEKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImRlc2NyaWJlIiwibW9ja1N1cGFiYXNlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJhdXRoIiwic2lnbkluV2l0aFBhc3N3b3JkIiwiZm4iLCJzaWduSW5XaXRoT3RwIiwiZ2V0U2Vzc2lvbiIsInJlZnJlc2hTZXNzaW9uIiwic2lnbk91dCIsImZyb20iLCJtb2NrUmV0dXJuVGhpcyIsInNlbGVjdCIsImVxIiwic2luZ2xlIiwiY3JlYXRlQ2xpZW50IiwibW9ja1JldHVyblZhbHVlIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwiaXQiLCJtb2NrU2Vzc2lvbiIsImFjY2Vzc190b2tlbiIsInJlZnJlc2hfdG9rZW4iLCJleHBpcmVzX2F0IiwibW9ja1VzZXIiLCJpZCIsImVtYWlsIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJkYXRhIiwic2Vzc2lvbiIsInVzZXIiLCJlcnJvciIsInJvbGUiLCJyZXN1bHQiLCJhdXRoU2VydmljZSIsImxvZ2luV2l0aFBhc3N3b3JkIiwicGFzc3dvcmQiLCJleHBlY3QiLCJzdWNjZXNzIiwidG9CZSIsImFjY2Vzc1Rva2VuIiwicmVmcmVzaFRva2VuIiwibWVzc2FnZSIsImNvZGUiLCJFUlJPUl9DT0RFUyIsIklOVkFMSURfQ1JFREVOVElBTFMiLCJVTkFVVEhPUklaRUQiLCJzZW5kTWFnaWNMaW5rIiwicmVkaXJlY3RUbyIsInRvQ29udGFpbiIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwib3B0aW9ucyIsImVtYWlsUmVkaXJlY3RUbyIsIkVYVEVSTkFMX1NFUlZJQ0VfRVJST1IiLCJTRVNTSU9OX0VYUElSRUQiLCJsb2dvdXQiLCJVTktOT1dOX0VSUk9SIiwicGFzdFRpbWVzdGFtcCIsIk1hdGgiLCJmbG9vciIsIkRhdGUiLCJub3ciLCJpc1Nlc3Npb25FeHBpcmVkIiwiZnV0dXJlVGltZXN0YW1wIiwibW9ja1VzZXJEYXRhIiwiY3JlYXRlZF9hdCIsImxhc3RfbG9naW4iLCJtb2NrUmVzb2x2ZWRWYWx1ZU9uY2UiLCJnZXRDdXJyZW50VXNlciJdLCJtYXBwaW5ncyI6IjtBQUlBLGdCQUFnQjtBQUNoQkEsS0FBS0MsSUFBSSxDQUFDOzs7O3FFQUxtQjs0QkFDQTt1QkFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSzVCQyxTQUFTLGVBQWU7SUFDdEIsSUFBSUM7SUFFSkMsV0FBVztRQUNULGNBQWM7UUFDZEosS0FBS0ssYUFBYTtRQUVsQiw2QkFBNkI7UUFDN0JGLGVBQWU7WUFDYkcsTUFBTTtnQkFDSkMsb0JBQW9CUCxLQUFL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