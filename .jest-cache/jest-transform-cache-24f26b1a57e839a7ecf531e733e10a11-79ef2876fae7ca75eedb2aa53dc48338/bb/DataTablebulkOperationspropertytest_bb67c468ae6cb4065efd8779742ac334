d49cdebb61d13c9cad8968d7515799e6
/**
 * Property-Based Tests for DataTable Bulk Operations
 * 
 * Tests bulk action toolbar, bulk delete, and CSV export functionality
 * using property-based testing with fast-check.
 */ "use strict";
// Mock Next.js router
jest.mock('next/navigation', ()=>({
        useRouter: ()=>({
                push: jest.fn()
            }),
        useSearchParams: ()=>({
                get: jest.fn(),
                toString: jest.fn(()=>'')
            })
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = require("@testing-library/react");
const _DataTable = require("./DataTable");
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _csvExport = require("../../utils/csvExport");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Clean up after each test to prevent DOM pollution
afterEach(()=>{
    (0, _react.cleanup)();
});
// Arbitraries for generating test data
const testItemArbitrary = _fastcheck.record({
    id: _fastcheck.uuid(),
    name: _fastcheck.string({
        minLength: 1,
        maxLength: 50
    }),
    value: _fastcheck.integer({
        min: 0,
        max: 1000
    }),
    category: _fastcheck.constantFrom('A', 'B', 'C', 'D')
});
const testItemArrayArbitrary = _fastcheck.array(testItemArbitrary, {
    minLength: 1,
    maxLength: 100
});
// Column definitions for tests
const testColumns = [
    {
        key: 'name',
        label: 'Name',
        sortable: true
    },
    {
        key: 'value',
        label: 'Value',
        sortable: true
    },
    {
        key: 'category',
        label: 'Category',
        sortable: true,
        filterable: true
    }
];
describe('Feature: admin-ui-modernization, Property 21: Bulk action toolbar visibility', ()=>{
    /**
   * Property 21: Bulk action toolbar visibility
   * For any data table with row selection enabled, when one or more rows are selected,
   * the bulk action toolbar should be visible.
   * Validates: Requirements 14.2
   */ it('should show bulk action toolbar when rows are selected', ()=>{
        _fastcheck.assert(_fastcheck.property(testItemArrayArbitrary, _fastcheck.integer({
            min: 1,
            max: 10
        }), (items, selectCount)=>{
            // Clean up before rendering to ensure fresh DOM
            (0, _react.cleanup)();
            const actualSelectCount = Math.min(selectCount, items.length);
            const onSelectionChange = jest.fn();
            const onBulkDelete = jest.fn();
            const { container } = (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_DataTable.DataTable, {
                data: items,
                columns: testColumns,
                selectable: true,
                onSelectionChange: onSelectionChange,
                onBulkDelete: onBulkDelete,
                entityType: "items"
            }));
            // Select the specified number of rows
            const checkboxes = container.querySelectorAll('input[type="checkbox"]');
            for(let i = 1; i <= actualSelectCount && i < checkboxes.length; i++){
                _react.fireEvent.click(checkboxes[i]);
            }
            // Bulk action toolbar should be visible
            // Look specifically for the count text, not the button
            const toolbar = _react.screen.queryByText(/\d+\s+(item|items)\s+selected/i);
            expect(toolbar).toBeInTheDocument();
        }), {
            numRuns: 100
        });
    });
    it('should hide bulk action toolbar when no rows are selected', ()=>{
        _fastcheck.assert(_fastcheck.property(testItemArrayArbitrary, (items)=>{
            // Clean up before rendering to ensure fresh DOM
            (0, _react.cleanup)();
            const onSelectionChange = jest.fn();
            const onBulkDelete = jest.fn();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_DataTable.DataTable, {
                data: items,
                columns: testColumns,
                selectable: true,
                onSelectionChange: onSelectionChange,
                onBulkDelete: onBulkDelete,
                entityType: "items"
            }));
            // Bulk action toolbar should not be visible initially
            // Look specifically for the count text, not the button
            const toolbar = _react.screen.queryByText(/\d+\s+(item|items)\s+selected/i);
            expect(toolbar).not.toBeInTheDocument();
        }), {
            numRuns: 100
        });
    });
});
describe('Feature: admin-ui-modernization, Property 22: Selected count accuracy', ()=>{
    /**
   * Property 22: Selected count accuracy
   * For any data table with selected rows, the bulk action toolbar should display
   * a count that equals the number of currently selected rows.
   * Validates: Requirements 14.3
   */ it('should display accurate count of selected items', ()=>{
        _fastcheck.assert(_fastcheck.property(testItemArrayArbitrary, _fastcheck.integer({
            min: 1,
            max: 10
        }), (items, selectCount)=>{
            // Clean up before rendering to ensure fresh DOM
            (0, _react.cleanup)();
            const actualSelectCount = Math.min(selectCount, items.length);
            const onSelectionChange = jest.fn();
            const onBulkDelete = jest.fn();
            const { container } = (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_DataTable.DataTable, {
                data: items,
                columns: testColumns,
                selectable: true,
                onSelectionChange: onSelectionChange,
                onBulkDelete: onBulkDelete,
                entityType: "items"
            }));
            // Select the specified number of rows
            const checkboxes = container.querySelectorAll('input[type="checkbox"]');
            for(let i = 1; i <= actualSelectCount && i < checkboxes.length; i++){
                _react.fireEvent.click(checkboxes[i]);
            }
            // Check that the displayed count matches the actual selection
            const countText = _react.screen.getByText(new RegExp(`${actualSelectCount}.*selected`, 'i'));
            expect(countText).toBeInTheDocument();
        }), {
            numRuns: 100
        });
    });
    it('should update count when selection changes', ()=>{
        _fastcheck.assert(_fastcheck.property(testItemArrayArbitrary, (items)=>{
            if (items.length < 2) return; // Need at least 2 items
            // Clean up before rendering to ensure fresh DOM
            (0, _react.cleanup)();
            const onSelectionChange = jest.fn();
            const onBulkDelete = jest.fn();
            const { container } = (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_DataTable.DataTable, {
                data: items,
                columns: testColumns,
                selectable: true,
                onSelectionChange: onSelectionChange,
                onBulkDelete: onBulkDelete,
                entityType: "items"
            }));
            const checkboxes = container.querySelectorAll('input[type="checkbox"]');
            // Select first item
            _react.fireEvent.click(checkboxes[1]);
            expect(_react.screen.getByText(/1.*selected/i)).toBeInTheDocument();
            // Select second item
            _react.fireEvent.click(checkboxes[2]);
            expect(_react.screen.getByText(/2.*selected/i)).toBeInTheDocument();
            // Deselect first item
            _react.fireEvent.click(checkboxes[1]);
            expect(_react.screen.getByText(/1.*selected/i)).toBeInTheDocument();
        }), {
            numRuns: 100
        });
    });
});
describe('Feature: admin-ui-modernization, Property 23: Bulk operation progress indication', ()=>{
    /**
   * Property 23: Bulk operation progress indication
   * For any bulk operation in progress, a progress indicator should be visible to the user.
   * Validates: Requirements 14.5
   */ it('should show progress indicator during bulk delete', async ()=>{
        _fastcheck.assert(_fastcheck.asyncProperty(testItemArrayArbitrary, async (items)=>{
            if (items.length === 0) return;
            // Clean up before rendering to ensure fresh DOM
            (0, _react.cleanup)();
            let resolveDelete;
            const deletePromise = new Promise((resolve)=>{
                resolveDelete = resolve;
            });
            const onBulkDelete = jest.fn(()=>deletePromise);
            const { container } = (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_DataTable.DataTable, {
                data: items,
                columns: testColumns,
                selectable: true,
                onBulkDelete: onBulkDelete,
                entityType: "items"
            }));
            // Select first row
            const checkboxes = container.querySelectorAll('input[type="checkbox"]');
            _react.fireEvent.click(checkboxes[1]);
            // Click delete button
            const deleteButton = _react.screen.getByText(/Delete Selected/i);
            _react.fireEvent.click(deleteButton);
            // Progress indicator should be visible
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByText(/Processing/i)).toBeInTheDocument();
            });
            // Resolve the delete operation
            resolveDelete();
            // Wait for progress indicator to disappear
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText(/Processing/i)).not.toBeInTheDocument();
            });
        }), {
            numRuns: 50
        } // Fewer runs for async tests
        );
    });
    it('should disable buttons during bulk operation', async ()=>{
        _fastcheck.assert(_fastcheck.asyncProperty(testItemArrayArbitrary, async (items)=>{
            if (items.length === 0) return;
            // Clean up before rendering to ensure fresh DOM
            (0, _react.cleanup)();
            let resolveDelete;
            const deletePromise = new Promise((resolve)=>{
                resolveDelete = resolve;
            });
            const onBulkDelete = jest.fn(()=>deletePromise);
            const { container } = (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_DataTable.DataTable, {
                data: items,
                columns: testColumns,
                selectable: true,
                onBulkDelete: onBulkDelete,
                entityType: "items"
            }));
            // Select first row
            const checkboxes = container.querySelectorAll('input[type="checkbox"]');
            _react.fireEvent.click(checkboxes[1]);
            // Click delete button
            const deleteButton = _react.screen.getByText(/Delete Selected/i);
            _react.fireEvent.click(deleteButton);
            // Button should be disabled during operation
            await (0, _react.waitFor)(()=>{
                expect(deleteButton.disabled).toBe(true);
            });
            // Resolve the delete operation
            resolveDelete();
            // Button should be enabled after operation
            await (0, _react.waitFor)(()=>{
                expect(deleteButton.disabled).toBe(false);
            });
        }), {
            numRuns: 50
        });
    });
});
describe('Feature: admin-ui-modernization, Property 24: CSV export data accuracy', ()=>{
    /**
   * Property 24: CSV export data accuracy
   * For any data table state with active filters, exporting to CSV should generate
   * a file containing exactly the rows currently visible in the filtered table.
   * Validates: Requirements 15.2
   */ it('should export exactly the visible data', ()=>{
        _fastcheck.assert(_fastcheck.property(testItemArrayArbitrary, (items)=>{
            const csv = (0, _csvExport.convertToCSV)(items, testColumns);
            const lines = csv.split('\n');
            // Should have header + data rows
            expect(lines.length).toBe(items.length + 1);
            // Header should contain all column labels
            const header = lines[0];
            testColumns.forEach((col)=>{
                expect(header).toContain(col.label);
            });
            // Each data row should be present (accounting for CSV escaping)
            items.forEach((item, index)=>{
                const row = lines[index + 1];
                // For names with quotes, they will be escaped in CSV
                const escapedName = item.name.includes('"') ? item.name.replace(/"/g, '""') : item.name;
                // Check if the row contains the value (may be quoted)
                const nameInRow = row.includes(escapedName) || row.includes(`"${escapedName}"`);
                expect(nameInRow).toBe(true);
                expect(row).toContain(String(item.value));
                expect(row).toContain(item.category);
            });
        }), {
            numRuns: 100
        });
    });
});
describe('Feature: admin-ui-modernization, Property 25: CSV column completeness', ()=>{
    /**
   * Property 25: CSV column completeness
   * For any CSV export, the file should include all columns that are currently
   * visible in the data table.
   * Validates: Requirements 15.3
   */ it('should include all visible columns in CSV', ()=>{
        _fastcheck.assert(_fastcheck.property(testItemArrayArbitrary, (items)=>{
            const csv = (0, _csvExport.convertToCSV)(items, testColumns);
            const lines = csv.split('\n');
            const header = lines[0];
            // All column labels should be in the header
            testColumns.forEach((col)=>{
                expect(header).toContain(col.label);
            });
            // Count of columns in header should match column definitions
            const headerColumns = header.split(',').length;
            expect(headerColumns).toBe(testColumns.length);
        }), {
            numRuns: 100
        });
    });
    it('should maintain column order in CSV', ()=>{
        _fastcheck.assert(_fastcheck.property(testItemArrayArbitrary, (items)=>{
            const csv = (0, _csvExport.convertToCSV)(items, testColumns);
            const lines = csv.split('\n');
            const header = lines[0];
            const headerColumns = header.split(',');
            // Columns should appear in the same order as defined
            testColumns.forEach((col, index)=>{
                expect(headerColumns[index]).toContain(col.label);
            });
        }), {
            numRuns: 100
        });
    });
});
describe('Feature: admin-ui-modernization, Property 26: CSV filename format', ()=>{
    /**
   * Property 26: CSV filename format
   * For any CSV export operation, the generated filename should follow
   * the pattern {entity-type}-{timestamp}.csv.
   * Validates: Requirements 15.4
   */ it('should generate filename with correct format', ()=>{
        _fastcheck.assert(_fastcheck.property(_fastcheck.constantFrom('guests', 'events', 'activities', 'vendors', 'photos'), (entityType)=>{
            const filename = (0, _csvExport.generateCSVFilename)(entityType);
            // Should start with entity type
            expect(filename).toMatch(new RegExp(`^${entityType}-`));
            // Should end with .csv
            expect(filename).toMatch(/\.csv$/);
            // Should contain timestamp in ISO format
            expect(filename).toMatch(/\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2}/);
        }), {
            numRuns: 100
        });
    });
    it('should generate unique filenames for different timestamps', ()=>{
        _fastcheck.assert(_fastcheck.property(_fastcheck.constantFrom('guests', 'events', 'activities'), (entityType)=>{
            const filename1 = (0, _csvExport.generateCSVFilename)(entityType);
            // Wait a tiny bit to ensure different timestamp
            const start = Date.now();
            while(Date.now() - start < 2){
            // Busy wait
            }
            const filename2 = (0, _csvExport.generateCSVFilename)(entityType);
            // Filenames should be different due to timestamp
            // (may occasionally be the same if generated in same millisecond, but very unlikely)
            if (filename1 === filename2) {
                // This is acceptable in rare cases
                return true;
            }
            expect(filename1).not.toBe(filename2);
            return true;
        }), {
            numRuns: 50
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvY29tcG9uZW50cy91aS9EYXRhVGFibGUuYnVsa09wZXJhdGlvbnMucHJvcGVydHkudGVzdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQcm9wZXJ0eS1CYXNlZCBUZXN0cyBmb3IgRGF0YVRhYmxlIEJ1bGsgT3BlcmF0aW9uc1xuICogXG4gKiBUZXN0cyBidWxrIGFjdGlvbiB0b29sYmFyLCBidWxrIGRlbGV0ZSwgYW5kIENTViBleHBvcnQgZnVuY3Rpb25hbGl0eVxuICogdXNpbmcgcHJvcGVydHktYmFzZWQgdGVzdGluZyB3aXRoIGZhc3QtY2hlY2suXG4gKi9cblxuaW1wb3J0IHsgcmVuZGVyLCBzY3JlZW4sIGZpcmVFdmVudCwgd2FpdEZvciwgY2xlYW51cCB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xuaW1wb3J0IHsgRGF0YVRhYmxlLCB0eXBlIENvbHVtbkRlZiB9IGZyb20gJy4vRGF0YVRhYmxlJztcbmltcG9ydCAqIGFzIGZjIGZyb20gJ2Zhc3QtY2hlY2snO1xuaW1wb3J0IHsgY29udmVydFRvQ1NWLCBnZW5lcmF0ZUNTVkZpbGVuYW1lIH0gZnJvbSAnQC91dGlscy9jc3ZFeHBvcnQnO1xuXG4vLyBNb2NrIE5leHQuanMgcm91dGVyXG5qZXN0Lm1vY2soJ25leHQvbmF2aWdhdGlvbicsICgpID0+ICh7XG4gIHVzZVJvdXRlcjogKCkgPT4gKHtcbiAgICBwdXNoOiBqZXN0LmZuKCksXG4gIH0pLFxuICB1c2VTZWFyY2hQYXJhbXM6ICgpID0+ICh7XG4gICAgZ2V0OiBqZXN0LmZuKCksXG4gICAgdG9TdHJpbmc6IGplc3QuZm4oKCkgPT4gJycpLFxuICB9KSxcbn0pKTtcblxuLy8gQ2xlYW4gdXAgYWZ0ZXIgZWFjaCB0ZXN0IHRvIHByZXZlbnQgRE9NIHBvbGx1dGlvblxuYWZ0ZXJFYWNoKCgpID0+IHtcbiAgY2xlYW51cCgpO1xufSk7XG5cbi8vIFRlc3QgZGF0YSB0eXBlXG5pbnRlcmZhY2UgVGVzdEl0ZW0ge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHZhbHVlOiBudW1iZXI7XG4gIGNhdGVnb3J5OiBzdHJpbmc7XG59XG5cbi8vIEFyYml0cmFyaWVzIGZvciBnZW5lcmF0aW5nIHRlc3QgZGF0YVxuY29uc3QgdGVzdEl0ZW1BcmJpdHJhcnkgPSBmYy5yZWNvcmQoe1xuICBpZDogZmMudXVpZCgpLFxuICBuYW1lOiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogNTAgfSksXG4gIHZhbHVlOiBmYy5pbnRlZ2VyKHsgbWluOiAwLCBtYXg6IDEwMDAgfSksXG4gIGNhdGVnb3J5OiBmYy5jb25zdGFudEZyb20oJ0EnLCAnQicsICdDJywgJ0QnKSxcbn0pO1xuXG5jb25zdCB0ZXN0SXRlbUFycmF5QXJiaXRyYXJ5ID0gZmMuYXJyYXkodGVzdEl0ZW1BcmJpdHJhcnksIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwMCB9KTtcblxuLy8gQ29sdW1uIGRlZmluaXRpb25zIGZvciB0ZXN0c1xuY29uc3QgdGVzdENvbHVtbnM6IENvbHVtbkRlZjxUZXN0SXRlbT5bXSA9IFtcbiAgeyBrZXk6ICduYW1lJywgbGFiZWw6ICdOYW1lJywgc29ydGFibGU6IHRydWUgfSxcbiAgeyBrZXk6ICd2YWx1ZScsIGxhYmVsOiAnVmFsdWUnLCBzb3J0YWJsZTogdHJ1ZSB9LFxuICB7IGtleTogJ2NhdGVnb3J5JywgbGFiZWw6ICdDYXRlZ29yeScsIHNvcnRhYmxlOiB0cnVlLCBmaWx0ZXJhYmxlOiB0cnVlIH0sXG5dO1xuXG5kZXNjcmliZSgnRmVhdHVyZTogYWRtaW4tdWktbW9kZXJuaXphdGlvbiwgUHJvcGVydHkgMjE6IEJ1bGsgYWN0aW9uIHRvb2xiYXIgdmlzaWJpbGl0eScsICgpID0+IHtcbiAgLyoqXG4gICAqIFByb3BlcnR5IDIxOiBCdWxrIGFjdGlvbiB0b29sYmFyIHZpc2liaWxpdHlcbiAgICogRm9yIGFueSBkYXRhIHRhYmxlIHdpdGggcm93IHNlbGVjdGlvbiBlbmFibGVkLCB3aGVuIG9uZSBvciBtb3JlIHJvd3MgYXJlIHNlbGVjdGVkLFxuICAgKiB0aGUgYnVsayBhY3Rpb24gdG9vbGJhciBzaG91bGQgYmUgdmlzaWJsZS5cbiAgICogVmFsaWRhdGVzOiBSZXF1aXJlbWVudHMgMTQuMlxuICAgKi9cbiAgaXQoJ3Nob3VsZCBzaG93IGJ1bGsgYWN0aW9uIHRvb2xiYXIgd2hlbiByb3dzIGFyZSBzZWxlY3RlZCcsICgpID0+IHtcbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5wcm9wZXJ0eSh0ZXN0SXRlbUFycmF5QXJiaXRyYXJ5LCBmYy5pbnRlZ2VyKHsgbWluOiAxLCBtYXg6IDEwIH0pLCAoaXRlbXMsIHNlbGVjdENvdW50KSA9PiB7XG4gICAgICAgIC8vIENsZWFuIHVwIGJlZm9yZSByZW5kZXJpbmcgdG8gZW5zdXJlIGZyZXNoIERPTVxuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBhY3R1YWxTZWxlY3RDb3VudCA9IE1hdGgubWluKHNlbGVjdENvdW50LCBpdGVtcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBvblNlbGVjdGlvbkNoYW5nZSA9IGplc3QuZm4oKTtcbiAgICAgICAgY29uc3Qgb25CdWxrRGVsZXRlID0gamVzdC5mbigpO1xuXG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXG4gICAgICAgICAgPERhdGFUYWJsZVxuICAgICAgICAgICAgZGF0YT17aXRlbXN9XG4gICAgICAgICAgICBjb2x1bW5zPXt0ZXN0Q29sdW1uc31cbiAgICAgICAgICAgIHNlbGVjdGFibGU9e3RydWV9XG4gICAgICAgICAgICBvblNlbGVjdGlvbkNoYW5nZT17b25TZWxlY3Rpb25DaGFuZ2V9XG4gICAgICAgICAgICBvbkJ1bGtEZWxldGU9e29uQnVsa0RlbGV0ZX1cbiAgICAgICAgICAgIGVudGl0eVR5cGU9XCJpdGVtc1wiXG4gICAgICAgICAgLz5cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBTZWxlY3QgdGhlIHNwZWNpZmllZCBudW1iZXIgb2Ygcm93c1xuICAgICAgICBjb25zdCBjaGVja2JveGVzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBhY3R1YWxTZWxlY3RDb3VudCAmJiBpIDwgY2hlY2tib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZpcmVFdmVudC5jbGljayhjaGVja2JveGVzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ1bGsgYWN0aW9uIHRvb2xiYXIgc2hvdWxkIGJlIHZpc2libGVcbiAgICAgICAgLy8gTG9vayBzcGVjaWZpY2FsbHkgZm9yIHRoZSBjb3VudCB0ZXh0LCBub3QgdGhlIGJ1dHRvblxuICAgICAgICBjb25zdCB0b29sYmFyID0gc2NyZWVuLnF1ZXJ5QnlUZXh0KC9cXGQrXFxzKyhpdGVtfGl0ZW1zKVxccytzZWxlY3RlZC9pKTtcbiAgICAgICAgZXhwZWN0KHRvb2xiYXIpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGhpZGUgYnVsayBhY3Rpb24gdG9vbGJhciB3aGVuIG5vIHJvd3MgYXJlIHNlbGVjdGVkJywgKCkgPT4ge1xuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLnByb3BlcnR5KHRlc3RJdGVtQXJyYXlBcmJpdHJhcnksIChpdGVtcykgPT4ge1xuICAgICAgICAvLyBDbGVhbiB1cCBiZWZvcmUgcmVuZGVyaW5nIHRvIGVuc3VyZSBmcmVzaCBET01cbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBcbiAgICAgICAgY29uc3Qgb25TZWxlY3Rpb25DaGFuZ2UgPSBqZXN0LmZuKCk7XG4gICAgICAgIGNvbnN0IG9uQnVsa0RlbGV0ZSA9IGplc3QuZm4oKTtcblxuICAgICAgICByZW5kZXIoXG4gICAgICAgICAgPERhdGFUYWJsZVxuICAgICAgICAgICAgZGF0YT17aXRlbXN9XG4gICAgICAgICAgICBjb2x1bW5zPXt0ZXN0Q29sdW1uc31cbiAgICAgICAgICAgIHNlbGVjdGFibGU9e3RydWV9XG4gICAgICAgICAgICBvblNlbGVjdGlvbkNoYW5nZT17b25TZWxlY3Rpb25DaGFuZ2V9XG4gICAgICAgICAgICBvbkJ1bGtEZWxldGU9e29uQnVsa0RlbGV0ZX1cbiAgICAgICAgICAgIGVudGl0eVR5cGU9XCJpdGVtc1wiXG4gICAgICAgICAgLz5cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBCdWxrIGFjdGlvbiB0b29sYmFyIHNob3VsZCBub3QgYmUgdmlzaWJsZSBpbml0aWFsbHlcbiAgICAgICAgLy8gTG9vayBzcGVjaWZpY2FsbHkgZm9yIHRoZSBjb3VudCB0ZXh0LCBub3QgdGhlIGJ1dHRvblxuICAgICAgICBjb25zdCB0b29sYmFyID0gc2NyZWVuLnF1ZXJ5QnlUZXh0KC9cXGQrXFxzKyhpdGVtfGl0ZW1zKVxccytzZWxlY3RlZC9pKTtcbiAgICAgICAgZXhwZWN0KHRvb2xiYXIpLm5vdC50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ0ZlYXR1cmU6IGFkbWluLXVpLW1vZGVybml6YXRpb24sIFByb3BlcnR5IDIyOiBTZWxlY3RlZCBjb3VudCBhY2N1cmFjeScsICgpID0+IHtcbiAgLyoqXG4gICAqIFByb3BlcnR5IDIyOiBTZWxlY3RlZCBjb3VudCBhY2N1cmFjeVxuICAgKiBGb3IgYW55IGRhdGEgdGFibGUgd2l0aCBzZWxlY3RlZCByb3dzLCB0aGUgYnVsayBhY3Rpb24gdG9vbGJhciBzaG91bGQgZGlzcGxheVxuICAgKiBhIGNvdW50IHRoYXQgZXF1YWxzIHRoZSBudW1iZXIgb2YgY3VycmVudGx5IHNlbGVjdGVkIHJvd3MuXG4gICAqIFZhbGlkYXRlczogUmVxdWlyZW1lbnRzIDE0LjNcbiAgICovXG4gIGl0KCdzaG91bGQgZGlzcGxheSBhY2N1cmF0ZSBjb3VudCBvZiBzZWxlY3RlZCBpdGVtcycsICgpID0+IHtcbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5wcm9wZXJ0eSh0ZXN0SXRlbUFycmF5QXJiaXRyYXJ5LCBmYy5pbnRlZ2VyKHsgbWluOiAxLCBtYXg6IDEwIH0pLCAoaXRlbXMsIHNlbGVjdENvdW50KSA9PiB7XG4gICAgICAgIC8vIENsZWFuIHVwIGJlZm9yZSByZW5kZXJpbmcgdG8gZW5zdXJlIGZyZXNoIERPTVxuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBhY3R1YWxTZWxlY3RDb3VudCA9IE1hdGgubWluKHNlbGVjdENvdW50LCBpdGVtcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBvblNlbGVjdGlvbkNoYW5nZSA9IGplc3QuZm4oKTtcbiAgICAgICAgY29uc3Qgb25CdWxrRGVsZXRlID0gamVzdC5mbigpO1xuXG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXG4gICAgICAgICAgPERhdGFUYWJsZVxuICAgICAgICAgICAgZGF0YT17aXRlbXN9XG4gICAgICAgICAgICBjb2x1bW5zPXt0ZXN0Q29sdW1uc31cbiAgICAgICAgICAgIHNlbGVjdGFibGU9e3RydWV9XG4gICAgICAgICAgICBvblNlbGVjdGlvbkNoYW5nZT17b25TZWxlY3Rpb25DaGFuZ2V9XG4gICAgICAgICAgICBvbkJ1bGtEZWxldGU9e29uQnVsa0RlbGV0ZX1cbiAgICAgICAgICAgIGVudGl0eVR5cGU9XCJpdGVtc1wiXG4gICAgICAgICAgLz5cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBTZWxlY3QgdGhlIHNwZWNpZmllZCBudW1iZXIgb2Ygcm93c1xuICAgICAgICBjb25zdCBjaGVja2JveGVzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBhY3R1YWxTZWxlY3RDb3VudCAmJiBpIDwgY2hlY2tib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZpcmVFdmVudC5jbGljayhjaGVja2JveGVzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIGRpc3BsYXllZCBjb3VudCBtYXRjaGVzIHRoZSBhY3R1YWwgc2VsZWN0aW9uXG4gICAgICAgIGNvbnN0IGNvdW50VGV4dCA9IHNjcmVlbi5nZXRCeVRleHQobmV3IFJlZ0V4cChgJHthY3R1YWxTZWxlY3RDb3VudH0uKnNlbGVjdGVkYCwgJ2knKSk7XG4gICAgICAgIGV4cGVjdChjb3VudFRleHQpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHVwZGF0ZSBjb3VudCB3aGVuIHNlbGVjdGlvbiBjaGFuZ2VzJywgKCkgPT4ge1xuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLnByb3BlcnR5KHRlc3RJdGVtQXJyYXlBcmJpdHJhcnksIChpdGVtcykgPT4ge1xuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoIDwgMikgcmV0dXJuOyAvLyBOZWVkIGF0IGxlYXN0IDIgaXRlbXNcblxuICAgICAgICAvLyBDbGVhbiB1cCBiZWZvcmUgcmVuZGVyaW5nIHRvIGVuc3VyZSBmcmVzaCBET01cbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBcbiAgICAgICAgY29uc3Qgb25TZWxlY3Rpb25DaGFuZ2UgPSBqZXN0LmZuKCk7XG4gICAgICAgIGNvbnN0IG9uQnVsa0RlbGV0ZSA9IGplc3QuZm4oKTtcblxuICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxuICAgICAgICAgIDxEYXRhVGFibGVcbiAgICAgICAgICAgIGRhdGE9e2l0ZW1zfVxuICAgICAgICAgICAgY29sdW1ucz17dGVzdENvbHVtbnN9XG4gICAgICAgICAgICBzZWxlY3RhYmxlPXt0cnVlfVxuICAgICAgICAgICAgb25TZWxlY3Rpb25DaGFuZ2U9e29uU2VsZWN0aW9uQ2hhbmdlfVxuICAgICAgICAgICAgb25CdWxrRGVsZXRlPXtvbkJ1bGtEZWxldGV9XG4gICAgICAgICAgICBlbnRpdHlUeXBlPVwiaXRlbXNcIlxuICAgICAgICAgIC8+XG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgY2hlY2tib3hlcyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKTtcblxuICAgICAgICAvLyBTZWxlY3QgZmlyc3QgaXRlbVxuICAgICAgICBmaXJlRXZlbnQuY2xpY2soY2hlY2tib3hlc1sxXSk7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KC8xLipzZWxlY3RlZC9pKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcblxuICAgICAgICAvLyBTZWxlY3Qgc2Vjb25kIGl0ZW1cbiAgICAgICAgZmlyZUV2ZW50LmNsaWNrKGNoZWNrYm94ZXNbMl0pO1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgvMi4qc2VsZWN0ZWQvaSkpLnRvQmVJblRoZURvY3VtZW50KCk7XG5cbiAgICAgICAgLy8gRGVzZWxlY3QgZmlyc3QgaXRlbVxuICAgICAgICBmaXJlRXZlbnQuY2xpY2soY2hlY2tib3hlc1sxXSk7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KC8xLipzZWxlY3RlZC9pKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xufSk7XG5cbmRlc2NyaWJlKCdGZWF0dXJlOiBhZG1pbi11aS1tb2Rlcm5pemF0aW9uLCBQcm9wZXJ0eSAyMzogQnVsayBvcGVyYXRpb24gcHJvZ3Jlc3MgaW5kaWNhdGlvbicsICgpID0+IHtcbiAgLyoqXG4gICAqIFByb3BlcnR5IDIzOiBCdWxrIG9wZXJhdGlvbiBwcm9ncmVzcyBpbmRpY2F0aW9uXG4gICAqIEZvciBhbnkgYnVsayBvcGVyYXRpb24gaW4gcHJvZ3Jlc3MsIGEgcHJvZ3Jlc3MgaW5kaWNhdG9yIHNob3VsZCBiZSB2aXNpYmxlIHRvIHRoZSB1c2VyLlxuICAgKiBWYWxpZGF0ZXM6IFJlcXVpcmVtZW50cyAxNC41XG4gICAqL1xuICBpdCgnc2hvdWxkIHNob3cgcHJvZ3Jlc3MgaW5kaWNhdG9yIGR1cmluZyBidWxrIGRlbGV0ZScsIGFzeW5jICgpID0+IHtcbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KHRlc3RJdGVtQXJyYXlBcmJpdHJhcnksIGFzeW5jIChpdGVtcykgPT4ge1xuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgICAgLy8gQ2xlYW4gdXAgYmVmb3JlIHJlbmRlcmluZyB0byBlbnN1cmUgZnJlc2ggRE9NXG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgXG4gICAgICAgIGxldCByZXNvbHZlRGVsZXRlOiAoKSA9PiB2b2lkO1xuICAgICAgICBjb25zdCBkZWxldGVQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICAgICAgICByZXNvbHZlRGVsZXRlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgb25CdWxrRGVsZXRlID0gamVzdC5mbigoKSA9PiBkZWxldGVQcm9taXNlKTtcblxuICAgICAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gcmVuZGVyKFxuICAgICAgICAgIDxEYXRhVGFibGVcbiAgICAgICAgICAgIGRhdGE9e2l0ZW1zfVxuICAgICAgICAgICAgY29sdW1ucz17dGVzdENvbHVtbnN9XG4gICAgICAgICAgICBzZWxlY3RhYmxlPXt0cnVlfVxuICAgICAgICAgICAgb25CdWxrRGVsZXRlPXtvbkJ1bGtEZWxldGV9XG4gICAgICAgICAgICBlbnRpdHlUeXBlPVwiaXRlbXNcIlxuICAgICAgICAgIC8+XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gU2VsZWN0IGZpcnN0IHJvd1xuICAgICAgICBjb25zdCBjaGVja2JveGVzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScpO1xuICAgICAgICBmaXJlRXZlbnQuY2xpY2soY2hlY2tib3hlc1sxXSk7XG5cbiAgICAgICAgLy8gQ2xpY2sgZGVsZXRlIGJ1dHRvblxuICAgICAgICBjb25zdCBkZWxldGVCdXR0b24gPSBzY3JlZW4uZ2V0QnlUZXh0KC9EZWxldGUgU2VsZWN0ZWQvaSk7XG4gICAgICAgIGZpcmVFdmVudC5jbGljayhkZWxldGVCdXR0b24pO1xuXG4gICAgICAgIC8vIFByb2dyZXNzIGluZGljYXRvciBzaG91bGQgYmUgdmlzaWJsZVxuICAgICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgvUHJvY2Vzc2luZy9pKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVzb2x2ZSB0aGUgZGVsZXRlIG9wZXJhdGlvblxuICAgICAgICByZXNvbHZlRGVsZXRlISgpO1xuXG4gICAgICAgIC8vIFdhaXQgZm9yIHByb2dyZXNzIGluZGljYXRvciB0byBkaXNhcHBlYXJcbiAgICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5VGV4dCgvUHJvY2Vzc2luZy9pKSkubm90LnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICB7IG51bVJ1bnM6IDUwIH0gLy8gRmV3ZXIgcnVucyBmb3IgYXN5bmMgdGVzdHNcbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGRpc2FibGUgYnV0dG9ucyBkdXJpbmcgYnVsayBvcGVyYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eSh0ZXN0SXRlbUFycmF5QXJiaXRyYXJ5LCBhc3luYyAoaXRlbXMpID0+IHtcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIENsZWFuIHVwIGJlZm9yZSByZW5kZXJpbmcgdG8gZW5zdXJlIGZyZXNoIERPTVxuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIFxuICAgICAgICBsZXQgcmVzb2x2ZURlbGV0ZTogKCkgPT4gdm9pZDtcbiAgICAgICAgY29uc3QgZGVsZXRlUHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZURlbGV0ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG9uQnVsa0RlbGV0ZSA9IGplc3QuZm4oKCkgPT4gZGVsZXRlUHJvbWlzZSk7XG5cbiAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcbiAgICAgICAgICA8RGF0YVRhYmxlXG4gICAgICAgICAgICBkYXRhPXtpdGVtc31cbiAgICAgICAgICAgIGNvbHVtbnM9e3Rlc3RDb2x1bW5zfVxuICAgICAgICAgICAgc2VsZWN0YWJsZT17dHJ1ZX1cbiAgICAgICAgICAgIG9uQnVsa0RlbGV0ZT17b25CdWxrRGVsZXRlfVxuICAgICAgICAgICAgZW50aXR5VHlwZT1cIml0ZW1zXCJcbiAgICAgICAgICAvPlxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFNlbGVjdCBmaXJzdCByb3dcbiAgICAgICAgY29uc3QgY2hlY2tib3hlcyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKTtcbiAgICAgICAgZmlyZUV2ZW50LmNsaWNrKGNoZWNrYm94ZXNbMV0pO1xuXG4gICAgICAgIC8vIENsaWNrIGRlbGV0ZSBidXR0b25cbiAgICAgICAgY29uc3QgZGVsZXRlQnV0dG9uID0gc2NyZWVuLmdldEJ5VGV4dCgvRGVsZXRlIFNlbGVjdGVkL2kpIGFzIEhUTUxCdXR0b25FbGVtZW50O1xuICAgICAgICBmaXJlRXZlbnQuY2xpY2soZGVsZXRlQnV0dG9uKTtcblxuICAgICAgICAvLyBCdXR0b24gc2hvdWxkIGJlIGRpc2FibGVkIGR1cmluZyBvcGVyYXRpb25cbiAgICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgICAgZXhwZWN0KGRlbGV0ZUJ1dHRvbi5kaXNhYmxlZCkudG9CZSh0cnVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVzb2x2ZSB0aGUgZGVsZXRlIG9wZXJhdGlvblxuICAgICAgICByZXNvbHZlRGVsZXRlISgpO1xuXG4gICAgICAgIC8vIEJ1dHRvbiBzaG91bGQgYmUgZW5hYmxlZCBhZnRlciBvcGVyYXRpb25cbiAgICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgICAgZXhwZWN0KGRlbGV0ZUJ1dHRvbi5kaXNhYmxlZCkudG9CZShmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICB7IG51bVJ1bnM6IDUwIH1cbiAgICApO1xuICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnRmVhdHVyZTogYWRtaW4tdWktbW9kZXJuaXphdGlvbiwgUHJvcGVydHkgMjQ6IENTViBleHBvcnQgZGF0YSBhY2N1cmFjeScsICgpID0+IHtcbiAgLyoqXG4gICAqIFByb3BlcnR5IDI0OiBDU1YgZXhwb3J0IGRhdGEgYWNjdXJhY3lcbiAgICogRm9yIGFueSBkYXRhIHRhYmxlIHN0YXRlIHdpdGggYWN0aXZlIGZpbHRlcnMsIGV4cG9ydGluZyB0byBDU1Ygc2hvdWxkIGdlbmVyYXRlXG4gICAqIGEgZmlsZSBjb250YWluaW5nIGV4YWN0bHkgdGhlIHJvd3MgY3VycmVudGx5IHZpc2libGUgaW4gdGhlIGZpbHRlcmVkIHRhYmxlLlxuICAgKiBWYWxpZGF0ZXM6IFJlcXVpcmVtZW50cyAxNS4yXG4gICAqL1xuICBpdCgnc2hvdWxkIGV4cG9ydCBleGFjdGx5IHRoZSB2aXNpYmxlIGRhdGEnLCAoKSA9PiB7XG4gICAgZmMuYXNzZXJ0KFxuICAgICAgZmMucHJvcGVydHkodGVzdEl0ZW1BcnJheUFyYml0cmFyeSwgKGl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IGNzdiA9IGNvbnZlcnRUb0NTVihpdGVtcywgdGVzdENvbHVtbnMpO1xuICAgICAgICBjb25zdCBsaW5lcyA9IGNzdi5zcGxpdCgnXFxuJyk7XG5cbiAgICAgICAgLy8gU2hvdWxkIGhhdmUgaGVhZGVyICsgZGF0YSByb3dzXG4gICAgICAgIGV4cGVjdChsaW5lcy5sZW5ndGgpLnRvQmUoaXRlbXMubGVuZ3RoICsgMSk7XG5cbiAgICAgICAgLy8gSGVhZGVyIHNob3VsZCBjb250YWluIGFsbCBjb2x1bW4gbGFiZWxzXG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGxpbmVzWzBdO1xuICAgICAgICB0ZXN0Q29sdW1ucy5mb3JFYWNoKGNvbCA9PiB7XG4gICAgICAgICAgZXhwZWN0KGhlYWRlcikudG9Db250YWluKGNvbC5sYWJlbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEVhY2ggZGF0YSByb3cgc2hvdWxkIGJlIHByZXNlbnQgKGFjY291bnRpbmcgZm9yIENTViBlc2NhcGluZylcbiAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCByb3cgPSBsaW5lc1tpbmRleCArIDFdO1xuICAgICAgICAgIC8vIEZvciBuYW1lcyB3aXRoIHF1b3RlcywgdGhleSB3aWxsIGJlIGVzY2FwZWQgaW4gQ1NWXG4gICAgICAgICAgY29uc3QgZXNjYXBlZE5hbWUgPSBpdGVtLm5hbWUuaW5jbHVkZXMoJ1wiJykgPyBpdGVtLm5hbWUucmVwbGFjZSgvXCIvZywgJ1wiXCInKSA6IGl0ZW0ubmFtZTtcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgcm93IGNvbnRhaW5zIHRoZSB2YWx1ZSAobWF5IGJlIHF1b3RlZClcbiAgICAgICAgICBjb25zdCBuYW1lSW5Sb3cgPSByb3cuaW5jbHVkZXMoZXNjYXBlZE5hbWUpIHx8IHJvdy5pbmNsdWRlcyhgXCIke2VzY2FwZWROYW1lfVwiYCk7XG4gICAgICAgICAgZXhwZWN0KG5hbWVJblJvdykudG9CZSh0cnVlKTtcbiAgICAgICAgICBleHBlY3Qocm93KS50b0NvbnRhaW4oU3RyaW5nKGl0ZW0udmFsdWUpKTtcbiAgICAgICAgICBleHBlY3Qocm93KS50b0NvbnRhaW4oaXRlbS5jYXRlZ29yeSk7XG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ0ZlYXR1cmU6IGFkbWluLXVpLW1vZGVybml6YXRpb24sIFByb3BlcnR5IDI1OiBDU1YgY29sdW1uIGNvbXBsZXRlbmVzcycsICgpID0+IHtcbiAgLyoqXG4gICAqIFByb3BlcnR5IDI1OiBDU1YgY29sdW1uIGNvbXBsZXRlbmVzc1xuICAgKiBGb3IgYW55IENTViBleHBvcnQsIHRoZSBmaWxlIHNob3VsZCBpbmNsdWRlIGFsbCBjb2x1bW5zIHRoYXQgYXJlIGN1cnJlbnRseVxuICAgKiB2aXNpYmxlIGluIHRoZSBkYXRhIHRhYmxlLlxuICAgKiBWYWxpZGF0ZXM6IFJlcXVpcmVtZW50cyAxNS4zXG4gICAqL1xuICBpdCgnc2hvdWxkIGluY2x1ZGUgYWxsIHZpc2libGUgY29sdW1ucyBpbiBDU1YnLCAoKSA9PiB7XG4gICAgZmMuYXNzZXJ0KFxuICAgICAgZmMucHJvcGVydHkodGVzdEl0ZW1BcnJheUFyYml0cmFyeSwgKGl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IGNzdiA9IGNvbnZlcnRUb0NTVihpdGVtcywgdGVzdENvbHVtbnMpO1xuICAgICAgICBjb25zdCBsaW5lcyA9IGNzdi5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGxpbmVzWzBdO1xuXG4gICAgICAgIC8vIEFsbCBjb2x1bW4gbGFiZWxzIHNob3VsZCBiZSBpbiB0aGUgaGVhZGVyXG4gICAgICAgIHRlc3RDb2x1bW5zLmZvckVhY2goY29sID0+IHtcbiAgICAgICAgICBleHBlY3QoaGVhZGVyKS50b0NvbnRhaW4oY29sLmxhYmVsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ291bnQgb2YgY29sdW1ucyBpbiBoZWFkZXIgc2hvdWxkIG1hdGNoIGNvbHVtbiBkZWZpbml0aW9uc1xuICAgICAgICBjb25zdCBoZWFkZXJDb2x1bW5zID0gaGVhZGVyLnNwbGl0KCcsJykubGVuZ3RoO1xuICAgICAgICBleHBlY3QoaGVhZGVyQ29sdW1ucykudG9CZSh0ZXN0Q29sdW1ucy5sZW5ndGgpO1xuICAgICAgfSksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBtYWludGFpbiBjb2x1bW4gb3JkZXIgaW4gQ1NWJywgKCkgPT4ge1xuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLnByb3BlcnR5KHRlc3RJdGVtQXJyYXlBcmJpdHJhcnksIChpdGVtcykgPT4ge1xuICAgICAgICBjb25zdCBjc3YgPSBjb252ZXJ0VG9DU1YoaXRlbXMsIHRlc3RDb2x1bW5zKTtcbiAgICAgICAgY29uc3QgbGluZXMgPSBjc3Yuc3BsaXQoJ1xcbicpO1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBsaW5lc1swXTtcbiAgICAgICAgY29uc3QgaGVhZGVyQ29sdW1ucyA9IGhlYWRlci5zcGxpdCgnLCcpO1xuXG4gICAgICAgIC8vIENvbHVtbnMgc2hvdWxkIGFwcGVhciBpbiB0aGUgc2FtZSBvcmRlciBhcyBkZWZpbmVkXG4gICAgICAgIHRlc3RDb2x1bW5zLmZvckVhY2goKGNvbCwgaW5kZXgpID0+IHtcbiAgICAgICAgICBleHBlY3QoaGVhZGVyQ29sdW1uc1tpbmRleF0pLnRvQ29udGFpbihjb2wubGFiZWwpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xufSk7XG5cbmRlc2NyaWJlKCdGZWF0dXJlOiBhZG1pbi11aS1tb2Rlcm5pemF0aW9uLCBQcm9wZXJ0eSAyNjogQ1NWIGZpbGVuYW1lIGZvcm1hdCcsICgpID0+IHtcbiAgLyoqXG4gICAqIFByb3BlcnR5IDI2OiBDU1YgZmlsZW5hbWUgZm9ybWF0XG4gICAqIEZvciBhbnkgQ1NWIGV4cG9ydCBvcGVyYXRpb24sIHRoZSBnZW5lcmF0ZWQgZmlsZW5hbWUgc2hvdWxkIGZvbGxvd1xuICAgKiB0aGUgcGF0dGVybiB7ZW50aXR5LXR5cGV9LXt0aW1lc3RhbXB9LmNzdi5cbiAgICogVmFsaWRhdGVzOiBSZXF1aXJlbWVudHMgMTUuNFxuICAgKi9cbiAgaXQoJ3Nob3VsZCBnZW5lcmF0ZSBmaWxlbmFtZSB3aXRoIGNvcnJlY3QgZm9ybWF0JywgKCkgPT4ge1xuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLnByb3BlcnR5KGZjLmNvbnN0YW50RnJvbSgnZ3Vlc3RzJywgJ2V2ZW50cycsICdhY3Rpdml0aWVzJywgJ3ZlbmRvcnMnLCAncGhvdG9zJyksIChlbnRpdHlUeXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gZ2VuZXJhdGVDU1ZGaWxlbmFtZShlbnRpdHlUeXBlKTtcblxuICAgICAgICAvLyBTaG91bGQgc3RhcnQgd2l0aCBlbnRpdHkgdHlwZVxuICAgICAgICBleHBlY3QoZmlsZW5hbWUpLnRvTWF0Y2gobmV3IFJlZ0V4cChgXiR7ZW50aXR5VHlwZX0tYCkpO1xuXG4gICAgICAgIC8vIFNob3VsZCBlbmQgd2l0aCAuY3N2XG4gICAgICAgIGV4cGVjdChmaWxlbmFtZSkudG9NYXRjaCgvXFwuY3N2JC8pO1xuXG4gICAgICAgIC8vIFNob3VsZCBjb250YWluIHRpbWVzdGFtcCBpbiBJU08gZm9ybWF0XG4gICAgICAgIGV4cGVjdChmaWxlbmFtZSkudG9NYXRjaCgvXFxkezR9LVxcZHsyfS1cXGR7Mn1UXFxkezJ9LVxcZHsyfS1cXGR7Mn0vKTtcbiAgICAgIH0pLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgZ2VuZXJhdGUgdW5pcXVlIGZpbGVuYW1lcyBmb3IgZGlmZmVyZW50IHRpbWVzdGFtcHMnLCAoKSA9PiB7XG4gICAgZmMuYXNzZXJ0KFxuICAgICAgZmMucHJvcGVydHkoZmMuY29uc3RhbnRGcm9tKCdndWVzdHMnLCAnZXZlbnRzJywgJ2FjdGl2aXRpZXMnKSwgKGVudGl0eVR5cGUpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUxID0gZ2VuZXJhdGVDU1ZGaWxlbmFtZShlbnRpdHlUeXBlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFdhaXQgYSB0aW55IGJpdCB0byBlbnN1cmUgZGlmZmVyZW50IHRpbWVzdGFtcFxuICAgICAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnQgPCAyKSB7XG4gICAgICAgICAgLy8gQnVzeSB3YWl0XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGZpbGVuYW1lMiA9IGdlbmVyYXRlQ1NWRmlsZW5hbWUoZW50aXR5VHlwZSk7XG5cbiAgICAgICAgLy8gRmlsZW5hbWVzIHNob3VsZCBiZSBkaWZmZXJlbnQgZHVlIHRvIHRpbWVzdGFtcFxuICAgICAgICAvLyAobWF5IG9jY2FzaW9uYWxseSBiZSB0aGUgc2FtZSBpZiBnZW5lcmF0ZWQgaW4gc2FtZSBtaWxsaXNlY29uZCwgYnV0IHZlcnkgdW5saWtlbHkpXG4gICAgICAgIGlmIChmaWxlbmFtZTEgPT09IGZpbGVuYW1lMikge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYWNjZXB0YWJsZSBpbiByYXJlIGNhc2VzXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChmaWxlbmFtZTEpLm5vdC50b0JlKGZpbGVuYW1lMik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSksXG4gICAgICB7IG51bVJ1bnM6IDUwIH1cbiAgICApO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwidXNlUm91dGVyIiwicHVzaCIsImZuIiwidXNlU2VhcmNoUGFyYW1zIiwiZ2V0IiwidG9TdHJpbmciLCJhZnRlckVhY2giLCJjbGVhbnVwIiwidGVzdEl0ZW1BcmJpdHJhcnkiLCJmYyIsInJlY29yZCIsImlkIiwidXVpZCIsIm5hbWUiLCJzdHJpbmciLCJtaW5MZW5ndGgiLCJtYXhMZW5ndGgiLCJ2YWx1ZSIsImludGVnZXIiLCJtaW4iLCJtYXgiLCJjYXRlZ29yeSIsImNvbnN0YW50RnJvbSIsInRlc3RJdGVtQXJyYXlBcmJpdHJhcnkiLCJhcnJheSIsInRlc3RDb2x1bW5zIiwia2V5IiwibGFiZWwiLCJzb3J0YWJsZSIsImZpbHRlcmFibGUiLCJkZXNjcmliZSIsIml0IiwiYXNzZXJ0IiwicHJvcGVydHkiLCJpdGVtcyIsInNlbGVjdENvdW50IiwiYWN0dWFsU2VsZWN0Q291bnQiLCJNYXRoIiwibGVuZ3RoIiwib25TZWxlY3Rpb25DaGFuZ2UiLCJvbkJ1bGtEZWxldGUiLCJjb250YWluZXIiLCJyZW5kZXIiLCJEYXRhVGFibGUiLCJkYXRhIiwiY29sdW1ucyIsInNlbGVjdGFibGUiLCJlbnRpdHlUeXBlIiwiY2hlY2tib3hlcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJpIiwiZmlyZUV2ZW50IiwiY2xpY2siLCJ0b29sYmFyIiwic2NyZWVuIiwicXVlcnlCeVRleHQiLCJleHBlY3QiLCJ0b0JlSW5UaGVEb2N1bWVudCIsIm51bVJ1bnMiLCJub3QiLCJjb3VudFRleHQiLCJnZXRCeVRleHQiLCJSZWdFeHAiLCJhc3luY1Byb3BlcnR5IiwicmVzb2x2ZURlbGV0ZSIsImRlbGV0ZVByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsImRlbGV0ZUJ1dHRvbiIsIndhaXRGb3IiLCJkaXNhYmxlZCIsInRvQmUiLCJjc3YiLCJjb252ZXJ0VG9DU1YiLCJsaW5lcyIsInNwbGl0IiwiaGVhZGVyIiwiZm9yRWFjaCIsImNvbCIsInRvQ29udGFpbiIsIml0ZW0iLCJpbmRleCIsInJvdyIsImVzY2FwZWROYW1lIiwiaW5jbHVkZXMiLCJyZXBsYWNlIiwibmFtZUluUm93IiwiU3RyaW5nIiwiaGVhZGVyQ29sdW1ucyIsImZpbGVuYW1lIiwiZ2VuZXJhdGVDU1ZGaWxlbmFtZSIsInRvTWF0Y2giLCJmaWxlbmFtZTEiLCJzdGFydCIsIkRhdGUiLCJub3ciLCJmaWxlbmFtZTIiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztDQUtDO0FBT0Qsc0JBQXNCO0FBQ3RCQSxLQUFLQyxJQUFJLENBQUMsbUJBQW1CLElBQU8sQ0FBQTtRQUNsQ0MsV0FBVyxJQUFPLENBQUE7Z0JBQ2hCQyxNQUFNSCxLQUFLSSxFQUFFO1lBQ2YsQ0FBQTtRQUNBQyxpQkFBaUIsSUFBTyxDQUFBO2dCQUN0QkMsS0FBS04sS0FBS0ksRUFBRTtnQkFDWkcsVUFBVVAsS0FBS0ksRUFBRSxDQUFDLElBQU07WUFDMUIsQ0FBQTtJQUNGLENBQUE7Ozs7O3VCQWQ0RDsyQkFDbEI7bUVBQ3RCOzJCQUM4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBYWxELG9EQUFvRDtBQUNwREksVUFBVTtJQUNSQyxJQUFBQSxjQUFPO0FBQ1Q7QUFVQSx1Q0FBdUM7QUFDdkMsTUFBTUMsb0JBQW9CQyxXQUFHQyxNQUFNLENBQUM7SUFDbENDLElBQUlGLFdBQUdHLElBQUk7SUFDWEMsTUFBTUosV0FBR0ssTUFBTSxDQUFDO1FBQUVDLFdBQVc7UUFBR0MsV0FBVztJQUFHO0lBQzlDQyxPQUFPUixXQUFHUyxPQUFPLENBQUM7UUFBRUMsS0FBSztRQUFHQyxLQUFLO0lBQUs7SUFDdENDLFVBQVVaLFdBQUdhLFlBQVksQ0FBQyxLQUFLLEtBQUssS0FBSztBQUMzQztBQUVBLE1BQU1DLHlCQUF5QmQsV0FBR2UsS0FBSyxDQUFDaEIsbUJBQW1CO0lBQUVPLFdBQVc7SUFBR0MsV0FBVztBQUFJO0FBRTFGLCtCQUErQjtBQUMvQixNQUFNUyxjQUFxQztJQUN6QztRQUFFQyxLQUFLO1FBQVFDLE9BQU87UUFBUUMsVUFBVTtJQUFLO0lBQzdDO1FBQUVGLEtBQUs7UUFBU0MsT0FBTztRQUFTQyxVQUFVO0lBQUs7SUFDL0M7UUFBRUYsS0FBSztRQUFZQyxPQUFPO1FBQVlDLFVBQVU7UUFBTUMsWUFBWTtJQUFLO0NBQ3hFO0FBRURDLFNBQVMsZ0ZBQWdGO0lBQ3ZGOzs7OztHQUtDLEdBQ0RDLEdBQUcsMERBQTBEO1FBQzNEdEIsV0FBR3VCLE1BQU0sQ0FDUHZCLFdBQUd3QixRQUFRLENBQUNWLHdCQUF3QmQsV0FBR1MsT0FBTyxDQUFDO1lBQUVDLEtBQUs7WUFBR0MsS0FBSztRQUFHLElBQUksQ0FBQ2MsT0FBT0M7WUFDM0UsZ0RBQWdEO1lBQ2hENUIsSUFBQUEsY0FBTztZQUVQLE1BQU02QixvQkFBb0JDLEtBQUtsQixHQUFHLENBQUNnQixhQUFhRCxNQUFNSSxNQUFNO1lBQzVELE1BQU1DLG9CQUFvQnpDLEtBQUtJLEVBQUU7WUFDakMsTUFBTXNDLGVBQWUxQyxLQUFLSSxFQUFFO1lBRTVCLE1BQU0sRUFBRXVDLFNBQVMsRUFBRSxHQUFHQyxJQUFBQSxhQUFNLGdCQUMxQixxQkFBQ0Msb0JBQVM7Z0JBQ1JDLE1BQU1WO2dCQUNOVyxTQUFTcEI7Z0JBQ1RxQixZQUFZO2dCQUNaUCxtQkFBbUJBO2dCQUNuQkMsY0FBY0E7Z0JBQ2RPLFlBQVc7O1lBSWYsc0NBQXNDO1lBQ3RDLE1BQU1DLGFBQWFQLFVBQVVRLGdCQUFnQixDQUFDO1lBQzlDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxLQUFLZCxxQkFBcUJjLElBQUlGLFdBQVdWLE1BQU0sRUFBRVksSUFBSztnQkFDcEVDLGdCQUFTLENBQUNDLEtBQUssQ0FBQ0osVUFBVSxDQUFDRSxFQUFFO1lBQy9CO1lBRUEsd0NBQXdDO1lBQ3hDLHVEQUF1RDtZQUN2RCxNQUFNRyxVQUFVQyxhQUFNLENBQUNDLFdBQVcsQ0FBQztZQUNuQ0MsT0FBT0gsU0FBU0ksaUJBQWlCO1FBQ25DLElBQ0E7WUFBRUMsU0FBUztRQUFJO0lBRW5CO0lBRUEzQixHQUFHLDZEQUE2RDtRQUM5RHRCLFdBQUd1QixNQUFNLENBQ1B2QixXQUFHd0IsUUFBUSxDQUFDVix3QkFBd0IsQ0FBQ1c7WUFDbkMsZ0RBQWdEO1lBQ2hEM0IsSUFBQUEsY0FBTztZQUVQLE1BQU1nQyxvQkFBb0J6QyxLQUFLSSxFQUFFO1lBQ2pDLE1BQU1zQyxlQUFlMUMsS0FBS0ksRUFBRTtZQUU1QndDLElBQUFBLGFBQU0sZ0JBQ0oscUJBQUNDLG9CQUFTO2dCQUNSQyxNQUFNVjtnQkFDTlcsU0FBU3BCO2dCQUNUcUIsWUFBWTtnQkFDWlAsbUJBQW1CQTtnQkFDbkJDLGNBQWNBO2dCQUNkTyxZQUFXOztZQUlmLHNEQUFzRDtZQUN0RCx1REFBdUQ7WUFDdkQsTUFBTU0sVUFBVUMsYUFBTSxDQUFDQyxXQUFXLENBQUM7WUFDbkNDLE9BQU9ILFNBQVNNLEdBQUcsQ0FBQ0YsaUJBQWlCO1FBQ3ZDLElBQ0E7WUFBRUMsU0FBUztRQUFJO0lBRW5CO0FBQ0Y7QUFFQTVCLFNBQVMseUVBQXlFO0lBQ2hGOzs7OztHQUtDLEdBQ0RDLEdBQUcsbURBQW1EO1FBQ3BEdEIsV0FBR3VCLE1BQU0sQ0FDUHZCLFdBQUd3QixRQUFRLENBQUNWLHdCQUF3QmQsV0FBR1MsT0FBTyxDQUFDO1lBQUVDLEtBQUs7WUFBR0MsS0FBSztRQUFHLElBQUksQ0FBQ2MsT0FBT0M7WUFDM0UsZ0RBQWdEO1lBQ2hENUIsSUFBQUEsY0FBTztZQUVQLE1BQU02QixvQkFBb0JDLEtBQUtsQixHQUFHLENBQUNnQixhQUFhRCxNQUFNSSxNQUFNO1lBQzVELE1BQU1DLG9CQUFvQnpDLEtBQUtJLEVBQUU7WUFDakMsTUFBTXNDLGVBQWUxQyxLQUFLSSxFQUFFO1lBRTVCLE1BQU0sRUFBRXVDLFNBQVMsRUFBRSxHQUFHQyxJQUFBQSxhQUFNLGdCQUMxQixxQkFBQ0Msb0JBQVM7Z0JBQ1JDLE1BQU1WO2dCQUNOVyxTQUFTcEI7Z0JBQ1RxQixZQUFZO2dCQUNaUCxtQkFBbUJBO2dCQUNuQkMsY0FBY0E7Z0JBQ2RPLFlBQVc7O1lBSWYsc0NBQXNDO1lBQ3RDLE1BQU1DLGFBQWFQLFVBQVVRLGdCQUFnQixDQUFDO1lBQzlDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxLQUFLZCxxQkFBcUJjLElBQUlGLFdBQVdWLE1BQU0sRUFBRVksSUFBSztnQkFDcEVDLGdCQUFTLENBQUNDLEtBQUssQ0FBQ0osVUFBVSxDQUFDRSxFQUFFO1lBQy9CO1lBRUEsOERBQThEO1lBQzlELE1BQU1VLFlBQVlOLGFBQU0sQ0FBQ08sU0FBUyxDQUFDLElBQUlDLE9BQU8sR0FBRzFCLGtCQUFrQixVQUFVLENBQUMsRUFBRTtZQUNoRm9CLE9BQU9JLFdBQVdILGlCQUFpQjtRQUNyQyxJQUNBO1lBQUVDLFNBQVM7UUFBSTtJQUVuQjtJQUVBM0IsR0FBRyw4Q0FBOEM7UUFDL0N0QixXQUFHdUIsTUFBTSxDQUNQdkIsV0FBR3dCLFFBQVEsQ0FBQ1Ysd0JBQXdCLENBQUNXO1lBQ25DLElBQUlBLE1BQU1JLE1BQU0sR0FBRyxHQUFHLFFBQVEsd0JBQXdCO1lBRXRELGdEQUFnRDtZQUNoRC9CLElBQUFBLGNBQU87WUFFUCxNQUFNZ0Msb0JBQW9CekMsS0FBS0ksRUFBRTtZQUNqQyxNQUFNc0MsZUFBZTFDLEtBQUtJLEVBQUU7WUFFNUIsTUFBTSxFQUFFdUMsU0FBUyxFQUFFLEdBQUdDLElBQUFBLGFBQU0sZ0JBQzFCLHFCQUFDQyxvQkFBUztnQkFDUkMsTUFBTVY7Z0JBQ05XLFNBQVNwQjtnQkFDVHFCLFlBQVk7Z0JBQ1pQLG1CQUFtQkE7Z0JBQ25CQyxjQUFjQTtnQkFDZE8sWUFBVzs7WUFJZixNQUFNQyxhQUFhUCxVQUFVUSxnQkFBZ0IsQ0FBQztZQUU5QyxvQkFBb0I7WUFDcEJFLGdCQUFTLENBQUNDLEtBQUssQ0FBQ0osVUFBVSxDQUFDLEVBQUU7WUFDN0JRLE9BQU9GLGFBQU0sQ0FBQ08sU0FBUyxDQUFDLGlCQUFpQkosaUJBQWlCO1lBRTFELHFCQUFxQjtZQUNyQk4sZ0JBQVMsQ0FBQ0MsS0FBSyxDQUFDSixVQUFVLENBQUMsRUFBRTtZQUM3QlEsT0FBT0YsYUFBTSxDQUFDTyxTQUFTLENBQUMsaUJBQWlCSixpQkFBaUI7WUFFMUQsc0JBQXNCO1lBQ3RCTixnQkFBUyxDQUFDQyxLQUFLLENBQUNKLFVBQVUsQ0FBQyxFQUFFO1lBQzdCUSxPQUFPRixhQUFNLENBQUNPLFNBQVMsQ0FBQyxpQkFBaUJKLGlCQUFpQjtRQUM1RCxJQUNBO1lBQUVDLFNBQVM7UUFBSTtJQUVuQjtBQUNGO0FBRUE1QixTQUFTLG9GQUFvRjtJQUMzRjs7OztHQUlDLEdBQ0RDLEdBQUcscURBQXFEO1FBQ3REdEIsV0FBR3VCLE1BQU0sQ0FDUHZCLFdBQUdzRCxhQUFhLENBQUN4Qyx3QkFBd0IsT0FBT1c7WUFDOUMsSUFBSUEsTUFBTUksTUFBTSxLQUFLLEdBQUc7WUFFeEIsZ0RBQWdEO1lBQ2hEL0IsSUFBQUEsY0FBTztZQUVQLElBQUl5RDtZQUNKLE1BQU1DLGdCQUFnQixJQUFJQyxRQUFjLENBQUNDO2dCQUN2Q0gsZ0JBQWdCRztZQUNsQjtZQUVBLE1BQU0zQixlQUFlMUMsS0FBS0ksRUFBRSxDQUFDLElBQU0rRDtZQUVuQyxNQUFNLEVBQUV4QixTQUFTLEVBQUUsR0FBR0MsSUFBQUEsYUFBTSxnQkFDMUIscUJBQUNDLG9CQUFTO2dCQUNSQyxNQUFNVjtnQkFDTlcsU0FBU3BCO2dCQUNUcUIsWUFBWTtnQkFDWk4sY0FBY0E7Z0JBQ2RPLFlBQVc7O1lBSWYsbUJBQW1CO1lBQ25CLE1BQU1DLGFBQWFQLFVBQVVRLGdCQUFnQixDQUFDO1lBQzlDRSxnQkFBUyxDQUFDQyxLQUFLLENBQUNKLFVBQVUsQ0FBQyxFQUFFO1lBRTdCLHNCQUFzQjtZQUN0QixNQUFNb0IsZUFBZWQsYUFBTSxDQUFDTyxTQUFTLENBQUM7WUFDdENWLGdCQUFTLENBQUNDLEtBQUssQ0FBQ2dCO1lBRWhCLHVDQUF1QztZQUN2QyxNQUFNQyxJQUFBQSxjQUFPLEVBQUM7Z0JBQ1piLE9BQU9GLGFBQU0sQ0FBQ08sU0FBUyxDQUFDLGdCQUFnQkosaUJBQWlCO1lBQzNEO1lBRUEsK0JBQStCO1lBQy9CTztZQUVBLDJDQUEyQztZQUMzQyxNQUFNSyxJQUFBQSxjQUFPLEVBQUM7Z0JBQ1piLE9BQU9GLGFBQU0sQ0FBQ0MsV0FBVyxDQUFDLGdCQUFnQkksR0FBRyxDQUFDRixpQkFBaUI7WUFDakU7UUFDRixJQUNBO1lBQUVDLFNBQVM7UUFBRyxFQUFFLDZCQUE2Qjs7SUFFakQ7SUFFQTNCLEdBQUcsZ0RBQWdEO1FBQ2pEdEIsV0FBR3VCLE1BQU0sQ0FDUHZCLFdBQUdzRCxhQUFhLENBQUN4Qyx3QkFBd0IsT0FBT1c7WUFDOUMsSUFBSUEsTUFBTUksTUFBTSxLQUFLLEdBQUc7WUFFeEIsZ0RBQWdEO1lBQ2hEL0IsSUFBQUEsY0FBTztZQUVQLElBQUl5RDtZQUNKLE1BQU1DLGdCQUFnQixJQUFJQyxRQUFjLENBQUNDO2dCQUN2Q0gsZ0JBQWdCRztZQUNsQjtZQUVBLE1BQU0zQixlQUFlMUMsS0FBS0ksRUFBRSxDQUFDLElBQU0rRDtZQUVuQyxNQUFNLEVBQUV4QixTQUFTLEVBQUUsR0FBR0MsSUFBQUEsYUFBTSxnQkFDMUIscUJBQUNDLG9CQUFTO2dCQUNSQyxNQUFNVjtnQkFDTlcsU0FBU3BCO2dCQUNUcUIsWUFBWTtnQkFDWk4sY0FBY0E7Z0JBQ2RPLFlBQVc7O1lBSWYsbUJBQW1CO1lBQ25CLE1BQU1DLGFBQWFQLFVBQVVRLGdCQUFnQixDQUFDO1lBQzlDRSxnQkFBUyxDQUFDQyxLQUFLLENBQUNKLFVBQVUsQ0FBQyxFQUFFO1lBRTdCLHNCQUFzQjtZQUN0QixNQUFNb0IsZUFBZWQsYUFBTSxDQUFDTyxTQUFTLENBQUM7WUFDdENWLGdCQUFTLENBQUNDLEtBQUssQ0FBQ2dCO1lBRWhCLDZDQUE2QztZQUM3QyxNQUFNQyxJQUFBQSxjQUFPLEVBQUM7Z0JBQ1piLE9BQU9ZLGFBQWFFLFFBQVEsRUFBRUMsSUFBSSxDQUFDO1lBQ3JDO1lBRUEsK0JBQStCO1lBQy9CUDtZQUVBLDJDQUEyQztZQUMzQyxNQUFNSyxJQUFBQSxjQUFPLEVBQUM7Z0JBQ1piLE9BQU9ZLGFBQWFFLFFBQVEsRUFBRUMsSUFBSSxDQUFDO1lBQ3JDO1FBQ0YsSUFDQTtZQUFFYixTQUFTO1FBQUc7SUFFbEI7QUFDRjtBQUVBNUIsU0FBUywwRUFBMEU7SUFDakY7Ozs7O0dBS0MsR0FDREMsR0FBRywwQ0FBMEM7UUFDM0N0QixXQUFHdUIsTUFBTSxDQUNQdkIsV0FBR3dCLFFBQVEsQ0FBQ1Ysd0JBQXdCLENBQUNXO1lBQ25DLE1BQU1zQyxNQUFNQyxJQUFBQSx1QkFBWSxFQUFDdkMsT0FBT1Q7WUFDaEMsTUFBTWlELFFBQVFGLElBQUlHLEtBQUssQ0FBQztZQUV4QixpQ0FBaUM7WUFDakNuQixPQUFPa0IsTUFBTXBDLE1BQU0sRUFBRWlDLElBQUksQ0FBQ3JDLE1BQU1JLE1BQU0sR0FBRztZQUV6QywwQ0FBMEM7WUFDMUMsTUFBTXNDLFNBQVNGLEtBQUssQ0FBQyxFQUFFO1lBQ3ZCakQsWUFBWW9ELE9BQU8sQ0FBQ0MsQ0FBQUE7Z0JBQ2xCdEIsT0FBT29CLFFBQVFHLFNBQVMsQ0FBQ0QsSUFBSW5ELEtBQUs7WUFDcEM7WUFFQSxnRUFBZ0U7WUFDaEVPLE1BQU0yQyxPQUFPLENBQUMsQ0FBQ0csTUFBTUM7Z0JBQ25CLE1BQU1DLE1BQU1SLEtBQUssQ0FBQ08sUUFBUSxFQUFFO2dCQUM1QixxREFBcUQ7Z0JBQ3JELE1BQU1FLGNBQWNILEtBQUtuRSxJQUFJLENBQUN1RSxRQUFRLENBQUMsT0FBT0osS0FBS25FLElBQUksQ0FBQ3dFLE9BQU8sQ0FBQyxNQUFNLFFBQVFMLEtBQUtuRSxJQUFJO2dCQUN2RixzREFBc0Q7Z0JBQ3RELE1BQU15RSxZQUFZSixJQUFJRSxRQUFRLENBQUNELGdCQUFnQkQsSUFBSUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFRCxZQUFZLENBQUMsQ0FBQztnQkFDOUUzQixPQUFPOEIsV0FBV2YsSUFBSSxDQUFDO2dCQUN2QmYsT0FBTzBCLEtBQUtILFNBQVMsQ0FBQ1EsT0FBT1AsS0FBSy9ELEtBQUs7Z0JBQ3ZDdUMsT0FBTzBCLEtBQUtILFNBQVMsQ0FBQ0MsS0FBSzNELFFBQVE7WUFDckM7UUFDRixJQUNBO1lBQUVxQyxTQUFTO1FBQUk7SUFFbkI7QUFDRjtBQUVBNUIsU0FBUyx5RUFBeUU7SUFDaEY7Ozs7O0dBS0MsR0FDREMsR0FBRyw2Q0FBNkM7UUFDOUN0QixXQUFHdUIsTUFBTSxDQUNQdkIsV0FBR3dCLFFBQVEsQ0FBQ1Ysd0JBQXdCLENBQUNXO1lBQ25DLE1BQU1zQyxNQUFNQyxJQUFBQSx1QkFBWSxFQUFDdkMsT0FBT1Q7WUFDaEMsTUFBTWlELFFBQVFGLElBQUlHLEtBQUssQ0FBQztZQUN4QixNQUFNQyxTQUFTRixLQUFLLENBQUMsRUFBRTtZQUV2Qiw0Q0FBNEM7WUFDNUNqRCxZQUFZb0QsT0FBTyxDQUFDQyxDQUFBQTtnQkFDbEJ0QixPQUFPb0IsUUFBUUcsU0FBUyxDQUFDRCxJQUFJbkQsS0FBSztZQUNwQztZQUVBLDZEQUE2RDtZQUM3RCxNQUFNNkQsZ0JBQWdCWixPQUFPRCxLQUFLLENBQUMsS0FBS3JDLE1BQU07WUFDOUNrQixPQUFPZ0MsZUFBZWpCLElBQUksQ0FBQzlDLFlBQVlhLE1BQU07UUFDL0MsSUFDQTtZQUFFb0IsU0FBUztRQUFJO0lBRW5CO0lBRUEzQixHQUFHLHVDQUF1QztRQUN4Q3RCLFdBQUd1QixNQUFNLENBQ1B2QixXQUFHd0IsUUFBUSxDQUFDVix3QkFBd0IsQ0FBQ1c7WUFDbkMsTUFBTXNDLE1BQU1DLElBQUFBLHVCQUFZLEVBQUN2QyxPQUFPVDtZQUNoQyxNQUFNaUQsUUFBUUYsSUFBSUcsS0FBSyxDQUFDO1lBQ3hCLE1BQU1DLFNBQVNGLEtBQUssQ0FBQyxFQUFFO1lBQ3ZCLE1BQU1jLGdCQUFnQlosT0FBT0QsS0FBSyxDQUFDO1lBRW5DLHFEQUFxRDtZQUNyRGxELFlBQVlvRCxPQUFPLENBQUMsQ0FBQ0MsS0FBS0c7Z0JBQ3hCekIsT0FBT2dDLGFBQWEsQ0FBQ1AsTUFBTSxFQUFFRixTQUFTLENBQUNELElBQUluRCxLQUFLO1lBQ2xEO1FBQ0YsSUFDQTtZQUFFK0IsU0FBUztRQUFJO0lBRW5CO0FBQ0Y7QUFFQTVCLFNBQVMscUVBQXFFO0lBQzVFOzs7OztHQUtDLEdBQ0RDLEdBQUcsZ0RBQWdEO1FBQ2pEdEIsV0FBR3VCLE1BQU0sQ0FDUHZCLFdBQUd3QixRQUFRLENBQUN4QixXQUFHYSxZQUFZLENBQUMsVUFBVSxVQUFVLGNBQWMsV0FBVyxXQUFXLENBQUN5QjtZQUNuRixNQUFNMEMsV0FBV0MsSUFBQUEsOEJBQW1CLEVBQUMzQztZQUVyQyxnQ0FBZ0M7WUFDaENTLE9BQU9pQyxVQUFVRSxPQUFPLENBQUMsSUFBSTdCLE9BQU8sQ0FBQyxDQUFDLEVBQUVmLFdBQVcsQ0FBQyxDQUFDO1lBRXJELHVCQUF1QjtZQUN2QlMsT0FBT2lDLFVBQVVFLE9BQU8sQ0FBQztZQUV6Qix5Q0FBeUM7WUFDekNuQyxPQUFPaUMsVUFBVUUsT0FBTyxDQUFDO1FBQzNCLElBQ0E7WUFBRWpDLFNBQVM7UUFBSTtJQUVuQjtJQUVBM0IsR0FBRyw2REFBNkQ7UUFDOUR0QixXQUFHdUIsTUFBTSxDQUNQdkIsV0FBR3dCLFFBQVEsQ0FBQ3hCLFdBQUdhLFlBQVksQ0FBQyxVQUFVLFVBQVUsZUFBZSxDQUFDeUI7WUFDOUQsTUFBTTZDLFlBQVlGLElBQUFBLDhCQUFtQixFQUFDM0M7WUFFdEMsZ0RBQWdEO1lBQ2hELE1BQU04QyxRQUFRQyxLQUFLQyxHQUFHO1lBQ3RCLE1BQU9ELEtBQUtDLEdBQUcsS0FBS0YsUUFBUSxFQUFHO1lBQzdCLFlBQVk7WUFDZDtZQUVBLE1BQU1HLFlBQVlOLElBQUFBLDhCQUFtQixFQUFDM0M7WUFFdEMsaURBQWlEO1lBQ2pELHFGQUFxRjtZQUNyRixJQUFJNkMsY0FBY0ksV0FBVztnQkFDM0IsbUNBQW1DO2dCQUNuQyxPQUFPO1lBQ1Q7WUFFQXhDLE9BQU9vQyxXQUFXakMsR0FBRyxDQUFDWSxJQUFJLENBQUN5QjtZQUMzQixPQUFPO1FBQ1QsSUFDQTtZQUFFdEMsU0FBUztRQUFHO0lBRWxCO0FBQ0YifQ==