3a91056baf3f22918b2905c85ac45339
"use strict";
// Mock supabase
jest.mock('../lib/supabase', ()=>({
        supabase: {
            from: jest.fn()
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _sectionsService = /*#__PURE__*/ _interop_require_wildcard(require("./sectionsService"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const { supabase } = require('../lib/supabase');
describe('Feature: destination-wedding-platform, Property 27: Reference Existence Validation', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    // Arbitrary for reference types
    const referenceTypeArbitrary = _fastcheck.constantFrom('event', 'activity', 'content_page', 'accommodation', 'location');
    // Arbitrary for valid reference
    const validReferenceArbitrary = _fastcheck.record({
        type: referenceTypeArbitrary,
        id: _fastcheck.uuid(),
        name: _fastcheck.string({
            minLength: 1,
            maxLength: 100
        })
    });
    // Arbitrary for array of references
    const referencesArrayArbitrary = _fastcheck.array(validReferenceArbitrary, {
        minLength: 1,
        maxLength: 10
    });
    it('should validate that all existing references return valid=true', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(referencesArrayArbitrary, async (references)=>{
            // Mock all references as existing
            const mockFrom = jest.fn().mockReturnValue({
                select: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        is: jest.fn().mockReturnValue({
                            single: jest.fn().mockResolvedValue({
                                data: {
                                    id: 'exists'
                                },
                                error: null
                            })
                        }),
                        single: jest.fn().mockResolvedValue({
                            data: {
                                id: 'exists'
                            },
                            error: null
                        })
                    }),
                    single: jest.fn().mockResolvedValue({
                        data: {
                            id: 'exists'
                        },
                        error: null
                    })
                })
            });
            supabase.from = mockFrom;
            const result = await _sectionsService.validateReferences(references);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.valid).toBe(true);
                expect(result.data.brokenReferences).toHaveLength(0);
            }
        }), {
            numRuns: 100
        });
    });
    it('should identify broken references when entities do not exist', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(referencesArrayArbitrary, async (references)=>{
            // Mock all references as NOT existing
            const mockFrom = jest.fn().mockReturnValue({
                select: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        is: jest.fn().mockReturnValue({
                            single: jest.fn().mockResolvedValue({
                                data: null,
                                error: null
                            })
                        }),
                        single: jest.fn().mockResolvedValue({
                            data: null,
                            error: null
                        })
                    }),
                    single: jest.fn().mockResolvedValue({
                        data: null,
                        error: null
                    })
                })
            });
            supabase.from = mockFrom;
            const result = await _sectionsService.validateReferences(references);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.valid).toBe(false);
                expect(result.data.brokenReferences).toHaveLength(references.length);
                // All references should be marked as broken
                references.forEach((ref)=>{
                    expect(result.data.brokenReferences).toContainEqual(expect.objectContaining({
                        id: ref.id,
                        type: ref.type
                    }));
                });
            }
        }), {
            numRuns: 100
        });
    });
    it('should handle mixed valid and invalid references correctly', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.array(validReferenceArbitrary, {
            minLength: 2,
            maxLength: 10
        }), _fastcheck.integer({
            min: 1,
            max: 9
        }), async (references, invalidIndex)=>{
            const actualInvalidIndex = invalidIndex % references.length;
            // Mock: first reference exists, others don't
            let callCount = 0;
            const mockFrom = jest.fn().mockReturnValue({
                select: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        is: jest.fn().mockReturnValue({
                            single: jest.fn().mockImplementation(()=>{
                                const exists = callCount !== actualInvalidIndex;
                                callCount++;
                                return Promise.resolve({
                                    data: exists ? {
                                        id: 'exists'
                                    } : null,
                                    error: null
                                });
                            })
                        }),
                        single: jest.fn().mockImplementation(()=>{
                            const exists = callCount !== actualInvalidIndex;
                            callCount++;
                            return Promise.resolve({
                                data: exists ? {
                                    id: 'exists'
                                } : null,
                                error: null
                            });
                        })
                    }),
                    single: jest.fn().mockImplementation(()=>{
                        const exists = callCount !== actualInvalidIndex;
                        callCount++;
                        return Promise.resolve({
                            data: exists ? {
                                id: 'exists'
                            } : null,
                            error: null
                        });
                    })
                })
            });
            supabase.from = mockFrom;
            const result = await _sectionsService.validateReferences(references);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.valid).toBe(false);
                expect(result.data.brokenReferences).toHaveLength(1);
                expect(result.data.brokenReferences[0]).toEqual(expect.objectContaining({
                    id: references[actualInvalidIndex].id,
                    type: references[actualInvalidIndex].type
                }));
            }
        }), {
            numRuns: 100
        });
    });
    it('should validate all reference types correctly', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(referenceTypeArbitrary, _fastcheck.uuid(), async (type, id)=>{
            const reference = {
                type,
                id,
                name: 'Test'
            };
            const mockFrom = jest.fn().mockReturnValue({
                select: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        is: jest.fn().mockReturnValue({
                            single: jest.fn().mockResolvedValue({
                                data: {
                                    id
                                },
                                error: null
                            })
                        }),
                        single: jest.fn().mockResolvedValue({
                            data: {
                                id
                            },
                            error: null
                        })
                    }),
                    single: jest.fn().mockResolvedValue({
                        data: {
                            id
                        },
                        error: null
                    })
                })
            });
            supabase.from = mockFrom;
            const result = await _sectionsService.validateReferences([
                reference
            ]);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.valid).toBe(true);
            }
            // Verify correct table was queried based on type
            const expectedTable = type === 'content_page' ? 'content_pages' : type === 'location' ? 'locations' : type + 's'; // activities, events, accommodations
            expect(mockFrom).toHaveBeenCalledWith(expectedTable);
        }), {
            numRuns: 100
        });
    });
    it('should handle empty reference arrays', async ()=>{
        const result = await _sectionsService.validateReferences([]);
        expect(result.success).toBe(true);
        if (result.success) {
            expect(result.data.valid).toBe(true);
            expect(result.data.brokenReferences).toHaveLength(0);
        }
    });
    it('should filter out soft-deleted entities', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(validReferenceArbitrary, async (reference)=>{
            // Mock entity exists but is soft-deleted (deleted_at is not null)
            const mockFrom = jest.fn().mockReturnValue({
                select: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        is: jest.fn().mockReturnValue({
                            single: jest.fn().mockResolvedValue({
                                data: null,
                                error: null
                            })
                        }),
                        single: jest.fn().mockResolvedValue({
                            data: null,
                            error: null
                        })
                    }),
                    single: jest.fn().mockResolvedValue({
                        data: null,
                        error: null
                    })
                })
            });
            supabase.from = mockFrom;
            const result = await _sectionsService.validateReferences([
                reference
            ]);
            expect(result.success).toBe(true);
            if (result.success) {
                // Soft-deleted entities should be treated as broken references
                expect(result.data.valid).toBe(false);
                expect(result.data.brokenReferences).toHaveLength(1);
            }
        }), {
            numRuns: 100
        });
    });
    it('should maintain reference order in broken references list', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(referencesArrayArbitrary, async (references)=>{
            // Mock all as broken
            const mockFrom = jest.fn().mockReturnValue({
                select: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        is: jest.fn().mockReturnValue({
                            single: jest.fn().mockResolvedValue({
                                data: null,
                                error: null
                            })
                        }),
                        single: jest.fn().mockResolvedValue({
                            data: null,
                            error: null
                        })
                    }),
                    single: jest.fn().mockResolvedValue({
                        data: null,
                        error: null
                    })
                })
            });
            supabase.from = mockFrom;
            const result = await _sectionsService.validateReferences(references);
            expect(result.success).toBe(true);
            if (result.success) {
                // Broken references should maintain input order
                expect(result.data.brokenReferences).toHaveLength(references.length);
                references.forEach((ref, index)=>{
                    expect(result.data.brokenReferences[index]).toEqual(expect.objectContaining({
                        id: ref.id,
                        type: ref.type
                    }));
                });
            }
        }), {
            numRuns: 100
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvc2VjdGlvbnNTZXJ2aWNlLnJlZmVyZW5jZUV4aXN0ZW5jZVZhbGlkYXRpb24ucHJvcGVydHkudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmYyBmcm9tICdmYXN0LWNoZWNrJztcbmltcG9ydCAqIGFzIHNlY3Rpb25zU2VydmljZSBmcm9tICcuL3NlY3Rpb25zU2VydmljZSc7XG5cbi8vIE1vY2sgc3VwYWJhc2Vcbmplc3QubW9jaygnLi4vbGliL3N1cGFiYXNlJywgKCkgPT4gKHtcbiAgc3VwYWJhc2U6IHtcbiAgICBmcm9tOiBqZXN0LmZuKCksXG4gIH0sXG59KSk7XG5cbmNvbnN0IHsgc3VwYWJhc2UgfSA9IHJlcXVpcmUoJy4uL2xpYi9zdXBhYmFzZScpO1xuXG5kZXNjcmliZSgnRmVhdHVyZTogZGVzdGluYXRpb24td2VkZGluZy1wbGF0Zm9ybSwgUHJvcGVydHkgMjc6IFJlZmVyZW5jZSBFeGlzdGVuY2UgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIC8vIEFyYml0cmFyeSBmb3IgcmVmZXJlbmNlIHR5cGVzXG4gIGNvbnN0IHJlZmVyZW5jZVR5cGVBcmJpdHJhcnkgPSBmYy5jb25zdGFudEZyb20oJ2V2ZW50JywgJ2FjdGl2aXR5JywgJ2NvbnRlbnRfcGFnZScsICdhY2NvbW1vZGF0aW9uJywgJ2xvY2F0aW9uJyk7XG5cbiAgLy8gQXJiaXRyYXJ5IGZvciB2YWxpZCByZWZlcmVuY2VcbiAgY29uc3QgdmFsaWRSZWZlcmVuY2VBcmJpdHJhcnkgPSBmYy5yZWNvcmQoe1xuICAgIHR5cGU6IHJlZmVyZW5jZVR5cGVBcmJpdHJhcnksXG4gICAgaWQ6IGZjLnV1aWQoKSxcbiAgICBuYW1lOiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTAwIH0pLFxuICB9KTtcblxuICAvLyBBcmJpdHJhcnkgZm9yIGFycmF5IG9mIHJlZmVyZW5jZXNcbiAgY29uc3QgcmVmZXJlbmNlc0FycmF5QXJiaXRyYXJ5ID0gZmMuYXJyYXkodmFsaWRSZWZlcmVuY2VBcmJpdHJhcnksIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwIH0pO1xuXG4gIGl0KCdzaG91bGQgdmFsaWRhdGUgdGhhdCBhbGwgZXhpc3RpbmcgcmVmZXJlbmNlcyByZXR1cm4gdmFsaWQ9dHJ1ZScsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KHJlZmVyZW5jZXNBcnJheUFyYml0cmFyeSwgYXN5bmMgKHJlZmVyZW5jZXMpID0+IHtcbiAgICAgICAgLy8gTW9jayBhbGwgcmVmZXJlbmNlcyBhcyBleGlzdGluZ1xuICAgICAgICBjb25zdCBtb2NrRnJvbSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgIGlzOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRhdGE6IHsgaWQ6ICdleGlzdHMnIH0sIGVycm9yOiBudWxsIH0pLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBkYXRhOiB7IGlkOiAnZXhpc3RzJyB9LCBlcnJvcjogbnVsbCB9KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBkYXRhOiB7IGlkOiAnZXhpc3RzJyB9LCBlcnJvcjogbnVsbCB9KSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIHN1cGFiYXNlLmZyb20gPSBtb2NrRnJvbTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZWN0aW9uc1NlcnZpY2UudmFsaWRhdGVSZWZlcmVuY2VzKHJlZmVyZW5jZXMpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnZhbGlkKS50b0JlKHRydWUpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5icm9rZW5SZWZlcmVuY2VzKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgaWRlbnRpZnkgYnJva2VuIHJlZmVyZW5jZXMgd2hlbiBlbnRpdGllcyBkbyBub3QgZXhpc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShyZWZlcmVuY2VzQXJyYXlBcmJpdHJhcnksIGFzeW5jIChyZWZlcmVuY2VzKSA9PiB7XG4gICAgICAgIC8vIE1vY2sgYWxsIHJlZmVyZW5jZXMgYXMgTk9UIGV4aXN0aW5nXG4gICAgICAgIGNvbnN0IG1vY2tGcm9tID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgaXM6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZGF0YTogbnVsbCwgZXJyb3I6IG51bGwgfSksXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH0pLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH0pLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICAgICAgc3VwYWJhc2UuZnJvbSA9IG1vY2tGcm9tO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlY3Rpb25zU2VydmljZS52YWxpZGF0ZVJlZmVyZW5jZXMocmVmZXJlbmNlcyk7XG5cbiAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5icm9rZW5SZWZlcmVuY2VzKS50b0hhdmVMZW5ndGgocmVmZXJlbmNlcy5sZW5ndGgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFsbCByZWZlcmVuY2VzIHNob3VsZCBiZSBtYXJrZWQgYXMgYnJva2VuXG4gICAgICAgICAgcmVmZXJlbmNlcy5mb3JFYWNoKChyZWYpID0+IHtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5icm9rZW5SZWZlcmVuY2VzKS50b0NvbnRhaW5FcXVhbChcbiAgICAgICAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoeyBpZDogcmVmLmlkLCB0eXBlOiByZWYudHlwZSB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBoYW5kbGUgbWl4ZWQgdmFsaWQgYW5kIGludmFsaWQgcmVmZXJlbmNlcyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMuYXJyYXkodmFsaWRSZWZlcmVuY2VBcmJpdHJhcnksIHsgbWluTGVuZ3RoOiAyLCBtYXhMZW5ndGg6IDEwIH0pLFxuICAgICAgICBmYy5pbnRlZ2VyKHsgbWluOiAxLCBtYXg6IDkgfSksXG4gICAgICAgIGFzeW5jIChyZWZlcmVuY2VzLCBpbnZhbGlkSW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBhY3R1YWxJbnZhbGlkSW5kZXggPSBpbnZhbGlkSW5kZXggJSByZWZlcmVuY2VzLmxlbmd0aDtcblxuICAgICAgICAgIC8vIE1vY2s6IGZpcnN0IHJlZmVyZW5jZSBleGlzdHMsIG90aGVycyBkb24ndFxuICAgICAgICAgIGxldCBjYWxsQ291bnQgPSAwO1xuICAgICAgICAgIGNvbnN0IG1vY2tGcm9tID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgaXM6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RzID0gY2FsbENvdW50ICE9PSBhY3R1YWxJbnZhbGlkSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YTogZXhpc3RzID8geyBpZDogJ2V4aXN0cycgfSA6IG51bGwsIFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsIFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBleGlzdHMgPSBjYWxsQ291bnQgIT09IGFjdHVhbEludmFsaWRJbmRleDtcbiAgICAgICAgICAgICAgICAgIGNhbGxDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBleGlzdHMgPyB7IGlkOiAnZXhpc3RzJyB9IDogbnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsIFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0cyA9IGNhbGxDb3VudCAhPT0gYWN0dWFsSW52YWxpZEluZGV4O1xuICAgICAgICAgICAgICAgIGNhbGxDb3VudCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBcbiAgICAgICAgICAgICAgICAgIGRhdGE6IGV4aXN0cyA/IHsgaWQ6ICdleGlzdHMnIH0gOiBudWxsLCBcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsIFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN1cGFiYXNlLmZyb20gPSBtb2NrRnJvbTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlY3Rpb25zU2VydmljZS52YWxpZGF0ZVJlZmVyZW5jZXMocmVmZXJlbmNlcyk7XG5cbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmJyb2tlblJlZmVyZW5jZXMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5icm9rZW5SZWZlcmVuY2VzWzBdKS50b0VxdWFsKFxuICAgICAgICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgICAgICAgaWQ6IHJlZmVyZW5jZXNbYWN0dWFsSW52YWxpZEluZGV4XS5pZCxcbiAgICAgICAgICAgICAgICB0eXBlOiByZWZlcmVuY2VzW2FjdHVhbEludmFsaWRJbmRleF0udHlwZSxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgdmFsaWRhdGUgYWxsIHJlZmVyZW5jZSB0eXBlcyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShyZWZlcmVuY2VUeXBlQXJiaXRyYXJ5LCBmYy51dWlkKCksIGFzeW5jICh0eXBlLCBpZCkgPT4ge1xuICAgICAgICBjb25zdCByZWZlcmVuY2UgPSB7IHR5cGUsIGlkLCBuYW1lOiAnVGVzdCcgfTtcblxuICAgICAgICBjb25zdCBtb2NrRnJvbSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgIGlzOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRhdGE6IHsgaWQgfSwgZXJyb3I6IG51bGwgfSksXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRhdGE6IHsgaWQgfSwgZXJyb3I6IG51bGwgfSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZGF0YTogeyBpZCB9LCBlcnJvcjogbnVsbCB9KSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIHN1cGFiYXNlLmZyb20gPSBtb2NrRnJvbTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZWN0aW9uc1NlcnZpY2UudmFsaWRhdGVSZWZlcmVuY2VzKFtyZWZlcmVuY2VdKTtcblxuICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS52YWxpZCkudG9CZSh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZlcmlmeSBjb3JyZWN0IHRhYmxlIHdhcyBxdWVyaWVkIGJhc2VkIG9uIHR5cGVcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRUYWJsZSA9IHR5cGUgPT09ICdjb250ZW50X3BhZ2UnID8gJ2NvbnRlbnRfcGFnZXMnIDogXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPT09ICdsb2NhdGlvbicgPyAnbG9jYXRpb25zJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgKyAncyc7IC8vIGFjdGl2aXRpZXMsIGV2ZW50cywgYWNjb21tb2RhdGlvbnNcbiAgICAgICAgZXhwZWN0KG1vY2tGcm9tKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3RlZFRhYmxlKTtcbiAgICAgIH0pLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgaGFuZGxlIGVtcHR5IHJlZmVyZW5jZSBhcnJheXMnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VjdGlvbnNTZXJ2aWNlLnZhbGlkYXRlUmVmZXJlbmNlcyhbXSk7XG5cbiAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICBleHBlY3QocmVzdWx0LmRhdGEudmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmRhdGEuYnJva2VuUmVmZXJlbmNlcykudG9IYXZlTGVuZ3RoKDApO1xuICAgIH1cbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBmaWx0ZXIgb3V0IHNvZnQtZGVsZXRlZCBlbnRpdGllcycsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KHZhbGlkUmVmZXJlbmNlQXJiaXRyYXJ5LCBhc3luYyAocmVmZXJlbmNlKSA9PiB7XG4gICAgICAgIC8vIE1vY2sgZW50aXR5IGV4aXN0cyBidXQgaXMgc29mdC1kZWxldGVkIChkZWxldGVkX2F0IGlzIG5vdCBudWxsKVxuICAgICAgICBjb25zdCBtb2NrRnJvbSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgIGlzOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH0pLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBkYXRhOiBudWxsLCBlcnJvcjogbnVsbCB9KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBkYXRhOiBudWxsLCBlcnJvcjogbnVsbCB9KSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIHN1cGFiYXNlLmZyb20gPSBtb2NrRnJvbTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZWN0aW9uc1NlcnZpY2UudmFsaWRhdGVSZWZlcmVuY2VzKFtyZWZlcmVuY2VdKTtcblxuICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIC8vIFNvZnQtZGVsZXRlZCBlbnRpdGllcyBzaG91bGQgYmUgdHJlYXRlZCBhcyBicm9rZW4gcmVmZXJlbmNlc1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS52YWxpZCkudG9CZShmYWxzZSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmJyb2tlblJlZmVyZW5jZXMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBtYWludGFpbiByZWZlcmVuY2Ugb3JkZXIgaW4gYnJva2VuIHJlZmVyZW5jZXMgbGlzdCcsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KHJlZmVyZW5jZXNBcnJheUFyYml0cmFyeSwgYXN5bmMgKHJlZmVyZW5jZXMpID0+IHtcbiAgICAgICAgLy8gTW9jayBhbGwgYXMgYnJva2VuXG4gICAgICAgIGNvbnN0IG1vY2tGcm9tID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgaXM6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZGF0YTogbnVsbCwgZXJyb3I6IG51bGwgfSksXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH0pLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH0pLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICAgICAgc3VwYWJhc2UuZnJvbSA9IG1vY2tGcm9tO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlY3Rpb25zU2VydmljZS52YWxpZGF0ZVJlZmVyZW5jZXMocmVmZXJlbmNlcyk7XG5cbiAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAvLyBCcm9rZW4gcmVmZXJlbmNlcyBzaG91bGQgbWFpbnRhaW4gaW5wdXQgb3JkZXJcbiAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuYnJva2VuUmVmZXJlbmNlcykudG9IYXZlTGVuZ3RoKHJlZmVyZW5jZXMubGVuZ3RoKTtcbiAgICAgICAgICByZWZlcmVuY2VzLmZvckVhY2goKHJlZiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5icm9rZW5SZWZlcmVuY2VzW2luZGV4XSkudG9FcXVhbChcbiAgICAgICAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoeyBpZDogcmVmLmlkLCB0eXBlOiByZWYudHlwZSB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsInN1cGFiYXNlIiwiZnJvbSIsImZuIiwicmVxdWlyZSIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJyZWZlcmVuY2VUeXBlQXJiaXRyYXJ5IiwiZmMiLCJjb25zdGFudEZyb20iLCJ2YWxpZFJlZmVyZW5jZUFyYml0cmFyeSIsInJlY29yZCIsInR5cGUiLCJpZCIsInV1aWQiLCJuYW1lIiwic3RyaW5nIiwibWluTGVuZ3RoIiwibWF4TGVuZ3RoIiwicmVmZXJlbmNlc0FycmF5QXJiaXRyYXJ5IiwiYXJyYXkiLCJpdCIsImFzc2VydCIsImFzeW5jUHJvcGVydHkiLCJyZWZlcmVuY2VzIiwibW9ja0Zyb20iLCJtb2NrUmV0dXJuVmFsdWUiLCJzZWxlY3QiLCJlcSIsImlzIiwic2luZ2xlIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJkYXRhIiwiZXJyb3IiLCJyZXN1bHQiLCJzZWN0aW9uc1NlcnZpY2UiLCJ2YWxpZGF0ZVJlZmVyZW5jZXMiLCJleHBlY3QiLCJzdWNjZXNzIiwidG9CZSIsInZhbGlkIiwiYnJva2VuUmVmZXJlbmNlcyIsInRvSGF2ZUxlbmd0aCIsIm51bVJ1bnMiLCJsZW5ndGgiLCJmb3JFYWNoIiwicmVmIiwidG9Db250YWluRXF1YWwiLCJvYmplY3RDb250YWluaW5nIiwiaW50ZWdlciIsIm1pbiIsIm1heCIsImludmFsaWRJbmRleCIsImFjdHVhbEludmFsaWRJbmRleCIsImNhbGxDb3VudCIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsImV4aXN0cyIsIlByb21pc2UiLCJyZXNvbHZlIiwidG9FcXVhbCIsInJlZmVyZW5jZSIsImV4cGVjdGVkVGFibGUiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsImluZGV4Il0sIm1hcHBpbmdzIjoiO0FBR0EsZ0JBQWdCO0FBQ2hCQSxLQUFLQyxJQUFJLENBQUMsbUJBQW1CLElBQU8sQ0FBQTtRQUNsQ0MsVUFBVTtZQUNSQyxNQUFNSCxLQUFLSSxFQUFFO1FBQ2Y7SUFDRixDQUFBOzs7O21FQVJvQjt5RUFDYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBU2pDLE1BQU0sRUFBRUYsUUFBUSxFQUFFLEdBQUdHLFFBQVE7QUFFN0JDLFNBQVMsc0ZBQXNGO0lBQzdGQyxXQUFXO1FBQ1RQLEtBQUtRLGFBQWE7SUFDcEI7SUFFQSxnQ0FBZ0M7SUFDaEMsTUFBTUMseUJBQXlCQyxXQUFHQyxZQUFZLENBQUMsU0FBUyxZQUFZLGdCQUFnQixpQkFBaUI7SUFFckcsZ0NBQWdDO0lBQ2hDLE1BQU1DLDBCQUEwQkYsV0FBR0csTUFBTSxDQUFDO1FBQ3hDQyxNQUFNTDtRQUNOTSxJQUFJTCxXQUFHTSxJQUFJO1FBQ1hDLE1BQU1QLFdBQUdRLE1BQU0sQ0FBQztZQUFFQyxXQUFXO1lBQUdDLFdBQVc7UUFBSTtJQUNqRDtJQUVBLG9DQUFvQztJQUNwQyxNQUFNQywyQkFBMkJYLFdBQUdZLEtBQUssQ0FBQ1YseUJBQXlCO1FBQUVPLFdBQVc7UUFBR0MsV0FBVztJQUFHO0lBRWpHRyxHQUFHLGtFQUFrRTtRQUNuRSxNQUFNYixXQUFHYyxNQUFNLENBQ2JkLFdBQUdlLGFBQWEsQ0FBQ0osMEJBQTBCLE9BQU9LO1lBQ2hELGtDQUFrQztZQUNsQyxNQUFNQyxXQUFXM0IsS0FBS0ksRUFBRSxHQUFHd0IsZUFB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