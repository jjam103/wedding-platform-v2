{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/services/sectionsService.referenceExistenceValidation.property.test.ts"],"sourcesContent":["import * as fc from 'fast-check';\nimport * as sectionsService from './sectionsService';\n\n// Mock supabase\njest.mock('../lib/supabase', () => ({\n  supabase: {\n    from: jest.fn(),\n  },\n}));\n\nconst { supabase } = require('../lib/supabase');\n\ndescribe('Feature: destination-wedding-platform, Property 27: Reference Existence Validation', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  // Arbitrary for reference types\n  const referenceTypeArbitrary = fc.constantFrom('event', 'activity', 'content_page', 'accommodation', 'location');\n\n  // Arbitrary for valid reference\n  const validReferenceArbitrary = fc.record({\n    type: referenceTypeArbitrary,\n    id: fc.uuid(),\n    name: fc.string({ minLength: 1, maxLength: 100 }),\n  });\n\n  // Arbitrary for array of references\n  const referencesArrayArbitrary = fc.array(validReferenceArbitrary, { minLength: 1, maxLength: 10 });\n\n  it('should validate that all existing references return valid=true', async () => {\n    await fc.assert(\n      fc.asyncProperty(referencesArrayArbitrary, async (references) => {\n        // Mock all references as existing\n        const mockFrom = jest.fn().mockReturnValue({\n          select: jest.fn().mockReturnValue({\n            eq: jest.fn().mockReturnValue({\n              is: jest.fn().mockReturnValue({\n                single: jest.fn().mockResolvedValue({ data: { id: 'exists' }, error: null }),\n              }),\n              single: jest.fn().mockResolvedValue({ data: { id: 'exists' }, error: null }),\n            }),\n            single: jest.fn().mockResolvedValue({ data: { id: 'exists' }, error: null }),\n          }),\n        });\n        supabase.from = mockFrom;\n\n        const result = await sectionsService.validateReferences(references);\n\n        expect(result.success).toBe(true);\n        if (result.success) {\n          expect(result.data.valid).toBe(true);\n          expect(result.data.brokenReferences).toHaveLength(0);\n        }\n      }),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should identify broken references when entities do not exist', async () => {\n    await fc.assert(\n      fc.asyncProperty(referencesArrayArbitrary, async (references) => {\n        // Mock all references as NOT existing\n        const mockFrom = jest.fn().mockReturnValue({\n          select: jest.fn().mockReturnValue({\n            eq: jest.fn().mockReturnValue({\n              is: jest.fn().mockReturnValue({\n                single: jest.fn().mockResolvedValue({ data: null, error: null }),\n              }),\n              single: jest.fn().mockResolvedValue({ data: null, error: null }),\n            }),\n            single: jest.fn().mockResolvedValue({ data: null, error: null }),\n          }),\n        });\n        supabase.from = mockFrom;\n\n        const result = await sectionsService.validateReferences(references);\n\n        expect(result.success).toBe(true);\n        if (result.success) {\n          expect(result.data.valid).toBe(false);\n          expect(result.data.brokenReferences).toHaveLength(references.length);\n          \n          // All references should be marked as broken\n          references.forEach((ref) => {\n            expect(result.data.brokenReferences).toContainEqual(\n              expect.objectContaining({ id: ref.id, type: ref.type })\n            );\n          });\n        }\n      }),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should handle mixed valid and invalid references correctly', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.array(validReferenceArbitrary, { minLength: 2, maxLength: 10 }),\n        fc.integer({ min: 1, max: 9 }),\n        async (references, invalidIndex) => {\n          const actualInvalidIndex = invalidIndex % references.length;\n\n          // Mock: first reference exists, others don't\n          let callCount = 0;\n          const mockFrom = jest.fn().mockReturnValue({\n            select: jest.fn().mockReturnValue({\n              eq: jest.fn().mockReturnValue({\n                is: jest.fn().mockReturnValue({\n                  single: jest.fn().mockImplementation(() => {\n                    const exists = callCount !== actualInvalidIndex;\n                    callCount++;\n                    return Promise.resolve({ \n                      data: exists ? { id: 'exists' } : null, \n                      error: null \n                    });\n                  }),\n                }),\n                single: jest.fn().mockImplementation(() => {\n                  const exists = callCount !== actualInvalidIndex;\n                  callCount++;\n                  return Promise.resolve({ \n                    data: exists ? { id: 'exists' } : null, \n                    error: null \n                  });\n                }),\n              }),\n              single: jest.fn().mockImplementation(() => {\n                const exists = callCount !== actualInvalidIndex;\n                callCount++;\n                return Promise.resolve({ \n                  data: exists ? { id: 'exists' } : null, \n                  error: null \n                });\n              }),\n            }),\n          });\n          supabase.from = mockFrom;\n\n          const result = await sectionsService.validateReferences(references);\n\n          expect(result.success).toBe(true);\n          if (result.success) {\n            expect(result.data.valid).toBe(false);\n            expect(result.data.brokenReferences).toHaveLength(1);\n            expect(result.data.brokenReferences[0]).toEqual(\n              expect.objectContaining({\n                id: references[actualInvalidIndex].id,\n                type: references[actualInvalidIndex].type,\n              })\n            );\n          }\n        }\n      ),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should validate all reference types correctly', async () => {\n    await fc.assert(\n      fc.asyncProperty(referenceTypeArbitrary, fc.uuid(), async (type, id) => {\n        const reference = { type, id, name: 'Test' };\n\n        const mockFrom = jest.fn().mockReturnValue({\n          select: jest.fn().mockReturnValue({\n            eq: jest.fn().mockReturnValue({\n              is: jest.fn().mockReturnValue({\n                single: jest.fn().mockResolvedValue({ data: { id }, error: null }),\n              }),\n              single: jest.fn().mockResolvedValue({ data: { id }, error: null }),\n            }),\n            single: jest.fn().mockResolvedValue({ data: { id }, error: null }),\n          }),\n        });\n        supabase.from = mockFrom;\n\n        const result = await sectionsService.validateReferences([reference]);\n\n        expect(result.success).toBe(true);\n        if (result.success) {\n          expect(result.data.valid).toBe(true);\n        }\n\n        // Verify correct table was queried based on type\n        const expectedTable = type === 'content_page' ? 'content_pages' : \n                             type === 'location' ? 'locations' :\n                             type + 's'; // activities, events, accommodations\n        expect(mockFrom).toHaveBeenCalledWith(expectedTable);\n      }),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should handle empty reference arrays', async () => {\n    const result = await sectionsService.validateReferences([]);\n\n    expect(result.success).toBe(true);\n    if (result.success) {\n      expect(result.data.valid).toBe(true);\n      expect(result.data.brokenReferences).toHaveLength(0);\n    }\n  });\n\n  it('should filter out soft-deleted entities', async () => {\n    await fc.assert(\n      fc.asyncProperty(validReferenceArbitrary, async (reference) => {\n        // Mock entity exists but is soft-deleted (deleted_at is not null)\n        const mockFrom = jest.fn().mockReturnValue({\n          select: jest.fn().mockReturnValue({\n            eq: jest.fn().mockReturnValue({\n              is: jest.fn().mockReturnValue({\n                single: jest.fn().mockResolvedValue({ data: null, error: null }),\n              }),\n              single: jest.fn().mockResolvedValue({ data: null, error: null }),\n            }),\n            single: jest.fn().mockResolvedValue({ data: null, error: null }),\n          }),\n        });\n        supabase.from = mockFrom;\n\n        const result = await sectionsService.validateReferences([reference]);\n\n        expect(result.success).toBe(true);\n        if (result.success) {\n          // Soft-deleted entities should be treated as broken references\n          expect(result.data.valid).toBe(false);\n          expect(result.data.brokenReferences).toHaveLength(1);\n        }\n      }),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should maintain reference order in broken references list', async () => {\n    await fc.assert(\n      fc.asyncProperty(referencesArrayArbitrary, async (references) => {\n        // Mock all as broken\n        const mockFrom = jest.fn().mockReturnValue({\n          select: jest.fn().mockReturnValue({\n            eq: jest.fn().mockReturnValue({\n              is: jest.fn().mockReturnValue({\n                single: jest.fn().mockResolvedValue({ data: null, error: null }),\n              }),\n              single: jest.fn().mockResolvedValue({ data: null, error: null }),\n            }),\n            single: jest.fn().mockResolvedValue({ data: null, error: null }),\n          }),\n        });\n        supabase.from = mockFrom;\n\n        const result = await sectionsService.validateReferences(references);\n\n        expect(result.success).toBe(true);\n        if (result.success) {\n          // Broken references should maintain input order\n          expect(result.data.brokenReferences).toHaveLength(references.length);\n          references.forEach((ref, index) => {\n            expect(result.data.brokenReferences[index]).toEqual(\n              expect.objectContaining({ id: ref.id, type: ref.type })\n            );\n          });\n        }\n      }),\n      { numRuns: 100 }\n    );\n  });\n});\n"],"names":["jest","mock","supabase","from","fn","require","describe","beforeEach","clearAllMocks","referenceTypeArbitrary","fc","constantFrom","validReferenceArbitrary","record","type","id","uuid","name","string","minLength","maxLength","referencesArrayArbitrary","array","it","assert","asyncProperty","references","mockFrom","mockReturnValue","select","eq","is","single","mockResolvedValue","data","error","result","sectionsService","validateReferences","expect","success","toBe","valid","brokenReferences","toHaveLength","numRuns","length","forEach","ref","toContainEqual","objectContaining","integer","min","max","invalidIndex","actualInvalidIndex","callCount","mockImplementation","exists","Promise","resolve","toEqual","reference","expectedTable","toHaveBeenCalledWith","index"],"mappings":"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"}