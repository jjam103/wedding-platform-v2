07583745a1bf8a2bacf192df23a6f2f8
/**
 * Property-Based Tests for Slug Conflict Resolution
 * 
 * Feature: destination-wedding-platform
 * Property 20: Slug Conflict Resolution
 * Validates: Requirements 31.3
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _slugs = require("../utils/slugs");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('Feature: destination-wedding-platform, Property 20: Slug Conflict Resolution', ()=>{
    describe('slug conflict resolution properties', ()=>{
        it('should always produce a valid slug format after conflict resolution', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.string({
                minLength: 1,
                maxLength: 50
            }).map(_slugs.generateSlug).filter((s)=>s.length > 0), _fastcheck.integer({
                min: 2,
                max: 100
            }), (baseSlug, counter)=>{
                const resolvedSlug = `${baseSlug}-${counter}`;
                // Should only contain lowercase letters, numbers, and hyphens
                expect(resolvedSlug).toMatch(/^[a-z0-9-]+$/);
                // Should not have consecutive hyphens
                expect(resolvedSlug).not.toContain('--');
                // Should not start or end with hyphen
                expect(resolvedSlug).not.toMatch(/^-/);
                expect(resolvedSlug).not.toMatch(/-$/);
            }), {
                numRuns: 100
            });
        });
        it('should maintain slug uniqueness across multiple conflicts', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.string({
                minLength: 1,
                maxLength: 50
            }).map(_slugs.generateSlug).filter((s)=>s.length > 0), _fastcheck.uniqueArray(_fastcheck.integer({
                min: 2,
                max: 20
            }), {
                minLength: 1,
                maxLength: 10
            }), (baseSlug, counters)=>{
                const resolvedSlugs = counters.map((counter)=>`${baseSlug}-${counter}`);
                // All resolved slugs should be unique
                const uniqueSlugs = new Set(resolvedSlugs);
                expect(uniqueSlugs.size).toBe(resolvedSlugs.length);
            }), {
                numRuns: 100
            });
        });
        it('should preserve the base slug in the resolved slug', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.string({
                minLength: 1,
                maxLength: 50
            }).map(_slugs.generateSlug).filter((s)=>s.length > 0), _fastcheck.integer({
                min: 2,
                max: 1000
            }), (baseSlug, counter)=>{
                const resolvedSlug = `${baseSlug}-${counter}`;
                // Resolved slug should start with base slug
                expect(resolvedSlug.startsWith(baseSlug)).toBe(true);
                // Should be followed by hyphen and number
                expect(resolvedSlug.substring(baseSlug.length)).toMatch(/^-\d+$/);
            }), {
                numRuns: 100
            });
        });
        it('should append -2 when base slug exists', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.string({
                minLength: 1,
                maxLength: 50
            }).map(_slugs.generateSlug).filter((s)=>s.length > 0), (baseSlug)=>{
                const existingSlugs = [
                    baseSlug
                ];
                const uniqueSlug = (0, _slugs.makeUniqueSlug)(baseSlug, existingSlugs);
                expect(uniqueSlug).toBe(`${baseSlug}-2`);
            }), {
                numRuns: 100
            });
        });
        it('should increment counter until unique slug is found', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.string({
                minLength: 1,
                maxLength: 50
            }).map(_slugs.generateSlug).filter((s)=>s.length > 0), _fastcheck.integer({
                min: 1,
                max: 10
            }), (baseSlug, maxCounter)=>{
                // Create existing slugs: base, base-2, base-3, ..., base-maxCounter
                const existingSlugs = [
                    baseSlug
                ];
                for(let i = 2; i <= maxCounter; i++){
                    existingSlugs.push(`${baseSlug}-${i}`);
                }
                const uniqueSlug = (0, _slugs.makeUniqueSlug)(baseSlug, existingSlugs);
                // Should be base-{maxCounter+1}
                expect(uniqueSlug).toBe(`${baseSlug}-${maxCounter + 1}`);
                // Should not be in existing slugs
                expect(existingSlugs).not.toContain(uniqueSlug);
            }), {
                numRuns: 100
            });
        });
        it('should handle gaps in counter sequence', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.string({
                minLength: 1,
                maxLength: 50
            }).map(_slugs.generateSlug).filter((s)=>s.length > 0), (baseSlug)=>{
                // Create existing slugs with gaps: base, base-2, base-4 (missing base-3)
                const existingSlugs = [
                    baseSlug,
                    `${baseSlug}-2`,
                    `${baseSlug}-4`
                ];
                const uniqueSlug = (0, _slugs.makeUniqueSlug)(baseSlug, existingSlugs);
                // Should find base-3 (the first available)
                // Note: Our implementation increments from 2, so it will find base-3
                expect(uniqueSlug).toBe(`${baseSlug}-3`);
                expect(existingSlugs).not.toContain(uniqueSlug);
            }), {
                numRuns: 100
            });
        });
        it('should preserve base slug structure when resolving conflicts', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.string({
                minLength: 1,
                maxLength: 50
            }).map(_slugs.generateSlug).filter((s)=>s.length > 0), _fastcheck.array(_fastcheck.string({
                minLength: 1,
                maxLength: 50
            }).map(_slugs.generateSlug), {
                maxLength: 20
            }), (baseSlug, existingSlugs)=>{
                const uniqueSlug = (0, _slugs.makeUniqueSlug)(baseSlug, existingSlugs);
                // Unique slug should start with base slug or be the base slug itself
                expect(uniqueSlug.startsWith(baseSlug) || uniqueSlug === baseSlug).toBe(true);
            }), {
                numRuns: 100
            });
        });
        it('should always produce a slug not in the existing slugs list', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.string({
                minLength: 1,
                maxLength: 50
            }).map(_slugs.generateSlug).filter((s)=>s.length > 0), _fastcheck.array(_fastcheck.string({
                minLength: 1,
                maxLength: 50
            }).map(_slugs.generateSlug), {
                maxLength: 50
            }), (baseSlug, existingSlugs)=>{
                const uniqueSlug = (0, _slugs.makeUniqueSlug)(baseSlug, existingSlugs);
                expect(existingSlugs).not.toContain(uniqueSlug);
            }), {
                numRuns: 100
            });
        });
        it('should handle empty existing slugs list', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.string({
                minLength: 1,
                maxLength: 50
            }).map(_slugs.generateSlug).filter((s)=>s.length > 0), (baseSlug)=>{
                const uniqueSlug = (0, _slugs.makeUniqueSlug)(baseSlug, []);
                // Should return base slug unchanged
                expect(uniqueSlug).toBe(baseSlug);
            }), {
                numRuns: 100
            });
        });
        it('should handle large counter values', ()=>{
            _fastcheck.assert(_fastcheck.property(_fastcheck.string({
                minLength: 1,
                maxLength: 50
            }).map(_slugs.generateSlug).filter((s)=>s.length > 0), _fastcheck.integer({
                min: 100,
                max: 1000
            }), (baseSlug, largeCounter)=>{
                // Create existing slugs up to largeCounter
                const existingSlugs = [
                    baseSlug
                ];
                for(let i = 2; i <= largeCounter; i++){
                    existingSlugs.push(`${baseSlug}-${i}`);
                }
                const uniqueSlug = (0, _slugs.makeUniqueSlug)(baseSlug, existingSlugs);
                // Should be base-{largeCounter+1}
                expect(uniqueSlug).toBe(`${baseSlug}-${largeCounter + 1}`);
                expect(existingSlugs).not.toContain(uniqueSlug);
            }), {
                numRuns: 20
            } // Fewer runs for performance
            );
        });
    });
    describe('conflict resolution examples', ()=>{
        it('should handle basic conflict: slug exists', ()=>{
            const baseSlug = 'test-page';
            const existingSlugs = [
                'test-page'
            ];
            const uniqueSlug = (0, _slugs.makeUniqueSlug)(baseSlug, existingSlugs);
            expect(uniqueSlug).toBe('test-page-2');
        });
        it('should handle multiple conflicts: slug and slug-2 exist', ()=>{
            const baseSlug = 'test-page';
            const existingSlugs = [
                'test-page',
                'test-page-2'
            ];
            const uniqueSlug = (0, _slugs.makeUniqueSlug)(baseSlug, existingSlugs);
            expect(uniqueSlug).toBe('test-page-3');
        });
        it('should handle sequential conflicts', ()=>{
            const baseSlug = 'popular-page';
            const existingSlugs = [
                'popular-page',
                'popular-page-2',
                'popular-page-3'
            ];
            const uniqueSlug = (0, _slugs.makeUniqueSlug)(baseSlug, existingSlugs);
            expect(uniqueSlug).toBe('popular-page-4');
        });
        it('should return base slug when no conflicts', ()=>{
            const baseSlug = 'unique-page';
            const existingSlugs = [
                'other-page',
                'another-page'
            ];
            const uniqueSlug = (0, _slugs.makeUniqueSlug)(baseSlug, existingSlugs);
            expect(uniqueSlug).toBe('unique-page');
        });
        it('should handle gaps in sequence', ()=>{
            const baseSlug = 'test';
            const existingSlugs = [
                'test',
                'test-2',
                'test-4'
            ]; // Missing test-3
            const uniqueSlug = (0, _slugs.makeUniqueSlug)(baseSlug, existingSlugs);
            expect(uniqueSlug).toBe('test-3');
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvY29udGVudFBhZ2VzU2VydmljZS5zbHVnQ29uZmxpY3RSZXNvbHV0aW9uLnByb3BlcnR5LnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQcm9wZXJ0eS1CYXNlZCBUZXN0cyBmb3IgU2x1ZyBDb25mbGljdCBSZXNvbHV0aW9uXG4gKiBcbiAqIEZlYXR1cmU6IGRlc3RpbmF0aW9uLXdlZGRpbmctcGxhdGZvcm1cbiAqIFByb3BlcnR5IDIwOiBTbHVnIENvbmZsaWN0IFJlc29sdXRpb25cbiAqIFZhbGlkYXRlczogUmVxdWlyZW1lbnRzIDMxLjNcbiAqL1xuXG5pbXBvcnQgKiBhcyBmYyBmcm9tICdmYXN0LWNoZWNrJztcbmltcG9ydCB7IGdlbmVyYXRlU2x1ZywgbWFrZVVuaXF1ZVNsdWcgfSBmcm9tICcuLi91dGlscy9zbHVncyc7XG5cbmRlc2NyaWJlKCdGZWF0dXJlOiBkZXN0aW5hdGlvbi13ZWRkaW5nLXBsYXRmb3JtLCBQcm9wZXJ0eSAyMDogU2x1ZyBDb25mbGljdCBSZXNvbHV0aW9uJywgKCkgPT4ge1xuICBkZXNjcmliZSgnc2x1ZyBjb25mbGljdCByZXNvbHV0aW9uIHByb3BlcnRpZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBhbHdheXMgcHJvZHVjZSBhIHZhbGlkIHNsdWcgZm9ybWF0IGFmdGVyIGNvbmZsaWN0IHJlc29sdXRpb24nLCAoKSA9PiB7XG4gICAgICBmYy5hc3NlcnQoXG4gICAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICAgIGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1MCB9KS5tYXAoZ2VuZXJhdGVTbHVnKS5maWx0ZXIoKHMpID0+IHMubGVuZ3RoID4gMCksXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMiwgbWF4OiAxMDAgfSksXG4gICAgICAgICAgKGJhc2VTbHVnLCBjb3VudGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZFNsdWcgPSBgJHtiYXNlU2x1Z30tJHtjb3VudGVyfWA7XG4gICAgICAgICAgICAvLyBTaG91bGQgb25seSBjb250YWluIGxvd2VyY2FzZSBsZXR0ZXJzLCBudW1iZXJzLCBhbmQgaHlwaGVuc1xuICAgICAgICAgICAgZXhwZWN0KHJlc29sdmVkU2x1ZykudG9NYXRjaCgvXlthLXowLTktXSskLyk7XG4gICAgICAgICAgICAvLyBTaG91bGQgbm90IGhhdmUgY29uc2VjdXRpdmUgaHlwaGVuc1xuICAgICAgICAgICAgZXhwZWN0KHJlc29sdmVkU2x1Zykubm90LnRvQ29udGFpbignLS0nKTtcbiAgICAgICAgICAgIC8vIFNob3VsZCBub3Qgc3RhcnQgb3IgZW5kIHdpdGggaHlwaGVuXG4gICAgICAgICAgICBleHBlY3QocmVzb2x2ZWRTbHVnKS5ub3QudG9NYXRjaCgvXi0vKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXNvbHZlZFNsdWcpLm5vdC50b01hdGNoKC8tJC8pO1xuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbWFpbnRhaW4gc2x1ZyB1bmlxdWVuZXNzIGFjcm9zcyBtdWx0aXBsZSBjb25mbGljdHMnLCAoKSA9PiB7XG4gICAgICBmYy5hc3NlcnQoXG4gICAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICAgIGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1MCB9KS5tYXAoZ2VuZXJhdGVTbHVnKS5maWx0ZXIoKHMpID0+IHMubGVuZ3RoID4gMCksXG4gICAgICAgICAgZmMudW5pcXVlQXJyYXkoZmMuaW50ZWdlcih7IG1pbjogMiwgbWF4OiAyMCB9KSwgeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTAgfSksXG4gICAgICAgICAgKGJhc2VTbHVnLCBjb3VudGVycykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRTbHVncyA9IGNvdW50ZXJzLm1hcCgoY291bnRlcikgPT4gYCR7YmFzZVNsdWd9LSR7Y291bnRlcn1gKTtcbiAgICAgICAgICAgIC8vIEFsbCByZXNvbHZlZCBzbHVncyBzaG91bGQgYmUgdW5pcXVlXG4gICAgICAgICAgICBjb25zdCB1bmlxdWVTbHVncyA9IG5ldyBTZXQocmVzb2x2ZWRTbHVncyk7XG4gICAgICAgICAgICBleHBlY3QodW5pcXVlU2x1Z3Muc2l6ZSkudG9CZShyZXNvbHZlZFNsdWdzLmxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBwcmVzZXJ2ZSB0aGUgYmFzZSBzbHVnIGluIHRoZSByZXNvbHZlZCBzbHVnJywgKCkgPT4ge1xuICAgICAgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5wcm9wZXJ0eShcbiAgICAgICAgICBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogNTAgfSkubWFwKGdlbmVyYXRlU2x1ZykuZmlsdGVyKChzKSA9PiBzLmxlbmd0aCA+IDApLFxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDIsIG1heDogMTAwMCB9KSxcbiAgICAgICAgICAoYmFzZVNsdWcsIGNvdW50ZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkU2x1ZyA9IGAke2Jhc2VTbHVnfS0ke2NvdW50ZXJ9YDtcbiAgICAgICAgICAgIC8vIFJlc29sdmVkIHNsdWcgc2hvdWxkIHN0YXJ0IHdpdGggYmFzZSBzbHVnXG4gICAgICAgICAgICBleHBlY3QocmVzb2x2ZWRTbHVnLnN0YXJ0c1dpdGgoYmFzZVNsdWcpKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgLy8gU2hvdWxkIGJlIGZvbGxvd2VkIGJ5IGh5cGhlbiBhbmQgbnVtYmVyXG4gICAgICAgICAgICBleHBlY3QocmVzb2x2ZWRTbHVnLnN1YnN0cmluZyhiYXNlU2x1Zy5sZW5ndGgpKS50b01hdGNoKC9eLVxcZCskLyk7XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBhcHBlbmQgLTIgd2hlbiBiYXNlIHNsdWcgZXhpc3RzJywgKCkgPT4ge1xuICAgICAgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5wcm9wZXJ0eShcbiAgICAgICAgICBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogNTAgfSkubWFwKGdlbmVyYXRlU2x1ZykuZmlsdGVyKChzKSA9PiBzLmxlbmd0aCA+IDApLFxuICAgICAgICAgIChiYXNlU2x1ZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdTbHVncyA9IFtiYXNlU2x1Z107XG4gICAgICAgICAgICBjb25zdCB1bmlxdWVTbHVnID0gbWFrZVVuaXF1ZVNsdWcoYmFzZVNsdWcsIGV4aXN0aW5nU2x1Z3MpO1xuICAgICAgICAgICAgZXhwZWN0KHVuaXF1ZVNsdWcpLnRvQmUoYCR7YmFzZVNsdWd9LTJgKTtcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGluY3JlbWVudCBjb3VudGVyIHVudGlsIHVuaXF1ZSBzbHVnIGlzIGZvdW5kJywgKCkgPT4ge1xuICAgICAgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5wcm9wZXJ0eShcbiAgICAgICAgICBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogNTAgfSkubWFwKGdlbmVyYXRlU2x1ZykuZmlsdGVyKChzKSA9PiBzLmxlbmd0aCA+IDApLFxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDEsIG1heDogMTAgfSksXG4gICAgICAgICAgKGJhc2VTbHVnLCBtYXhDb3VudGVyKSA9PiB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgZXhpc3Rpbmcgc2x1Z3M6IGJhc2UsIGJhc2UtMiwgYmFzZS0zLCAuLi4sIGJhc2UtbWF4Q291bnRlclxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdTbHVncyA9IFtiYXNlU2x1Z107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8PSBtYXhDb3VudGVyOyBpKyspIHtcbiAgICAgICAgICAgICAgZXhpc3RpbmdTbHVncy5wdXNoKGAke2Jhc2VTbHVnfS0ke2l9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZVNsdWcgPSBtYWtlVW5pcXVlU2x1ZyhiYXNlU2x1ZywgZXhpc3RpbmdTbHVncyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNob3VsZCBiZSBiYXNlLXttYXhDb3VudGVyKzF9XG4gICAgICAgICAgICBleHBlY3QodW5pcXVlU2x1ZykudG9CZShgJHtiYXNlU2x1Z30tJHttYXhDb3VudGVyICsgMX1gKTtcbiAgICAgICAgICAgIC8vIFNob3VsZCBub3QgYmUgaW4gZXhpc3Rpbmcgc2x1Z3NcbiAgICAgICAgICAgIGV4cGVjdChleGlzdGluZ1NsdWdzKS5ub3QudG9Db250YWluKHVuaXF1ZVNsdWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGdhcHMgaW4gY291bnRlciBzZXF1ZW5jZScsICgpID0+IHtcbiAgICAgIGZjLmFzc2VydChcbiAgICAgICAgZmMucHJvcGVydHkoXG4gICAgICAgICAgZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLm1hcChnZW5lcmF0ZVNsdWcpLmZpbHRlcigocykgPT4gcy5sZW5ndGggPiAwKSxcbiAgICAgICAgICAoYmFzZVNsdWcpID0+IHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBleGlzdGluZyBzbHVncyB3aXRoIGdhcHM6IGJhc2UsIGJhc2UtMiwgYmFzZS00IChtaXNzaW5nIGJhc2UtMylcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nU2x1Z3MgPSBbYmFzZVNsdWcsIGAke2Jhc2VTbHVnfS0yYCwgYCR7YmFzZVNsdWd9LTRgXTtcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZVNsdWcgPSBtYWtlVW5pcXVlU2x1ZyhiYXNlU2x1ZywgZXhpc3RpbmdTbHVncyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNob3VsZCBmaW5kIGJhc2UtMyAodGhlIGZpcnN0IGF2YWlsYWJsZSlcbiAgICAgICAgICAgIC8vIE5vdGU6IE91ciBpbXBsZW1lbnRhdGlvbiBpbmNyZW1lbnRzIGZyb20gMiwgc28gaXQgd2lsbCBmaW5kIGJhc2UtM1xuICAgICAgICAgICAgZXhwZWN0KHVuaXF1ZVNsdWcpLnRvQmUoYCR7YmFzZVNsdWd9LTNgKTtcbiAgICAgICAgICAgIGV4cGVjdChleGlzdGluZ1NsdWdzKS5ub3QudG9Db250YWluKHVuaXF1ZVNsdWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcHJlc2VydmUgYmFzZSBzbHVnIHN0cnVjdHVyZSB3aGVuIHJlc29sdmluZyBjb25mbGljdHMnLCAoKSA9PiB7XG4gICAgICBmYy5hc3NlcnQoXG4gICAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICAgIGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1MCB9KS5tYXAoZ2VuZXJhdGVTbHVnKS5maWx0ZXIoKHMpID0+IHMubGVuZ3RoID4gMCksXG4gICAgICAgICAgZmMuYXJyYXkoZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLm1hcChnZW5lcmF0ZVNsdWcpLCB7IG1heExlbmd0aDogMjAgfSksXG4gICAgICAgICAgKGJhc2VTbHVnLCBleGlzdGluZ1NsdWdzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1bmlxdWVTbHVnID0gbWFrZVVuaXF1ZVNsdWcoYmFzZVNsdWcsIGV4aXN0aW5nU2x1Z3MpO1xuICAgICAgICAgICAgLy8gVW5pcXVlIHNsdWcgc2hvdWxkIHN0YXJ0IHdpdGggYmFzZSBzbHVnIG9yIGJlIHRoZSBiYXNlIHNsdWcgaXRzZWxmXG4gICAgICAgICAgICBleHBlY3QodW5pcXVlU2x1Zy5zdGFydHNXaXRoKGJhc2VTbHVnKSB8fCB1bmlxdWVTbHVnID09PSBiYXNlU2x1ZykudG9CZSh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGFsd2F5cyBwcm9kdWNlIGEgc2x1ZyBub3QgaW4gdGhlIGV4aXN0aW5nIHNsdWdzIGxpc3QnLCAoKSA9PiB7XG4gICAgICBmYy5hc3NlcnQoXG4gICAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICAgIGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1MCB9KS5tYXAoZ2VuZXJhdGVTbHVnKS5maWx0ZXIoKHMpID0+IHMubGVuZ3RoID4gMCksXG4gICAgICAgICAgZmMuYXJyYXkoZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLm1hcChnZW5lcmF0ZVNsdWcpLCB7IG1heExlbmd0aDogNTAgfSksXG4gICAgICAgICAgKGJhc2VTbHVnLCBleGlzdGluZ1NsdWdzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1bmlxdWVTbHVnID0gbWFrZVVuaXF1ZVNsdWcoYmFzZVNsdWcsIGV4aXN0aW5nU2x1Z3MpO1xuICAgICAgICAgICAgZXhwZWN0KGV4aXN0aW5nU2x1Z3MpLm5vdC50b0NvbnRhaW4odW5pcXVlU2x1Zyk7XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgZXhpc3Rpbmcgc2x1Z3MgbGlzdCcsICgpID0+IHtcbiAgICAgIGZjLmFzc2VydChcbiAgICAgICAgZmMucHJvcGVydHkoXG4gICAgICAgICAgZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLm1hcChnZW5lcmF0ZVNsdWcpLmZpbHRlcigocykgPT4gcy5sZW5ndGggPiAwKSxcbiAgICAgICAgICAoYmFzZVNsdWcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZVNsdWcgPSBtYWtlVW5pcXVlU2x1ZyhiYXNlU2x1ZywgW10pO1xuICAgICAgICAgICAgLy8gU2hvdWxkIHJldHVybiBiYXNlIHNsdWcgdW5jaGFuZ2VkXG4gICAgICAgICAgICBleHBlY3QodW5pcXVlU2x1ZykudG9CZShiYXNlU2x1Zyk7XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbGFyZ2UgY291bnRlciB2YWx1ZXMnLCAoKSA9PiB7XG4gICAgICBmYy5hc3NlcnQoXG4gICAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICAgIGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1MCB9KS5tYXAoZ2VuZXJhdGVTbHVnKS5maWx0ZXIoKHMpID0+IHMubGVuZ3RoID4gMCksXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMTAwLCBtYXg6IDEwMDAgfSksXG4gICAgICAgICAgKGJhc2VTbHVnLCBsYXJnZUNvdW50ZXIpID0+IHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBleGlzdGluZyBzbHVncyB1cCB0byBsYXJnZUNvdW50ZXJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nU2x1Z3MgPSBbYmFzZVNsdWddO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPD0gbGFyZ2VDb3VudGVyOyBpKyspIHtcbiAgICAgICAgICAgICAgZXhpc3RpbmdTbHVncy5wdXNoKGAke2Jhc2VTbHVnfS0ke2l9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZVNsdWcgPSBtYWtlVW5pcXVlU2x1ZyhiYXNlU2x1ZywgZXhpc3RpbmdTbHVncyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNob3VsZCBiZSBiYXNlLXtsYXJnZUNvdW50ZXIrMX1cbiAgICAgICAgICAgIGV4cGVjdCh1bmlxdWVTbHVnKS50b0JlKGAke2Jhc2VTbHVnfS0ke2xhcmdlQ291bnRlciArIDF9YCk7XG4gICAgICAgICAgICBleHBlY3QoZXhpc3RpbmdTbHVncykubm90LnRvQ29udGFpbih1bmlxdWVTbHVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHsgbnVtUnVuczogMjAgfSAvLyBGZXdlciBydW5zIGZvciBwZXJmb3JtYW5jZVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NvbmZsaWN0IHJlc29sdXRpb24gZXhhbXBsZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYmFzaWMgY29uZmxpY3Q6IHNsdWcgZXhpc3RzJywgKCkgPT4ge1xuICAgICAgY29uc3QgYmFzZVNsdWcgPSAndGVzdC1wYWdlJztcbiAgICAgIGNvbnN0IGV4aXN0aW5nU2x1Z3MgPSBbJ3Rlc3QtcGFnZSddO1xuICAgICAgY29uc3QgdW5pcXVlU2x1ZyA9IG1ha2VVbmlxdWVTbHVnKGJhc2VTbHVnLCBleGlzdGluZ1NsdWdzKTtcbiAgICAgIGV4cGVjdCh1bmlxdWVTbHVnKS50b0JlKCd0ZXN0LXBhZ2UtMicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbXVsdGlwbGUgY29uZmxpY3RzOiBzbHVnIGFuZCBzbHVnLTIgZXhpc3QnLCAoKSA9PiB7XG4gICAgICBjb25zdCBiYXNlU2x1ZyA9ICd0ZXN0LXBhZ2UnO1xuICAgICAgY29uc3QgZXhpc3RpbmdTbHVncyA9IFsndGVzdC1wYWdlJywgJ3Rlc3QtcGFnZS0yJ107XG4gICAgICBjb25zdCB1bmlxdWVTbHVnID0gbWFrZVVuaXF1ZVNsdWcoYmFzZVNsdWcsIGV4aXN0aW5nU2x1Z3MpO1xuICAgICAgZXhwZWN0KHVuaXF1ZVNsdWcpLnRvQmUoJ3Rlc3QtcGFnZS0zJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBzZXF1ZW50aWFsIGNvbmZsaWN0cycsICgpID0+IHtcbiAgICAgIGNvbnN0IGJhc2VTbHVnID0gJ3BvcHVsYXItcGFnZSc7XG4gICAgICBjb25zdCBleGlzdGluZ1NsdWdzID0gWydwb3B1bGFyLXBhZ2UnLCAncG9wdWxhci1wYWdlLTInLCAncG9wdWxhci1wYWdlLTMnXTtcbiAgICAgIGNvbnN0IHVuaXF1ZVNsdWcgPSBtYWtlVW5pcXVlU2x1ZyhiYXNlU2x1ZywgZXhpc3RpbmdTbHVncyk7XG4gICAgICBleHBlY3QodW5pcXVlU2x1ZykudG9CZSgncG9wdWxhci1wYWdlLTQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGJhc2Ugc2x1ZyB3aGVuIG5vIGNvbmZsaWN0cycsICgpID0+IHtcbiAgICAgIGNvbnN0IGJhc2VTbHVnID0gJ3VuaXF1ZS1wYWdlJztcbiAgICAgIGNvbnN0IGV4aXN0aW5nU2x1Z3MgPSBbJ290aGVyLXBhZ2UnLCAnYW5vdGhlci1wYWdlJ107XG4gICAgICBjb25zdCB1bmlxdWVTbHVnID0gbWFrZVVuaXF1ZVNsdWcoYmFzZVNsdWcsIGV4aXN0aW5nU2x1Z3MpO1xuICAgICAgZXhwZWN0KHVuaXF1ZVNsdWcpLnRvQmUoJ3VuaXF1ZS1wYWdlJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBnYXBzIGluIHNlcXVlbmNlJywgKCkgPT4ge1xuICAgICAgY29uc3QgYmFzZVNsdWcgPSAndGVzdCc7XG4gICAgICBjb25zdCBleGlzdGluZ1NsdWdzID0gWyd0ZXN0JywgJ3Rlc3QtMicsICd0ZXN0LTQnXTsgLy8gTWlzc2luZyB0ZXN0LTNcbiAgICAgIGNvbnN0IHVuaXF1ZVNsdWcgPSBtYWtlVW5pcXVlU2x1ZyhiYXNlU2x1ZywgZXhpc3RpbmdTbHVncyk7XG4gICAgICBleHBlY3QodW5pcXVlU2x1ZykudG9CZSgndGVzdC0zJyk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJpdCIsImZjIiwiYXNzZXJ0IiwicHJvcGVydHkiLCJzdHJpbmciLCJtaW5MZW5ndGgiLCJtYXhMZW5ndGgiLCJtYXAiLCJnZW5lcmF0ZVNsdWciLCJmaWx0ZXIiLCJzIiwibGVuZ3RoIiwiaW50ZWdlciIsIm1pbiIsIm1heCIsImJhc2VTbHVnIiwiY291bnRlciIsInJlc29sdmVkU2x1ZyIsImV4cGVjdCIsInRvTWF0Y2giLCJub3QiLCJ0b0NvbnRhaW4iLCJudW1SdW5zIiwidW5pcXVlQXJyYXkiLCJjb3VudGVycyIsInJlc29sdmVkU2x1Z3MiLCJ1bmlxdWVTbHVncyIsIlNldCIsInNpemUiLCJ0b0JlIiwic3RhcnRzV2l0aCIsInN1YnN0cmluZyIsImV4aXN0aW5nU2x1Z3MiLCJ1bmlxdWVTbHVnIiwibWFrZVVuaXF1ZVNsdWciLCJtYXhDb3VudGVyIiwiaSIsInB1c2giLCJhcnJheSIsImxhcmdlQ291bnRlciJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DOzs7O21FQUVtQjt1QkFDeUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUU3Q0EsU0FBUyxnRkFBZ0Y7SUFDdkZBLFNBQVMsdUNBQXVDO1FBQzlDQyxHQUFHLHVFQUF1RTtZQUN4RUMsV0FBR0MsTUFBTSxDQUNQRCxXQUFHRSxRQUFRLENBQ1RGLFdBQUdHLE1BQU0sQ0FBQztnQkFBRUMsV0FBVztnQkFBR0MsV0FBVztZQUFHLEdBQUdDLEdBQUcsQ0FBQ0MsbUJBQVksRUFBRUMsTUFBTSxDQUFDLENBQUNDLElBQU1BLEVBQUVDLE1BQU0sR0FBRyxJQUN0RlYsV0FBR1csT0FBTyxD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