{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/services/contentPagesService.slugConflictResolution.property.test.ts"],"sourcesContent":["/**\n * Property-Based Tests for Slug Conflict Resolution\n * \n * Feature: destination-wedding-platform\n * Property 20: Slug Conflict Resolution\n * Validates: Requirements 31.3\n */\n\nimport * as fc from 'fast-check';\nimport { generateSlug, makeUniqueSlug } from '../utils/slugs';\n\ndescribe('Feature: destination-wedding-platform, Property 20: Slug Conflict Resolution', () => {\n  describe('slug conflict resolution properties', () => {\n    it('should always produce a valid slug format after conflict resolution', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug).filter((s) => s.length > 0),\n          fc.integer({ min: 2, max: 100 }),\n          (baseSlug, counter) => {\n            const resolvedSlug = `${baseSlug}-${counter}`;\n            // Should only contain lowercase letters, numbers, and hyphens\n            expect(resolvedSlug).toMatch(/^[a-z0-9-]+$/);\n            // Should not have consecutive hyphens\n            expect(resolvedSlug).not.toContain('--');\n            // Should not start or end with hyphen\n            expect(resolvedSlug).not.toMatch(/^-/);\n            expect(resolvedSlug).not.toMatch(/-$/);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should maintain slug uniqueness across multiple conflicts', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug).filter((s) => s.length > 0),\n          fc.uniqueArray(fc.integer({ min: 2, max: 20 }), { minLength: 1, maxLength: 10 }),\n          (baseSlug, counters) => {\n            const resolvedSlugs = counters.map((counter) => `${baseSlug}-${counter}`);\n            // All resolved slugs should be unique\n            const uniqueSlugs = new Set(resolvedSlugs);\n            expect(uniqueSlugs.size).toBe(resolvedSlugs.length);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should preserve the base slug in the resolved slug', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug).filter((s) => s.length > 0),\n          fc.integer({ min: 2, max: 1000 }),\n          (baseSlug, counter) => {\n            const resolvedSlug = `${baseSlug}-${counter}`;\n            // Resolved slug should start with base slug\n            expect(resolvedSlug.startsWith(baseSlug)).toBe(true);\n            // Should be followed by hyphen and number\n            expect(resolvedSlug.substring(baseSlug.length)).toMatch(/^-\\d+$/);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should append -2 when base slug exists', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug).filter((s) => s.length > 0),\n          (baseSlug) => {\n            const existingSlugs = [baseSlug];\n            const uniqueSlug = makeUniqueSlug(baseSlug, existingSlugs);\n            expect(uniqueSlug).toBe(`${baseSlug}-2`);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should increment counter until unique slug is found', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug).filter((s) => s.length > 0),\n          fc.integer({ min: 1, max: 10 }),\n          (baseSlug, maxCounter) => {\n            // Create existing slugs: base, base-2, base-3, ..., base-maxCounter\n            const existingSlugs = [baseSlug];\n            for (let i = 2; i <= maxCounter; i++) {\n              existingSlugs.push(`${baseSlug}-${i}`);\n            }\n            \n            const uniqueSlug = makeUniqueSlug(baseSlug, existingSlugs);\n            \n            // Should be base-{maxCounter+1}\n            expect(uniqueSlug).toBe(`${baseSlug}-${maxCounter + 1}`);\n            // Should not be in existing slugs\n            expect(existingSlugs).not.toContain(uniqueSlug);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should handle gaps in counter sequence', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug).filter((s) => s.length > 0),\n          (baseSlug) => {\n            // Create existing slugs with gaps: base, base-2, base-4 (missing base-3)\n            const existingSlugs = [baseSlug, `${baseSlug}-2`, `${baseSlug}-4`];\n            const uniqueSlug = makeUniqueSlug(baseSlug, existingSlugs);\n            \n            // Should find base-3 (the first available)\n            // Note: Our implementation increments from 2, so it will find base-3\n            expect(uniqueSlug).toBe(`${baseSlug}-3`);\n            expect(existingSlugs).not.toContain(uniqueSlug);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should preserve base slug structure when resolving conflicts', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug).filter((s) => s.length > 0),\n          fc.array(fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug), { maxLength: 20 }),\n          (baseSlug, existingSlugs) => {\n            const uniqueSlug = makeUniqueSlug(baseSlug, existingSlugs);\n            // Unique slug should start with base slug or be the base slug itself\n            expect(uniqueSlug.startsWith(baseSlug) || uniqueSlug === baseSlug).toBe(true);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should always produce a slug not in the existing slugs list', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug).filter((s) => s.length > 0),\n          fc.array(fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug), { maxLength: 50 }),\n          (baseSlug, existingSlugs) => {\n            const uniqueSlug = makeUniqueSlug(baseSlug, existingSlugs);\n            expect(existingSlugs).not.toContain(uniqueSlug);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should handle empty existing slugs list', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug).filter((s) => s.length > 0),\n          (baseSlug) => {\n            const uniqueSlug = makeUniqueSlug(baseSlug, []);\n            // Should return base slug unchanged\n            expect(uniqueSlug).toBe(baseSlug);\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n\n    it('should handle large counter values', () => {\n      fc.assert(\n        fc.property(\n          fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug).filter((s) => s.length > 0),\n          fc.integer({ min: 100, max: 1000 }),\n          (baseSlug, largeCounter) => {\n            // Create existing slugs up to largeCounter\n            const existingSlugs = [baseSlug];\n            for (let i = 2; i <= largeCounter; i++) {\n              existingSlugs.push(`${baseSlug}-${i}`);\n            }\n            \n            const uniqueSlug = makeUniqueSlug(baseSlug, existingSlugs);\n            \n            // Should be base-{largeCounter+1}\n            expect(uniqueSlug).toBe(`${baseSlug}-${largeCounter + 1}`);\n            expect(existingSlugs).not.toContain(uniqueSlug);\n          }\n        ),\n        { numRuns: 20 } // Fewer runs for performance\n      );\n    });\n  });\n\n  describe('conflict resolution examples', () => {\n    it('should handle basic conflict: slug exists', () => {\n      const baseSlug = 'test-page';\n      const existingSlugs = ['test-page'];\n      const uniqueSlug = makeUniqueSlug(baseSlug, existingSlugs);\n      expect(uniqueSlug).toBe('test-page-2');\n    });\n\n    it('should handle multiple conflicts: slug and slug-2 exist', () => {\n      const baseSlug = 'test-page';\n      const existingSlugs = ['test-page', 'test-page-2'];\n      const uniqueSlug = makeUniqueSlug(baseSlug, existingSlugs);\n      expect(uniqueSlug).toBe('test-page-3');\n    });\n\n    it('should handle sequential conflicts', () => {\n      const baseSlug = 'popular-page';\n      const existingSlugs = ['popular-page', 'popular-page-2', 'popular-page-3'];\n      const uniqueSlug = makeUniqueSlug(baseSlug, existingSlugs);\n      expect(uniqueSlug).toBe('popular-page-4');\n    });\n\n    it('should return base slug when no conflicts', () => {\n      const baseSlug = 'unique-page';\n      const existingSlugs = ['other-page', 'another-page'];\n      const uniqueSlug = makeUniqueSlug(baseSlug, existingSlugs);\n      expect(uniqueSlug).toBe('unique-page');\n    });\n\n    it('should handle gaps in sequence', () => {\n      const baseSlug = 'test';\n      const existingSlugs = ['test', 'test-2', 'test-4']; // Missing test-3\n      const uniqueSlug = makeUniqueSlug(baseSlug, existingSlugs);\n      expect(uniqueSlug).toBe('test-3');\n    });\n  });\n});\n"],"names":["describe","it","fc","assert","property","string","minLength","maxLength","map","generateSlug","filter","s","length","integer","min","max","baseSlug","counter","resolvedSlug","expect","toMatch","not","toContain","numRuns","uniqueArray","counters","resolvedSlugs","uniqueSlugs","Set","size","toBe","startsWith","substring","existingSlugs","uniqueSlug","makeUniqueSlug","maxCounter","i","push","array","largeCounter"],"mappings":"AAAA;;;;;;CAMC;;;;mEAEmB;uBACyB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAE7CA,SAAS,gFAAgF;IACvFA,SAAS,uCAAuC;QAC9CC,GAAG,uEAAuE;YACxEC,WAAGC,MAAM,CACPD,WAAGE,QAAQ,CACTF,WAAGG,MAAM,CAAC;gBAAEC,WAAW;gBAAGC,WAAW;YAAG,GAAGC,GAAG,CAACC,mBAAY,EAAEC,MAAM,CAAC,CAACC,IAAMA,EAAEC,MAAM,GAAG,IACtFV,WAAGW,OAAO,CAAC;gBAAEC,KAAK;gBAAGC,KAAK;YAAI,IAC9B,CAACC,UAAUC;gBACT,MAAMC,eAAe,GAAGF,SAAS,CAAC,EAAEC,SAAS;gBAC7C,8DAA8D;gBAC9DE,OAAOD,cAAcE,OAAO,CAAC;gBAC7B,sCAAsC;gBACtCD,OAAOD,cAAcG,GAAG,CAACC,SAAS,CAAC;gBACnC,sCAAsC;gBACtCH,OAAOD,cAAcG,GAAG,CAACD,OAAO,CAAC;gBACjCD,OAAOD,cAAcG,GAAG,CAACD,OAAO,CAAC;YACnC,IAEF;gBAAEG,SAAS;YAAI;QAEnB;QAEAtB,GAAG,6DAA6D;YAC9DC,WAAGC,MAAM,CACPD,WAAGE,QAAQ,CACTF,WAAGG,MAAM,CAAC;gBAAEC,WAAW;gBAAGC,WAAW;YAAG,GAAGC,GAAG,CAACC,mBAAY,EAAEC,MAAM,CAAC,CAACC,IAAMA,EAAEC,MAAM,GAAG,IACtFV,WAAGsB,WAAW,CAACtB,WAAGW,OAAO,CAAC;gBAAEC,KAAK;gBAAGC,KAAK;YAAG,IAAI;gBAAET,WAAW;gBAAGC,WAAW;YAAG,IAC9E,CAACS,UAAUS;gBACT,MAAMC,gBAAgBD,SAASjB,GAAG,CAAC,CAACS,UAAY,GAAGD,SAAS,CAAC,EAAEC,SAAS;gBACxE,sCAAsC;gBACtC,MAAMU,cAAc,IAAIC,IAAIF;gBAC5BP,OAAOQ,YAAYE,IAAI,EAAEC,IAAI,CAACJ,cAAcd,MAAM;YACpD,IAEF;gBAAEW,SAAS;YAAI;QAEnB;QAEAtB,GAAG,sDAAsD;YACvDC,WAAGC,MAAM,CACPD,WAAGE,QAAQ,CACTF,WAAGG,MAAM,CAAC;gBAAEC,WAAW;gBAAGC,WAAW;YAAG,GAAGC,GAAG,CAACC,mBAAY,EAAEC,MAAM,CAAC,CAACC,IAAMA,EAAEC,MAAM,GAAG,IACtFV,WAAGW,OAAO,CAAC;gBAAEC,KAAK;gBAAGC,KAAK;YAAK,IAC/B,CAACC,UAAUC;gBACT,MAAMC,eAAe,GAAGF,SAAS,CAAC,EAAEC,SAAS;gBAC7C,4CAA4C;gBAC5CE,OAAOD,aAAaa,UAAU,CAACf,WAAWc,IAAI,CAAC;gBAC/C,0CAA0C;gBAC1CX,OAAOD,aAAac,SAAS,CAAChB,SAASJ,MAAM,GAAGQ,OAAO,CAAC;YAC1D,IAEF;gBAAEG,SAAS;YAAI;QAEnB;QAEAtB,GAAG,0CAA0C;YAC3CC,WAAGC,MAAM,CACPD,WAAGE,QAAQ,CACTF,WAAGG,MAAM,CAAC;gBAAEC,WAAW;gBAAGC,WAAW;YAAG,GAAGC,GAAG,CAACC,mBAAY,EAAEC,MAAM,CAAC,CAACC,IAAMA,EAAEC,MAAM,GAAG,IACtF,CAACI;gBACC,MAAMiB,gBAAgB;oBAACjB;iBAAS;gBAChC,MAAMkB,aAAaC,IAAAA,qBAAc,EAACnB,UAAUiB;gBAC5Cd,OAAOe,YAAYJ,IAAI,CAAC,GAAGd,SAAS,EAAE,CAAC;YACzC,IAEF;gBAAEO,SAAS;YAAI;QAEnB;QAEAtB,GAAG,uDAAuD;YACxDC,WAAGC,MAAM,CACPD,WAAGE,QAAQ,CACTF,WAAGG,MAAM,CAAC;gBAAEC,WAAW;gBAAGC,WAAW;YAAG,GAAGC,GAAG,CAACC,mBAAY,EAAEC,MAAM,CAAC,CAACC,IAAMA,EAAEC,MAAM,GAAG,IACtFV,WAAGW,OAAO,CAAC;gBAAEC,KAAK;gBAAGC,KAAK;YAAG,IAC7B,CAACC,UAAUoB;gBACT,oEAAoE;gBACpE,MAAMH,gBAAgB;oBAACjB;iBAAS;gBAChC,IAAK,IAAIqB,IAAI,GAAGA,KAAKD,YAAYC,IAAK;oBACpCJ,cAAcK,IAAI,CAAC,GAAGtB,SAAS,CAAC,EAAEqB,GAAG;gBACvC;gBAEA,MAAMH,aAAaC,IAAAA,qBAAc,EAACnB,UAAUiB;gBAE5C,gCAAgC;gBAChCd,OAAOe,YAAYJ,IAAI,CAAC,GAAGd,SAAS,CAAC,EAAEoB,aAAa,GAAG;gBACvD,kCAAkC;gBAClCjB,OAAOc,eAAeZ,GAAG,CAACC,SAAS,CAACY;YACtC,IAEF;gBAAEX,SAAS;YAAI;QAEnB;QAEAtB,GAAG,0CAA0C;YAC3CC,WAAGC,MAAM,CACPD,WAAGE,QAAQ,CACTF,WAAGG,MAAM,CAAC;gBAAEC,WAAW;gBAAGC,WAAW;YAAG,GAAGC,GAAG,CAACC,mBAAY,EAAEC,MAAM,CAAC,CAACC,IAAMA,EAAEC,MAAM,GAAG,IACtF,CAACI;gBACC,yEAAyE;gBACzE,MAAMiB,gBAAgB;oBAACjB;oBAAU,GAAGA,SAAS,EAAE,CAAC;oBAAE,GAAGA,SAAS,EAAE,CAAC;iBAAC;gBAClE,MAAMkB,aAAaC,IAAAA,qBAAc,EAACnB,UAAUiB;gBAE5C,2CAA2C;gBAC3C,qEAAqE;gBACrEd,OAAOe,YAAYJ,IAAI,CAAC,GAAGd,SAAS,EAAE,CAAC;gBACvCG,OAAOc,eAAeZ,GAAG,CAACC,SAAS,CAACY;YACtC,IAEF;gBAAEX,SAAS;YAAI;QAEnB;QAEAtB,GAAG,gEAAgE;YACjEC,WAAGC,MAAM,CACPD,WAAGE,QAAQ,CACTF,WAAGG,MAAM,CAAC;gBAAEC,WAAW;gBAAGC,WAAW;YAAG,GAAGC,GAAG,CAACC,mBAAY,EAAEC,MAAM,CAAC,CAACC,IAAMA,EAAEC,MAAM,GAAG,IACtFV,WAAGqC,KAAK,CAACrC,WAAGG,MAAM,CAAC;gBAAEC,WAAW;gBAAGC,WAAW;YAAG,GAAGC,GAAG,CAACC,mBAAY,GAAG;gBAAEF,WAAW;YAAG,IACvF,CAACS,UAAUiB;gBACT,MAAMC,aAAaC,IAAAA,qBAAc,EAACnB,UAAUiB;gBAC5C,qEAAqE;gBACrEd,OAAOe,WAAWH,UAAU,CAACf,aAAakB,eAAelB,UAAUc,IAAI,CAAC;YAC1E,IAEF;gBAAEP,SAAS;YAAI;QAEnB;QAEAtB,GAAG,+DAA+D;YAChEC,WAAGC,MAAM,CACPD,WAAGE,QAAQ,CACTF,WAAGG,MAAM,CAAC;gBAAEC,WAAW;gBAAGC,WAAW;YAAG,GAAGC,GAAG,CAACC,mBAAY,EAAEC,MAAM,CAAC,CAACC,IAAMA,EAAEC,MAAM,GAAG,IACtFV,WAAGqC,KAAK,CAACrC,WAAGG,MAAM,CAAC;gBAAEC,WAAW;gBAAGC,WAAW;YAAG,GAAGC,GAAG,CAACC,mBAAY,GAAG;gBAAEF,WAAW;YAAG,IACvF,CAACS,UAAUiB;gBACT,MAAMC,aAAaC,IAAAA,qBAAc,EAACnB,UAAUiB;gBAC5Cd,OAAOc,eAAeZ,GAAG,CAACC,SAAS,CAACY;YACtC,IAEF;gBAAEX,SAAS;YAAI;QAEnB;QAEAtB,GAAG,2CAA2C;YAC5CC,WAAGC,MAAM,CACPD,WAAGE,QAAQ,CACTF,WAAGG,MAAM,CAAC;gBAAEC,WAAW;gBAAGC,WAAW;YAAG,GAAGC,GAAG,CAACC,mBAAY,EAAEC,MAAM,CAAC,CAACC,IAAMA,EAAEC,MAAM,GAAG,IACtF,CAACI;gBACC,MAAMkB,aAAaC,IAAAA,qBAAc,EAACnB,UAAU,EAAE;gBAC9C,oCAAoC;gBACpCG,OAAOe,YAAYJ,IAAI,CAACd;YAC1B,IAEF;gBAAEO,SAAS;YAAI;QAEnB;QAEAtB,GAAG,sCAAsC;YACvCC,WAAGC,MAAM,CACPD,WAAGE,QAAQ,CACTF,WAAGG,MAAM,CAAC;gBAAEC,WAAW;gBAAGC,WAAW;YAAG,GAAGC,GAAG,CAACC,mBAAY,EAAEC,MAAM,CAAC,CAACC,IAAMA,EAAEC,MAAM,GAAG,IACtFV,WAAGW,OAAO,CAAC;gBAAEC,KAAK;gBAAKC,KAAK;YAAK,IACjC,CAACC,UAAUwB;gBACT,2CAA2C;gBAC3C,MAAMP,gBAAgB;oBAACjB;iBAAS;gBAChC,IAAK,IAAIqB,IAAI,GAAGA,KAAKG,cAAcH,IAAK;oBACtCJ,cAAcK,IAAI,CAAC,GAAGtB,SAAS,CAAC,EAAEqB,GAAG;gBACvC;gBAEA,MAAMH,aAAaC,IAAAA,qBAAc,EAACnB,UAAUiB;gBAE5C,kCAAkC;gBAClCd,OAAOe,YAAYJ,IAAI,CAAC,GAAGd,SAAS,CAAC,EAAEwB,eAAe,GAAG;gBACzDrB,OAAOc,eAAeZ,GAAG,CAACC,SAAS,CAACY;YACtC,IAEF;gBAAEX,SAAS;YAAG,EAAE,6BAA6B;;QAEjD;IACF;IAEAvB,SAAS,gCAAgC;QACvCC,GAAG,6CAA6C;YAC9C,MAAMe,WAAW;YACjB,MAAMiB,gBAAgB;gBAAC;aAAY;YACnC,MAAMC,aAAaC,IAAAA,qBAAc,EAACnB,UAAUiB;YAC5Cd,OAAOe,YAAYJ,IAAI,CAAC;QAC1B;QAEA7B,GAAG,2DAA2D;YAC5D,MAAMe,WAAW;YACjB,MAAMiB,gBAAgB;gBAAC;gBAAa;aAAc;YAClD,MAAMC,aAAaC,IAAAA,qBAAc,EAACnB,UAAUiB;YAC5Cd,OAAOe,YAAYJ,IAAI,CAAC;QAC1B;QAEA7B,GAAG,sCAAsC;YACvC,MAAMe,WAAW;YACjB,MAAMiB,gBAAgB;gBAAC;gBAAgB;gBAAkB;aAAiB;YAC1E,MAAMC,aAAaC,IAAAA,qBAAc,EAACnB,UAAUiB;YAC5Cd,OAAOe,YAAYJ,IAAI,CAAC;QAC1B;QAEA7B,GAAG,6CAA6C;YAC9C,MAAMe,WAAW;YACjB,MAAMiB,gBAAgB;gBAAC;gBAAc;aAAe;YACpD,MAAMC,aAAaC,IAAAA,qBAAc,EAACnB,UAAUiB;YAC5Cd,OAAOe,YAAYJ,IAAI,CAAC;QAC1B;QAEA7B,GAAG,kCAAkC;YACnC,MAAMe,WAAW;YACjB,MAAMiB,gBAAgB;gBAAC;gBAAQ;gBAAU;aAAS,EAAE,iBAAiB;YACrE,MAAMC,aAAaC,IAAAA,qBAAc,EAACnB,UAAUiB;YAC5Cd,OAAOe,YAAYJ,IAAI,CAAC;QAC1B;IACF;AACF"}