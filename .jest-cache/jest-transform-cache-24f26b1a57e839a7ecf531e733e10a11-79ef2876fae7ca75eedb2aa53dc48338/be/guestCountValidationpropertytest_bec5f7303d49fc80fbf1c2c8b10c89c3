4a4fc1ad0bdd7cbf8c912c8ec5e9005b
/**
 * Property-Based Test: Guest Count Validation
 * 
 * Feature: guest-portal-and-admin-enhancements
 * Property 7: Guest Count Validation
 * 
 * Description:
 * For any activity RSVP with guest count, the guest count SHALL be less than
 * or equal to the activity's maximum guests per party setting
 * 
 * Validates: Requirements 10.3
 * 
 * Test Strategy:
 * - Generate activities with various max guests per party settings
 * - Generate RSVP scenarios with different guest counts
 * - Verify rejection when guest count exceeds maximum
 * - Verify acceptance when guest count is within limit
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _arbitraries = require("../helpers/arbitraries");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('Feature: guest-portal-and-admin-enhancements, Property 7: Guest Count Validation', ()=>{
    /**
   * Arbitrary for activity with max guests per party setting
   */ const activityWithMaxGuestsArbitrary = _fastcheck.record({
        id: _arbitraries.uuidArbitrary,
        name: _fastcheck.string({
            minLength: 1,
            maxLength: 100
        }),
        maxGuestsPerParty: _fastcheck.option(_fastcheck.integer({
            min: 1,
            max: 20
        }), {
            nil: null
        }),
        requiresGuestCount: _fastcheck.boolean()
    });
    /**
   * Arbitrary for RSVP with guest count
   */ const rsvpWithGuestCountArbitrary = _fastcheck.record({
        guestId: _arbitraries.uuidArbitrary,
        activityId: _arbitraries.uuidArbitrary,
        status: _fastcheck.constantFrom('pending', 'attending', 'maybe', 'declined'),
        guestCount: _fastcheck.integer({
            min: 1,
            max: 50
        })
    });
    /**
   * Validate guest count against activity's max guests per party
   */ function validateGuestCount(activity, rsvp) {
        // Only validate for attending status
        if (rsvp.status !== 'attending') {
            return {
                success: true
            };
        }
        // Validate minimum guest count (must be at least 1)
        if (rsvp.guestCount < 1) {
            return {
                success: false,
                error: {
                    code: 'INVALID_GUEST_COUNT',
                    message: 'Guest count must be at least 1'
                }
            };
        }
        // If no max guests per party set, accept any positive count
        if (activity.maxGuestsPerParty === null) {
            return {
                success: true
            };
        }
        // Validate guest count against maximum
        if (rsvp.guestCount > activity.maxGuestsPerParty) {
            return {
                success: false,
                error: {
                    code: 'GUEST_COUNT_EXCEEDED',
                    message: `Guest count (${rsvp.guestCount}) exceeds maximum allowed per party (${activity.maxGuestsPerParty})`
                }
            };
        }
        return {
            success: true
        };
    }
    it('should reject RSVP when guest count exceeds max guests per party', ()=>{
        _fastcheck.assert(_fastcheck.property(activityWithMaxGuestsArbitrary, rsvpWithGuestCountArbitrary, (activity, rsvp)=>{
            // Skip if no max guests per party set
            if (activity.maxGuestsPerParty === null) {
                return;
            }
            // Create scenario where guest count exceeds maximum
            const excessiveGuestCount = activity.maxGuestsPerParty + _fastcheck.sample(_fastcheck.integer({
                min: 1,
                max: 10
            }), 1)[0];
            const result = validateGuestCount(activity, {
                ...rsvp,
                status: 'attending',
                guestCount: excessiveGuestCount
            });
            // Should be rejected
            expect(result.success).toBe(false);
            expect(result.error).toBeDefined();
            expect(result.error?.code).toBe('GUEST_COUNT_EXCEEDED');
        }), {
            numRuns: 100
        });
    });
    it('should accept RSVP when guest count is within max guests per party', ()=>{
        _fastcheck.assert(_fastcheck.property(activityWithMaxGuestsArbitrary, rsvpWithGuestCountArbitrary, (activity, rsvp)=>{
            // Skip if no max guests per party set
            if (activity.maxGuestsPerParty === null) {
                return;
            }
            // Create scenario where guest count is within maximum
            const validGuestCount = _fastcheck.sample(_fastcheck.integer({
                min: 1,
                max: activity.maxGuestsPerParty
            }), 1)[0];
            const result = validateGuestCount(activity, {
                ...rsvp,
                status: 'attending',
                guestCount: validGuestCount
            });
            // Should be accepted
            expect(result.success).toBe(true);
            expect(result.error).toBeUndefined();
        }), {
            numRuns: 100
        });
    });
    it('should accept any guest count when max guests per party is not set', ()=>{
        _fastcheck.assert(_fastcheck.property(rsvpWithGuestCountArbitrary, _fastcheck.integer({
            min: 1,
            max: 100
        }), (rsvp, largeGuestCount)=>{
            const activity = {
                maxGuestsPerParty: null,
                requiresGuestCount: true
            };
            const result = validateGuestCount(activity, {
                ...rsvp,
                status: 'attending',
                guestCount: largeGuestCount
            });
            // Should be accepted regardless of count
            expect(result.success).toBe(true);
            expect(result.error).toBeUndefined();
        }), {
            numRuns: 100
        });
    });
    it('should not validate guest count for non-attending statuses', ()=>{
        _fastcheck.assert(_fastcheck.property(activityWithMaxGuestsArbitrary, rsvpWithGuestCountArbitrary, (activity, rsvp)=>{
            // Skip if no max guests per party set
            if (activity.maxGuestsPerParty === null) {
                return;
            }
            // Test with non-attending statuses and excessive guest count
            const nonAttendingStatuses = [
                'pending',
                'maybe',
                'declined'
            ];
            const excessiveGuestCount = activity.maxGuestsPerParty + 10;
            for (const status of nonAttendingStatuses){
                const result = validateGuestCount(activity, {
                    ...rsvp,
                    status,
                    guestCount: excessiveGuestCount
                });
                // Should be accepted regardless of guest count
                expect(result.success).toBe(true);
                expect(result.error).toBeUndefined();
            }
        }), {
            numRuns: 100
        });
    });
    it('should handle edge case: guest count exactly at maximum', ()=>{
        _fastcheck.assert(_fastcheck.property(_fastcheck.integer({
            min: 1,
            max: 20
        }), (maxGuestsPerParty)=>{
            const activity = {
                maxGuestsPerParty,
                requiresGuestCount: true
            };
            const result = validateGuestCount(activity, {
                status: 'attending',
                guestCount: maxGuestsPerParty
            });
            // Should be accepted
            expect(result.success).toBe(true);
            expect(result.error).toBeUndefined();
        }), {
            numRuns: 100
        });
    });
    it('should handle edge case: guest count one over maximum', ()=>{
        _fastcheck.assert(_fastcheck.property(_fastcheck.integer({
            min: 1,
            max: 20
        }), (maxGuestsPerParty)=>{
            const activity = {
                maxGuestsPerParty,
                requiresGuestCount: true
            };
            const result = validateGuestCount(activity, {
                status: 'attending',
                guestCount: maxGuestsPerParty + 1
            });
            // Should be rejected
            expect(result.success).toBe(false);
            expect(result.error?.code).toBe('GUEST_COUNT_EXCEEDED');
        }), {
            numRuns: 100
        });
    });
    it('should reject guest count of zero', ()=>{
        _fastcheck.assert(_fastcheck.property(activityWithMaxGuestsArbitrary, (activity)=>{
            const result = validateGuestCount(activity, {
                status: 'attending',
                guestCount: 0
            });
            // Should be rejected
            expect(result.success).toBe(false);
            expect(result.error?.code).toBe('INVALID_GUEST_COUNT');
        }), {
            numRuns: 100
        });
    });
    it('should reject negative guest count', ()=>{
        _fastcheck.assert(_fastcheck.property(activityWithMaxGuestsArbitrary, _fastcheck.integer({
            min: -100,
            max: -1
        }), (activity, negativeCount)=>{
            const result = validateGuestCount(activity, {
                status: 'attending',
                guestCount: negativeCount
            });
            // Should be rejected
            expect(result.success).toBe(false);
            expect(result.error?.code).toBe('INVALID_GUEST_COUNT');
        }), {
            numRuns: 100
        });
    });
    it('should provide clear error message with guest count details', ()=>{
        _fastcheck.assert(_fastcheck.property(_fastcheck.integer({
            min: 1,
            max: 20
        }), _fastcheck.integer({
            min: 1,
            max: 10
        }), (maxGuestsPerParty, excess)=>{
            const activity = {
                maxGuestsPerParty,
                requiresGuestCount: true
            };
            const excessiveGuestCount = maxGuestsPerParty + excess;
            const result = validateGuestCount(activity, {
                status: 'attending',
                guestCount: excessiveGuestCount
            });
            if (!result.success && result.error) {
                // Error message should include both counts
                expect(result.error.message).toContain(excessiveGuestCount.toString());
                expect(result.error.message).toContain(maxGuestsPerParty.toString());
            }
        }), {
            numRuns: 100
        });
    });
    it('should handle max guests per party of 1 (solo activities)', ()=>{
        const activity = {
            maxGuestsPerParty: 1,
            requiresGuestCount: true
        };
        // Guest count of 1 should be accepted
        const result1 = validateGuestCount(activity, {
            status: 'attending',
            guestCount: 1
        });
        expect(result1.success).toBe(true);
        // Guest count of 2 should be rejected
        const result2 = validateGuestCount(activity, {
            status: 'attending',
            guestCount: 2
        });
        expect(result2.success).toBe(false);
        expect(result2.error?.code).toBe('GUEST_COUNT_EXCEEDED');
    });
    it('should handle large max guests per party values', ()=>{
        _fastcheck.assert(_fastcheck.property(_fastcheck.integer({
            min: 50,
            max: 1000
        }), (largeMaxGuests)=>{
            const activity = {
                maxGuestsPerParty: largeMaxGuests,
                requiresGuestCount: true
            };
            // Any count up to max should be accepted
            const validCount = _fastcheck.sample(_fastcheck.integer({
                min: 1,
                max: largeMaxGuests
            }), 1)[0];
            const result = validateGuestCount(activity, {
                status: 'attending',
                guestCount: validCount
            });
            expect(result.success).toBe(true);
        }), {
            numRuns: 100
        });
    });
    it('should be idempotent - multiple validations with same input produce same result', ()=>{
        _fastcheck.assert(_fastcheck.property(activityWithMaxGuestsArbitrary, rsvpWithGuestCountArbitrary, (activity, rsvp)=>{
            const result1 = validateGuestCount(activity, rsvp);
            const result2 = validateGuestCount(activity, rsvp);
            // Results should be identical
            expect(result1.success).toBe(result2.success);
            expect(result1.error?.code).toBe(result2.error?.code);
        }), {
            numRuns: 100
        });
    });
    it('should validate guest count independently of capacity constraints', ()=>{
        _fastcheck.assert(_fastcheck.property(_fastcheck.integer({
            min: 1,
            max: 10
        }), _fastcheck.integer({
            min: 1,
            max: 100
        }), (maxGuestsPerParty, activityCapacity)=>{
            const activity = {
                maxGuestsPerParty,
                requiresGuestCount: true
            };
            // Guest count validation should not consider activity capacity
            // It only checks against max guests per party
            const validGuestCount = maxGuestsPerParty;
            const result = validateGuestCount(activity, {
                status: 'attending',
                guestCount: validGuestCount
            });
            // Should be accepted based on max guests per party alone
            expect(result.success).toBe(true);
        }), {
            numRuns: 100
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvX190ZXN0c19fL3Byb3BlcnR5L2d1ZXN0Q291bnRWYWxpZGF0aW9uLnByb3BlcnR5LnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQcm9wZXJ0eS1CYXNlZCBUZXN0OiBHdWVzdCBDb3VudCBWYWxpZGF0aW9uXG4gKiBcbiAqIEZlYXR1cmU6IGd1ZXN0LXBvcnRhbC1hbmQtYWRtaW4tZW5oYW5jZW1lbnRzXG4gKiBQcm9wZXJ0eSA3OiBHdWVzdCBDb3VudCBWYWxpZGF0aW9uXG4gKiBcbiAqIERlc2NyaXB0aW9uOlxuICogRm9yIGFueSBhY3Rpdml0eSBSU1ZQIHdpdGggZ3Vlc3QgY291bnQsIHRoZSBndWVzdCBjb3VudCBTSEFMTCBiZSBsZXNzIHRoYW5cbiAqIG9yIGVxdWFsIHRvIHRoZSBhY3Rpdml0eSdzIG1heGltdW0gZ3Vlc3RzIHBlciBwYXJ0eSBzZXR0aW5nXG4gKiBcbiAqIFZhbGlkYXRlczogUmVxdWlyZW1lbnRzIDEwLjNcbiAqIFxuICogVGVzdCBTdHJhdGVneTpcbiAqIC0gR2VuZXJhdGUgYWN0aXZpdGllcyB3aXRoIHZhcmlvdXMgbWF4IGd1ZXN0cyBwZXIgcGFydHkgc2V0dGluZ3NcbiAqIC0gR2VuZXJhdGUgUlNWUCBzY2VuYXJpb3Mgd2l0aCBkaWZmZXJlbnQgZ3Vlc3QgY291bnRzXG4gKiAtIFZlcmlmeSByZWplY3Rpb24gd2hlbiBndWVzdCBjb3VudCBleGNlZWRzIG1heGltdW1cbiAqIC0gVmVyaWZ5IGFjY2VwdGFuY2Ugd2hlbiBndWVzdCBjb3VudCBpcyB3aXRoaW4gbGltaXRcbiAqL1xuXG5pbXBvcnQgKiBhcyBmYyBmcm9tICdmYXN0LWNoZWNrJztcbmltcG9ydCB7IHV1aWRBcmJpdHJhcnkgfSBmcm9tICcuLi9oZWxwZXJzL2FyYml0cmFyaWVzJztcblxuZGVzY3JpYmUoJ0ZlYXR1cmU6IGd1ZXN0LXBvcnRhbC1hbmQtYWRtaW4tZW5oYW5jZW1lbnRzLCBQcm9wZXJ0eSA3OiBHdWVzdCBDb3VudCBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICAvKipcbiAgICogQXJiaXRyYXJ5IGZvciBhY3Rpdml0eSB3aXRoIG1heCBndWVzdHMgcGVyIHBhcnR5IHNldHRpbmdcbiAgICovXG4gIGNvbnN0IGFjdGl2aXR5V2l0aE1heEd1ZXN0c0FyYml0cmFyeSA9IGZjLnJlY29yZCh7XG4gICAgaWQ6IHV1aWRBcmJpdHJhcnksXG4gICAgbmFtZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwMCB9KSxcbiAgICBtYXhHdWVzdHNQZXJQYXJ0eTogZmMub3B0aW9uKGZjLmludGVnZXIoeyBtaW46IDEsIG1heDogMjAgfSksIHsgbmlsOiBudWxsIH0pLFxuICAgIHJlcXVpcmVzR3Vlc3RDb3VudDogZmMuYm9vbGVhbigpLFxuICB9KTtcblxuICAvKipcbiAgICogQXJiaXRyYXJ5IGZvciBSU1ZQIHdpdGggZ3Vlc3QgY291bnRcbiAgICovXG4gIGNvbnN0IHJzdnBXaXRoR3Vlc3RDb3VudEFyYml0cmFyeSA9IGZjLnJlY29yZCh7XG4gICAgZ3Vlc3RJZDogdXVpZEFyYml0cmFyeSxcbiAgICBhY3Rpdml0eUlkOiB1dWlkQXJiaXRyYXJ5LFxuICAgIHN0YXR1czogZmMuY29uc3RhbnRGcm9tPCdwZW5kaW5nJyB8ICdhdHRlbmRpbmcnIHwgJ21heWJlJyB8ICdkZWNsaW5lZCc+KFxuICAgICAgJ3BlbmRpbmcnLFxuICAgICAgJ2F0dGVuZGluZycsXG4gICAgICAnbWF5YmUnLFxuICAgICAgJ2RlY2xpbmVkJ1xuICAgICksXG4gICAgZ3Vlc3RDb3VudDogZmMuaW50ZWdlcih7IG1pbjogMSwgbWF4OiA1MCB9KSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGd1ZXN0IGNvdW50IGFnYWluc3QgYWN0aXZpdHkncyBtYXggZ3Vlc3RzIHBlciBwYXJ0eVxuICAgKi9cbiAgZnVuY3Rpb24gdmFsaWRhdGVHdWVzdENvdW50KFxuICAgIGFjdGl2aXR5OiB7IG1heEd1ZXN0c1BlclBhcnR5OiBudW1iZXIgfCBudWxsOyByZXF1aXJlc0d1ZXN0Q291bnQ6IGJvb2xlYW4gfSxcbiAgICByc3ZwOiB7IHN0YXR1czogc3RyaW5nOyBndWVzdENvdW50OiBudW1iZXIgfVxuICApOiB7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogeyBjb2RlOiBzdHJpbmc7IG1lc3NhZ2U6IHN0cmluZyB9IH0ge1xuICAgIC8vIE9ubHkgdmFsaWRhdGUgZm9yIGF0dGVuZGluZyBzdGF0dXNcbiAgICBpZiAocnN2cC5zdGF0dXMgIT09ICdhdHRlbmRpbmcnKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgbWluaW11bSBndWVzdCBjb3VudCAobXVzdCBiZSBhdCBsZWFzdCAxKVxuICAgIGlmIChyc3ZwLmd1ZXN0Q291bnQgPCAxKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICBjb2RlOiAnSU5WQUxJRF9HVUVTVF9DT1VOVCcsXG4gICAgICAgICAgbWVzc2FnZTogJ0d1ZXN0IGNvdW50IG11c3QgYmUgYXQgbGVhc3QgMScsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIG5vIG1heCBndWVzdHMgcGVyIHBhcnR5IHNldCwgYWNjZXB0IGFueSBwb3NpdGl2ZSBjb3VudFxuICAgIGlmIChhY3Rpdml0eS5tYXhHdWVzdHNQZXJQYXJ0eSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIGd1ZXN0IGNvdW50IGFnYWluc3QgbWF4aW11bVxuICAgIGlmIChyc3ZwLmd1ZXN0Q291bnQgPiBhY3Rpdml0eS5tYXhHdWVzdHNQZXJQYXJ0eSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgY29kZTogJ0dVRVNUX0NPVU5UX0VYQ0VFREVEJyxcbiAgICAgICAgICBtZXNzYWdlOiBgR3Vlc3QgY291bnQgKCR7cnN2cC5ndWVzdENvdW50fSkgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgcGVyIHBhcnR5ICgke2FjdGl2aXR5Lm1heEd1ZXN0c1BlclBhcnR5fSlgLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gIH1cblxuICBpdCgnc2hvdWxkIHJlamVjdCBSU1ZQIHdoZW4gZ3Vlc3QgY291bnQgZXhjZWVkcyBtYXggZ3Vlc3RzIHBlciBwYXJ0eScsICgpID0+IHtcbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5wcm9wZXJ0eShhY3Rpdml0eVdpdGhNYXhHdWVzdHNBcmJpdHJhcnksIHJzdnBXaXRoR3Vlc3RDb3VudEFyYml0cmFyeSwgKGFjdGl2aXR5LCByc3ZwKSA9PiB7XG4gICAgICAgIC8vIFNraXAgaWYgbm8gbWF4IGd1ZXN0cyBwZXIgcGFydHkgc2V0XG4gICAgICAgIGlmIChhY3Rpdml0eS5tYXhHdWVzdHNQZXJQYXJ0eSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBzY2VuYXJpbyB3aGVyZSBndWVzdCBjb3VudCBleGNlZWRzIG1heGltdW1cbiAgICAgICAgY29uc3QgZXhjZXNzaXZlR3Vlc3RDb3VudCA9IGFjdGl2aXR5Lm1heEd1ZXN0c1BlclBhcnR5ICsgZmMuc2FtcGxlKGZjLmludGVnZXIoeyBtaW46IDEsIG1heDogMTAgfSksIDEpWzBdO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlR3Vlc3RDb3VudChhY3Rpdml0eSwge1xuICAgICAgICAgIC4uLnJzdnAsXG4gICAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyxcbiAgICAgICAgICBndWVzdENvdW50OiBleGNlc3NpdmVHdWVzdENvdW50LFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTaG91bGQgYmUgcmVqZWN0ZWRcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9CZURlZmluZWQoKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcj8uY29kZSkudG9CZSgnR1VFU1RfQ09VTlRfRVhDRUVERUQnKTtcbiAgICAgIH0pLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgYWNjZXB0IFJTVlAgd2hlbiBndWVzdCBjb3VudCBpcyB3aXRoaW4gbWF4IGd1ZXN0cyBwZXIgcGFydHknLCAoKSA9PiB7XG4gICAgZmMuYXNzZXJ0KFxuICAgICAgZmMucHJvcGVydHkoYWN0aXZpdHlXaXRoTWF4R3Vlc3RzQXJiaXRyYXJ5LCByc3ZwV2l0aEd1ZXN0Q291bnRBcmJpdHJhcnksIChhY3Rpdml0eSwgcnN2cCkgPT4ge1xuICAgICAgICAvLyBTa2lwIGlmIG5vIG1heCBndWVzdHMgcGVyIHBhcnR5IHNldFxuICAgICAgICBpZiAoYWN0aXZpdHkubWF4R3Vlc3RzUGVyUGFydHkgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgc2NlbmFyaW8gd2hlcmUgZ3Vlc3QgY291bnQgaXMgd2l0aGluIG1heGltdW1cbiAgICAgICAgY29uc3QgdmFsaWRHdWVzdENvdW50ID0gZmMuc2FtcGxlKGZjLmludGVnZXIoeyBtaW46IDEsIG1heDogYWN0aXZpdHkubWF4R3Vlc3RzUGVyUGFydHkgfSksIDEpWzBdO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlR3Vlc3RDb3VudChhY3Rpdml0eSwge1xuICAgICAgICAgIC4uLnJzdnAsXG4gICAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyxcbiAgICAgICAgICBndWVzdENvdW50OiB2YWxpZEd1ZXN0Q291bnQsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNob3VsZCBiZSBhY2NlcHRlZFxuICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQmVVbmRlZmluZWQoKTtcbiAgICAgIH0pLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgYWNjZXB0IGFueSBndWVzdCBjb3VudCB3aGVuIG1heCBndWVzdHMgcGVyIHBhcnR5IGlzIG5vdCBzZXQnLCAoKSA9PiB7XG4gICAgZmMuYXNzZXJ0KFxuICAgICAgZmMucHJvcGVydHkocnN2cFdpdGhHdWVzdENvdW50QXJiaXRyYXJ5LCBmYy5pbnRlZ2VyKHsgbWluOiAxLCBtYXg6IDEwMCB9KSwgKHJzdnAsIGxhcmdlR3Vlc3RDb3VudCkgPT4ge1xuICAgICAgICBjb25zdCBhY3Rpdml0eSA9IHtcbiAgICAgICAgICBtYXhHdWVzdHNQZXJQYXJ0eTogbnVsbCxcbiAgICAgICAgICByZXF1aXJlc0d1ZXN0Q291bnQ6IHRydWUsXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGVHdWVzdENvdW50KGFjdGl2aXR5LCB7XG4gICAgICAgICAgLi4ucnN2cCxcbiAgICAgICAgICBzdGF0dXM6ICdhdHRlbmRpbmcnLFxuICAgICAgICAgIGd1ZXN0Q291bnQ6IGxhcmdlR3Vlc3RDb3VudCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2hvdWxkIGJlIGFjY2VwdGVkIHJlZ2FyZGxlc3Mgb2YgY291bnRcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgICB9KSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIG5vdCB2YWxpZGF0ZSBndWVzdCBjb3VudCBmb3Igbm9uLWF0dGVuZGluZyBzdGF0dXNlcycsICgpID0+IHtcbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5wcm9wZXJ0eShhY3Rpdml0eVdpdGhNYXhHdWVzdHNBcmJpdHJhcnksIHJzdnBXaXRoR3Vlc3RDb3VudEFyYml0cmFyeSwgKGFjdGl2aXR5LCByc3ZwKSA9PiB7XG4gICAgICAgIC8vIFNraXAgaWYgbm8gbWF4IGd1ZXN0cyBwZXIgcGFydHkgc2V0XG4gICAgICAgIGlmIChhY3Rpdml0eS5tYXhHdWVzdHNQZXJQYXJ0eSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlc3Qgd2l0aCBub24tYXR0ZW5kaW5nIHN0YXR1c2VzIGFuZCBleGNlc3NpdmUgZ3Vlc3QgY291bnRcbiAgICAgICAgY29uc3Qgbm9uQXR0ZW5kaW5nU3RhdHVzZXM6IEFycmF5PCdwZW5kaW5nJyB8ICdtYXliZScgfCAnZGVjbGluZWQnPiA9IFsncGVuZGluZycsICdtYXliZScsICdkZWNsaW5lZCddO1xuICAgICAgICBjb25zdCBleGNlc3NpdmVHdWVzdENvdW50ID0gYWN0aXZpdHkubWF4R3Vlc3RzUGVyUGFydHkgKyAxMDtcblxuICAgICAgICBmb3IgKGNvbnN0IHN0YXR1cyBvZiBub25BdHRlbmRpbmdTdGF0dXNlcykge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlR3Vlc3RDb3VudChhY3Rpdml0eSwge1xuICAgICAgICAgICAgLi4ucnN2cCxcbiAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgIGd1ZXN0Q291bnQ6IGV4Y2Vzc2l2ZUd1ZXN0Q291bnQsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBTaG91bGQgYmUgYWNjZXB0ZWQgcmVnYXJkbGVzcyBvZiBndWVzdCBjb3VudFxuICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgaGFuZGxlIGVkZ2UgY2FzZTogZ3Vlc3QgY291bnQgZXhhY3RseSBhdCBtYXhpbXVtJywgKCkgPT4ge1xuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLnByb3BlcnR5KGZjLmludGVnZXIoeyBtaW46IDEsIG1heDogMjAgfSksIChtYXhHdWVzdHNQZXJQYXJ0eSkgPT4ge1xuICAgICAgICBjb25zdCBhY3Rpdml0eSA9IHtcbiAgICAgICAgICBtYXhHdWVzdHNQZXJQYXJ0eSxcbiAgICAgICAgICByZXF1aXJlc0d1ZXN0Q291bnQ6IHRydWUsXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGVHdWVzdENvdW50KGFjdGl2aXR5LCB7XG4gICAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyxcbiAgICAgICAgICBndWVzdENvdW50OiBtYXhHdWVzdHNQZXJQYXJ0eSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2hvdWxkIGJlIGFjY2VwdGVkXG4gICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgfSksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBoYW5kbGUgZWRnZSBjYXNlOiBndWVzdCBjb3VudCBvbmUgb3ZlciBtYXhpbXVtJywgKCkgPT4ge1xuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLnByb3BlcnR5KGZjLmludGVnZXIoeyBtaW46IDEsIG1heDogMjAgfSksIChtYXhHdWVzdHNQZXJQYXJ0eSkgPT4ge1xuICAgICAgICBjb25zdCBhY3Rpdml0eSA9IHtcbiAgICAgICAgICBtYXhHdWVzdHNQZXJQYXJ0eSxcbiAgICAgICAgICByZXF1aXJlc0d1ZXN0Q291bnQ6IHRydWUsXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGVHdWVzdENvdW50KGFjdGl2aXR5LCB7XG4gICAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyxcbiAgICAgICAgICBndWVzdENvdW50OiBtYXhHdWVzdHNQZXJQYXJ0eSArIDEsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNob3VsZCBiZSByZWplY3RlZFxuICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yPy5jb2RlKS50b0JlKCdHVUVTVF9DT1VOVF9FWENFRURFRCcpO1xuICAgICAgfSksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCByZWplY3QgZ3Vlc3QgY291bnQgb2YgemVybycsICgpID0+IHtcbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5wcm9wZXJ0eShhY3Rpdml0eVdpdGhNYXhHdWVzdHNBcmJpdHJhcnksIChhY3Rpdml0eSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZUd1ZXN0Q291bnQoYWN0aXZpdHksIHtcbiAgICAgICAgICBzdGF0dXM6ICdhdHRlbmRpbmcnLFxuICAgICAgICAgIGd1ZXN0Q291bnQ6IDAsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNob3VsZCBiZSByZWplY3RlZFxuICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yPy5jb2RlKS50b0JlKCdJTlZBTElEX0dVRVNUX0NPVU5UJyk7XG4gICAgICB9KSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHJlamVjdCBuZWdhdGl2ZSBndWVzdCBjb3VudCcsICgpID0+IHtcbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5wcm9wZXJ0eShhY3Rpdml0eVdpdGhNYXhHdWVzdHNBcmJpdHJhcnksIGZjLmludGVnZXIoeyBtaW46IC0xMDAsIG1heDogLTEgfSksIChhY3Rpdml0eSwgbmVnYXRpdmVDb3VudCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZUd1ZXN0Q291bnQoYWN0aXZpdHksIHtcbiAgICAgICAgICBzdGF0dXM6ICdhdHRlbmRpbmcnLFxuICAgICAgICAgIGd1ZXN0Q291bnQ6IG5lZ2F0aXZlQ291bnQsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNob3VsZCBiZSByZWplY3RlZFxuICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yPy5jb2RlKS50b0JlKCdJTlZBTElEX0dVRVNUX0NPVU5UJyk7XG4gICAgICB9KSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHByb3ZpZGUgY2xlYXIgZXJyb3IgbWVzc2FnZSB3aXRoIGd1ZXN0IGNvdW50IGRldGFpbHMnLCAoKSA9PiB7XG4gICAgZmMuYXNzZXJ0KFxuICAgICAgZmMucHJvcGVydHkoZmMuaW50ZWdlcih7IG1pbjogMSwgbWF4OiAyMCB9KSwgZmMuaW50ZWdlcih7IG1pbjogMSwgbWF4OiAxMCB9KSwgKG1heEd1ZXN0c1BlclBhcnR5LCBleGNlc3MpID0+IHtcbiAgICAgICAgY29uc3QgYWN0aXZpdHkgPSB7XG4gICAgICAgICAgbWF4R3Vlc3RzUGVyUGFydHksXG4gICAgICAgICAgcmVxdWlyZXNHdWVzdENvdW50OiB0cnVlLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGV4Y2Vzc2l2ZUd1ZXN0Q291bnQgPSBtYXhHdWVzdHNQZXJQYXJ0eSArIGV4Y2VzcztcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZUd1ZXN0Q291bnQoYWN0aXZpdHksIHtcbiAgICAgICAgICBzdGF0dXM6ICdhdHRlbmRpbmcnLFxuICAgICAgICAgIGd1ZXN0Q291bnQ6IGV4Y2Vzc2l2ZUd1ZXN0Q291bnQsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MgJiYgcmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgLy8gRXJyb3IgbWVzc2FnZSBzaG91bGQgaW5jbHVkZSBib3RoIGNvdW50c1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9Db250YWluKGV4Y2Vzc2l2ZUd1ZXN0Q291bnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4obWF4R3Vlc3RzUGVyUGFydHkudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgaGFuZGxlIG1heCBndWVzdHMgcGVyIHBhcnR5IG9mIDEgKHNvbG8gYWN0aXZpdGllcyknLCAoKSA9PiB7XG4gICAgY29uc3QgYWN0aXZpdHkgPSB7XG4gICAgICBtYXhHdWVzdHNQZXJQYXJ0eTogMSxcbiAgICAgIHJlcXVpcmVzR3Vlc3RDb3VudDogdHJ1ZSxcbiAgICB9O1xuXG4gICAgLy8gR3Vlc3QgY291bnQgb2YgMSBzaG91bGQgYmUgYWNjZXB0ZWRcbiAgICBjb25zdCByZXN1bHQxID0gdmFsaWRhdGVHdWVzdENvdW50KGFjdGl2aXR5LCB7XG4gICAgICBzdGF0dXM6ICdhdHRlbmRpbmcnLFxuICAgICAgZ3Vlc3RDb3VudDogMSxcbiAgICB9KTtcbiAgICBleHBlY3QocmVzdWx0MS5zdWNjZXNzKS50b0JlKHRydWUpO1xuXG4gICAgLy8gR3Vlc3QgY291bnQgb2YgMiBzaG91bGQgYmUgcmVqZWN0ZWRcbiAgICBjb25zdCByZXN1bHQyID0gdmFsaWRhdGVHdWVzdENvdW50KGFjdGl2aXR5LCB7XG4gICAgICBzdGF0dXM6ICdhdHRlbmRpbmcnLFxuICAgICAgZ3Vlc3RDb3VudDogMixcbiAgICB9KTtcbiAgICBleHBlY3QocmVzdWx0Mi5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICBleHBlY3QocmVzdWx0Mi5lcnJvcj8uY29kZSkudG9CZSgnR1VFU1RfQ09VTlRfRVhDRUVERUQnKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBoYW5kbGUgbGFyZ2UgbWF4IGd1ZXN0cyBwZXIgcGFydHkgdmFsdWVzJywgKCkgPT4ge1xuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLnByb3BlcnR5KGZjLmludGVnZXIoeyBtaW46IDUwLCBtYXg6IDEwMDAgfSksIChsYXJnZU1heEd1ZXN0cykgPT4ge1xuICAgICAgICBjb25zdCBhY3Rpdml0eSA9IHtcbiAgICAgICAgICBtYXhHdWVzdHNQZXJQYXJ0eTogbGFyZ2VNYXhHdWVzdHMsXG4gICAgICAgICAgcmVxdWlyZXNHdWVzdENvdW50OiB0cnVlLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFueSBjb3VudCB1cCB0byBtYXggc2hvdWxkIGJlIGFjY2VwdGVkXG4gICAgICAgIGNvbnN0IHZhbGlkQ291bnQgPSBmYy5zYW1wbGUoZmMuaW50ZWdlcih7IG1pbjogMSwgbWF4OiBsYXJnZU1heEd1ZXN0cyB9KSwgMSlbMF07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlR3Vlc3RDb3VudChhY3Rpdml0eSwge1xuICAgICAgICAgIHN0YXR1czogJ2F0dGVuZGluZycsXG4gICAgICAgICAgZ3Vlc3RDb3VudDogdmFsaWRDb3VudCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgfSksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBiZSBpZGVtcG90ZW50IC0gbXVsdGlwbGUgdmFsaWRhdGlvbnMgd2l0aCBzYW1lIGlucHV0IHByb2R1Y2Ugc2FtZSByZXN1bHQnLCAoKSA9PiB7XG4gICAgZmMuYXNzZXJ0KFxuICAgICAgZmMucHJvcGVydHkoYWN0aXZpdHlXaXRoTWF4R3Vlc3RzQXJiaXRyYXJ5LCByc3ZwV2l0aEd1ZXN0Q291bnRBcmJpdHJhcnksIChhY3Rpdml0eSwgcnN2cCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQxID0gdmFsaWRhdGVHdWVzdENvdW50KGFjdGl2aXR5LCByc3ZwKTtcbiAgICAgICAgY29uc3QgcmVzdWx0MiA9IHZhbGlkYXRlR3Vlc3RDb3VudChhY3Rpdml0eSwgcnN2cCk7XG5cbiAgICAgICAgLy8gUmVzdWx0cyBzaG91bGQgYmUgaWRlbnRpY2FsXG4gICAgICAgIGV4cGVjdChyZXN1bHQxLnN1Y2Nlc3MpLnRvQmUocmVzdWx0Mi5zdWNjZXNzKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdDEuZXJyb3I/LmNvZGUpLnRvQmUocmVzdWx0Mi5lcnJvcj8uY29kZSk7XG4gICAgICB9KSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHZhbGlkYXRlIGd1ZXN0IGNvdW50IGluZGVwZW5kZW50bHkgb2YgY2FwYWNpdHkgY29uc3RyYWludHMnLCAoKSA9PiB7XG4gICAgZmMuYXNzZXJ0KFxuICAgICAgZmMucHJvcGVydHkoXG4gICAgICAgIGZjLmludGVnZXIoeyBtaW46IDEsIG1heDogMTAgfSksXG4gICAgICAgIGZjLmludGVnZXIoeyBtaW46IDEsIG1heDogMTAwIH0pLFxuICAgICAgICAobWF4R3Vlc3RzUGVyUGFydHksIGFjdGl2aXR5Q2FwYWNpdHkpID0+IHtcbiAgICAgICAgICBjb25zdCBhY3Rpdml0eSA9IHtcbiAgICAgICAgICAgIG1heEd1ZXN0c1BlclBhcnR5LFxuICAgICAgICAgICAgcmVxdWlyZXNHdWVzdENvdW50OiB0cnVlLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBHdWVzdCBjb3VudCB2YWxpZGF0aW9uIHNob3VsZCBub3QgY29uc2lkZXIgYWN0aXZpdHkgY2FwYWNpdHlcbiAgICAgICAgICAvLyBJdCBvbmx5IGNoZWNrcyBhZ2FpbnN0IG1heCBndWVzdHMgcGVyIHBhcnR5XG4gICAgICAgICAgY29uc3QgdmFsaWRHdWVzdENvdW50ID0gbWF4R3Vlc3RzUGVyUGFydHk7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGVHdWVzdENvdW50KGFjdGl2aXR5LCB7XG4gICAgICAgICAgICBzdGF0dXM6ICdhdHRlbmRpbmcnLFxuICAgICAgICAgICAgZ3Vlc3RDb3VudDogdmFsaWRHdWVzdENvdW50LFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gU2hvdWxkIGJlIGFjY2VwdGVkIGJhc2VkIG9uIG1heCBndWVzdHMgcGVyIHBhcnR5IGFsb25lXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJhY3Rpdml0eVdpdGhNYXhHdWVzdHNBcmJpdHJhcnkiLCJmYyIsInJlY29yZCIsImlkIiwidXVpZEFyYml0cmFyeSIsIm5hbWUiLCJzdHJpbmciLCJtaW5MZW5ndGgiLCJtYXhMZW5ndGgiLCJtYXhHdWVzdHNQZXJQYXJ0eSIsIm9wdGlvbiIsImludGVnZXIiLCJtaW4iLCJtYXgiLCJuaWwiLCJyZXF1aXJlc0d1ZXN0Q291bnQiLCJib29sZWFuIiwicnN2cFdpdGhHdWVzdENvdW50QXJiaXRyYXJ5IiwiZ3Vlc3RJZCIsImFjdGl2aXR5SWQiLCJzdGF0dXMiLCJjb25zdGFudEZyb20iLCJndWVzdENvdW50IiwidmFsaWRhdGVHdWVzdENvdW50IiwiYWN0aXZpdHkiLCJyc3ZwIiwic3VjY2VzcyIsImVycm9yIiwiY29kZSIsIm1lc3NhZ2UiLCJpdCIsImFzc2VydCIsInByb3BlcnR5IiwiZXhjZXNzaXZlR3Vlc3RDb3VudCIsInNhbXBsZSIsInJlc3VsdCIsImV4cGVjdCIsInRvQmUiLCJ0b0JlRGVmaW5lZCIsIm51bVJ1bnMiLCJ2YWxpZEd1ZXN0Q291bnQiLCJ0b0JlVW5kZWZpbmVkIiwibGFyZ2VHdWVzdENvdW50Iiwibm9uQXR0ZW5kaW5nU3RhdHVzZXMiLCJuZWdhdGl2ZUNvdW50IiwiZXhjZXNzIiwidG9Db250YWluIiwidG9TdHJpbmciLCJyZXN1bHQxIiwicmVzdWx0MiIsImxhcmdlTWF4R3Vlc3RzIiwidmFsaWRDb3VudCIsImFjdGl2aXR5Q2FwYWNpdHkiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQzs7OzttRUFFbUI7NkJBQ1U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUU5QkEsU0FBUyxvRkFBb0Y7SUFDM0Y7O0dBRUMsR0FDRCxNQUFNQyxpQ0FBaUNDLFdBQUdDLE1BQU0sQ0FBQztRQUMvQ0MsSUFBSUMsMEJBQWE7UUFDakJDLE1BQU1KLFdBQUdLLE1BQU0sQ0FBQztZQUFFQyxXQUFXO1lBQUdDLFdBQVc7UUFBSTtRQUMvQ0MsbUJBQW1CUixXQUFHUyxNQUFNLENBQUNULFdBQUdVLE9BQU8sQ0FBQztZQUFFQyxLQUFLO1lBQUdDLEtBQUs7UUFBRyxJQUFJO1lBQUVDLEtBQUs7UUFBSztRQUMxRUMsb0JBQW9CZCxXQUFHZSxPQUFPO0lBQ2hDO0lBRUE7O0dBRUMsR0FDRCxNQUFNQyw4QkFBOEJoQixXQUFHQyxNQUFNLENBQUM7UUFDNUNnQixTQUFTZCwwQkFBYTtRQUN0QmUsWUFBWWYsMEJBQWE7UUFDekJnQixRQUFRbkIsV0FBR29CLFlBQVksQ0FDckIsV0FDQSxhQUNBLFNBQ0E7UUFFRkMsWUFBWXJCLFdBQUdVLE9BQU8sQ0FBQztZQUFFQyxLQUFLO1lBQUdDLEtBQUs7UUFBRztJQUMzQztJQUVBOztHQUVDLEdBQ0QsU0FBU1UsbUJBQ1BDLFFBQTJFLEVBQzNFQyxJQUE0QztRQUU1QyxxQ0FBcUM7UUFDckMs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