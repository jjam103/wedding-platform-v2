{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/lib/apiHelpers.ts"],"sourcesContent":["import { createServerClient } from '@supabase/ssr';\nimport { cookies } from 'next/headers';\nimport { NextResponse } from 'next/server';\nimport { z } from 'zod';\n\n/**\n * API Helper utilities for consistent route handling\n * \n * Provides:\n * - Authentication verification\n * - Standard error responses\n * - Pagination support\n * - Filtering support\n */\n\nexport interface AuthResult {\n  success: boolean;\n  userId?: string;\n  error?: { code: string; message: string };\n}\n\n/**\n * Verify authentication for API routes\n * \n * @returns AuthResult with userId if authenticated, error otherwise\n */\nexport async function verifyAuth(): Promise<AuthResult> {\n  try {\n    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\n    const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\n\n    if (!supabaseUrl || !supabaseAnonKey) {\n      console.error('[verifyAuth] Missing Supabase environment variables');\n      return {\n        success: false,\n        error: {\n          code: 'UNAUTHORIZED',\n          message: 'Authentication configuration error',\n        },\n      };\n    }\n\n    const cookieStore = await cookies();\n    \n    // Use createServerClient (same as middleware) instead of createRouteHandlerClient\n    const supabase = createServerClient(\n      supabaseUrl,\n      supabaseAnonKey,\n      {\n        cookies: {\n          getAll() {\n            return cookieStore.getAll();\n          },\n          setAll(cookiesToSet) {\n            cookiesToSet.forEach(({ name, value }) => {\n              cookieStore.set(name, value);\n            });\n          },\n        },\n      }\n    );\n    \n    // Use getUser() instead of getSession() for more reliable auth check\n    const { data: { user }, error } = await supabase.auth.getUser();\n\n    if (error || !user) {\n      console.error('[verifyAuth] Authentication failed:', error?.message || 'No user');\n      return {\n        success: false,\n        error: {\n          code: 'UNAUTHORIZED',\n          message: 'Authentication required',\n        },\n      };\n    }\n\n    console.log('[verifyAuth] User authenticated:', user.id);\n    return {\n      success: true,\n      userId: user.id,\n    };\n  } catch (error) {\n    console.error('[verifyAuth] Unexpected error:', error);\n    return {\n      success: false,\n      error: {\n        code: 'UNAUTHORIZED',\n        message: 'Authentication failed',\n      },\n    };\n  }\n}\n\n/**\n * Create standard error response\n * \n * @param code - Error code\n * @param message - Error message\n * @param status - HTTP status code\n * @param details - Optional error details\n * @returns NextResponse with error\n */\nexport function errorResponse(\n  code: string,\n  message: string,\n  status: number,\n  details?: any\n): NextResponse {\n  return NextResponse.json(\n    {\n      success: false,\n      error: {\n        code,\n        message,\n        ...(details && { details }),\n      },\n    },\n    { status }\n  );\n}\n\n/**\n * Create validation error response with field-level details\n * \n * Requirement 13.6: Return HTTP 400 with VALIDATION_ERROR code and field-level error details\n * Requirement 18.1: Display specific field and validation rule that failed\n * \n * @param message - Error message\n * @param fieldErrors - Array of field-level errors\n * @returns NextResponse with validation error\n * \n * @example\n * return validationErrorResponse('Validation failed', [\n *   { field: 'email', message: 'Invalid email format', code: 'invalid_string' },\n *   { field: 'firstName', message: 'Required', code: 'required' }\n * ]);\n */\nexport function validationErrorResponse(\n  message: string = 'Validation failed',\n  fieldErrors: Array<{ field: string; message: string; code?: string }>\n): NextResponse {\n  return NextResponse.json(\n    {\n      success: false,\n      error: {\n        code: 'VALIDATION_ERROR',\n        message,\n        details: {\n          fields: fieldErrors,\n        },\n      },\n    },\n    { status: 400 }\n  );\n}\n\n/**\n * Create standard success response\n * \n * @param data - Response data\n * @param status - HTTP status code (default: 200)\n * @returns NextResponse with data\n */\nexport function successResponse<T>(data: T, status: number = 200): NextResponse {\n  return NextResponse.json(\n    {\n      success: true,\n      data,\n    },\n    { status }\n  );\n}\n\n/**\n * Pagination parameters schema\n */\nexport const paginationSchema = z.object({\n  page: z.coerce.number().int().positive().default(1),\n  pageSize: z.coerce.number().int().positive().max(100).default(50),\n});\n\nexport type PaginationParams = z.infer<typeof paginationSchema>;\n\n/**\n * Parse pagination parameters from URL search params\n * \n * @param searchParams - URL search params\n * @returns Pagination parameters with defaults\n */\nexport function parsePagination(searchParams: URLSearchParams): PaginationParams {\n  const result = paginationSchema.safeParse({\n    page: searchParams.get('page'),\n    pageSize: searchParams.get('pageSize'),\n  });\n\n  if (result.success) {\n    return result.data;\n  }\n\n  // Return defaults if parsing fails\n  return { page: 1, pageSize: 50 };\n}\n\n/**\n * Calculate pagination range for Supabase queries\n * \n * @param page - Page number (1-indexed)\n * @param pageSize - Items per page\n * @returns Object with from and to indices for Supabase range()\n */\nexport function getPaginationRange(page: number, pageSize: number): { from: number; to: number } {\n  const from = (page - 1) * pageSize;\n  const to = from + pageSize - 1;\n  return { from, to };\n}\n\n/**\n * Parse filter parameters from URL search params\n * \n * @param searchParams - URL search params\n * @param allowedFilters - Array of allowed filter keys\n * @returns Object with filter key-value pairs\n */\nexport function parseFilters(\n  searchParams: URLSearchParams,\n  allowedFilters: string[]\n): Record<string, string> {\n  const filters: Record<string, string> = {};\n\n  allowedFilters.forEach((key) => {\n    const value = searchParams.get(key);\n    if (value) {\n      filters[key] = value;\n    }\n  });\n\n  return filters;\n}\n\n/**\n * Validate request body with Zod schema\n * \n * Returns field-level error details for validation failures.\n * Requirement 13.6: Return HTTP 400 with VALIDATION_ERROR code and field-level error details\n * Requirement 18.1: Display specific field and validation rule that failed\n * \n * @param body - Request body\n * @param schema - Zod schema\n * @returns Validation result with field-level error details\n * \n * @example\n * const validation = validateBody(body, createGuestSchema);\n * if (!validation.success) {\n *   // validation.error.details contains field-level errors:\n *   // [{ field: 'email', message: 'Invalid email format', code: 'invalid_string' }]\n *   return errorResponse(validation.error.code, validation.error.message, 400, validation.error.details);\n * }\n */\nexport function validateBody<T extends z.ZodTypeAny>(\n  body: unknown,\n  schema: T\n): { success: true; data: z.infer<T> } | { success: false; error: { code: string; message: string; details: any } } {\n  const validation = schema.safeParse(body);\n\n  if (!validation.success) {\n    // Format field-level errors for better client consumption\n    const fieldErrors = validation.error.issues.map((issue) => ({\n      field: issue.path.join('.'),\n      message: issue.message,\n      code: issue.code,\n    }));\n\n    return {\n      success: false,\n      error: {\n        code: 'VALIDATION_ERROR',\n        message: 'Invalid request data',\n        details: {\n          fields: fieldErrors,\n          raw: validation.error.issues, // Keep raw issues for debugging\n        },\n      },\n    };\n  }\n\n  return {\n    success: true,\n    data: validation.data,\n  };\n}\n\n/**\n * Handle API errors consistently\n * \n * @param error - Error object\n * @returns NextResponse with appropriate error\n */\nexport function handleApiError(error: unknown): NextResponse {\n  console.error('API Error:', error);\n\n  if (error instanceof Error) {\n    // Check for specific error types\n    if (error.message.includes('not found')) {\n      return errorResponse('NOT_FOUND', error.message, 404);\n    }\n    if (error.message.includes('duplicate') || error.message.includes('conflict')) {\n      return errorResponse('CONFLICT', error.message, 409);\n    }\n    if (error.message.includes('unauthorized') || error.message.includes('permission')) {\n      return errorResponse('FORBIDDEN', error.message, 403);\n    }\n\n    return errorResponse('INTERNAL_ERROR', error.message, 500);\n  }\n\n  return errorResponse('UNKNOWN_ERROR', 'An unexpected error occurred', 500);\n}\n\n/**\n * Standard API route handler wrapper\n * \n * Handles authentication, error handling, and response formatting\n * \n * @param handler - Async handler function that receives userId\n * @returns NextResponse\n */\nexport async function withAuth(\n  handler: (userId: string) => Promise<NextResponse>\n): Promise<NextResponse> {\n  try {\n    const auth = await verifyAuth();\n\n    if (!auth.success || !auth.userId) {\n      return errorResponse(\n        auth.error?.code || 'UNAUTHORIZED',\n        auth.error?.message || 'Authentication required',\n        401\n      );\n    }\n\n    return await handler(auth.userId);\n  } catch (error) {\n    return handleApiError(error);\n  }\n}\n"],"names":["errorResponse","getPaginationRange","handleApiError","paginationSchema","parseFilters","parsePagination","successResponse","validateBody","validationErrorResponse","verifyAuth","withAuth","supabaseUrl","process","env","NEXT_PUBLIC_SUPABASE_URL","supabaseAnonKey","NEXT_PUBLIC_SUPABASE_ANON_KEY","console","error","success","code","message","cookieStore","cookies","supabase","createServerClient","getAll","setAll","cookiesToSet","forEach","name","value","set","data","user","auth","getUser","log","id","userId","status","details","NextResponse","json","fieldErrors","fields","z","object","page","coerce","number","int","positive","default","pageSize","max","searchParams","result","safeParse","get","from","to","allowedFilters","filters","key","body","schema","validation","issues","map","issue","field","path","join","raw","Error","includes","handler"],"mappings":"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"}