ad45d9cfc206596eb9ff7619f0016966
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
/**
 * Property-Based Test: Itinerary Chronological Ordering
 * 
 * Feature: destination-wedding-platform
 * Property 35: Itinerary Chronological Ordering
 * 
 * Validates: Requirements 26.2
 * 
 * Property: Activities in an itinerary must always be sorted chronologically
 * by date and time, regardless of the order they were added or retrieved.
 */ describe('Feature: destination-wedding-platform, Property 35: Itinerary Chronological Ordering', ()=>{
    it('should always sort activities chronologically by date and time', ()=>{
        _fastcheck.assert(_fastcheck.property(// Generate array of activities with random dates and times
        _fastcheck.array(_fastcheck.record({
            id: _fastcheck.uuid(),
            name: _fastcheck.string({
                minLength: 1,
                maxLength: 100
            }),
            type: _fastcheck.constantFrom('event', 'activity'),
            date: _fastcheck.date({
                min: new Date('2025-01-01'),
                max: new Date('2025-12-31')
            }).map((d)=>d.toISOString().split('T')[0]),
            time: _fastcheck.date({
                min: new Date('2025-01-01T00:00:00'),
                max: new Date('2025-01-01T23:59:59')
            }).map((d)=>d.toISOString()),
            location: _fastcheck.option(_fastcheck.string({
                minLength: 1,
                maxLength: 100
            }), {
                nil: undefined
            }),
            description: _fastcheck.option(_fastcheck.string({
                minLength: 1,
                maxLength: 500
            }), {
                nil: undefined
            }),
            rsvp_status: _fastcheck.option(_fastcheck.constantFrom('attending', 'declined', 'maybe', 'pending'), {
                nil: undefined
            })
        }), {
            minLength: 1,
            maxLength: 50
        }), (activities)=>{
            // Sort activities chronologically
            const sorted = [
                ...activities
            ].sort((a, b)=>{
                const dateA = new Date(`${a.date}T${new Date(a.time).toISOString().split('T')[1]}`);
                const dateB = new Date(`${b.date}T${new Date(b.time).toISOString().split('T')[1]}`);
                return dateA.getTime() - dateB.getTime();
            });
            // Verify chronological order
            for(let i = 0; i < sorted.length - 1; i++){
                const currentDateTime = new Date(`${sorted[i].date}T${new Date(sorted[i].time).toISOString().split('T')[1]}`);
                const nextDateTime = new Date(`${sorted[i + 1].date}T${new Date(sorted[i + 1].time).toISOString().split('T')[1]}`);
                // Current activity should be before or equal to next activity
                expect(currentDateTime.getTime()).toBeLessThanOrEqual(nextDateTime.getTime());
            }
            // Verify all activities are present
            expect(sorted.length).toBe(activities.length);
            // Verify no activities were lost or duplicated
            const sortedIds = sorted.map((a)=>a.id).sort();
            const originalIds = activities.map((a)=>a.id).sort();
            expect(sortedIds).toEqual(originalIds);
        }), {
            numRuns: 100
        });
    });
    it('should handle activities on the same date sorted by time', ()=>{
        _fastcheck.assert(_fastcheck.property(// Generate activities all on the same date but different times
        _fastcheck.tuple(_fastcheck.date({
            min: new Date('2025-01-01'),
            max: new Date('2025-12-31')
        }).map((d)=>d.toISOString().split('T')[0]), _fastcheck.array(_fastcheck.record({
            id: _fastcheck.uuid(),
            name: _fastcheck.string({
                minLength: 1,
                maxLength: 100
            }),
            type: _fastcheck.constantFrom('event', 'activity'),
            time: _fastcheck.date({
                min: new Date('2025-01-01T00:00:00'),
                max: new Date('2025-01-01T23:59:59')
            }).map((d)=>d.toISOString())
        }), {
            minLength: 2,
            maxLength: 20
        })).map(([date, activities])=>activities.map((a)=>({
                    ...a,
                    date
                }))), (activities)=>{
            // Sort activities by time
            const sorted = [
                ...activities
            ].sort((a, b)=>{
                const timeA = new Date(a.time);
                const timeB = new Date(b.time);
                return timeA.getTime() - timeB.getTime();
            });
            // Verify time order
            for(let i = 0; i < sorted.length - 1; i++){
                const currentTime = new Date(sorted[i].time);
                const nextTime = new Date(sorted[i + 1].time);
                expect(currentTime.getTime()).toBeLessThanOrEqual(nextTime.getTime());
            }
        }), {
            numRuns: 100
        });
    });
    it('should maintain chronological order after filtering', ()=>{
        _fastcheck.assert(_fastcheck.property(_fastcheck.array(_fastcheck.record({
            id: _fastcheck.uuid(),
            name: _fastcheck.string({
                minLength: 1,
                maxLength: 100
            }),
            type: _fastcheck.constantFrom('event', 'activity'),
            date: _fastcheck.date({
                min: new Date('2025-01-01'),
                max: new Date('2025-12-31')
            }).map((d)=>d.toISOString().split('T')[0]),
            time: _fastcheck.date({
                min: new Date('2025-01-01T00:00:00'),
                max: new Date('2025-01-01T23:59:59')
            }).map((d)=>d.toISOString()),
            rsvp_status: _fastcheck.constantFrom('attending', 'declined', 'maybe', 'pending')
        }), {
            minLength: 5,
            maxLength: 50
        }), (activities)=>{
            // Filter to only attending activities
            const filtered = activities.filter((a)=>a.rsvp_status === 'attending');
            if (filtered.length === 0) return; // Skip if no attending activities
            // Sort filtered activities chronologically
            const sorted = [
                ...filtered
            ].sort((a, b)=>{
                const dateA = new Date(`${a.date}T${new Date(a.time).toISOString().split('T')[1]}`);
                const dateB = new Date(`${b.date}T${new Date(b.time).toISOString().split('T')[1]}`);
                return dateA.getTime() - dateB.getTime();
            });
            // Verify chronological order is maintained after filtering
            for(let i = 0; i < sorted.length - 1; i++){
                const currentDateTime = new Date(`${sorted[i].date}T${new Date(sorted[i].time).toISOString().split('T')[1]}`);
                const nextDateTime = new Date(`${sorted[i + 1].date}T${new Date(sorted[i + 1].time).toISOString().split('T')[1]}`);
                expect(currentDateTime.getTime()).toBeLessThanOrEqual(nextDateTime.getTime());
            }
        }), {
            numRuns: 100
        });
    });
    it('should handle edge cases: single activity, identical times, midnight times', ()=>{
        _fastcheck.assert(_fastcheck.property(_fastcheck.oneof(// Single activity
        _fastcheck.array(_fastcheck.record({
            id: _fastcheck.uuid(),
            name: _fastcheck.string({
                minLength: 1,
                maxLength: 100
            }),
            type: _fastcheck.constantFrom('event', 'activity'),
            date: _fastcheck.date({
                min: new Date('2025-01-01'),
                max: new Date('2025-12-31')
            }).map((d)=>d.toISOString().split('T')[0]),
            time: _fastcheck.date({
                min: new Date('2025-01-01T00:00:00'),
                max: new Date('2025-01-01T23:59:59')
            }).map((d)=>d.toISOString())
        }), {
            minLength: 1,
            maxLength: 1
        }), // Activities with identical times
        _fastcheck.tuple(_fastcheck.date({
            min: new Date('2025-01-01'),
            max: new Date('2025-12-31')
        }).map((d)=>d.toISOString().split('T')[0]), _fastcheck.date({
            min: new Date('2025-01-01T00:00:00'),
            max: new Date('2025-01-01T23:59:59')
        }).map((d)=>d.toISOString()), _fastcheck.array(_fastcheck.uuid(), {
            minLength: 2,
            maxLength: 5
        })).map(([date, time, ids])=>ids.map((id)=>({
                    id,
                    name: `Activity ${id}`,
                    type: 'activity',
                    date,
                    time
                }))), // Activities at midnight
        _fastcheck.array(_fastcheck.record({
            id: _fastcheck.uuid(),
            name: _fastcheck.string({
                minLength: 1,
                maxLength: 100
            }),
            type: _fastcheck.constantFrom('event', 'activity'),
            date: _fastcheck.date({
                min: new Date('2025-01-01'),
                max: new Date('2025-12-31')
            }).map((d)=>d.toISOString().split('T')[0])
        }).map((a)=>({
                ...a,
                time: `${a.date}T00:00:00.000Z`
            })), {
            minLength: 1,
            maxLength: 10
        })), (activities)=>{
            // Sort activities chronologically
            const sorted = [
                ...activities
            ].sort((a, b)=>{
                const dateA = new Date(`${a.date}T${new Date(a.time).toISOString().split('T')[1]}`);
                const dateB = new Date(`${b.date}T${new Date(b.time).toISOString().split('T')[1]}`);
                return dateA.getTime() - dateB.getTime();
            });
            // Verify no errors occur and all activities are present
            expect(sorted.length).toBe(activities.length);
            // Verify chronological order (or equal times)
            for(let i = 0; i < sorted.length - 1; i++){
                const currentDateTime = new Date(`${sorted[i].date}T${new Date(sorted[i].time).toISOString().split('T')[1]}`);
                const nextDateTime = new Date(`${sorted[i + 1].date}T${new Date(sorted[i + 1].time).toISOString().split('T')[1]}`);
                expect(currentDateTime.getTime()).toBeLessThanOrEqual(nextDateTime.getTime());
            }
        }), {
            numRuns: 100
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvX190ZXN0c19fL3Byb3BlcnR5L2l0aW5lcmFyeUNocm9ub2xvZ2ljYWxPcmRlcmluZy5wcm9wZXJ0eS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGZjIGZyb20gJ2Zhc3QtY2hlY2snO1xuXG4vKipcbiAqIFByb3BlcnR5LUJhc2VkIFRlc3Q6IEl0aW5lcmFyeSBDaHJvbm9sb2dpY2FsIE9yZGVyaW5nXG4gKiBcbiAqIEZlYXR1cmU6IGRlc3RpbmF0aW9uLXdlZGRpbmctcGxhdGZvcm1cbiAqIFByb3BlcnR5IDM1OiBJdGluZXJhcnkgQ2hyb25vbG9naWNhbCBPcmRlcmluZ1xuICogXG4gKiBWYWxpZGF0ZXM6IFJlcXVpcmVtZW50cyAyNi4yXG4gKiBcbiAqIFByb3BlcnR5OiBBY3Rpdml0aWVzIGluIGFuIGl0aW5lcmFyeSBtdXN0IGFsd2F5cyBiZSBzb3J0ZWQgY2hyb25vbG9naWNhbGx5XG4gKiBieSBkYXRlIGFuZCB0aW1lLCByZWdhcmRsZXNzIG9mIHRoZSBvcmRlciB0aGV5IHdlcmUgYWRkZWQgb3IgcmV0cmlldmVkLlxuICovXG5cbmRlc2NyaWJlKCdGZWF0dXJlOiBkZXN0aW5hdGlvbi13ZWRkaW5nLXBsYXRmb3JtLCBQcm9wZXJ0eSAzNTogSXRpbmVyYXJ5IENocm9ub2xvZ2ljYWwgT3JkZXJpbmcnLCAoKSA9PiB7XG4gIGl0KCdzaG91bGQgYWx3YXlzIHNvcnQgYWN0aXZpdGllcyBjaHJvbm9sb2dpY2FsbHkgYnkgZGF0ZSBhbmQgdGltZScsICgpID0+IHtcbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5wcm9wZXJ0eShcbiAgICAgICAgLy8gR2VuZXJhdGUgYXJyYXkgb2YgYWN0aXZpdGllcyB3aXRoIHJhbmRvbSBkYXRlcyBhbmQgdGltZXNcbiAgICAgICAgZmMuYXJyYXkoXG4gICAgICAgICAgZmMucmVjb3JkKHtcbiAgICAgICAgICAgIGlkOiBmYy51dWlkKCksXG4gICAgICAgICAgICBuYW1lOiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTAwIH0pLFxuICAgICAgICAgICAgdHlwZTogZmMuY29uc3RhbnRGcm9tKCdldmVudCcsICdhY3Rpdml0eScpLFxuICAgICAgICAgICAgZGF0ZTogZmMuZGF0ZSh7IG1pbjogbmV3IERhdGUoJzIwMjUtMDEtMDEnKSwgbWF4OiBuZXcgRGF0ZSgnMjAyNS0xMi0zMScpIH0pLm1hcChkID0+IGQudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdKSxcbiAgICAgICAgICAgIHRpbWU6IGZjLmRhdGUoeyBtaW46IG5ldyBEYXRlKCcyMDI1LTAxLTAxVDAwOjAwOjAwJyksIG1heDogbmV3IERhdGUoJzIwMjUtMDEtMDFUMjM6NTk6NTknKSB9KS5tYXAoZCA9PiBkLnRvSVNPU3RyaW5nKCkpLFxuICAgICAgICAgICAgbG9jYXRpb246IGZjLm9wdGlvbihmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTAwIH0pLCB7IG5pbDogdW5kZWZpbmVkIH0pLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGZjLm9wdGlvbihmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogNTAwIH0pLCB7IG5pbDogdW5kZWZpbmVkIH0pLFxuICAgICAgICAgICAgcnN2cF9zdGF0dXM6IGZjLm9wdGlvbihmYy5jb25zdGFudEZyb20oJ2F0dGVuZGluZycsICdkZWNsaW5lZCcsICdtYXliZScsICdwZW5kaW5nJyksIHsgbmlsOiB1bmRlZmluZWQgfSksXG4gICAgICAgICAgfSksXG4gICAgICAgICAgeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogNTAgfVxuICAgICAgICApLFxuICAgICAgICAoYWN0aXZpdGllcykgPT4ge1xuICAgICAgICAgIC8vIFNvcnQgYWN0aXZpdGllcyBjaHJvbm9sb2dpY2FsbHlcbiAgICAgICAgICBjb25zdCBzb3J0ZWQgPSBbLi4uYWN0aXZpdGllc10uc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0ZUEgPSBuZXcgRGF0ZShgJHthLmRhdGV9VCR7bmV3IERhdGUoYS50aW1lKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMV19YCk7XG4gICAgICAgICAgICBjb25zdCBkYXRlQiA9IG5ldyBEYXRlKGAke2IuZGF0ZX1UJHtuZXcgRGF0ZShiLnRpbWUpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVsxXX1gKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRlQS5nZXRUaW1lKCkgLSBkYXRlQi5nZXRUaW1lKCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBWZXJpZnkgY2hyb25vbG9naWNhbCBvcmRlclxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc29ydGVkLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudERhdGVUaW1lID0gbmV3IERhdGUoYCR7c29ydGVkW2ldLmRhdGV9VCR7bmV3IERhdGUoc29ydGVkW2ldLnRpbWUpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVsxXX1gKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHREYXRlVGltZSA9IG5ldyBEYXRlKGAke3NvcnRlZFtpICsgMV0uZGF0ZX1UJHtuZXcgRGF0ZShzb3J0ZWRbaSArIDFdLnRpbWUpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVsxXX1gKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ3VycmVudCBhY3Rpdml0eSBzaG91bGQgYmUgYmVmb3JlIG9yIGVxdWFsIHRvIG5leHQgYWN0aXZpdHlcbiAgICAgICAgICAgIGV4cGVjdChjdXJyZW50RGF0ZVRpbWUuZ2V0VGltZSgpKS50b0JlTGVzc1RoYW5PckVxdWFsKG5leHREYXRlVGltZS5nZXRUaW1lKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFZlcmlmeSBhbGwgYWN0aXZpdGllcyBhcmUgcHJlc2VudFxuICAgICAgICAgIGV4cGVjdChzb3J0ZWQubGVuZ3RoKS50b0JlKGFjdGl2aXRpZXMubGVuZ3RoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBWZXJpZnkgbm8gYWN0aXZpdGllcyB3ZXJlIGxvc3Qgb3IgZHVwbGljYXRlZFxuICAgICAgICAgIGNvbnN0IHNvcnRlZElkcyA9IHNvcnRlZC5tYXAoYSA9PiBhLmlkKS5zb3J0KCk7XG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWxJZHMgPSBhY3Rpdml0aWVzLm1hcChhID0+IGEuaWQpLnNvcnQoKTtcbiAgICAgICAgICBleHBlY3Qoc29ydGVkSWRzKS50b0VxdWFsKG9yaWdpbmFsSWRzKTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGhhbmRsZSBhY3Rpdml0aWVzIG9uIHRoZSBzYW1lIGRhdGUgc29ydGVkIGJ5IHRpbWUnLCAoKSA9PiB7XG4gICAgZmMuYXNzZXJ0KFxuICAgICAgZmMucHJvcGVydHkoXG4gICAgICAgIC8vIEdlbmVyYXRlIGFjdGl2aXRpZXMgYWxsIG9uIHRoZSBzYW1lIGRhdGUgYnV0IGRpZmZlcmVudCB0aW1lc1xuICAgICAgICBmYy50dXBsZShcbiAgICAgICAgICBmYy5kYXRlKHsgbWluOiBuZXcgRGF0ZSgnMjAyNS0wMS0wMScpLCBtYXg6IG5ldyBEYXRlKCcyMDI1LTEyLTMxJykgfSkubWFwKGQgPT4gZC50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0pLFxuICAgICAgICAgIGZjLmFycmF5KFxuICAgICAgICAgICAgZmMucmVjb3JkKHtcbiAgICAgICAgICAgICAgaWQ6IGZjLnV1aWQoKSxcbiAgICAgICAgICAgICAgbmFtZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwMCB9KSxcbiAgICAgICAgICAgICAgdHlwZTogZmMuY29uc3RhbnRGcm9tKCdldmVudCcsICdhY3Rpdml0eScpLFxuICAgICAgICAgICAgICB0aW1lOiBmYy5kYXRlKHsgbWluOiBuZXcgRGF0ZSgnMjAyNS0wMS0wMVQwMDowMDowMCcpLCBtYXg6IG5ldyBEYXRlKCcyMDI1LTAxLTAxVDIzOjU5OjU5JykgfSkubWFwKGQgPT4gZC50b0lTT1N0cmluZygpKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgeyBtaW5MZW5ndGg6IDIsIG1heExlbmd0aDogMjAgfVxuICAgICAgICAgIClcbiAgICAgICAgKS5tYXAoKFtkYXRlLCBhY3Rpdml0aWVzXSkgPT4gYWN0aXZpdGllcy5tYXAoYSA9PiAoeyAuLi5hLCBkYXRlIH0pKSksXG4gICAgICAgIChhY3Rpdml0aWVzKSA9PiB7XG4gICAgICAgICAgLy8gU29ydCBhY3Rpdml0aWVzIGJ5IHRpbWVcbiAgICAgICAgICBjb25zdCBzb3J0ZWQgPSBbLi4uYWN0aXZpdGllc10uc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGltZUEgPSBuZXcgRGF0ZShhLnRpbWUpO1xuICAgICAgICAgICAgY29uc3QgdGltZUIgPSBuZXcgRGF0ZShiLnRpbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVBLmdldFRpbWUoKSAtIHRpbWVCLmdldFRpbWUoKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIFZlcmlmeSB0aW1lIG9yZGVyXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3J0ZWQubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKHNvcnRlZFtpXS50aW1lKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRUaW1lID0gbmV3IERhdGUoc29ydGVkW2kgKyAxXS50aW1lKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KGN1cnJlbnRUaW1lLmdldFRpbWUoKSkudG9CZUxlc3NUaGFuT3JFcXVhbChuZXh0VGltZS5nZXRUaW1lKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIG1haW50YWluIGNocm9ub2xvZ2ljYWwgb3JkZXIgYWZ0ZXIgZmlsdGVyaW5nJywgKCkgPT4ge1xuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICBmYy5hcnJheShcbiAgICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgICAgaWQ6IGZjLnV1aWQoKSxcbiAgICAgICAgICAgIG5hbWU6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxMDAgfSksXG4gICAgICAgICAgICB0eXBlOiBmYy5jb25zdGFudEZyb20oJ2V2ZW50JywgJ2FjdGl2aXR5JyksXG4gICAgICAgICAgICBkYXRlOiBmYy5kYXRlKHsgbWluOiBuZXcgRGF0ZSgnMjAyNS0wMS0wMScpLCBtYXg6IG5ldyBEYXRlKCcyMDI1LTEyLTMxJykgfSkubWFwKGQgPT4gZC50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0pLFxuICAgICAgICAgICAgdGltZTogZmMuZGF0ZSh7IG1pbjogbmV3IERhdGUoJzIwMjUtMDEtMDFUMDA6MDA6MDAnKSwgbWF4OiBuZXcgRGF0ZSgnMjAyNS0wMS0wMVQyMzo1OTo1OScpIH0pLm1hcChkID0+IGQudG9JU09TdHJpbmcoKSksXG4gICAgICAgICAgICByc3ZwX3N0YXR1czogZmMuY29uc3RhbnRGcm9tKCdhdHRlbmRpbmcnLCAnZGVjbGluZWQnLCAnbWF5YmUnLCAncGVuZGluZycpLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHsgbWluTGVuZ3RoOiA1LCBtYXhMZW5ndGg6IDUwIH1cbiAgICAgICAgKSxcbiAgICAgICAgKGFjdGl2aXRpZXMpID0+IHtcbiAgICAgICAgICAvLyBGaWx0ZXIgdG8gb25seSBhdHRlbmRpbmcgYWN0aXZpdGllc1xuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gYWN0aXZpdGllcy5maWx0ZXIoYSA9PiBhLnJzdnBfc3RhdHVzID09PSAnYXR0ZW5kaW5nJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGZpbHRlcmVkLmxlbmd0aCA9PT0gMCkgcmV0dXJuOyAvLyBTa2lwIGlmIG5vIGF0dGVuZGluZyBhY3Rpdml0aWVzXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU29ydCBmaWx0ZXJlZCBhY3Rpdml0aWVzIGNocm9ub2xvZ2ljYWxseVxuICAgICAgICAgIGNvbnN0IHNvcnRlZCA9IFsuLi5maWx0ZXJlZF0uc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0ZUEgPSBuZXcgRGF0ZShgJHthLmRhdGV9VCR7bmV3IERhdGUoYS50aW1lKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMV19YCk7XG4gICAgICAgICAgICBjb25zdCBkYXRlQiA9IG5ldyBEYXRlKGAke2IuZGF0ZX1UJHtuZXcgRGF0ZShiLnRpbWUpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVsxXX1gKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRlQS5nZXRUaW1lKCkgLSBkYXRlQi5nZXRUaW1lKCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBWZXJpZnkgY2hyb25vbG9naWNhbCBvcmRlciBpcyBtYWludGFpbmVkIGFmdGVyIGZpbHRlcmluZ1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc29ydGVkLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudERhdGVUaW1lID0gbmV3IERhdGUoYCR7c29ydGVkW2ldLmRhdGV9VCR7bmV3IERhdGUoc29ydGVkW2ldLnRpbWUpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVsxXX1gKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHREYXRlVGltZSA9IG5ldyBEYXRlKGAke3NvcnRlZFtpICsgMV0uZGF0ZX1UJHtuZXcgRGF0ZShzb3J0ZWRbaSArIDFdLnRpbWUpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVsxXX1gKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KGN1cnJlbnREYXRlVGltZS5nZXRUaW1lKCkpLnRvQmVMZXNzVGhhbk9yRXF1YWwobmV4dERhdGVUaW1lLmdldFRpbWUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgaGFuZGxlIGVkZ2UgY2FzZXM6IHNpbmdsZSBhY3Rpdml0eSwgaWRlbnRpY2FsIHRpbWVzLCBtaWRuaWdodCB0aW1lcycsICgpID0+IHtcbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5wcm9wZXJ0eShcbiAgICAgICAgZmMub25lb2YoXG4gICAgICAgICAgLy8gU2luZ2xlIGFjdGl2aXR5XG4gICAgICAgICAgZmMuYXJyYXkoXG4gICAgICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgICAgICBpZDogZmMudXVpZCgpLFxuICAgICAgICAgICAgICBuYW1lOiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTAwIH0pLFxuICAgICAgICAgICAgICB0eXBlOiBmYy5jb25zdGFudEZyb20oJ2V2ZW50JywgJ2FjdGl2aXR5JyksXG4gICAgICAgICAgICAgIGRhdGU6IGZjLmRhdGUoeyBtaW46IG5ldyBEYXRlKCcyMDI1LTAxLTAxJyksIG1heDogbmV3IERhdGUoJzIwMjUtMTItMzEnKSB9KS5tYXAoZCA9PiBkLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSksXG4gICAgICAgICAgICAgIHRpbWU6IGZjLmRhdGUoeyBtaW46IG5ldyBEYXRlKCcyMDI1LTAxLTAxVDAwOjAwOjAwJyksIG1heDogbmV3IERhdGUoJzIwMjUtMDEtMDFUMjM6NTk6NTknKSB9KS5tYXAoZCA9PiBkLnRvSVNPU3RyaW5nKCkpLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxIH1cbiAgICAgICAgICApLFxuICAgICAgICAgIC8vIEFjdGl2aXRpZXMgd2l0aCBpZGVudGljYWwgdGltZXNcbiAgICAgICAgICBmYy50dXBsZShcbiAgICAgICAgICAgIGZjLmRhdGUoeyBtaW46IG5ldyBEYXRlKCcyMDI1LTAxLTAxJyksIG1heDogbmV3IERhdGUoJzIwMjUtMTItMzEnKSB9KS5tYXAoZCA9PiBkLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSksXG4gICAgICAgICAgICBmYy5kYXRlKHsgbWluOiBuZXcgRGF0ZSgnMjAyNS0wMS0wMVQwMDowMDowMCcpLCBtYXg6IG5ldyBEYXRlKCcyMDI1LTAxLTAxVDIzOjU5OjU5JykgfSkubWFwKGQgPT4gZC50b0lTT1N0cmluZygpKSxcbiAgICAgICAgICAgIGZjLmFycmF5KGZjLnV1aWQoKSwgeyBtaW5MZW5ndGg6IDIsIG1heExlbmd0aDogNSB9KVxuICAgICAgICAgICkubWFwKChbZGF0ZSwgdGltZSwgaWRzXSkgPT4gaWRzLm1hcChpZCA9PiAoe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBuYW1lOiBgQWN0aXZpdHkgJHtpZH1gLFxuICAgICAgICAgICAgdHlwZTogJ2FjdGl2aXR5JyBhcyBjb25zdCxcbiAgICAgICAgICAgIGRhdGUsXG4gICAgICAgICAgICB0aW1lLFxuICAgICAgICAgIH0pKSksXG4gICAgICAgICAgLy8gQWN0aXZpdGllcyBhdCBtaWRuaWdodFxuICAgICAgICAgIGZjLmFycmF5KFxuICAgICAgICAgICAgZmMucmVjb3JkKHtcbiAgICAgICAgICAgICAgaWQ6IGZjLnV1aWQoKSxcbiAgICAgICAgICAgICAgbmFtZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwMCB9KSxcbiAgICAgICAgICAgICAgdHlwZTogZmMuY29uc3RhbnRGcm9tKCdldmVudCcsICdhY3Rpdml0eScpLFxuICAgICAgICAgICAgICBkYXRlOiBmYy5kYXRlKHsgbWluOiBuZXcgRGF0ZSgnMjAyNS0wMS0wMScpLCBtYXg6IG5ldyBEYXRlKCcyMDI1LTEyLTMxJykgfSkubWFwKGQgPT4gZC50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0pLFxuICAgICAgICAgICAgfSkubWFwKGEgPT4gKHsgLi4uYSwgdGltZTogYCR7YS5kYXRlfVQwMDowMDowMC4wMDBaYCB9KSksXG4gICAgICAgICAgICB7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxMCB9XG4gICAgICAgICAgKVxuICAgICAgICApLFxuICAgICAgICAoYWN0aXZpdGllcykgPT4ge1xuICAgICAgICAgIC8vIFNvcnQgYWN0aXZpdGllcyBjaHJvbm9sb2dpY2FsbHlcbiAgICAgICAgICBjb25zdCBzb3J0ZWQgPSBbLi4uYWN0aXZpdGllc10uc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0ZUEgPSBuZXcgRGF0ZShgJHthLmRhdGV9VCR7bmV3IERhdGUoYS50aW1lKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMV19YCk7XG4gICAgICAgICAgICBjb25zdCBkYXRlQiA9IG5ldyBEYXRlKGAke2IuZGF0ZX1UJHtuZXcgRGF0ZShiLnRpbWUpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVsxXX1gKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRlQS5nZXRUaW1lKCkgLSBkYXRlQi5nZXRUaW1lKCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBWZXJpZnkgbm8gZXJyb3JzIG9jY3VyIGFuZCBhbGwgYWN0aXZpdGllcyBhcmUgcHJlc2VudFxuICAgICAgICAgIGV4cGVjdChzb3J0ZWQubGVuZ3RoKS50b0JlKGFjdGl2aXRpZXMubGVuZ3RoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBWZXJpZnkgY2hyb25vbG9naWNhbCBvcmRlciAob3IgZXF1YWwgdGltZXMpXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3J0ZWQubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RGF0ZVRpbWUgPSBuZXcgRGF0ZShgJHtzb3J0ZWRbaV0uZGF0ZX1UJHtuZXcgRGF0ZShzb3J0ZWRbaV0udGltZSkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzFdfWApO1xuICAgICAgICAgICAgY29uc3QgbmV4dERhdGVUaW1lID0gbmV3IERhdGUoYCR7c29ydGVkW2kgKyAxXS5kYXRlfVQke25ldyBEYXRlKHNvcnRlZFtpICsgMV0udGltZSkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzFdfWApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHBlY3QoY3VycmVudERhdGVUaW1lLmdldFRpbWUoKSkudG9CZUxlc3NUaGFuT3JFcXVhbChuZXh0RGF0ZVRpbWUuZ2V0VGltZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJkZXNjcmliZSIsIml0IiwiZmMiLCJhc3NlcnQiLCJwcm9wZXJ0eSIsImFycmF5IiwicmVjb3JkIiwiaWQiLCJ1dWlkIiwibmFtZSIsInN0cmluZyIsIm1pbkxlbmd0aCIsIm1heExlbmd0aCIsInR5cGUiLCJjb25zdGFudEZyb20iLCJkYXRlIiwibWluIiwiRGF0ZSIsIm1heCIsIm1hcCIsImQiLCJ0b0lTT1N0cmluZyIsInNwbGl0IiwidGltZSIsImxvY2F0aW9uIiwib3B0aW9uIiwibmlsIiwidW5kZWZpbmVkIiwiZGVzY3JpcHRpb24iLCJyc3ZwX3N0YXR1cyIsImFjdGl2aXRpZXMiLCJzb3J0ZWQiLCJzb3J0IiwiYSIsImIiLCJkYXRlQSIsImRhdGVCIiwiZ2V0VGltZSIsImkiLCJsZW5ndGgiLCJjdXJyZW50RGF0ZVRpbWUiLCJuZXh0RGF0ZVRpbWUiLCJleHBlY3QiLCJ0b0JlTGVzc1RoYW5PckVxdWFsIiwidG9CZSIsInNvcnRlZElkcyIsIm9yaWdpbmFsSWRzIiwidG9FcXVhbCIsIm51bVJ1bnMiLCJ0dXBsZSIsInRpbWVBIiwidGltZUIiLCJjdXJyZW50VGltZSIsIm5leHRUaW1lIiwiZmlsdGVyZWQi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