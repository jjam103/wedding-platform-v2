{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/__tests__/helpers/testIsolation.test.ts"],"sourcesContent":["/**\n * Test Isolation Utilities Tests\n * \n * Validates that test isolation utilities work correctly for parallel execution.\n */\n\nimport {\n  generateTestId,\n  generateTestEmail,\n  generateTestSlug,\n  createCleanupTracker,\n  createTestNamespace,\n  waitFor,\n  retry,\n  getWorkerId,\n  isCI,\n  getTestMode,\n} from './testIsolation';\n\ndescribe('Test Isolation Utilities', () => {\n  describe('generateTestId', () => {\n    it('should generate unique IDs', () => {\n      const id1 = generateTestId('test');\n      const id2 = generateTestId('test');\n      \n      expect(id1).not.toBe(id2);\n      expect(id1).toMatch(/^test-[a-f0-9]+-[a-z0-9]+-w\\d+$/);\n    });\n    \n    it('should include worker ID', () => {\n      const id = generateTestId('test');\n      const workerId = process.env.JEST_WORKER_ID || '0';\n      \n      expect(id).toContain(`-w${workerId}`);\n    });\n    \n    it('should use custom prefix', () => {\n      const id = generateTestId('custom');\n      \n      expect(id).toMatch(/^custom-/);\n    });\n  });\n  \n  describe('generateTestEmail', () => {\n    it('should generate unique emails', () => {\n      const email1 = generateTestEmail('user');\n      const email2 = generateTestEmail('user');\n      \n      expect(email1).not.toBe(email2);\n      expect(email1).toMatch(/^user-[a-f0-9]+-[a-z0-9]+-w\\d+@test\\.example\\.com$/);\n    });\n    \n    it('should be valid email format', () => {\n      const email = generateTestEmail('test');\n      \n      expect(email).toContain('@');\n      expect(email).toContain('test.example.com');\n    });\n  });\n  \n  describe('generateTestSlug', () => {\n    it('should generate unique slugs', () => {\n      const slug1 = generateTestSlug('page');\n      const slug2 = generateTestSlug('page');\n      \n      expect(slug1).not.toBe(slug2);\n      expect(slug1).toMatch(/^page-[a-f0-9]+-[a-z0-9]+-w\\d+$/);\n    });\n  });\n  \n  describe('createCleanupTracker', () => {\n    it('should track resources', () => {\n      const tracker = createCleanupTracker();\n      \n      tracker.track('guests', 'guest-1');\n      tracker.track('guests', 'guest-2');\n      tracker.track('events', 'event-1');\n      \n      expect(tracker.getTracked('guests')).toEqual(['guest-1', 'guest-2']);\n      expect(tracker.getTracked('events')).toEqual(['event-1']);\n    });\n    \n    it('should not track duplicates', () => {\n      const tracker = createCleanupTracker();\n      \n      tracker.track('guests', 'guest-1');\n      tracker.track('guests', 'guest-1');\n      \n      expect(tracker.getTracked('guests')).toEqual(['guest-1']);\n    });\n    \n    it('should clear tracking', () => {\n      const tracker = createCleanupTracker();\n      \n      tracker.track('guests', 'guest-1');\n      tracker.clear();\n      \n      expect(tracker.getTracked('guests')).toEqual([]);\n    });\n    \n    it('should cleanup resources', async () => {\n      const tracker = createCleanupTracker();\n      const mockSupabase = {\n        from: jest.fn().mockReturnValue({\n          delete: jest.fn().mockReturnValue({\n            in: jest.fn().mockResolvedValue({ error: null }),\n          }),\n        }),\n      };\n      \n      tracker.track('guests', 'guest-1');\n      tracker.track('guests', 'guest-2');\n      \n      await tracker.cleanupAll(mockSupabase);\n      \n      expect(mockSupabase.from).toHaveBeenCalledWith('guests');\n    });\n    \n    it('should handle cleanup errors gracefully', async () => {\n      const tracker = createCleanupTracker();\n      const mockSupabase = {\n        from: jest.fn().mockReturnValue({\n          delete: jest.fn().mockReturnValue({\n            in: jest.fn().mockResolvedValue({ \n              error: { message: 'Cleanup failed' } \n            }),\n          }),\n        }),\n      };\n      \n      tracker.track('guests', 'guest-1');\n      \n      // Should not throw\n      await expect(tracker.cleanupAll(mockSupabase)).resolves.not.toThrow();\n    });\n  });\n  \n  describe('createTestNamespace', () => {\n    it('should create namespaced identifiers', () => {\n      const ns = createTestNamespace('flow');\n      \n      expect(ns.id).toMatch(/^flow-/);\n      expect(ns.name('test')).toContain(ns.id);\n      expect(ns.email('user')).toContain(ns.id);\n      expect(ns.slug('page')).toContain(ns.id);\n      expect(ns.subId('sub')).toContain(ns.id);\n    });\n    \n    it('should generate consistent namespace', () => {\n      const ns = createTestNamespace('test');\n      \n      const name1 = ns.name('item');\n      const name2 = ns.name('item');\n      \n      expect(name1).toBe(name2);\n    });\n    \n    it('should generate valid emails', () => {\n      const ns = createTestNamespace('test');\n      const email = ns.email('john');\n      \n      expect(email).toMatch(/@test\\.example\\.com$/);\n      expect(email).toContain(ns.id);\n    });\n  });\n  \n  describe('waitFor', () => {\n    it('should resolve when condition is met', async () => {\n      let value = false;\n      setTimeout(() => { value = true; }, 100);\n      \n      await expect(waitFor(() => value, 1000)).resolves.not.toThrow();\n    });\n    \n    it('should timeout if condition not met', async () => {\n      await expect(\n        waitFor(() => false, 100)\n      ).rejects.toThrow('Timeout waiting for condition');\n    });\n    \n    it('should support async conditions', async () => {\n      let value = false;\n      setTimeout(() => { value = true; }, 100);\n      \n      await expect(\n        waitFor(async () => value, 1000)\n      ).resolves.not.toThrow();\n    });\n  });\n  \n  describe('retry', () => {\n    it('should succeed on first try', async () => {\n      const fn = jest.fn().mockResolvedValue('success');\n      \n      const result = await retry(fn, 3, 10);\n      \n      expect(result).toBe('success');\n      expect(fn).toHaveBeenCalledTimes(1);\n    });\n    \n    it('should retry on failure', async () => {\n      const fn = jest.fn()\n        .mockRejectedValueOnce(new Error('Fail 1'))\n        .mockRejectedValueOnce(new Error('Fail 2'))\n        .mockResolvedValue('success');\n      \n      const result = await retry(fn, 3, 10);\n      \n      expect(result).toBe('success');\n      expect(fn).toHaveBeenCalledTimes(3);\n    });\n    \n    it('should throw after max retries', async () => {\n      const fn = jest.fn().mockRejectedValue(new Error('Always fails'));\n      \n      await expect(retry(fn, 2, 10)).rejects.toThrow('Always fails');\n      expect(fn).toHaveBeenCalledTimes(3); // Initial + 2 retries\n    });\n    \n    it('should use exponential backoff', async () => {\n      const fn = jest.fn()\n        .mockRejectedValueOnce(new Error('Fail'))\n        .mockResolvedValue('success');\n      \n      const startTime = Date.now();\n      await retry(fn, 2, 100);\n      const duration = Date.now() - startTime;\n      \n      // Should wait at least 100ms for first retry\n      expect(duration).toBeGreaterThanOrEqual(100);\n    });\n  });\n  \n  describe('getWorkerId', () => {\n    it('should return worker ID', () => {\n      const workerId = getWorkerId();\n      \n      expect(workerId).toBeDefined();\n      expect(typeof workerId).toBe('string');\n    });\n  });\n  \n  describe('isCI', () => {\n    it('should detect CI environment', () => {\n      const originalCI = process.env.CI;\n      \n      process.env.CI = 'true';\n      expect(isCI()).toBe(true);\n      \n      process.env.CI = 'false';\n      expect(isCI()).toBe(false);\n      \n      delete process.env.CI;\n      expect(isCI()).toBe(false);\n      \n      // Restore\n      if (originalCI !== undefined) {\n        process.env.CI = originalCI;\n      }\n    });\n  });\n  \n  describe('getTestMode', () => {\n    it('should detect parallel mode', () => {\n      const mode = getTestMode();\n      \n      expect(mode).toMatch(/^(parallel|serial)$/);\n      \n      if (process.env.JEST_WORKER_ID) {\n        expect(mode).toBe('parallel');\n      } else {\n        expect(mode).toBe('serial');\n      }\n    });\n  });\n});\n"],"names":["describe","it","id1","generateTestId","id2","expect","not","toBe","toMatch","id","workerId","process","env","JEST_WORKER_ID","toContain","email1","generateTestEmail","email2","email","slug1","generateTestSlug","slug2","tracker","createCleanupTracker","track","getTracked","toEqual","clear","mockSupabase","from","jest","fn","mockReturnValue","delete","in","mockResolvedValue","error","cleanupAll","toHaveBeenCalledWith","message","resolves","toThrow","ns","createTestNamespace","name","slug","subId","name1","name2","value","setTimeout","waitFor","rejects","result","retry","toHaveBeenCalledTimes","mockRejectedValueOnce","Error","mockRejectedValue","startTime","Date","now","duration","toBeGreaterThanOrEqual","getWorkerId","toBeDefined","originalCI","CI","isCI","undefined","mode","getTestMode"],"mappings":"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"}