9e77b273204e22751bee26365c212e9f
/**
 * API Route Contract Tests
 * 
 * These tests validate that all API routes follow required patterns.
 * They catch common mistakes like forgetting to await params or missing auth.
 * 
 * Why this exists:
 * - Next.js 16 made params async, easy to forget await
 * - Auth checks should be consistent across all admin routes
 * - All routes should return Result<T> format
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _promises = require("node:fs/promises");
const _path = require("path");
describe('API Route Contracts', ()=>{
    describe('Dynamic Route Params', ()=>{
        it('all dynamic routes should await params', async ()=>{
            const dynamicRoutes = await findDynamicRoutes('app/api');
            expect(dynamicRoutes.length).toBeGreaterThan(0);
            for (const routePath of dynamicRoutes){
                const content = await (0, _promises.readFile)(routePath, 'utf-8');
                // Check if route uses params
                if (content.includes('params:') || content.includes('{ params }')) {
                    // Should have 'await params' or 'const resolvedParams = await params'
                    const hasAwaitParams = content.includes('await params') || content.includes('resolvedParams = await params');
                    expect(hasAwaitParams).toBe(true);
                    if (!hasAwaitParams) {
                        fail(`Route ${routePath} uses params but doesn't await it`);
                    }
                }
            }
        });
        it('dynamic routes should use resolvedParams pattern', async ()=>{
            const dynamicRoutes = await findDynamicRoutes('app/api');
            for (const routePath of dynamicRoutes){
                const content = await (0, _promises.readFile)(routePath, 'utf-8');
                if (content.includes('params:')) {
                    // Recommended pattern: const resolvedParams = await params;
                    const hasResolvedParams = content.includes('resolvedParams');
                    if (!hasResolvedParams) {
                        console.warn(`Route ${routePath} should use 'resolvedParams' pattern for clarity`);
                    }
                }
            }
        });
    });
    describe('Authentication', ()=>{
        it('all admin routes should call verifyAuth', async ()=>{
            const adminRoutes = await findAllRoutes('app/api/admin');
            expect(adminRoutes.length).toBeGreaterThan(0);
            for (const routePath of adminRoutes){
                const content = await (0, _promises.readFile)(routePath, 'utf-8');
                // Should call verifyAuth() or have auth check
                const hasAuth = content.includes('verifyAuth()') || content.includes('getSession()') || content.includes('auth.getUser()');
                expect(hasAuth).toBe(true);
                if (!hasAuth) {
                    fail(`Admin route ${routePath} is missing authentication check`);
                }
            }
        });
        it('auth should be checked before params resolution', async ()=>{
            const dynamicRoutes = await findDynamicRoutes('app/api/admin');
            for (const routePath of dynamicRoutes){
                const content = await (0, _promises.readFile)(routePath, 'utf-8');
                if (content.includes('verifyAuth') && content.includes('await params')) {
                    // Find positions
                    const authPos = content.indexOf('verifyAuth');
                    const paramsPos = content.indexOf('await params');
                    // Auth should come before params
                    expect(authPos).toBeLessThan(paramsPos);
                    if (authPos >= paramsPos) {
                        console.warn(`Route ${routePath} should check auth before resolving params`);
                    }
                }
            }
        });
    });
    describe('Response Format', ()=>{
        it('all routes should return Result<T> format', async ()=>{
            const allRoutes = await findAllRoutes('app/api');
            for (const routePath of allRoutes){
                const content = await (0, _promises.readFile)(routePath, 'utf-8');
                // Check for Result<T> return type
                const hasResultType = content.includes('Result<') || content.includes('success: true') || content.includes('success: false');
                expect(hasResultType).toBe(true);
                if (!hasResultType) {
                    console.warn(`Route ${routePath} should return Result<T> format`);
                }
            }
        });
        it('error responses should include error code', async ()=>{
            const allRoutes = await findAllRoutes('app/api');
            for (const routePath of allRoutes){
                const content = await (0, _promises.readFile)(routePath, 'utf-8');
                // If route has error handling, should include error code
                if (content.includes('success: false')) {
                    const hasErrorCode = content.includes('error: {') && content.includes('code:');
                    expect(hasErrorCode).toBe(true);
                    if (!hasErrorCode) {
                        fail(`Route ${routePath} has error response but missing error code`);
                    }
                }
            }
        });
    });
    describe('HTTP Methods', ()=>{
        it('routes should export proper HTTP method functions', async ()=>{
            const allRoutes = await findAllRoutes('app/api');
            for (const routePath of allRoutes){
                const content = await (0, _promises.readFile)(routePath, 'utf-8');
                // Should export at least one HTTP method
                const hasMethod = content.includes('export async function GET') || content.includes('export async function POST') || content.includes('export async function PUT') || content.includes('export async function DELETE') || content.includes('export async function PATCH');
                expect(hasMethod).toBe(true);
                if (!hasMethod) {
                    fail(`Route ${routePath} doesn't export any HTTP method functions`);
                }
            }
        });
    });
});
// Helper functions
async function findDynamicRoutes(dir) {
    const routes = [];
    try {
        const entries = await (0, _promises.readdir)(dir, {
            withFileTypes: true
        });
        for (const entry of entries){
            const fullPath = (0, _path.join)(dir, entry.name);
            if (entry.isDirectory()) {
                // Check if directory name indicates dynamic route
                if (entry.name.startsWith('[') && entry.name.endsWith(']')) {
                    const routeFile = (0, _path.join)(fullPath, 'route.ts');
                    try {
                        await (0, _promises.readFile)(routeFile);
                        routes.push(routeFile);
                    } catch  {
                    // route.ts doesn't exist in this directory
                    }
                }
                // Recursively search subdirectories
                const subRoutes = await findDynamicRoutes(fullPath);
                routes.push(...subRoutes);
            }
        }
    } catch (error) {
    // Directory doesn't exist or can't be read
    }
    return routes;
}
async function findAllRoutes(dir) {
    const routes = [];
    try {
        const entries = await (0, _promises.readdir)(dir, {
            withFileTypes: true
        });
        for (const entry of entries){
            const fullPath = (0, _path.join)(dir, entry.name);
            if (entry.isDirectory()) {
                const subRoutes = await findAllRoutes(fullPath);
                routes.push(...subRoutes);
            } else if (entry.name === 'route.ts') {
                routes.push(fullPath);
            }
        }
    } catch (error) {
    // Directory doesn't exist or can't be read
    }
    return routes;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvX190ZXN0c19fL2NvbnRyYWN0cy9hcGlSb3V0ZXMuY29udHJhY3QudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFQSSBSb3V0ZSBDb250cmFjdCBUZXN0c1xuICogXG4gKiBUaGVzZSB0ZXN0cyB2YWxpZGF0ZSB0aGF0IGFsbCBBUEkgcm91dGVzIGZvbGxvdyByZXF1aXJlZCBwYXR0ZXJucy5cbiAqIFRoZXkgY2F0Y2ggY29tbW9uIG1pc3Rha2VzIGxpa2UgZm9yZ2V0dGluZyB0byBhd2FpdCBwYXJhbXMgb3IgbWlzc2luZyBhdXRoLlxuICogXG4gKiBXaHkgdGhpcyBleGlzdHM6XG4gKiAtIE5leHQuanMgMTYgbWFkZSBwYXJhbXMgYXN5bmMsIGVhc3kgdG8gZm9yZ2V0IGF3YWl0XG4gKiAtIEF1dGggY2hlY2tzIHNob3VsZCBiZSBjb25zaXN0ZW50IGFjcm9zcyBhbGwgYWRtaW4gcm91dGVzXG4gKiAtIEFsbCByb3V0ZXMgc2hvdWxkIHJldHVybiBSZXN1bHQ8VD4gZm9ybWF0XG4gKi9cblxuaW1wb3J0IHsgcmVhZGRpciwgcmVhZEZpbGUgfSBmcm9tICdmcy9wcm9taXNlcyc7XG5pbXBvcnQgeyBqb2luIH0gZnJvbSAncGF0aCc7XG5cbmRlc2NyaWJlKCdBUEkgUm91dGUgQ29udHJhY3RzJywgKCkgPT4ge1xuICBkZXNjcmliZSgnRHluYW1pYyBSb3V0ZSBQYXJhbXMnLCAoKSA9PiB7XG4gICAgaXQoJ2FsbCBkeW5hbWljIHJvdXRlcyBzaG91bGQgYXdhaXQgcGFyYW1zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZHluYW1pY1JvdXRlcyA9IGF3YWl0IGZpbmREeW5hbWljUm91dGVzKCdhcHAvYXBpJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChkeW5hbWljUm91dGVzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHJvdXRlUGF0aCBvZiBkeW5hbWljUm91dGVzKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCByZWFkRmlsZShyb3V0ZVBhdGgsICd1dGYtOCcpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgcm91dGUgdXNlcyBwYXJhbXNcbiAgICAgICAgaWYgKGNvbnRlbnQuaW5jbHVkZXMoJ3BhcmFtczonKSB8fCBjb250ZW50LmluY2x1ZGVzKCd7IHBhcmFtcyB9JykpIHtcbiAgICAgICAgICAvLyBTaG91bGQgaGF2ZSAnYXdhaXQgcGFyYW1zJyBvciAnY29uc3QgcmVzb2x2ZWRQYXJhbXMgPSBhd2FpdCBwYXJhbXMnXG4gICAgICAgICAgY29uc3QgaGFzQXdhaXRQYXJhbXMgPSBcbiAgICAgICAgICAgIGNvbnRlbnQuaW5jbHVkZXMoJ2F3YWl0IHBhcmFtcycpIHx8XG4gICAgICAgICAgICBjb250ZW50LmluY2x1ZGVzKCdyZXNvbHZlZFBhcmFtcyA9IGF3YWl0IHBhcmFtcycpO1xuICAgICAgICAgIFxuICAgICAgICAgIGV4cGVjdChoYXNBd2FpdFBhcmFtcykudG9CZSh0cnVlKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIWhhc0F3YWl0UGFyYW1zKSB7XG4gICAgICAgICAgICBmYWlsKGBSb3V0ZSAke3JvdXRlUGF0aH0gdXNlcyBwYXJhbXMgYnV0IGRvZXNuJ3QgYXdhaXQgaXRgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdkeW5hbWljIHJvdXRlcyBzaG91bGQgdXNlIHJlc29sdmVkUGFyYW1zIHBhdHRlcm4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkeW5hbWljUm91dGVzID0gYXdhaXQgZmluZER5bmFtaWNSb3V0ZXMoJ2FwcC9hcGknKTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCByb3V0ZVBhdGggb2YgZHluYW1pY1JvdXRlcykge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgcmVhZEZpbGUocm91dGVQYXRoLCAndXRmLTgnKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChjb250ZW50LmluY2x1ZGVzKCdwYXJhbXM6JykpIHtcbiAgICAgICAgICAvLyBSZWNvbW1lbmRlZCBwYXR0ZXJuOiBjb25zdCByZXNvbHZlZFBhcmFtcyA9IGF3YWl0IHBhcmFtcztcbiAgICAgICAgICBjb25zdCBoYXNSZXNvbHZlZFBhcmFtcyA9IGNvbnRlbnQuaW5jbHVkZXMoJ3Jlc29sdmVkUGFyYW1zJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFoYXNSZXNvbHZlZFBhcmFtcykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBSb3V0ZSAke3JvdXRlUGF0aH0gc2hvdWxkIHVzZSAncmVzb2x2ZWRQYXJhbXMnIHBhdHRlcm4gZm9yIGNsYXJpdHlgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0F1dGhlbnRpY2F0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdhbGwgYWRtaW4gcm91dGVzIHNob3VsZCBjYWxsIHZlcmlmeUF1dGgnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhZG1pblJvdXRlcyA9IGF3YWl0IGZpbmRBbGxSb3V0ZXMoJ2FwcC9hcGkvYWRtaW4nKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGFkbWluUm91dGVzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHJvdXRlUGF0aCBvZiBhZG1pblJvdXRlcykge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgcmVhZEZpbGUocm91dGVQYXRoLCAndXRmLTgnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3VsZCBjYWxsIHZlcmlmeUF1dGgoKSBvciBoYXZlIGF1dGggY2hlY2tcbiAgICAgICAgY29uc3QgaGFzQXV0aCA9IFxuICAgICAgICAgIGNvbnRlbnQuaW5jbHVkZXMoJ3ZlcmlmeUF1dGgoKScpIHx8XG4gICAgICAgICAgY29udGVudC5pbmNsdWRlcygnZ2V0U2Vzc2lvbigpJykgfHxcbiAgICAgICAgICBjb250ZW50LmluY2x1ZGVzKCdhdXRoLmdldFVzZXIoKScpO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KGhhc0F1dGgpLnRvQmUodHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWhhc0F1dGgpIHtcbiAgICAgICAgICBmYWlsKGBBZG1pbiByb3V0ZSAke3JvdXRlUGF0aH0gaXMgbWlzc2luZyBhdXRoZW50aWNhdGlvbiBjaGVja2ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnYXV0aCBzaG91bGQgYmUgY2hlY2tlZCBiZWZvcmUgcGFyYW1zIHJlc29sdXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkeW5hbWljUm91dGVzID0gYXdhaXQgZmluZER5bmFtaWNSb3V0ZXMoJ2FwcC9hcGkvYWRtaW4nKTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCByb3V0ZVBhdGggb2YgZHluYW1pY1JvdXRlcykge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgcmVhZEZpbGUocm91dGVQYXRoLCAndXRmLTgnKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChjb250ZW50LmluY2x1ZGVzKCd2ZXJpZnlBdXRoJykgJiYgY29udGVudC5pbmNsdWRlcygnYXdhaXQgcGFyYW1zJykpIHtcbiAgICAgICAgICAvLyBGaW5kIHBvc2l0aW9uc1xuICAgICAgICAgIGNvbnN0IGF1dGhQb3MgPSBjb250ZW50LmluZGV4T2YoJ3ZlcmlmeUF1dGgnKTtcbiAgICAgICAgICBjb25zdCBwYXJhbXNQb3MgPSBjb250ZW50LmluZGV4T2YoJ2F3YWl0IHBhcmFtcycpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEF1dGggc2hvdWxkIGNvbWUgYmVmb3JlIHBhcmFtc1xuICAgICAgICAgIGV4cGVjdChhdXRoUG9zKS50b0JlTGVzc1RoYW4ocGFyYW1zUG9zKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoYXV0aFBvcyA+PSBwYXJhbXNQb3MpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgUm91dGUgJHtyb3V0ZVBhdGh9IHNob3VsZCBjaGVjayBhdXRoIGJlZm9yZSByZXNvbHZpbmcgcGFyYW1zYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSZXNwb25zZSBGb3JtYXQnLCAoKSA9PiB7XG4gICAgaXQoJ2FsbCByb3V0ZXMgc2hvdWxkIHJldHVybiBSZXN1bHQ8VD4gZm9ybWF0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYWxsUm91dGVzID0gYXdhaXQgZmluZEFsbFJvdXRlcygnYXBwL2FwaScpO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHJvdXRlUGF0aCBvZiBhbGxSb3V0ZXMpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHJlYWRGaWxlKHJvdXRlUGF0aCwgJ3V0Zi04Jyk7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBmb3IgUmVzdWx0PFQ+IHJldHVybiB0eXBlXG4gICAgICAgIGNvbnN0IGhhc1Jlc3VsdFR5cGUgPSBcbiAgICAgICAgICBjb250ZW50LmluY2x1ZGVzKCdSZXN1bHQ8JykgfHxcbiAgICAgICAgICBjb250ZW50LmluY2x1ZGVzKCdzdWNjZXNzOiB0cnVlJykgfHxcbiAgICAgICAgICBjb250ZW50LmluY2x1ZGVzKCdzdWNjZXNzOiBmYWxzZScpO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KGhhc1Jlc3VsdFR5cGUpLnRvQmUodHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWhhc1Jlc3VsdFR5cGUpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYFJvdXRlICR7cm91dGVQYXRofSBzaG91bGQgcmV0dXJuIFJlc3VsdDxUPiBmb3JtYXRgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ2Vycm9yIHJlc3BvbnNlcyBzaG91bGQgaW5jbHVkZSBlcnJvciBjb2RlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYWxsUm91dGVzID0gYXdhaXQgZmluZEFsbFJvdXRlcygnYXBwL2FwaScpO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHJvdXRlUGF0aCBvZiBhbGxSb3V0ZXMpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHJlYWRGaWxlKHJvdXRlUGF0aCwgJ3V0Zi04Jyk7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiByb3V0ZSBoYXMgZXJyb3IgaGFuZGxpbmcsIHNob3VsZCBpbmNsdWRlIGVycm9yIGNvZGVcbiAgICAgICAgaWYgKGNvbnRlbnQuaW5jbHVkZXMoJ3N1Y2Nlc3M6IGZhbHNlJykpIHtcbiAgICAgICAgICBjb25zdCBoYXNFcnJvckNvZGUgPSBjb250ZW50LmluY2x1ZGVzKCdlcnJvcjogeycpICYmIGNvbnRlbnQuaW5jbHVkZXMoJ2NvZGU6Jyk7XG4gICAgICAgICAgXG4gICAgICAgICAgZXhwZWN0KGhhc0Vycm9yQ29kZSkudG9CZSh0cnVlKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIWhhc0Vycm9yQ29kZSkge1xuICAgICAgICAgICAgZmFpbChgUm91dGUgJHtyb3V0ZVBhdGh9IGhhcyBlcnJvciByZXNwb25zZSBidXQgbWlzc2luZyBlcnJvciBjb2RlYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdIVFRQIE1ldGhvZHMnLCAoKSA9PiB7XG4gICAgaXQoJ3JvdXRlcyBzaG91bGQgZXhwb3J0IHByb3BlciBIVFRQIG1ldGhvZCBmdW5jdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhbGxSb3V0ZXMgPSBhd2FpdCBmaW5kQWxsUm91dGVzKCdhcHAvYXBpJyk7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3Qgcm91dGVQYXRoIG9mIGFsbFJvdXRlcykge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgcmVhZEZpbGUocm91dGVQYXRoLCAndXRmLTgnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3VsZCBleHBvcnQgYXQgbGVhc3Qgb25lIEhUVFAgbWV0aG9kXG4gICAgICAgIGNvbnN0IGhhc01ldGhvZCA9IFxuICAgICAgICAgIGNvbnRlbnQuaW5jbHVkZXMoJ2V4cG9ydCBhc3luYyBmdW5jdGlvbiBHRVQnKSB8fFxuICAgICAgICAgIGNvbnRlbnQuaW5jbHVkZXMoJ2V4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUJykgfHxcbiAgICAgICAgICBjb250ZW50LmluY2x1ZGVzKCdleHBvcnQgYXN5bmMgZnVuY3Rpb24gUFVUJykgfHxcbiAgICAgICAgICBjb250ZW50LmluY2x1ZGVzKCdleHBvcnQgYXN5bmMgZnVuY3Rpb24gREVMRVRFJykgfHxcbiAgICAgICAgICBjb250ZW50LmluY2x1ZGVzKCdleHBvcnQgYXN5bmMgZnVuY3Rpb24gUEFUQ0gnKTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChoYXNNZXRob2QpLnRvQmUodHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWhhc01ldGhvZCkge1xuICAgICAgICAgIGZhaWwoYFJvdXRlICR7cm91dGVQYXRofSBkb2Vzbid0IGV4cG9ydCBhbnkgSFRUUCBtZXRob2QgZnVuY3Rpb25zYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59KTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uc1xuXG5hc3luYyBmdW5jdGlvbiBmaW5kRHluYW1pY1JvdXRlcyhkaXI6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgY29uc3Qgcm91dGVzOiBzdHJpbmdbXSA9IFtdO1xuICBcbiAgdHJ5IHtcbiAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgcmVhZGRpcihkaXIsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIGNvbnN0IGZ1bGxQYXRoID0gam9pbihkaXIsIGVudHJ5Lm5hbWUpO1xuICAgICAgXG4gICAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAvLyBDaGVjayBpZiBkaXJlY3RvcnkgbmFtZSBpbmRpY2F0ZXMgZHluYW1pYyByb3V0ZVxuICAgICAgICBpZiAoZW50cnkubmFtZS5zdGFydHNXaXRoKCdbJykgJiYgZW50cnkubmFtZS5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgICAgY29uc3Qgcm91dGVGaWxlID0gam9pbihmdWxsUGF0aCwgJ3JvdXRlLnRzJyk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHJlYWRGaWxlKHJvdXRlRmlsZSk7XG4gICAgICAgICAgICByb3V0ZXMucHVzaChyb3V0ZUZpbGUpO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgLy8gcm91dGUudHMgZG9lc24ndCBleGlzdCBpbiB0aGlzIGRpcmVjdG9yeVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VhcmNoIHN1YmRpcmVjdG9yaWVzXG4gICAgICAgIGNvbnN0IHN1YlJvdXRlcyA9IGF3YWl0IGZpbmREeW5hbWljUm91dGVzKGZ1bGxQYXRoKTtcbiAgICAgICAgcm91dGVzLnB1c2goLi4uc3ViUm91dGVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gRGlyZWN0b3J5IGRvZXNuJ3QgZXhpc3Qgb3IgY2FuJ3QgYmUgcmVhZFxuICB9XG4gIFxuICByZXR1cm4gcm91dGVzO1xufVxuXG5hc3luYyBmdW5jdGlvbiBmaW5kQWxsUm91dGVzKGRpcjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICBjb25zdCByb3V0ZXM6IHN0cmluZ1tdID0gW107XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBhd2FpdCByZWFkZGlyKGRpciwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0pO1xuICAgIFxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgY29uc3QgZnVsbFBhdGggPSBqb2luKGRpciwgZW50cnkubmFtZSk7XG4gICAgICBcbiAgICAgIGlmIChlbnRyeS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgIGNvbnN0IHN1YlJvdXRlcyA9IGF3YWl0IGZpbmRBbGxSb3V0ZXMoZnVsbFBhdGgpO1xuICAgICAgICByb3V0ZXMucHVzaCguLi5zdWJSb3V0ZXMpO1xuICAgICAgfSBlbHNlIGlmIChlbnRyeS5uYW1lID09PSAncm91dGUudHMnKSB7XG4gICAgICAgIHJvdXRlcy5wdXNoKGZ1bGxQYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gRGlyZWN0b3J5IGRvZXNuJ3QgZXhpc3Qgb3IgY2FuJ3QgYmUgcmVhZFxuICB9XG4gIFxuICByZXR1cm4gcm91dGVzO1xufVxuIl0sIm5hbWVzIjpbImRlc2NyaWJlIiwiaXQiLCJkeW5hbWljUm91dGVzIiwiZmluZER5bmFtaWNSb3V0ZXMiLCJleHBlY3QiLCJsZW5ndGgiLCJ0b0JlR3JlYXRlclRoYW4iLCJyb3V0ZVBhdGgiLCJjb250ZW50IiwicmVhZEZpbGUiLCJpbmNsdWRlcyIsImhhc0F3YWl0UGFyYW1zIiwidG9CZSIsImZhaWwiLCJoYXNSZXNvbHZlZFBhcmFtcyIsImNvbnNvbGUiLCJ3YXJuIiwiYWRtaW5Sb3V0ZXMiLCJmaW5kQWxsUm91dGVzIiwiaGFzQXV0aCIsImF1dGhQb3MiLCJpbmRleE9mIiwicGFyYW1zUG9zIiwidG9CZUxlc3NUaGFuIiwiYWxsUm91dGVzIiwiaGFzUmVzdWx0VHlwZSIsImhhc0Vycm9yQ29kZSIsImhhc01ldGhvZCIsImRpciIsInJvdXRlcyIsImVudHJpZXMiLCJyZWFkZGlyIiwid2l0aEZpbGVUeXBlcyIsImVudHJ5IiwiZnVsbFBhdGgiLCJqb2luIiwibmFtZSIsImlzRGlyZWN0b3J5Iiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwicm91dGVGaWxlIiwicHVzaCIsInN1YlJvdXRlcyIsImVycm9yIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztDQVVDOzs7OzBCQUVpQztzQkFDYjtBQUVyQkEsU0FBUyx1QkFBdUI7SUFDOUJBLFNBQVMsd0JBQXdCO1FBQy9CQyxHQUFHLDBDQUEwQztZQUMzQyxNQUFNQyxnQkFBZ0IsTUFBTUMsa0JBQWtCO1lBRTlDQyxPQUFPRixjQUFjRyxNQUFNLEVBQUVDLGVBQWUsQ0FBQztZQUU3QyxLQUFLLE1BQU1DLGFBQWFMLGNBQWU7Z0JBQ3JDLE1BQU1NLFVBQVUsTUFBTUMsSUFBQUEsa0JBQVEsRUFBQ0YsV0FBVztnQkFFMUMsNkJBQTZCO2dCQUM3QixJQUFJQyxRQUFRRSxRQUFRLENBQUMsY0FBY0YsUUFBUUUsUUFBUSxDQUFDLGVBQWU7b0JBQ2pFLHNFQUFzRTtvQkFDdEUsTUFBTUMsaUJBQ0pILFFBQVFFLFFBQVEsQ0FBQyxtQkFDakJGLFFBQVFFLFFBQVEsQ0FBQztvQkFFbkJOLE9BQU9PLGdCQUFnQkMsSUFBSSxDQUFDO29CQUU1QixJQUFJLENBQUNELGdCQUFnQjt3QkFDbkJFLEtBQUssQ0FBQyxNQUFNLEVBQUVOLFVBQVUsaUNBQWlDLENBQUM7b0JBQzVEO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBTixHQUFHLG9EQUFvRDtZQUNyRCxNQUFNQyxnQkFBZ0IsTUFBTUMsa0JBQWtCO1lBRTlDLEtBQUssTUFBTUksYUFBYUwsY0FBZTtnQkFDckMsTUFBTU0sVUFBVSxNQUFNQyxJQUFBQSxrQkFBUSxFQUFDRixXQUFXO2dCQUUxQyxJQUFJQyxRQUFRRSxRQUFRLENBQUMsWUFBWTtvQkFDL0IsNERBQTREO29CQUM1RCxNQUFNSSxvQkFBb0JOLFFBQVFFLFFBQVEsQ0FBQztvQkFFM0MsSUFBSSxDQUFDSSxtQkFBbUI7d0JBQ3RCQyxRQUFRQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUVULFVBQVUsZ0RBQWdELENBQUM7b0JBQ25G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