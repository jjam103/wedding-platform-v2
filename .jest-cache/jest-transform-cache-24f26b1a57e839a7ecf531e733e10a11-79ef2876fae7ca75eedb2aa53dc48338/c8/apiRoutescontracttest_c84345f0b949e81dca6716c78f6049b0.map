{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/__tests__/contracts/apiRoutes.contract.test.ts"],"sourcesContent":["/**\n * API Route Contract Tests\n * \n * These tests validate that all API routes follow required patterns.\n * They catch common mistakes like forgetting to await params or missing auth.\n * \n * Why this exists:\n * - Next.js 16 made params async, easy to forget await\n * - Auth checks should be consistent across all admin routes\n * - All routes should return Result<T> format\n */\n\nimport { readdir, readFile } from 'fs/promises';\nimport { join } from 'path';\n\ndescribe('API Route Contracts', () => {\n  describe('Dynamic Route Params', () => {\n    it('all dynamic routes should await params', async () => {\n      const dynamicRoutes = await findDynamicRoutes('app/api');\n      \n      expect(dynamicRoutes.length).toBeGreaterThan(0);\n      \n      for (const routePath of dynamicRoutes) {\n        const content = await readFile(routePath, 'utf-8');\n        \n        // Check if route uses params\n        if (content.includes('params:') || content.includes('{ params }')) {\n          // Should have 'await params' or 'const resolvedParams = await params'\n          const hasAwaitParams = \n            content.includes('await params') ||\n            content.includes('resolvedParams = await params');\n          \n          expect(hasAwaitParams).toBe(true);\n          \n          if (!hasAwaitParams) {\n            fail(`Route ${routePath} uses params but doesn't await it`);\n          }\n        }\n      }\n    });\n\n    it('dynamic routes should use resolvedParams pattern', async () => {\n      const dynamicRoutes = await findDynamicRoutes('app/api');\n      \n      for (const routePath of dynamicRoutes) {\n        const content = await readFile(routePath, 'utf-8');\n        \n        if (content.includes('params:')) {\n          // Recommended pattern: const resolvedParams = await params;\n          const hasResolvedParams = content.includes('resolvedParams');\n          \n          if (!hasResolvedParams) {\n            console.warn(`Route ${routePath} should use 'resolvedParams' pattern for clarity`);\n          }\n        }\n      }\n    });\n  });\n\n  describe('Authentication', () => {\n    it('all admin routes should call verifyAuth', async () => {\n      const adminRoutes = await findAllRoutes('app/api/admin');\n      \n      expect(adminRoutes.length).toBeGreaterThan(0);\n      \n      for (const routePath of adminRoutes) {\n        const content = await readFile(routePath, 'utf-8');\n        \n        // Should call verifyAuth() or have auth check\n        const hasAuth = \n          content.includes('verifyAuth()') ||\n          content.includes('getSession()') ||\n          content.includes('auth.getUser()');\n        \n        expect(hasAuth).toBe(true);\n        \n        if (!hasAuth) {\n          fail(`Admin route ${routePath} is missing authentication check`);\n        }\n      }\n    });\n\n    it('auth should be checked before params resolution', async () => {\n      const dynamicRoutes = await findDynamicRoutes('app/api/admin');\n      \n      for (const routePath of dynamicRoutes) {\n        const content = await readFile(routePath, 'utf-8');\n        \n        if (content.includes('verifyAuth') && content.includes('await params')) {\n          // Find positions\n          const authPos = content.indexOf('verifyAuth');\n          const paramsPos = content.indexOf('await params');\n          \n          // Auth should come before params\n          expect(authPos).toBeLessThan(paramsPos);\n          \n          if (authPos >= paramsPos) {\n            console.warn(`Route ${routePath} should check auth before resolving params`);\n          }\n        }\n      }\n    });\n  });\n\n  describe('Response Format', () => {\n    it('all routes should return Result<T> format', async () => {\n      const allRoutes = await findAllRoutes('app/api');\n      \n      for (const routePath of allRoutes) {\n        const content = await readFile(routePath, 'utf-8');\n        \n        // Check for Result<T> return type\n        const hasResultType = \n          content.includes('Result<') ||\n          content.includes('success: true') ||\n          content.includes('success: false');\n        \n        expect(hasResultType).toBe(true);\n        \n        if (!hasResultType) {\n          console.warn(`Route ${routePath} should return Result<T> format`);\n        }\n      }\n    });\n\n    it('error responses should include error code', async () => {\n      const allRoutes = await findAllRoutes('app/api');\n      \n      for (const routePath of allRoutes) {\n        const content = await readFile(routePath, 'utf-8');\n        \n        // If route has error handling, should include error code\n        if (content.includes('success: false')) {\n          const hasErrorCode = content.includes('error: {') && content.includes('code:');\n          \n          expect(hasErrorCode).toBe(true);\n          \n          if (!hasErrorCode) {\n            fail(`Route ${routePath} has error response but missing error code`);\n          }\n        }\n      }\n    });\n  });\n\n  describe('HTTP Methods', () => {\n    it('routes should export proper HTTP method functions', async () => {\n      const allRoutes = await findAllRoutes('app/api');\n      \n      for (const routePath of allRoutes) {\n        const content = await readFile(routePath, 'utf-8');\n        \n        // Should export at least one HTTP method\n        const hasMethod = \n          content.includes('export async function GET') ||\n          content.includes('export async function POST') ||\n          content.includes('export async function PUT') ||\n          content.includes('export async function DELETE') ||\n          content.includes('export async function PATCH');\n        \n        expect(hasMethod).toBe(true);\n        \n        if (!hasMethod) {\n          fail(`Route ${routePath} doesn't export any HTTP method functions`);\n        }\n      }\n    });\n  });\n});\n\n// Helper functions\n\nasync function findDynamicRoutes(dir: string): Promise<string[]> {\n  const routes: string[] = [];\n  \n  try {\n    const entries = await readdir(dir, { withFileTypes: true });\n    \n    for (const entry of entries) {\n      const fullPath = join(dir, entry.name);\n      \n      if (entry.isDirectory()) {\n        // Check if directory name indicates dynamic route\n        if (entry.name.startsWith('[') && entry.name.endsWith(']')) {\n          const routeFile = join(fullPath, 'route.ts');\n          try {\n            await readFile(routeFile);\n            routes.push(routeFile);\n          } catch {\n            // route.ts doesn't exist in this directory\n          }\n        }\n        \n        // Recursively search subdirectories\n        const subRoutes = await findDynamicRoutes(fullPath);\n        routes.push(...subRoutes);\n      }\n    }\n  } catch (error) {\n    // Directory doesn't exist or can't be read\n  }\n  \n  return routes;\n}\n\nasync function findAllRoutes(dir: string): Promise<string[]> {\n  const routes: string[] = [];\n  \n  try {\n    const entries = await readdir(dir, { withFileTypes: true });\n    \n    for (const entry of entries) {\n      const fullPath = join(dir, entry.name);\n      \n      if (entry.isDirectory()) {\n        const subRoutes = await findAllRoutes(fullPath);\n        routes.push(...subRoutes);\n      } else if (entry.name === 'route.ts') {\n        routes.push(fullPath);\n      }\n    }\n  } catch (error) {\n    // Directory doesn't exist or can't be read\n  }\n  \n  return routes;\n}\n"],"names":["describe","it","dynamicRoutes","findDynamicRoutes","expect","length","toBeGreaterThan","routePath","content","readFile","includes","hasAwaitParams","toBe","fail","hasResolvedParams","console","warn","adminRoutes","findAllRoutes","hasAuth","authPos","indexOf","paramsPos","toBeLessThan","allRoutes","hasResultType","hasErrorCode","hasMethod","dir","routes","entries","readdir","withFileTypes","entry","fullPath","join","name","isDirectory","startsWith","endsWith","routeFile","push","subRoutes","error"],"mappings":"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"}