bc996c282cb0d3e92a329c1d8e2deb14
/**
 * Property-based tests for authentication method validation
 * 
 * Requirements: 5.1, 5.2, 5.3, 22.1, 22.2
 * Tasks: 4.1, 4.2
 * 
 * Property: Authentication Method Validation
 * - auth_method must be either 'email_matching' or 'magic_link'
 * - default_auth_method must be either 'email_matching' or 'magic_link'
 * - Invalid values should be rejected
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _supabasejs = require("@supabase/supabase-js");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
describe('Feature: guest-portal-and-admin-enhancements, Property: Authentication Method Validation', ()=>{
    let supabase;
    let testGroupId;
    beforeAll(async ()=>{
        supabase = (0, _supabasejs.createClient)(supabaseUrl, supabaseServiceKey);
        // Create test group
        const { data: group } = await supabase.from('groups').insert({
            name: 'Property Test Auth Group'
        }).select().single();
        testGroupId = group.id;
    });
    afterAll(async ()=>{
        // Clean up
        if (testGroupId) {
            await supabase.from('groups').delete().eq('id', testGroupId);
        }
    });
    describe('Property 1: Valid auth_method values are accepted', ()=>{
        it('should accept email_matching and magic_link as valid auth_method values', ()=>{
            _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.constantFrom('email_matching', 'magic_link'), _fastcheck.string({
                minLength: 1,
                maxLength: 50
            }), _fastcheck.string({
                minLength: 1,
                maxLength: 50
            }), _fastcheck.emailAddress(), async (authMethod, firstName, lastName, email)=>{
                // Create guest with specified auth_method
                const { data: guest, error } = await supabase.from('guests').insert({
                    group_id: testGroupId,
                    first_name: firstName,
                    last_name: lastName,
                    email: email,
                    age_type: 'adult',
                    guest_type: 'wedding_guest',
                    auth_method: authMethod
                }).select().single();
                // Clean up
                if (guest) {
                    await supabase.from('guests').delete().eq('id', guest.id);
                }
                // Assertion
                expect(error).toBeNull();
                expect(guest).toBeDefined();
                expect(guest?.auth_method).toBe(authMethod);
            }), {
                numRuns: 20
            });
        });
    });
    describe('Property 2: Invalid auth_method values are rejected', ()=>{
        it('should reject any auth_method value other than email_matching or magic_link', ()=>{
            _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.string({
                minLength: 1,
                maxLength: 50
            }).filter((s)=>s !== 'email_matching' && s !== 'magic_link'), _fastcheck.string({
                minLength: 1,
                maxLength: 50
            }), _fastcheck.string({
                minLength: 1,
                maxLength: 50
            }), _fastcheck.emailAddress(), async (invalidAuthMethod, firstName, lastName, email)=>{
                // Try to create guest with invalid auth_method
                const { error } = await supabase.from('guests').insert({
                    group_id: testGroupId,
                    first_name: firstName,
                    last_name: lastName,
                    email: email,
                    age_type: 'adult',
                    guest_type: 'wedding_guest',
                    auth_method: invalidAuthMethod
                });
                // Assertion: should fail with constraint violation
                expect(error).not.toBeNull();
                expect(error?.message).toMatch(/auth_method|constraint|check/i);
            }), {
                numRuns: 20
            });
        });
    });
    describe('Property 3: Default auth_method is email_matching', ()=>{
        it('should default to email_matching when auth_method is not specified', ()=>{
            _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.string({
                minLength: 1,
                maxLength: 50
            }), _fastcheck.string({
                minLength: 1,
                maxLength: 50
            }), _fastcheck.emailAddress(), async (firstName, lastName, email)=>{
                // Create guest without specifying auth_method
                const { data: guest, error } = await supabase.from('guests').insert({
                    group_id: testGroupId,
                    first_name: firstName,
                    last_name: lastName,
                    email: email,
                    age_type: 'adult',
                    guest_type: 'wedding_guest'
                }).select().single();
                // Clean up
                if (guest) {
                    await supabase.from('guests').delete().eq('id', guest.id);
                }
                // Assertion
                expect(error).toBeNull();
                expect(guest).toBeDefined();
                expect(guest?.auth_method).toBe('email_matching');
            }), {
                numRuns: 20
            });
        });
    });
    describe('Property 4: auth_method can be updated', ()=>{
        it('should allow updating auth_method between valid values', ()=>{
            _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.constantFrom('email_matching', 'magic_link'), _fastcheck.constantFrom('email_matching', 'magic_link'), _fastcheck.string({
                minLength: 1,
                maxLength: 50
            }), _fastcheck.string({
                minLength: 1,
                maxLength: 50
            }), _fastcheck.emailAddress(), async (initialMethod, updatedMethod, firstName, lastName, email)=>{
                // Create guest with initial auth_method
                const { data: guest } = await supabase.from('guests').insert({
                    group_id: testGroupId,
                    first_name: firstName,
                    last_name: lastName,
                    email: email,
                    age_type: 'adult',
                    guest_type: 'wedding_guest',
                    auth_method: initialMethod
                }).select().single();
                const guestId = guest.id;
                // Update auth_method
                const { data: updatedGuest, error } = await supabase.from('guests').update({
                    auth_method: updatedMethod
                }).eq('id', guestId).select().single();
                // Clean up
                await supabase.from('guests').delete().eq('id', guestId);
                // Assertion
                expect(error).toBeNull();
                expect(updatedGuest).toBeDefined();
                expect(updatedGuest?.auth_method).toBe(updatedMethod);
            }), {
                numRuns: 20
            });
        });
    });
    describe('Property 5: Magic link tokens must have valid expiration', ()=>{
        it('should only accept tokens with future expiration dates', ()=>{
            _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.integer({
                min: 1,
                max: 60
            }), _fastcheck.string({
                minLength: 32,
                maxLength: 64
            }), async (minutesInFuture, token)=>{
                // Create test guest
                const { data: guest } = await supabase.from('guests').insert({
                    group_id: testGroupId,
                    first_name: 'Token',
                    last_name: 'Test',
                    email: `token.test.${Date.now()}@example.com`,
                    age_type: 'adult',
                    guest_type: 'wedding_guest'
                }).select().single();
                const guestId = guest.id;
                const expiresAt = new Date(Date.now() + minutesInFuture * 60 * 1000);
                // Create token with future expiration
                const { data: tokenRecord, error } = await supabase.from('magic_link_tokens').insert({
                    token: token,
                    guest_id: guestId,
                    expires_at: expiresAt.toISOString()
                }).select().single();
                // Clean up
                if (tokenRecord) {
                    await supabase.from('magic_link_tokens').delete().eq('id', tokenRecord.id);
                }
                await supabase.from('guests').delete().eq('id', guestId);
                // Assertion
                expect(error).toBeNull();
                expect(tokenRecord).toBeDefined();
                expect(new Date(tokenRecord.expires_at).getTime()).toBeGreaterThan(Date.now());
            }), {
                numRuns: 20
            });
        });
    });
    describe('Property 6: Magic link tokens are single-use', ()=>{
        it('should prevent marking an already-used token as used again', ()=>{
            _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.string({
                minLength: 32,
                maxLength: 64
            }), async (token)=>{
                // Create test guest
                const { data: guest } = await supabase.from('guests').insert({
                    group_id: testGroupId,
                    first_name: 'SingleUse',
                    last_name: 'Test',
                    email: `singleuse.${Date.now()}@example.com`,
                    age_type: 'adult',
                    guest_type: 'wedding_guest'
                }).select().single();
                const guestId = guest.id;
                const expiresAt = new Date(Date.now() + 15 * 60 * 1000);
                // Create token
                const { data: tokenRecord } = await supabase.from('magic_link_tokens').insert({
                    token: token,
                    guest_id: guestId,
                    expires_at: expiresAt.toISOString()
                }).select().single();
                const tokenId = tokenRecord.id;
                // Mark token as used (first time)
                const { data: firstUse } = await supabase.rpc('mark_magic_link_token_used', {
                    token_value: token
                });
                // Try to mark as used again (second time)
                const { data: secondUse } = await supabase.rpc('mark_magic_link_token_used', {
                    token_value: token
                });
                // Clean up
                await supabase.from('magic_link_tokens').delete().eq('id', tokenId);
                await supabase.from('guests').delete().eq('id', guestId);
                // Assertions
                expect(firstUse).toBe(true); // First use succeeds
                expect(secondUse).toBe(false); // Second use fails
            }), {
                numRuns: 20
            });
        });
    });
    describe('Property 7: Expired tokens cannot be used', ()=>{
        it('should reject tokens that have expired', ()=>{
            _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.integer({
                min: 1,
                max: 60
            }), _fastcheck.string({
                minLength: 32,
                maxLength: 64
            }), async (minutesInPast, token)=>{
                // Create test guest
                const { data: guest } = await supabase.from('guests').insert({
                    group_id: testGroupId,
                    first_name: 'Expired',
                    last_name: 'Test',
                    email: `expired.${Date.now()}@example.com`,
                    age_type: 'adult',
                    guest_type: 'wedding_guest'
                }).select().single();
                const guestId = guest.id;
                const expiresAt = new Date(Date.now() - minutesInPast * 60 * 1000);
                // Create expired token
                const { data: tokenRecord } = await supabase.from('magic_link_tokens').insert({
                    token: token,
                    guest_id: guestId,
                    expires_at: expiresAt.toISOString()
                }).select().single();
                const tokenId = tokenRecord.id;
                // Try to mark expired token as used
                const { data: result } = await supabase.rpc('mark_magic_link_token_used', {
                    token_value: token
                });
                // Clean up
                await supabase.from('magic_link_tokens').delete().eq('id', tokenId);
                await supabase.from('guests').delete().eq('id', guestId);
                // Assertion: expired token cannot be used
                expect(result).toBe(false);
            }), {
                numRuns: 20
            });
        });
    });
    describe('Property 8: Token uniqueness is enforced', ()=>{
        it('should reject duplicate tokens', ()=>{
            _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.string({
                minLength: 32,
                maxLength: 64
            }), async (token)=>{
                // Create test guest
                const { data: guest } = await supabase.from('guests').insert({
                    group_id: testGroupId,
                    first_name: 'Unique',
                    last_name: 'Test',
                    email: `unique.${Date.now()}@example.com`,
                    age_type: 'adult',
                    guest_type: 'wedding_guest'
                }).select().single();
                const guestId = guest.id;
                const expiresAt = new Date(Date.now() + 15 * 60 * 1000);
                // Create first token
                const { data: token1 } = await supabase.from('magic_link_tokens').insert({
                    token: token,
                    guest_id: guestId,
                    expires_at: expiresAt.toISOString()
                }).select().single();
                const token1Id = token1.id;
                // Try to create duplicate token
                const { error: duplicateError } = await supabase.from('magic_link_tokens').insert({
                    token: token,
                    guest_id: guestId,
                    expires_at: expiresAt.toISOString()
                });
                // Clean up
                await supabase.from('magic_link_tokens').delete().eq('id', token1Id);
                await supabase.from('guests').delete().eq('id', guestId);
                // Assertion: duplicate should be rejected
                expect(duplicateError).not.toBeNull();
                expect(duplicateError?.message).toMatch(/duplicate|unique/i);
            }), {
                numRuns: 20
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvX190ZXN0c19fL3Byb3BlcnR5L2F1dGhNZXRob2RWYWxpZGF0aW9uLnByb3BlcnR5LnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQcm9wZXJ0eS1iYXNlZCB0ZXN0cyBmb3IgYXV0aGVudGljYXRpb24gbWV0aG9kIHZhbGlkYXRpb25cbiAqIFxuICogUmVxdWlyZW1lbnRzOiA1LjEsIDUuMiwgNS4zLCAyMi4xLCAyMi4yXG4gKiBUYXNrczogNC4xLCA0LjJcbiAqIFxuICogUHJvcGVydHk6IEF1dGhlbnRpY2F0aW9uIE1ldGhvZCBWYWxpZGF0aW9uXG4gKiAtIGF1dGhfbWV0aG9kIG11c3QgYmUgZWl0aGVyICdlbWFpbF9tYXRjaGluZycgb3IgJ21hZ2ljX2xpbmsnXG4gKiAtIGRlZmF1bHRfYXV0aF9tZXRob2QgbXVzdCBiZSBlaXRoZXIgJ2VtYWlsX21hdGNoaW5nJyBvciAnbWFnaWNfbGluaydcbiAqIC0gSW52YWxpZCB2YWx1ZXMgc2hvdWxkIGJlIHJlamVjdGVkXG4gKi9cblxuaW1wb3J0ICogYXMgZmMgZnJvbSAnZmFzdC1jaGVjayc7XG5pbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuXG5jb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCE7XG5jb25zdCBzdXBhYmFzZVNlcnZpY2VLZXkgPSBwcm9jZXNzLmVudi5TVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZITtcblxuZGVzY3JpYmUoJ0ZlYXR1cmU6IGd1ZXN0LXBvcnRhbC1hbmQtYWRtaW4tZW5oYW5jZW1lbnRzLCBQcm9wZXJ0eTogQXV0aGVudGljYXRpb24gTWV0aG9kIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gIGxldCBzdXBhYmFzZTogUmV0dXJuVHlwZTx0eXBlb2YgY3JlYXRlQ2xpZW50PjtcbiAgbGV0IHRlc3RHcm91cElkOiBzdHJpbmc7XG5cbiAgYmVmb3JlQWxsKGFzeW5jICgpID0+IHtcbiAgICBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VTZXJ2aWNlS2V5KTtcblxuICAgIC8vIENyZWF0ZSB0ZXN0IGdyb3VwXG4gICAgY29uc3QgeyBkYXRhOiBncm91cCB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdncm91cHMnKVxuICAgICAgLmluc2VydCh7IG5hbWU6ICdQcm9wZXJ0eSBUZXN0IEF1dGggR3JvdXAnIH0pXG4gICAgICAuc2VsZWN0KClcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIHRlc3RHcm91cElkID0gZ3JvdXAhLmlkO1xuICB9KTtcblxuICBhZnRlckFsbChhc3luYyAoKSA9PiB7XG4gICAgLy8gQ2xlYW4gdXBcbiAgICBpZiAodGVzdEdyb3VwSWQpIHtcbiAgICAgIGF3YWl0IHN1cGFiYXNlLmZyb20oJ2dyb3VwcycpLmRlbGV0ZSgpLmVxKCdpZCcsIHRlc3RHcm91cElkKTtcbiAgICB9XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQcm9wZXJ0eSAxOiBWYWxpZCBhdXRoX21ldGhvZCB2YWx1ZXMgYXJlIGFjY2VwdGVkJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgYWNjZXB0IGVtYWlsX21hdGNoaW5nIGFuZCBtYWdpY19saW5rIGFzIHZhbGlkIGF1dGhfbWV0aG9kIHZhbHVlcycsICgpID0+IHtcbiAgICAgIGZjLmFzc2VydChcbiAgICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgICBmYy5jb25zdGFudEZyb20oJ2VtYWlsX21hdGNoaW5nJywgJ21hZ2ljX2xpbmsnKSxcbiAgICAgICAgICBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogNTAgfSksXG4gICAgICAgICAgZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLFxuICAgICAgICAgIGZjLmVtYWlsQWRkcmVzcygpLFxuICAgICAgICAgIGFzeW5jIChhdXRoTWV0aG9kLCBmaXJzdE5hbWUsIGxhc3ROYW1lLCBlbWFpbCkgPT4ge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGd1ZXN0IHdpdGggc3BlY2lmaWVkIGF1dGhfbWV0aG9kXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IGd1ZXN0LCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgLmZyb20oJ2d1ZXN0cycpXG4gICAgICAgICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgICAgICAgIGdyb3VwX2lkOiB0ZXN0R3JvdXBJZCxcbiAgICAgICAgICAgICAgICBmaXJzdF9uYW1lOiBmaXJzdE5hbWUsXG4gICAgICAgICAgICAgICAgbGFzdF9uYW1lOiBsYXN0TmFtZSxcbiAgICAgICAgICAgICAgICBlbWFpbDogZW1haWwsXG4gICAgICAgICAgICAgICAgYWdlX3R5cGU6ICdhZHVsdCcsXG4gICAgICAgICAgICAgICAgZ3Vlc3RfdHlwZTogJ3dlZGRpbmdfZ3Vlc3QnLFxuICAgICAgICAgICAgICAgIGF1dGhfbWV0aG9kOiBhdXRoTWV0aG9kLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICAgICAgICAvLyBDbGVhbiB1cFxuICAgICAgICAgICAgaWYgKGd1ZXN0KSB7XG4gICAgICAgICAgICAgIGF3YWl0IHN1cGFiYXNlLmZyb20oJ2d1ZXN0cycpLmRlbGV0ZSgpLmVxKCdpZCcsIGd1ZXN0LmlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXNzZXJ0aW9uXG4gICAgICAgICAgICBleHBlY3QoZXJyb3IpLnRvQmVOdWxsKCk7XG4gICAgICAgICAgICBleHBlY3QoZ3Vlc3QpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QoZ3Vlc3Q/LmF1dGhfbWV0aG9kKS50b0JlKGF1dGhNZXRob2QpO1xuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgeyBudW1SdW5zOiAyMCB9XG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUHJvcGVydHkgMjogSW52YWxpZCBhdXRoX21ldGhvZCB2YWx1ZXMgYXJlIHJlamVjdGVkJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmVqZWN0IGFueSBhdXRoX21ldGhvZCB2YWx1ZSBvdGhlciB0aGFuIGVtYWlsX21hdGNoaW5nIG9yIG1hZ2ljX2xpbmsnLCAoKSA9PiB7XG4gICAgICBmYy5hc3NlcnQoXG4gICAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgICAgZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLmZpbHRlcihcbiAgICAgICAgICAgIChzKSA9PiBzICE9PSAnZW1haWxfbWF0Y2hpbmcnICYmIHMgIT09ICdtYWdpY19saW5rJ1xuICAgICAgICAgICksXG4gICAgICAgICAgZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLFxuICAgICAgICAgIGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1MCB9KSxcbiAgICAgICAgICBmYy5lbWFpbEFkZHJlc3MoKSxcbiAgICAgICAgICBhc3luYyAoaW52YWxpZEF1dGhNZXRob2QsIGZpcnN0TmFtZSwgbGFzdE5hbWUsIGVtYWlsKSA9PiB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gY3JlYXRlIGd1ZXN0IHdpdGggaW52YWxpZCBhdXRoX21ldGhvZFxuICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgLmZyb20oJ2d1ZXN0cycpXG4gICAgICAgICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgICAgICAgIGdyb3VwX2lkOiB0ZXN0R3JvdXBJZCxcbiAgICAgICAgICAgICAgICBmaXJzdF9uYW1lOiBmaXJzdE5hbWUsXG4gICAgICAgICAgICAgICAgbGFzdF9uYW1lOiBsYXN0TmFtZSxcbiAgICAgICAgICAgICAgICBlbWFpbDogZW1haWwsXG4gICAgICAgICAgICAgICAgYWdlX3R5cGU6ICdhZHVsdCcsXG4gICAgICAgICAgICAgICAgZ3Vlc3RfdHlwZTogJ3dlZGRpbmdfZ3Vlc3QnLFxuICAgICAgICAgICAgICAgIGF1dGhfbWV0aG9kOiBpbnZhbGlkQXV0aE1ldGhvZCBhcyBhbnksXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBBc3NlcnRpb246IHNob3VsZCBmYWlsIHdpdGggY29uc3RyYWludCB2aW9sYXRpb25cbiAgICAgICAgICAgIGV4cGVjdChlcnJvcikubm90LnRvQmVOdWxsKCk7XG4gICAgICAgICAgICBleHBlY3QoZXJyb3I/Lm1lc3NhZ2UpLnRvTWF0Y2goL2F1dGhfbWV0aG9kfGNvbnN0cmFpbnR8Y2hlY2svaSk7XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDIwIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQcm9wZXJ0eSAzOiBEZWZhdWx0IGF1dGhfbWV0aG9kIGlzIGVtYWlsX21hdGNoaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZGVmYXVsdCB0byBlbWFpbF9tYXRjaGluZyB3aGVuIGF1dGhfbWV0aG9kIGlzIG5vdCBzcGVjaWZpZWQnLCAoKSA9PiB7XG4gICAgICBmYy5hc3NlcnQoXG4gICAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgICAgZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLFxuICAgICAgICAgIGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1MCB9KSxcbiAgICAgICAgICBmYy5lbWFpbEFkZHJlc3MoKSxcbiAgICAgICAgICBhc3luYyAoZmlyc3ROYW1lLCBsYXN0TmFtZSwgZW1haWwpID0+IHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBndWVzdCB3aXRob3V0IHNwZWNpZnlpbmcgYXV0aF9tZXRob2RcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogZ3Vlc3QsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAuZnJvbSgnZ3Vlc3RzJylcbiAgICAgICAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgICAgICAgZ3JvdXBfaWQ6IHRlc3RHcm91cElkLFxuICAgICAgICAgICAgICAgIGZpcnN0X25hbWU6IGZpcnN0TmFtZSxcbiAgICAgICAgICAgICAgICBsYXN0X25hbWU6IGxhc3ROYW1lLFxuICAgICAgICAgICAgICAgIGVtYWlsOiBlbWFpbCxcbiAgICAgICAgICAgICAgICBhZ2VfdHlwZTogJ2FkdWx0JyxcbiAgICAgICAgICAgICAgICBndWVzdF90eXBlOiAnd2VkZGluZ19ndWVzdCcsXG4gICAgICAgICAgICAgICAgLy8gYXV0aF9tZXRob2Qgbm90IHNwZWNpZmllZFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICAgICAgICAvLyBDbGVhbiB1cFxuICAgICAgICAgICAgaWYgKGd1ZXN0KSB7XG4gICAgICAgICAgICAgIGF3YWl0IHN1cGFiYXNlLmZyb20oJ2d1ZXN0cycpLmRlbGV0ZSgpLmVxKCdpZCcsIGd1ZXN0LmlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXNzZXJ0aW9uXG4gICAgICAgICAgICBleHBlY3QoZXJyb3IpLnRvQmVOdWxsKCk7XG4gICAgICAgICAgICBleHBlY3QoZ3Vlc3QpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QoZ3Vlc3Q/LmF1dGhfbWV0aG9kKS50b0JlKCdlbWFpbF9tYXRjaGluZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgeyBudW1SdW5zOiAyMCB9XG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUHJvcGVydHkgNDogYXV0aF9tZXRob2QgY2FuIGJlIHVwZGF0ZWQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBhbGxvdyB1cGRhdGluZyBhdXRoX21ldGhvZCBiZXR3ZWVuIHZhbGlkIHZhbHVlcycsICgpID0+IHtcbiAgICAgIGZjLmFzc2VydChcbiAgICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgICBmYy5jb25zdGFudEZyb20oJ2VtYWlsX21hdGNoaW5nJywgJ21hZ2ljX2xpbmsnKSxcbiAgICAgICAgICBmYy5jb25zdGFudEZyb20oJ2VtYWlsX21hdGNoaW5nJywgJ21hZ2ljX2xpbmsnKSxcbiAgICAgICAgICBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogNTAgfSksXG4gICAgICAgICAgZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLFxuICAgICAgICAgIGZjLmVtYWlsQWRkcmVzcygpLFxuICAgICAgICAgIGFzeW5jIChpbml0aWFsTWV0aG9kLCB1cGRhdGVkTWV0aG9kLCBmaXJzdE5hbWUsIGxhc3ROYW1lLCBlbWFpbCkgPT4ge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGd1ZXN0IHdpdGggaW5pdGlhbCBhdXRoX21ldGhvZFxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBndWVzdCB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgLmZyb20oJ2d1ZXN0cycpXG4gICAgICAgICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgICAgICAgIGdyb3VwX2lkOiB0ZXN0R3JvdXBJZCxcbiAgICAgICAgICAgICAgICBmaXJzdF9uYW1lOiBmaXJzdE5hbWUsXG4gICAgICAgICAgICAgICAgbGFzdF9uYW1lOiBsYXN0TmFtZSxcbiAgICAgICAgICAgICAgICBlbWFpbDogZW1haWwsXG4gICAgICAgICAgICAgICAgYWdlX3R5cGU6ICdhZHVsdCcsXG4gICAgICAgICAgICAgICAgZ3Vlc3RfdHlwZTogJ3dlZGRpbmdfZ3Vlc3QnLFxuICAgICAgICAgICAgICAgIGF1dGhfbWV0aG9kOiBpbml0aWFsTWV0aG9kLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICAgICAgICBjb25zdCBndWVzdElkID0gZ3Vlc3QhLmlkO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgYXV0aF9tZXRob2RcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogdXBkYXRlZEd1ZXN0LCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgLmZyb20oJ2d1ZXN0cycpXG4gICAgICAgICAgICAgIC51cGRhdGUoeyBhdXRoX21ldGhvZDogdXBkYXRlZE1ldGhvZCB9KVxuICAgICAgICAgICAgICAuZXEoJ2lkJywgZ3Vlc3RJZClcbiAgICAgICAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgICAgICAgIGF3YWl0IHN1cGFiYXNlLmZyb20oJ2d1ZXN0cycpLmRlbGV0ZSgpLmVxKCdpZCcsIGd1ZXN0SWQpO1xuXG4gICAgICAgICAgICAvLyBBc3NlcnRpb25cbiAgICAgICAgICAgIGV4cGVjdChlcnJvcikudG9CZU51bGwoKTtcbiAgICAgICAgICAgIGV4cGVjdCh1cGRhdGVkR3Vlc3QpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZEd1ZXN0Py5hdXRoX21ldGhvZCkudG9CZSh1cGRhdGVkTWV0aG9kKTtcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHsgbnVtUnVuczogMjAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Byb3BlcnR5IDU6IE1hZ2ljIGxpbmsgdG9rZW5zIG11c3QgaGF2ZSB2YWxpZCBleHBpcmF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgb25seSBhY2NlcHQgdG9rZW5zIHdpdGggZnV0dXJlIGV4cGlyYXRpb24gZGF0ZXMnLCAoKSA9PiB7XG4gICAgICBmYy5hc3NlcnQoXG4gICAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgICAgZmMuaW50ZWdlcih7IG1pbjogMSwgbWF4OiA2MCB9KSwgLy8gTWludXRlcyBpbiB0aGUgZnV0dXJlXG4gICAgICAgICAgZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAzMiwgbWF4TGVuZ3RoOiA2NCB9KSxcbiAgICAgICAgICBhc3luYyAobWludXRlc0luRnV0dXJlLCB0b2tlbikgPT4ge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRlc3QgZ3Vlc3RcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogZ3Vlc3QgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgIC5mcm9tKCdndWVzdHMnKVxuICAgICAgICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICAgICAgICBncm91cF9pZDogdGVzdEdyb3VwSWQsXG4gICAgICAgICAgICAgICAgZmlyc3RfbmFtZTogJ1Rva2VuJyxcbiAgICAgICAgICAgICAgICBsYXN0X25hbWU6ICdUZXN0JyxcbiAgICAgICAgICAgICAgICBlbWFpbDogYHRva2VuLnRlc3QuJHtEYXRlLm5vdygpfUBleGFtcGxlLmNvbWAsXG4gICAgICAgICAgICAgICAgYWdlX3R5cGU6ICdhZHVsdCcsXG4gICAgICAgICAgICAgICAgZ3Vlc3RfdHlwZTogJ3dlZGRpbmdfZ3Vlc3QnLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICAgICAgICBjb25zdCBndWVzdElkID0gZ3Vlc3QhLmlkO1xuICAgICAgICAgICAgY29uc3QgZXhwaXJlc0F0ID0gbmV3IERhdGUoRGF0ZS5ub3coKSArIG1pbnV0ZXNJbkZ1dHVyZSAqIDYwICogMTAwMCk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSB0b2tlbiB3aXRoIGZ1dHVyZSBleHBpcmF0aW9uXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IHRva2VuUmVjb3JkLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgLmZyb20oJ21hZ2ljX2xpbmtfdG9rZW5zJylcbiAgICAgICAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgICAgICAgdG9rZW46IHRva2VuLFxuICAgICAgICAgICAgICAgIGd1ZXN0X2lkOiBndWVzdElkLFxuICAgICAgICAgICAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZXNBdC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICAgICAgICAvLyBDbGVhbiB1cFxuICAgICAgICAgICAgaWYgKHRva2VuUmVjb3JkKSB7XG4gICAgICAgICAgICAgIGF3YWl0IHN1cGFiYXNlLmZyb20oJ21hZ2ljX2xpbmtfdG9rZW5zJykuZGVsZXRlKCkuZXEoJ2lkJywgdG9rZW5SZWNvcmQuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgc3VwYWJhc2UuZnJvbSgnZ3Vlc3RzJykuZGVsZXRlKCkuZXEoJ2lkJywgZ3Vlc3RJZCk7XG5cbiAgICAgICAgICAgIC8vIEFzc2VydGlvblxuICAgICAgICAgICAgZXhwZWN0KGVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgICAgICAgZXhwZWN0KHRva2VuUmVjb3JkKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KG5ldyBEYXRlKHRva2VuUmVjb3JkIS5leHBpcmVzX2F0KS5nZXRUaW1lKCkpLnRvQmVHcmVhdGVyVGhhbihEYXRlLm5vdygpKTtcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHsgbnVtUnVuczogMjAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Byb3BlcnR5IDY6IE1hZ2ljIGxpbmsgdG9rZW5zIGFyZSBzaW5nbGUtdXNlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcHJldmVudCBtYXJraW5nIGFuIGFscmVhZHktdXNlZCB0b2tlbiBhcyB1c2VkIGFnYWluJywgKCkgPT4ge1xuICAgICAgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICAgIGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMzIsIG1heExlbmd0aDogNjQgfSksXG4gICAgICAgICAgYXN5bmMgKHRva2VuKSA9PiB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGVzdCBndWVzdFxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBndWVzdCB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgLmZyb20oJ2d1ZXN0cycpXG4gICAgICAgICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgICAgICAgIGdyb3VwX2lkOiB0ZXN0R3JvdXBJZCxcbiAgICAgICAgICAgICAgICBmaXJzdF9uYW1lOiAnU2luZ2xlVXNlJyxcbiAgICAgICAgICAgICAgICBsYXN0X25hbWU6ICdUZXN0JyxcbiAgICAgICAgICAgICAgICBlbWFpbDogYHNpbmdsZXVzZS4ke0RhdGUubm93KCl9QGV4YW1wbGUuY29tYCxcbiAgICAgICAgICAgICAgICBhZ2VfdHlwZTogJ2FkdWx0JyxcbiAgICAgICAgICAgICAgICBndWVzdF90eXBlOiAnd2VkZGluZ19ndWVzdCcsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGd1ZXN0SWQgPSBndWVzdCEuaWQ7XG4gICAgICAgICAgICBjb25zdCBleHBpcmVzQXQgPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgMTUgKiA2MCAqIDEwMDApO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgdG9rZW5cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogdG9rZW5SZWNvcmQgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgIC5mcm9tKCdtYWdpY19saW5rX3Rva2VucycpXG4gICAgICAgICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgICAgICAgIHRva2VuOiB0b2tlbixcbiAgICAgICAgICAgICAgICBndWVzdF9pZDogZ3Vlc3RJZCxcbiAgICAgICAgICAgICAgICBleHBpcmVzX2F0OiBleHBpcmVzQXQudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgICAgICAgY29uc3QgdG9rZW5JZCA9IHRva2VuUmVjb3JkIS5pZDtcblxuICAgICAgICAgICAgLy8gTWFyayB0b2tlbiBhcyB1c2VkIChmaXJzdCB0aW1lKVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBmaXJzdFVzZSB9ID0gYXdhaXQgc3VwYWJhc2UucnBjKFxuICAgICAgICAgICAgICAnbWFya19tYWdpY19saW5rX3Rva2VuX3VzZWQnLFxuICAgICAgICAgICAgICB7IHRva2VuX3ZhbHVlOiB0b2tlbiB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBUcnkgdG8gbWFyayBhcyB1c2VkIGFnYWluIChzZWNvbmQgdGltZSlcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vjb25kVXNlIH0gPSBhd2FpdCBzdXBhYmFzZS5ycGMoXG4gICAgICAgICAgICAgICdtYXJrX21hZ2ljX2xpbmtfdG9rZW5fdXNlZCcsXG4gICAgICAgICAgICAgIHsgdG9rZW5fdmFsdWU6IHRva2VuIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIENsZWFuIHVwXG4gICAgICAgICAgICBhd2FpdCBzdXBhYmFzZS5mcm9tKCdtYWdpY19saW5rX3Rva2VucycpLmRlbGV0ZSgpLmVxKCdpZCcsIHRva2VuSWQpO1xuICAgICAgICAgICAgYXdhaXQgc3VwYWJhc2UuZnJvbSgnZ3Vlc3RzJykuZGVsZXRlKCkuZXEoJ2lkJywgZ3Vlc3RJZCk7XG5cbiAgICAgICAgICAgIC8vIEFzc2VydGlvbnNcbiAgICAgICAgICAgIGV4cGVjdChmaXJzdFVzZSkudG9CZSh0cnVlKTsgLy8gRmlyc3QgdXNlIHN1Y2NlZWRzXG4gICAgICAgICAgICBleHBlY3Qoc2Vjb25kVXNlKS50b0JlKGZhbHNlKTsgLy8gU2Vjb25kIHVzZSBmYWlsc1xuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgeyBudW1SdW5zOiAyMCB9XG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUHJvcGVydHkgNzogRXhwaXJlZCB0b2tlbnMgY2Fubm90IGJlIHVzZWQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZWplY3QgdG9rZW5zIHRoYXQgaGF2ZSBleHBpcmVkJywgKCkgPT4ge1xuICAgICAgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICAgIGZjLmludGVnZXIoeyBtaW46IDEsIG1heDogNjAgfSksIC8vIE1pbnV0ZXMgaW4gdGhlIHBhc3RcbiAgICAgICAgICBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDMyLCBtYXhMZW5ndGg6IDY0IH0pLFxuICAgICAgICAgIGFzeW5jIChtaW51dGVzSW5QYXN0LCB0b2tlbikgPT4ge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRlc3QgZ3Vlc3RcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogZ3Vlc3QgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgIC5mcm9tKCdndWVzdHMnKVxuICAgICAgICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICAgICAgICBncm91cF9pZDogdGVzdEdyb3VwSWQsXG4gICAgICAgICAgICAgICAgZmlyc3RfbmFtZTogJ0V4cGlyZWQnLFxuICAgICAgICAgICAgICAgIGxhc3RfbmFtZTogJ1Rlc3QnLFxuICAgICAgICAgICAgICAgIGVtYWlsOiBgZXhwaXJlZC4ke0RhdGUubm93KCl9QGV4YW1wbGUuY29tYCxcbiAgICAgICAgICAgICAgICBhZ2VfdHlwZTogJ2FkdWx0JyxcbiAgICAgICAgICAgICAgICBndWVzdF90eXBlOiAnd2VkZGluZ19ndWVzdCcsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGd1ZXN0SWQgPSBndWVzdCEuaWQ7XG4gICAgICAgICAgICBjb25zdCBleHBpcmVzQXQgPSBuZXcgRGF0ZShEYXRlLm5vdygpIC0gbWludXRlc0luUGFzdCAqIDYwICogMTAwMCk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBleHBpcmVkIHRva2VuXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IHRva2VuUmVjb3JkIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAuZnJvbSgnbWFnaWNfbGlua190b2tlbnMnKVxuICAgICAgICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICAgICAgICB0b2tlbjogdG9rZW4sXG4gICAgICAgICAgICAgICAgZ3Vlc3RfaWQ6IGd1ZXN0SWQsXG4gICAgICAgICAgICAgICAgZXhwaXJlc19hdDogZXhwaXJlc0F0LnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRva2VuSWQgPSB0b2tlblJlY29yZCEuaWQ7XG5cbiAgICAgICAgICAgIC8vIFRyeSB0byBtYXJrIGV4cGlyZWQgdG9rZW4gYXMgdXNlZFxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiByZXN1bHQgfSA9IGF3YWl0IHN1cGFiYXNlLnJwYyhcbiAgICAgICAgICAgICAgJ21hcmtfbWFnaWNfbGlua190b2tlbl91c2VkJyxcbiAgICAgICAgICAgICAgeyB0b2tlbl92YWx1ZTogdG9rZW4gfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgICAgICAgIGF3YWl0IHN1cGFiYXNlLmZyb20oJ21hZ2ljX2xpbmtfdG9rZW5zJykuZGVsZXRlKCkuZXEoJ2lkJywgdG9rZW5JZCk7XG4gICAgICAgICAgICBhd2FpdCBzdXBhYmFzZS5mcm9tKCdndWVzdHMnKS5kZWxldGUoKS5lcSgnaWQnLCBndWVzdElkKTtcblxuICAgICAgICAgICAgLy8gQXNzZXJ0aW9uOiBleHBpcmVkIHRva2VuIGNhbm5vdCBiZSB1c2VkXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHsgbnVtUnVuczogMjAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Byb3BlcnR5IDg6IFRva2VuIHVuaXF1ZW5lc3MgaXMgZW5mb3JjZWQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZWplY3QgZHVwbGljYXRlIHRva2VucycsICgpID0+IHtcbiAgICAgIGZjLmFzc2VydChcbiAgICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgICBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDMyLCBtYXhMZW5ndGg6IDY0IH0pLFxuICAgICAgICAgIGFzeW5jICh0b2tlbikgPT4ge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRlc3QgZ3Vlc3RcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogZ3Vlc3QgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgIC5mcm9tKCdndWVzdHMnKVxuICAgICAgICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICAgICAgICBncm91cF9pZDogdGVzdEdyb3VwSWQsXG4gICAgICAgICAgICAgICAgZmlyc3RfbmFtZTogJ1VuaXF1ZScsXG4gICAgICAgICAgICAgICAgbGFzdF9uYW1lOiAnVGVzdCcsXG4gICAgICAgICAgICAgICAgZW1haWw6IGB1bmlxdWUuJHtEYXRlLm5vdygpfUBleGFtcGxlLmNvbWAsXG4gICAgICAgICAgICAgICAgYWdlX3R5cGU6ICdhZHVsdCcsXG4gICAgICAgICAgICAgICAgZ3Vlc3RfdHlwZTogJ3dlZGRpbmdfZ3Vlc3QnLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICAgICAgICBjb25zdCBndWVzdElkID0gZ3Vlc3QhLmlkO1xuICAgICAgICAgICAgY29uc3QgZXhwaXJlc0F0ID0gbmV3IERhdGUoRGF0ZS5ub3coKSArIDE1ICogNjAgKiAxMDAwKTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGZpcnN0IHRva2VuXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IHRva2VuMSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgLmZyb20oJ21hZ2ljX2xpbmtfdG9rZW5zJylcbiAgICAgICAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgICAgICAgdG9rZW46IHRva2VuLFxuICAgICAgICAgICAgICAgIGd1ZXN0X2lkOiBndWVzdElkLFxuICAgICAgICAgICAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZXNBdC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICAgICAgICBjb25zdCB0b2tlbjFJZCA9IHRva2VuMSEuaWQ7XG5cbiAgICAgICAgICAgIC8vIFRyeSB0byBjcmVhdGUgZHVwbGljYXRlIHRva2VuXG4gICAgICAgICAgICBjb25zdCB7IGVycm9yOiBkdXBsaWNhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgLmZyb20oJ21hZ2ljX2xpbmtfdG9rZW5zJylcbiAgICAgICAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgICAgICAgdG9rZW46IHRva2VuLFxuICAgICAgICAgICAgICAgIGd1ZXN0X2lkOiBndWVzdElkLFxuICAgICAgICAgICAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZXNBdC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgICAgICAgIGF3YWl0IHN1cGFiYXNlLmZyb20oJ21hZ2ljX2xpbmtfdG9rZW5zJykuZGVsZXRlKCkuZXEoJ2lkJywgdG9rZW4xSWQpO1xuICAgICAgICAgICAgYXdhaXQgc3VwYWJhc2UuZnJvbSgnZ3Vlc3RzJykuZGVsZXRlKCkuZXEoJ2lkJywgZ3Vlc3RJZCk7XG5cbiAgICAgICAgICAgIC8vIEFzc2VydGlvbjogZHVwbGljYXRlIHNob3VsZCBiZSByZWplY3RlZFxuICAgICAgICAgICAgZXhwZWN0KGR1cGxpY2F0ZUVycm9yKS5ub3QudG9CZU51bGwoKTtcbiAgICAgICAgICAgIGV4cGVjdChkdXBsaWNhdGVFcnJvcj8ubWVzc2FnZSkudG9NYXRjaCgvZHVwbGljYXRlfHVuaXF1ZS9pKTtcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHsgbnVtUnVuczogMjAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJzdXBhYmFzZVVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJzdXBhYmFzZVNlcnZpY2VLZXkiLCJTVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZIiwiZGVzY3JpYmUiLCJzdXBhYmFzZSIsInRlc3RHcm91cElkIiwiYmVmb3JlQWxsIiwiY3JlYXRlQ2xpZW50IiwiZGF0YSIsImdyb3VwIiwiZnJvbSIsImluc2VydCIsIm5hbWUiLCJzZWxlY3QiLCJzaW5nbGUiLCJpZCIsImFmdGVyQWxsIiwiZGVsZXRlIiwiZXEiLCJpdCIsImZjIiwiYXNzZXJ0IiwiYXN5bmNQcm9wZXJ0eSIsImNvbnN0YW50RnJvbSIsInN0cmluZyIsIm1pbkxlbmd0aCIsIm1heExlbmd0aCIsImVtYWlsQWRkcmVzcyIsImF1dGhNZXRob2QiLCJmaXJzdE5hbWUiLCJsYXN0TmFtZSIsImVtYWlsIiwiZ3Vlc3QiLCJlcnJvciIsImdyb3VwX2lkIiwiZmlyc3RfbmFtZSIsImxhc3RfbmFtZSIsImFnZV90eXBlIiwiZ3Vlc3RfdHlwZSIsImF1dGhfbWV0aG9kIiwiZXhwZWN0IiwidG9CZU51bGwiLCJ0b0JlRGVmaW5lZCIsInRvQmUiLCJudW1SdW5zIiwiZmlsdGVyIiwicyIsImludmFsaWRBdXRoTWV0aG9kIiwibm90IiwibWVzc2FnZSIsInRvTWF0Y2giLCJpbml0aWFsTWV0aG9kIiwidXBkYXRlZE1ldGhvZCIsImd1ZXN0SWQiLCJ1cGRhdGVkR3Vlc3QiLCJ1cGRhdGUiLCJpbnRlZ2VyIiwibWluIiwibWF4IiwibWludXRlc0luRnV0dXJlIiwidG9rZW4iLCJEYXRlIiwibm93IiwiZXhwaXJlc0F0IiwidG9rZW5SZWNvcmQiLCJndWVzdF9pZCIsImV4cGlyZXNfYXQiLCJ0b0lTT1N0cmluZyIsImdldFRpbWUiLCJ0b0JlR3JlYXRlclRoYW4iLCJ0b2tlbklkIiwiZmlyc3RVc2UiLCJycGMiLCJ0b2tlbl92YWx1ZSIsInNlY29uZFVzZSIsIm1pbnV0ZXNJblBhc3QiLCJyZXN1bHQiLCJ0b2tlbjEiLCJ0b2tlbjFJZCIsImR1cGxpY2F0ZUVycm9yIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztDQVVDOzs7O21FQUVtQjs0QkFDUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRTdCLE1BQU1BLGNBQWNDLFFBQVFDLEdBQUcsQ0FBQ0Msd0JBQXdCO0FBQ3hELE1BQU1DLHFCQUFxQkgsUUFBUUMsR0FBRyxDQUFDRyx5QkFBeUI7QUFFaEVDLFNBQVMsNEZBQTRGO0lBQ25HLElBQUlDO0lBQ0osSUFBSUM7SUFFSkMsVUFBVTtRQUNSRixXQUFXRyxJQUFBQSx3QkFBWSxFQUFDVixhQUFhSTtRQUVyQyxvQkFBb0I7UUFDcEIsTUFBTSxFQUFFTyxNQUFNQyxLQUFLLEVBQUUsR0FBRyxNQUFNTCxTQUMzQk0sSUFB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