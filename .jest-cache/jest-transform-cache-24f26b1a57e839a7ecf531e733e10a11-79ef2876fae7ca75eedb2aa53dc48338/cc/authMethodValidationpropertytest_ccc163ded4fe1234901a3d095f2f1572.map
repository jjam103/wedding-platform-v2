{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/__tests__/property/authMethodValidation.property.test.ts"],"sourcesContent":["/**\n * Property-based tests for authentication method validation\n * \n * Requirements: 5.1, 5.2, 5.3, 22.1, 22.2\n * Tasks: 4.1, 4.2\n * \n * Property: Authentication Method Validation\n * - auth_method must be either 'email_matching' or 'magic_link'\n * - default_auth_method must be either 'email_matching' or 'magic_link'\n * - Invalid values should be rejected\n */\n\nimport * as fc from 'fast-check';\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;\n\ndescribe('Feature: guest-portal-and-admin-enhancements, Property: Authentication Method Validation', () => {\n  let supabase: ReturnType<typeof createClient>;\n  let testGroupId: string;\n\n  beforeAll(async () => {\n    supabase = createClient(supabaseUrl, supabaseServiceKey);\n\n    // Create test group\n    const { data: group } = await supabase\n      .from('groups')\n      .insert({ name: 'Property Test Auth Group' })\n      .select()\n      .single();\n\n    testGroupId = group!.id;\n  });\n\n  afterAll(async () => {\n    // Clean up\n    if (testGroupId) {\n      await supabase.from('groups').delete().eq('id', testGroupId);\n    }\n  });\n\n  describe('Property 1: Valid auth_method values are accepted', () => {\n    it('should accept email_matching and magic_link as valid auth_method values', () => {\n      fc.assert(\n        fc.asyncProperty(\n          fc.constantFrom('email_matching', 'magic_link'),\n          fc.string({ minLength: 1, maxLength: 50 }),\n          fc.string({ minLength: 1, maxLength: 50 }),\n          fc.emailAddress(),\n          async (authMethod, firstName, lastName, email) => {\n            // Create guest with specified auth_method\n            const { data: guest, error } = await supabase\n              .from('guests')\n              .insert({\n                group_id: testGroupId,\n                first_name: firstName,\n                last_name: lastName,\n                email: email,\n                age_type: 'adult',\n                guest_type: 'wedding_guest',\n                auth_method: authMethod,\n              })\n              .select()\n              .single();\n\n            // Clean up\n            if (guest) {\n              await supabase.from('guests').delete().eq('id', guest.id);\n            }\n\n            // Assertion\n            expect(error).toBeNull();\n            expect(guest).toBeDefined();\n            expect(guest?.auth_method).toBe(authMethod);\n          }\n        ),\n        { numRuns: 20 }\n      );\n    });\n  });\n\n  describe('Property 2: Invalid auth_method values are rejected', () => {\n    it('should reject any auth_method value other than email_matching or magic_link', () => {\n      fc.assert(\n        fc.asyncProperty(\n          fc.string({ minLength: 1, maxLength: 50 }).filter(\n            (s) => s !== 'email_matching' && s !== 'magic_link'\n          ),\n          fc.string({ minLength: 1, maxLength: 50 }),\n          fc.string({ minLength: 1, maxLength: 50 }),\n          fc.emailAddress(),\n          async (invalidAuthMethod, firstName, lastName, email) => {\n            // Try to create guest with invalid auth_method\n            const { error } = await supabase\n              .from('guests')\n              .insert({\n                group_id: testGroupId,\n                first_name: firstName,\n                last_name: lastName,\n                email: email,\n                age_type: 'adult',\n                guest_type: 'wedding_guest',\n                auth_method: invalidAuthMethod as any,\n              });\n\n            // Assertion: should fail with constraint violation\n            expect(error).not.toBeNull();\n            expect(error?.message).toMatch(/auth_method|constraint|check/i);\n          }\n        ),\n        { numRuns: 20 }\n      );\n    });\n  });\n\n  describe('Property 3: Default auth_method is email_matching', () => {\n    it('should default to email_matching when auth_method is not specified', () => {\n      fc.assert(\n        fc.asyncProperty(\n          fc.string({ minLength: 1, maxLength: 50 }),\n          fc.string({ minLength: 1, maxLength: 50 }),\n          fc.emailAddress(),\n          async (firstName, lastName, email) => {\n            // Create guest without specifying auth_method\n            const { data: guest, error } = await supabase\n              .from('guests')\n              .insert({\n                group_id: testGroupId,\n                first_name: firstName,\n                last_name: lastName,\n                email: email,\n                age_type: 'adult',\n                guest_type: 'wedding_guest',\n                // auth_method not specified\n              })\n              .select()\n              .single();\n\n            // Clean up\n            if (guest) {\n              await supabase.from('guests').delete().eq('id', guest.id);\n            }\n\n            // Assertion\n            expect(error).toBeNull();\n            expect(guest).toBeDefined();\n            expect(guest?.auth_method).toBe('email_matching');\n          }\n        ),\n        { numRuns: 20 }\n      );\n    });\n  });\n\n  describe('Property 4: auth_method can be updated', () => {\n    it('should allow updating auth_method between valid values', () => {\n      fc.assert(\n        fc.asyncProperty(\n          fc.constantFrom('email_matching', 'magic_link'),\n          fc.constantFrom('email_matching', 'magic_link'),\n          fc.string({ minLength: 1, maxLength: 50 }),\n          fc.string({ minLength: 1, maxLength: 50 }),\n          fc.emailAddress(),\n          async (initialMethod, updatedMethod, firstName, lastName, email) => {\n            // Create guest with initial auth_method\n            const { data: guest } = await supabase\n              .from('guests')\n              .insert({\n                group_id: testGroupId,\n                first_name: firstName,\n                last_name: lastName,\n                email: email,\n                age_type: 'adult',\n                guest_type: 'wedding_guest',\n                auth_method: initialMethod,\n              })\n              .select()\n              .single();\n\n            const guestId = guest!.id;\n\n            // Update auth_method\n            const { data: updatedGuest, error } = await supabase\n              .from('guests')\n              .update({ auth_method: updatedMethod })\n              .eq('id', guestId)\n              .select()\n              .single();\n\n            // Clean up\n            await supabase.from('guests').delete().eq('id', guestId);\n\n            // Assertion\n            expect(error).toBeNull();\n            expect(updatedGuest).toBeDefined();\n            expect(updatedGuest?.auth_method).toBe(updatedMethod);\n          }\n        ),\n        { numRuns: 20 }\n      );\n    });\n  });\n\n  describe('Property 5: Magic link tokens must have valid expiration', () => {\n    it('should only accept tokens with future expiration dates', () => {\n      fc.assert(\n        fc.asyncProperty(\n          fc.integer({ min: 1, max: 60 }), // Minutes in the future\n          fc.string({ minLength: 32, maxLength: 64 }),\n          async (minutesInFuture, token) => {\n            // Create test guest\n            const { data: guest } = await supabase\n              .from('guests')\n              .insert({\n                group_id: testGroupId,\n                first_name: 'Token',\n                last_name: 'Test',\n                email: `token.test.${Date.now()}@example.com`,\n                age_type: 'adult',\n                guest_type: 'wedding_guest',\n              })\n              .select()\n              .single();\n\n            const guestId = guest!.id;\n            const expiresAt = new Date(Date.now() + minutesInFuture * 60 * 1000);\n\n            // Create token with future expiration\n            const { data: tokenRecord, error } = await supabase\n              .from('magic_link_tokens')\n              .insert({\n                token: token,\n                guest_id: guestId,\n                expires_at: expiresAt.toISOString(),\n              })\n              .select()\n              .single();\n\n            // Clean up\n            if (tokenRecord) {\n              await supabase.from('magic_link_tokens').delete().eq('id', tokenRecord.id);\n            }\n            await supabase.from('guests').delete().eq('id', guestId);\n\n            // Assertion\n            expect(error).toBeNull();\n            expect(tokenRecord).toBeDefined();\n            expect(new Date(tokenRecord!.expires_at).getTime()).toBeGreaterThan(Date.now());\n          }\n        ),\n        { numRuns: 20 }\n      );\n    });\n  });\n\n  describe('Property 6: Magic link tokens are single-use', () => {\n    it('should prevent marking an already-used token as used again', () => {\n      fc.assert(\n        fc.asyncProperty(\n          fc.string({ minLength: 32, maxLength: 64 }),\n          async (token) => {\n            // Create test guest\n            const { data: guest } = await supabase\n              .from('guests')\n              .insert({\n                group_id: testGroupId,\n                first_name: 'SingleUse',\n                last_name: 'Test',\n                email: `singleuse.${Date.now()}@example.com`,\n                age_type: 'adult',\n                guest_type: 'wedding_guest',\n              })\n              .select()\n              .single();\n\n            const guestId = guest!.id;\n            const expiresAt = new Date(Date.now() + 15 * 60 * 1000);\n\n            // Create token\n            const { data: tokenRecord } = await supabase\n              .from('magic_link_tokens')\n              .insert({\n                token: token,\n                guest_id: guestId,\n                expires_at: expiresAt.toISOString(),\n              })\n              .select()\n              .single();\n\n            const tokenId = tokenRecord!.id;\n\n            // Mark token as used (first time)\n            const { data: firstUse } = await supabase.rpc(\n              'mark_magic_link_token_used',\n              { token_value: token }\n            );\n\n            // Try to mark as used again (second time)\n            const { data: secondUse } = await supabase.rpc(\n              'mark_magic_link_token_used',\n              { token_value: token }\n            );\n\n            // Clean up\n            await supabase.from('magic_link_tokens').delete().eq('id', tokenId);\n            await supabase.from('guests').delete().eq('id', guestId);\n\n            // Assertions\n            expect(firstUse).toBe(true); // First use succeeds\n            expect(secondUse).toBe(false); // Second use fails\n          }\n        ),\n        { numRuns: 20 }\n      );\n    });\n  });\n\n  describe('Property 7: Expired tokens cannot be used', () => {\n    it('should reject tokens that have expired', () => {\n      fc.assert(\n        fc.asyncProperty(\n          fc.integer({ min: 1, max: 60 }), // Minutes in the past\n          fc.string({ minLength: 32, maxLength: 64 }),\n          async (minutesInPast, token) => {\n            // Create test guest\n            const { data: guest } = await supabase\n              .from('guests')\n              .insert({\n                group_id: testGroupId,\n                first_name: 'Expired',\n                last_name: 'Test',\n                email: `expired.${Date.now()}@example.com`,\n                age_type: 'adult',\n                guest_type: 'wedding_guest',\n              })\n              .select()\n              .single();\n\n            const guestId = guest!.id;\n            const expiresAt = new Date(Date.now() - minutesInPast * 60 * 1000);\n\n            // Create expired token\n            const { data: tokenRecord } = await supabase\n              .from('magic_link_tokens')\n              .insert({\n                token: token,\n                guest_id: guestId,\n                expires_at: expiresAt.toISOString(),\n              })\n              .select()\n              .single();\n\n            const tokenId = tokenRecord!.id;\n\n            // Try to mark expired token as used\n            const { data: result } = await supabase.rpc(\n              'mark_magic_link_token_used',\n              { token_value: token }\n            );\n\n            // Clean up\n            await supabase.from('magic_link_tokens').delete().eq('id', tokenId);\n            await supabase.from('guests').delete().eq('id', guestId);\n\n            // Assertion: expired token cannot be used\n            expect(result).toBe(false);\n          }\n        ),\n        { numRuns: 20 }\n      );\n    });\n  });\n\n  describe('Property 8: Token uniqueness is enforced', () => {\n    it('should reject duplicate tokens', () => {\n      fc.assert(\n        fc.asyncProperty(\n          fc.string({ minLength: 32, maxLength: 64 }),\n          async (token) => {\n            // Create test guest\n            const { data: guest } = await supabase\n              .from('guests')\n              .insert({\n                group_id: testGroupId,\n                first_name: 'Unique',\n                last_name: 'Test',\n                email: `unique.${Date.now()}@example.com`,\n                age_type: 'adult',\n                guest_type: 'wedding_guest',\n              })\n              .select()\n              .single();\n\n            const guestId = guest!.id;\n            const expiresAt = new Date(Date.now() + 15 * 60 * 1000);\n\n            // Create first token\n            const { data: token1 } = await supabase\n              .from('magic_link_tokens')\n              .insert({\n                token: token,\n                guest_id: guestId,\n                expires_at: expiresAt.toISOString(),\n              })\n              .select()\n              .single();\n\n            const token1Id = token1!.id;\n\n            // Try to create duplicate token\n            const { error: duplicateError } = await supabase\n              .from('magic_link_tokens')\n              .insert({\n                token: token,\n                guest_id: guestId,\n                expires_at: expiresAt.toISOString(),\n              });\n\n            // Clean up\n            await supabase.from('magic_link_tokens').delete().eq('id', token1Id);\n            await supabase.from('guests').delete().eq('id', guestId);\n\n            // Assertion: duplicate should be rejected\n            expect(duplicateError).not.toBeNull();\n            expect(duplicateError?.message).toMatch(/duplicate|unique/i);\n          }\n        ),\n        { numRuns: 20 }\n      );\n    });\n  });\n});\n"],"names":["supabaseUrl","process","env","NEXT_PUBLIC_SUPABASE_URL","supabaseServiceKey","SUPABASE_SERVICE_ROLE_KEY","describe","supabase","testGroupId","beforeAll","createClient","data","group","from","insert","name","select","single","id","afterAll","delete","eq","it","fc","assert","asyncProperty","constantFrom","string","minLength","maxLength","emailAddress","authMethod","firstName","lastName","email","guest","error","group_id","first_name","last_name","age_type","guest_type","auth_method","expect","toBeNull","toBeDefined","toBe","numRuns","filter","s","invalidAuthMethod","not","message","toMatch","initialMethod","updatedMethod","guestId","updatedGuest","update","integer","min","max","minutesInFuture","token","Date","now","expiresAt","tokenRecord","guest_id","expires_at","toISOString","getTime","toBeGreaterThan","tokenId","firstUse","rpc","token_value","secondUse","minutesInPast","result","token1","token1Id","duplicateError"],"mappings":"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"}