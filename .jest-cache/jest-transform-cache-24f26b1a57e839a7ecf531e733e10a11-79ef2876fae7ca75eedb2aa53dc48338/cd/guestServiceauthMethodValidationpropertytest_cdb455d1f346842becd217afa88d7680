82c665c50f5c2fecda41a55eb351a4d0
/**
 * Property-Based Tests for Guest Auth Method Validation
 * Feature: admin-ux-enhancements
 * Property 1: Auth Method Consistency
 * 
 * Validates: Requirements 1.1, 1.2
 */ "use strict";
// Mock Supabase
jest.mock('@/lib/supabase', ()=>({
        createClient: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _guestService = /*#__PURE__*/ _interop_require_wildcard(require("./guestService"));
const _mockSupabase = require("../__tests__/helpers/mockSupabase");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('Feature: admin-ux-enhancements, Property 1: Auth Method Consistency', ()=>{
    let mockSupabase;
    beforeEach(()=>{
        mockSupabase = (0, _mockSupabase.createMockSupabaseClient)();
        jest.clearAllMocks();
    });
    /**
   * Property 1: Auth Method Consistency
   * 
   * For any guest record, the auth_method field should always contain 
   * a valid value ('email_matching' or 'magic_link'), never NULL or invalid values
   */ it('should ensure all created guests have valid auth_method', ()=>{
        _fastcheck.assert(_fastcheck.property(_fastcheck.record({
            firstName: _fastcheck.string({
                minLength: 1,
                maxLength: 50
            }),
            lastName: _fastcheck.string({
                minLength: 1,
                maxLength: 50
            }),
            email: _fastcheck.oneof(_fastcheck.emailAddress(), _fastcheck.constant(null)),
            ageType: _fastcheck.constantFrom('adult', 'child', 'senior'),
            guestType: _fastcheck.constantFrom('wedding_party', 'wedding_guest', 'prewedding_only', 'postwedding_only'),
            groupId: _fastcheck.uuid(),
            authMethod: _fastcheck.oneof(_fastcheck.constant('email_matching'), _fastcheck.constant('magic_link'), _fastcheck.constant(null), _fastcheck.constant(undefined))
        }), async (guestData)=>{
            // Mock successful database insert
            const mockGuest = {
                id: _fastcheck.sample(_fastcheck.uuid(), 1)[0],
                ...guestData,
                auth_method: guestData.authMethod || 'email_matching',
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
            };
            mockSupabase.from.mockReturnValue({
                insert: jest.fn().mockReturnValue({
                    select: jest.fn().mockReturnValue({
                        single: jest.fn().mockResolvedValue({
                            data: mockGuest,
                            error: null
                        })
                    })
                })
            });
            const result = await _guestService.create({
                firstName: guestData.firstName,
                lastName: guestData.lastName,
                email: guestData.email,
                ageType: guestData.ageType,
                guestType: guestData.guestType,
                groupId: guestData.groupId
            });
            // Property: Result should always succeed with valid auth_method
            expect(result.success).toBe(true);
            if (result.success) {
                // Auth method must be one of the valid values
                expect([
                    'email_matching',
                    'magic_link'
                ]).toContain(result.data.auth_method);
                // Auth method must never be null or undefined
                expect(result.data.auth_method).not.toBeNull();
                expect(result.data.auth_method).not.toBeUndefined();
            }
        }), {
            numRuns: 100
        });
    });
    /**
   * Property: Auth Method Inheritance
   * 
   * When creating a guest without specifying auth_method,
   * it should inherit the system default
   */ it('should inherit default auth_method when not specified', ()=>{
        _fastcheck.assert(_fastcheck.property(_fastcheck.record({
            firstName: _fastcheck.string({
                minLength: 1,
                maxLength: 50
            }),
            lastName: _fastcheck.string({
                minLength: 1,
                maxLength: 50
            }),
            email: _fastcheck.emailAddress(),
            ageType: _fastcheck.constantFrom('adult', 'child', 'senior'),
            guestType: _fastcheck.constantFrom('wedding_party', 'wedding_guest', 'prewedding_only', 'postwedding_only'),
            groupId: _fastcheck.uuid()
        }), _fastcheck.constantFrom('email_matching', 'magic_link'), async (guestData, defaultAuthMethod)=>{
            // Mock system settings to return default auth method
            const mockGuest = {
                id: _fastcheck.sample(_fastcheck.uuid(), 1)[0],
                ...guestData,
                auth_method: defaultAuthMethod,
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
            };
            mockSupabase.from.mockReturnValue({
                insert: jest.fn().mockReturnValue({
                    select: jest.fn().mockReturnValue({
                        single: jest.fn().mockResolvedValue({
                            data: mockGuest,
                            error: null
                        })
                    })
                })
            });
            const result = await _guestService.create(guestData);
            // Property: Guest should inherit the default auth method
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.auth_method).toBe(defaultAuthMethod);
            }
        }), {
            numRuns: 50
        });
    });
    /**
   * Property: Auth Method Update Validation
   * 
   * When updating a guest's auth_method, only valid values should be accepted
   */ it('should only accept valid auth_method values on update', ()=>{
        _fastcheck.assert(_fastcheck.property(_fastcheck.uuid(), _fastcheck.oneof(_fastcheck.constant('email_matching'), _fastcheck.constant('magic_link'), _fastcheck.string().filter((s)=>![
                'email_matching',
                'magic_link'
            ].includes(s))), async (guestId, authMethod)=>{
            const isValidAuthMethod = [
                'email_matching',
                'magic_link'
            ].includes(authMethod);
            if (isValidAuthMethod) {
                // Mock successful update
                mockSupabase.from.mockReturnValue({
                    update: jest.fn().mockReturnValue({
                        eq: jest.fn().mockReturnValue({
                            select: jest.fn().mockReturnValue({
                                single: jest.fn().mockResolvedValue({
                                    data: {
                                        id: guestId,
                                        auth_method: authMethod
                                    },
                                    error: null
                                })
                            })
                        })
                    })
                });
                const result = await _guestService.update(guestId, {
                    authMethod
                });
                // Property: Valid auth methods should succeed
                expect(result.success).toBe(true);
                if (result.success) {
                    expect(result.data.auth_method).toBe(authMethod);
                }
            } else {
                // Property: Invalid auth methods should fail validation
                const result = await _guestService.update(guestId, {
                    authMethod
                });
                expect(result.success).toBe(false);
                if (!result.success) {
                    expect(result.error.code).toBe('VALIDATION_ERROR');
                }
            }
        }), {
            numRuns: 100
        });
    });
    /**
   * Property: Bulk Auth Method Update Consistency
   * 
   * When bulk updating auth methods, all guests should receive the same valid value
   */ it('should consistently apply auth_method in bulk updates', ()=>{
        _fastcheck.assert(_fastcheck.property(_fastcheck.array(_fastcheck.uuid(), {
            minLength: 1,
            maxLength: 50
        }), _fastcheck.constantFrom('email_matching', 'magic_link'), async (guestIds, authMethod)=>{
            // Mock successful bulk update
            const mockUpdatedGuests = guestIds.map((id)=>({
                    id,
                    auth_method: authMethod
                }));
            mockSupabase.from.mockReturnValue({
                update: jest.fn().mockReturnValue({
                    in: jest.fn().mockReturnValue({
                        select: jest.fn().mockResolvedValue({
                            data: mockUpdatedGuests,
                            error: null
                        })
                    })
                })
            });
            // Simulate bulk update (would be implemented in service)
            const result = await Promise.all(guestIds.map((id)=>_guestService.update(id, {
                    authMethod
                })));
            // Property: All updates should succeed with consistent auth_method
            result.forEach((r)=>{
                expect(r.success).toBe(true);
                if (r.success) {
                    expect(r.data.auth_method).toBe(authMethod);
                }
            });
        }), {
            numRuns: 50
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvZ3Vlc3RTZXJ2aWNlLmF1dGhNZXRob2RWYWxpZGF0aW9uLnByb3BlcnR5LnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQcm9wZXJ0eS1CYXNlZCBUZXN0cyBmb3IgR3Vlc3QgQXV0aCBNZXRob2QgVmFsaWRhdGlvblxuICogRmVhdHVyZTogYWRtaW4tdXgtZW5oYW5jZW1lbnRzXG4gKiBQcm9wZXJ0eSAxOiBBdXRoIE1ldGhvZCBDb25zaXN0ZW5jeVxuICogXG4gKiBWYWxpZGF0ZXM6IFJlcXVpcmVtZW50cyAxLjEsIDEuMlxuICovXG5cbmltcG9ydCAqIGFzIGZjIGZyb20gJ2Zhc3QtY2hlY2snO1xuaW1wb3J0ICogYXMgZ3Vlc3RTZXJ2aWNlIGZyb20gJy4vZ3Vlc3RTZXJ2aWNlJztcbmltcG9ydCB7IGNyZWF0ZU1vY2tTdXBhYmFzZUNsaWVudCB9IGZyb20gJ0AvX190ZXN0c19fL2hlbHBlcnMvbW9ja1N1cGFiYXNlJztcblxuLy8gTW9jayBTdXBhYmFzZVxuamVzdC5tb2NrKCdAL2xpYi9zdXBhYmFzZScsICgpID0+ICh7XG4gIGNyZWF0ZUNsaWVudDogamVzdC5mbigpLFxufSkpO1xuXG5kZXNjcmliZSgnRmVhdHVyZTogYWRtaW4tdXgtZW5oYW5jZW1lbnRzLCBQcm9wZXJ0eSAxOiBBdXRoIE1ldGhvZCBDb25zaXN0ZW5jeScsICgpID0+IHtcbiAgbGV0IG1vY2tTdXBhYmFzZTogUmV0dXJuVHlwZTx0eXBlb2YgY3JlYXRlTW9ja1N1cGFiYXNlQ2xpZW50PjtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBtb2NrU3VwYWJhc2UgPSBjcmVhdGVNb2NrU3VwYWJhc2VDbGllbnQoKTtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFByb3BlcnR5IDE6IEF1dGggTWV0aG9kIENvbnNpc3RlbmN5XG4gICAqIFxuICAgKiBGb3IgYW55IGd1ZXN0IHJlY29yZCwgdGhlIGF1dGhfbWV0aG9kIGZpZWxkIHNob3VsZCBhbHdheXMgY29udGFpbiBcbiAgICogYSB2YWxpZCB2YWx1ZSAoJ2VtYWlsX21hdGNoaW5nJyBvciAnbWFnaWNfbGluaycpLCBuZXZlciBOVUxMIG9yIGludmFsaWQgdmFsdWVzXG4gICAqL1xuICBpdCgnc2hvdWxkIGVuc3VyZSBhbGwgY3JlYXRlZCBndWVzdHMgaGF2ZSB2YWxpZCBhdXRoX21ldGhvZCcsICgpID0+IHtcbiAgICBmYy5hc3NlcnQoXG4gICAgICBmYy5wcm9wZXJ0eShcbiAgICAgICAgZmMucmVjb3JkKHtcbiAgICAgICAgICBmaXJzdE5hbWU6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1MCB9KSxcbiAgICAgICAgICBsYXN0TmFtZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLFxuICAgICAgICAgIGVtYWlsOiBmYy5vbmVvZihmYy5lbWFpbEFkZHJlc3MoKSwgZmMuY29uc3RhbnQobnVsbCkpLFxuICAgICAgICAgIGFnZVR5cGU6IGZjLmNvbnN0YW50RnJvbSgnYWR1bHQnLCAnY2hpbGQnLCAnc2VuaW9yJyksXG4gICAgICAgICAgZ3Vlc3RUeXBlOiBmYy5jb25zdGFudEZyb20oJ3dlZGRpbmdfcGFydHknLCAnd2VkZGluZ19ndWVzdCcsICdwcmV3ZWRkaW5nX29ubHknLCAncG9zdHdlZGRpbmdfb25seScpLFxuICAgICAgICAgIGdyb3VwSWQ6IGZjLnV1aWQoKSxcbiAgICAgICAgICBhdXRoTWV0aG9kOiBmYy5vbmVvZihcbiAgICAgICAgICAgIGZjLmNvbnN0YW50KCdlbWFpbF9tYXRjaGluZycpLFxuICAgICAgICAgICAgZmMuY29uc3RhbnQoJ21hZ2ljX2xpbmsnKSxcbiAgICAgICAgICAgIGZjLmNvbnN0YW50KG51bGwpLFxuICAgICAgICAgICAgZmMuY29uc3RhbnQodW5kZWZpbmVkKVxuICAgICAgICAgICksXG4gICAgICAgIH0pLFxuICAgICAgICBhc3luYyAoZ3Vlc3REYXRhKSA9PiB7XG4gICAgICAgICAgLy8gTW9jayBzdWNjZXNzZnVsIGRhdGFiYXNlIGluc2VydFxuICAgICAgICAgIGNvbnN0IG1vY2tHdWVzdCA9IHtcbiAgICAgICAgICAgIGlkOiBmYy5zYW1wbGUoZmMudXVpZCgpLCAxKVswXSxcbiAgICAgICAgICAgIC4uLmd1ZXN0RGF0YSxcbiAgICAgICAgICAgIGF1dGhfbWV0aG9kOiBndWVzdERhdGEuYXV0aE1ldGhvZCB8fCAnZW1haWxfbWF0Y2hpbmcnLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgaW5zZXJ0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICBkYXRhOiBtb2NrR3Vlc3QsXG4gICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGd1ZXN0U2VydmljZS5jcmVhdGUoe1xuICAgICAgICAgICAgZmlyc3ROYW1lOiBndWVzdERhdGEuZmlyc3ROYW1lLFxuICAgICAgICAgICAgbGFzdE5hbWU6IGd1ZXN0RGF0YS5sYXN0TmFtZSxcbiAgICAgICAgICAgIGVtYWlsOiBndWVzdERhdGEuZW1haWwsXG4gICAgICAgICAgICBhZ2VUeXBlOiBndWVzdERhdGEuYWdlVHlwZSxcbiAgICAgICAgICAgIGd1ZXN0VHlwZTogZ3Vlc3REYXRhLmd1ZXN0VHlwZSxcbiAgICAgICAgICAgIGdyb3VwSWQ6IGd1ZXN0RGF0YS5ncm91cElkLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IFJlc3VsdCBzaG91bGQgYWx3YXlzIHN1Y2NlZWQgd2l0aCB2YWxpZCBhdXRoX21ldGhvZFxuICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIC8vIEF1dGggbWV0aG9kIG11c3QgYmUgb25lIG9mIHRoZSB2YWxpZCB2YWx1ZXNcbiAgICAgICAgICAgIGV4cGVjdChbJ2VtYWlsX21hdGNoaW5nJywgJ21hZ2ljX2xpbmsnXSkudG9Db250YWluKHJlc3VsdC5kYXRhLmF1dGhfbWV0aG9kKTtcbiAgICAgICAgICAgIC8vIEF1dGggbWV0aG9kIG11c3QgbmV2ZXIgYmUgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5hdXRoX21ldGhvZCkubm90LnRvQmVOdWxsKCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuYXV0aF9tZXRob2QpLm5vdC50b0JlVW5kZWZpbmVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQcm9wZXJ0eTogQXV0aCBNZXRob2QgSW5oZXJpdGFuY2VcbiAgICogXG4gICAqIFdoZW4gY3JlYXRpbmcgYSBndWVzdCB3aXRob3V0IHNwZWNpZnlpbmcgYXV0aF9tZXRob2QsXG4gICAqIGl0IHNob3VsZCBpbmhlcml0IHRoZSBzeXN0ZW0gZGVmYXVsdFxuICAgKi9cbiAgaXQoJ3Nob3VsZCBpbmhlcml0IGRlZmF1bHQgYXV0aF9tZXRob2Qgd2hlbiBub3Qgc3BlY2lmaWVkJywgKCkgPT4ge1xuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgIGZpcnN0TmFtZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLFxuICAgICAgICAgIGxhc3ROYW1lOiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogNTAgfSksXG4gICAgICAgICAgZW1haWw6IGZjLmVtYWlsQWRkcmVzcygpLFxuICAgICAgICAgIGFnZVR5cGU6IGZjLmNvbnN0YW50RnJvbSgnYWR1bHQnLCAnY2hpbGQnLCAnc2VuaW9yJyksXG4gICAgICAgICAgZ3Vlc3RUeXBlOiBmYy5jb25zdGFudEZyb20oJ3dlZGRpbmdfcGFydHknLCAnd2VkZGluZ19ndWVzdCcsICdwcmV3ZWRkaW5nX29ubHknLCAncG9zdHdlZGRpbmdfb25seScpLFxuICAgICAgICAgIGdyb3VwSWQ6IGZjLnV1aWQoKSxcbiAgICAgICAgfSksXG4gICAgICAgIGZjLmNvbnN0YW50RnJvbSgnZW1haWxfbWF0Y2hpbmcnLCAnbWFnaWNfbGluaycpLFxuICAgICAgICBhc3luYyAoZ3Vlc3REYXRhLCBkZWZhdWx0QXV0aE1ldGhvZCkgPT4ge1xuICAgICAgICAgIC8vIE1vY2sgc3lzdGVtIHNldHRpbmdzIHRvIHJldHVybiBkZWZhdWx0IGF1dGggbWV0aG9kXG4gICAgICAgICAgY29uc3QgbW9ja0d1ZXN0ID0ge1xuICAgICAgICAgICAgaWQ6IGZjLnNhbXBsZShmYy51dWlkKCksIDEpWzBdLFxuICAgICAgICAgICAgLi4uZ3Vlc3REYXRhLFxuICAgICAgICAgICAgYXV0aF9tZXRob2Q6IGRlZmF1bHRBdXRoTWV0aG9kLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBtb2NrU3VwYWJhc2UuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgaW5zZXJ0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICBkYXRhOiBtb2NrR3Vlc3QsXG4gICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGd1ZXN0U2VydmljZS5jcmVhdGUoZ3Vlc3REYXRhKTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBHdWVzdCBzaG91bGQgaW5oZXJpdCB0aGUgZGVmYXVsdCBhdXRoIG1ldGhvZFxuICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5hdXRoX21ldGhvZCkudG9CZShkZWZhdWx0QXV0aE1ldGhvZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiA1MCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFByb3BlcnR5OiBBdXRoIE1ldGhvZCBVcGRhdGUgVmFsaWRhdGlvblxuICAgKiBcbiAgICogV2hlbiB1cGRhdGluZyBhIGd1ZXN0J3MgYXV0aF9tZXRob2QsIG9ubHkgdmFsaWQgdmFsdWVzIHNob3VsZCBiZSBhY2NlcHRlZFxuICAgKi9cbiAgaXQoJ3Nob3VsZCBvbmx5IGFjY2VwdCB2YWxpZCBhdXRoX21ldGhvZCB2YWx1ZXMgb24gdXBkYXRlJywgKCkgPT4ge1xuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICBmYy51dWlkKCksXG4gICAgICAgIGZjLm9uZW9mKFxuICAgICAgICAgIGZjLmNvbnN0YW50KCdlbWFpbF9tYXRjaGluZycpLFxuICAgICAgICAgIGZjLmNvbnN0YW50KCdtYWdpY19saW5rJyksXG4gICAgICAgICAgZmMuc3RyaW5nKCkuZmlsdGVyKHMgPT4gIVsnZW1haWxfbWF0Y2hpbmcnLCAnbWFnaWNfbGluayddLmluY2x1ZGVzKHMpKVxuICAgICAgICApLFxuICAgICAgICBhc3luYyAoZ3Vlc3RJZCwgYXV0aE1ldGhvZCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGlzVmFsaWRBdXRoTWV0aG9kID0gWydlbWFpbF9tYXRjaGluZycsICdtYWdpY19saW5rJ10uaW5jbHVkZXMoYXV0aE1ldGhvZCk7XG5cbiAgICAgICAgICBpZiAoaXNWYWxpZEF1dGhNZXRob2QpIHtcbiAgICAgICAgICAgIC8vIE1vY2sgc3VjY2Vzc2Z1bCB1cGRhdGVcbiAgICAgICAgICAgIG1vY2tTdXBhYmFzZS5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgaWQ6IGd1ZXN0SWQsIGF1dGhfbWV0aG9kOiBhdXRoTWV0aG9kIH0sXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGd1ZXN0U2VydmljZS51cGRhdGUoZ3Vlc3RJZCwgeyBhdXRoTWV0aG9kIH0pO1xuXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eTogVmFsaWQgYXV0aCBtZXRob2RzIHNob3VsZCBzdWNjZWVkXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmF1dGhfbWV0aG9kKS50b0JlKGF1dGhNZXRob2QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBQcm9wZXJ0eTogSW52YWxpZCBhdXRoIG1ldGhvZHMgc2hvdWxkIGZhaWwgdmFsaWRhdGlvblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ3Vlc3RTZXJ2aWNlLnVwZGF0ZShndWVzdElkLCB7IGF1dGhNZXRob2QgfSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ1ZBTElEQVRJT05fRVJST1InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFByb3BlcnR5OiBCdWxrIEF1dGggTWV0aG9kIFVwZGF0ZSBDb25zaXN0ZW5jeVxuICAgKiBcbiAgICogV2hlbiBidWxrIHVwZGF0aW5nIGF1dGggbWV0aG9kcywgYWxsIGd1ZXN0cyBzaG91bGQgcmVjZWl2ZSB0aGUgc2FtZSB2YWxpZCB2YWx1ZVxuICAgKi9cbiAgaXQoJ3Nob3VsZCBjb25zaXN0ZW50bHkgYXBwbHkgYXV0aF9tZXRob2QgaW4gYnVsayB1cGRhdGVzJywgKCkgPT4ge1xuICAgIGZjLmFzc2VydChcbiAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICBmYy5hcnJheShmYy51dWlkKCksIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLFxuICAgICAgICBmYy5jb25zdGFudEZyb20oJ2VtYWlsX21hdGNoaW5nJywgJ21hZ2ljX2xpbmsnKSxcbiAgICAgICAgYXN5bmMgKGd1ZXN0SWRzLCBhdXRoTWV0aG9kKSA9PiB7XG4gICAgICAgICAgLy8gTW9jayBzdWNjZXNzZnVsIGJ1bGsgdXBkYXRlXG4gICAgICAgICAgY29uc3QgbW9ja1VwZGF0ZWRHdWVzdHMgPSBndWVzdElkcy5tYXAoaWQgPT4gKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgYXV0aF9tZXRob2Q6IGF1dGhNZXRob2QsXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgbW9ja1N1cGFiYXNlLmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgIGluOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICBkYXRhOiBtb2NrVXBkYXRlZEd1ZXN0cyxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gU2ltdWxhdGUgYnVsayB1cGRhdGUgKHdvdWxkIGJlIGltcGxlbWVudGVkIGluIHNlcnZpY2UpXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBndWVzdElkcy5tYXAoaWQgPT4gZ3Vlc3RTZXJ2aWNlLnVwZGF0ZShpZCwgeyBhdXRoTWV0aG9kIH0pKVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBQcm9wZXJ0eTogQWxsIHVwZGF0ZXMgc2hvdWxkIHN1Y2NlZWQgd2l0aCBjb25zaXN0ZW50IGF1dGhfbWV0aG9kXG4gICAgICAgICAgcmVzdWx0LmZvckVhY2gociA9PiB7XG4gICAgICAgICAgICBleHBlY3Qoci5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgaWYgKHIuc3VjY2Vzcykge1xuICAgICAgICAgICAgICBleHBlY3Qoci5kYXRhLmF1dGhfbWV0aG9kKS50b0JlKGF1dGhNZXRob2QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiA1MCB9XG4gICAgKTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImNyZWF0ZUNsaWVudCIsImZuIiwiZGVzY3JpYmUiLCJtb2NrU3VwYWJhc2UiLCJiZWZvcmVFYWNoIiwiY3JlYXRlTW9ja1N1cGFiYXNlQ2xpZW50IiwiY2xlYXJBbGxNb2NrcyIsIml0IiwiZmMiLCJhc3NlcnQiLCJwcm9wZXJ0eSIsInJlY29yZCIsImZpcnN0TmFtZSIsInN0cmluZyIsIm1pbkxlbmd0aCIsIm1heExlbmd0aCIsImxhc3ROYW1lIiwiZW1haWwiLCJvbmVvZiIsImVtYWlsQWRkcmVzcyIsImNvbnN0YW50IiwiYWdlVHlwZSIsImNvbnN0YW50RnJvbSIsImd1ZXN0VHlwZSIsImdyb3VwSWQiLCJ1dWlkIiwiYXV0aE1ldGhvZCIsInVuZGVmaW5lZCIsImd1ZXN0RGF0YSIsIm1vY2tHdWVzdCIsImlkIiwic2FtcGxlIiwiYXV0aF9tZXRob2QiLCJjcmVhdGVkX2F0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwidXBkYXRlZF9hdCIsImZyb20iLCJtb2NrUmV0dXJuVmFsdWUiLCJpbnNlcnQiLCJzZWxlY3QiLCJzaW5nbGUiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsImRhdGEiLCJlcnJvciIsInJlc3VsdCIsImd1ZXN0U2VydmljZSIsImNyZWF0ZSIsImV4cGVjdCIsInN1Y2Nlc3MiLCJ0b0JlIiwidG9Db250YWluIiwibm90IiwidG9CZU51bGwiLCJ0b0JlVW5kZWZpbmVkIiwibnVtUnVucyIsImRlZmF1bHRBdXRoTWV0aG9kIiwiZmlsdGVyIiwicyIsImluY2x1ZGVzIiwiZ3Vlc3RJZCIsImlzVmFsaWRBdXRoTWV0aG9kIiwidXBkYXRlIiwiZXEiLCJjb2RlIiwiYXJyYXkiLCJndWVzdElkcyIsIm1vY2tVcGRhdGVkR3Vlc3RzIiwibWFwIiwiaW4iLCJQcm9taXNlIiwiYWxsIiwiZm9yRWFjaCIsInIiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Q0FNQztBQU1ELGdCQUFnQjtBQUNoQkEsS0FBS0MsSUFBSSxDQUFDLGtCQUFrQixJQUFPLENBQUE7UUFDakNDLGNBQWNGLEtBQUtHLEVBQUU7SUFDdkIsQ0FBQTs7OzttRUFQb0I7c0VBQ1U7OEJBQ1c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU96Q0MsU0FBUyx1RUFBdUU7SUFDOUUsSUFBSUM7SUFFSkMsV0FBVztRQUNURCxlQUFlRSxJQUFBQSxzQ0FBd0I7UUFDdkNQLEtBQUtRLGFBQWE7SUFDcEI7SUFFQTs7Ozs7R0FLQyxHQUNEQyxHQUFHLDJEQUEyRDtRQUM1REMsV0FBR0MsTUFBTSxDQUNQRCxXQUFHRSxRQUFRLENBQ1RGLFdBQUdHLE1BQU0sQ0FBQztZQUNSQyxXQUFXSixXQUFHSyxNQUFNLENBQUM7Z0JBQUVDLFdBQVc7Z0JBQUdDLFdBQVc7WUFBRztZQUNuREMsVUFBVVIsV0FBR0ssTUFBTSxDQUFDO2dCQUFFQyxXQUFXO2dCQUFHQyxXQUFXO1lB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