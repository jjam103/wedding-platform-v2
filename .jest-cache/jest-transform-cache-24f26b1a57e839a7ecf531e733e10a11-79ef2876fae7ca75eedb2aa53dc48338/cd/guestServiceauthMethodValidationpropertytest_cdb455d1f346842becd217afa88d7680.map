{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/services/guestService.authMethodValidation.property.test.ts"],"sourcesContent":["/**\n * Property-Based Tests for Guest Auth Method Validation\n * Feature: admin-ux-enhancements\n * Property 1: Auth Method Consistency\n * \n * Validates: Requirements 1.1, 1.2\n */\n\nimport * as fc from 'fast-check';\nimport * as guestService from './guestService';\nimport { createMockSupabaseClient } from '@/__tests__/helpers/mockSupabase';\n\n// Mock Supabase\njest.mock('@/lib/supabase', () => ({\n  createClient: jest.fn(),\n}));\n\ndescribe('Feature: admin-ux-enhancements, Property 1: Auth Method Consistency', () => {\n  let mockSupabase: ReturnType<typeof createMockSupabaseClient>;\n\n  beforeEach(() => {\n    mockSupabase = createMockSupabaseClient();\n    jest.clearAllMocks();\n  });\n\n  /**\n   * Property 1: Auth Method Consistency\n   * \n   * For any guest record, the auth_method field should always contain \n   * a valid value ('email_matching' or 'magic_link'), never NULL or invalid values\n   */\n  it('should ensure all created guests have valid auth_method', () => {\n    fc.assert(\n      fc.property(\n        fc.record({\n          firstName: fc.string({ minLength: 1, maxLength: 50 }),\n          lastName: fc.string({ minLength: 1, maxLength: 50 }),\n          email: fc.oneof(fc.emailAddress(), fc.constant(null)),\n          ageType: fc.constantFrom('adult', 'child', 'senior'),\n          guestType: fc.constantFrom('wedding_party', 'wedding_guest', 'prewedding_only', 'postwedding_only'),\n          groupId: fc.uuid(),\n          authMethod: fc.oneof(\n            fc.constant('email_matching'),\n            fc.constant('magic_link'),\n            fc.constant(null),\n            fc.constant(undefined)\n          ),\n        }),\n        async (guestData) => {\n          // Mock successful database insert\n          const mockGuest = {\n            id: fc.sample(fc.uuid(), 1)[0],\n            ...guestData,\n            auth_method: guestData.authMethod || 'email_matching',\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString(),\n          };\n\n          mockSupabase.from.mockReturnValue({\n            insert: jest.fn().mockReturnValue({\n              select: jest.fn().mockReturnValue({\n                single: jest.fn().mockResolvedValue({\n                  data: mockGuest,\n                  error: null,\n                }),\n              }),\n            }),\n          });\n\n          const result = await guestService.create({\n            firstName: guestData.firstName,\n            lastName: guestData.lastName,\n            email: guestData.email,\n            ageType: guestData.ageType,\n            guestType: guestData.guestType,\n            groupId: guestData.groupId,\n          });\n\n          // Property: Result should always succeed with valid auth_method\n          expect(result.success).toBe(true);\n          if (result.success) {\n            // Auth method must be one of the valid values\n            expect(['email_matching', 'magic_link']).toContain(result.data.auth_method);\n            // Auth method must never be null or undefined\n            expect(result.data.auth_method).not.toBeNull();\n            expect(result.data.auth_method).not.toBeUndefined();\n          }\n        }\n      ),\n      { numRuns: 100 }\n    );\n  });\n\n  /**\n   * Property: Auth Method Inheritance\n   * \n   * When creating a guest without specifying auth_method,\n   * it should inherit the system default\n   */\n  it('should inherit default auth_method when not specified', () => {\n    fc.assert(\n      fc.property(\n        fc.record({\n          firstName: fc.string({ minLength: 1, maxLength: 50 }),\n          lastName: fc.string({ minLength: 1, maxLength: 50 }),\n          email: fc.emailAddress(),\n          ageType: fc.constantFrom('adult', 'child', 'senior'),\n          guestType: fc.constantFrom('wedding_party', 'wedding_guest', 'prewedding_only', 'postwedding_only'),\n          groupId: fc.uuid(),\n        }),\n        fc.constantFrom('email_matching', 'magic_link'),\n        async (guestData, defaultAuthMethod) => {\n          // Mock system settings to return default auth method\n          const mockGuest = {\n            id: fc.sample(fc.uuid(), 1)[0],\n            ...guestData,\n            auth_method: defaultAuthMethod,\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString(),\n          };\n\n          mockSupabase.from.mockReturnValue({\n            insert: jest.fn().mockReturnValue({\n              select: jest.fn().mockReturnValue({\n                single: jest.fn().mockResolvedValue({\n                  data: mockGuest,\n                  error: null,\n                }),\n              }),\n            }),\n          });\n\n          const result = await guestService.create(guestData);\n\n          // Property: Guest should inherit the default auth method\n          expect(result.success).toBe(true);\n          if (result.success) {\n            expect(result.data.auth_method).toBe(defaultAuthMethod);\n          }\n        }\n      ),\n      { numRuns: 50 }\n    );\n  });\n\n  /**\n   * Property: Auth Method Update Validation\n   * \n   * When updating a guest's auth_method, only valid values should be accepted\n   */\n  it('should only accept valid auth_method values on update', () => {\n    fc.assert(\n      fc.property(\n        fc.uuid(),\n        fc.oneof(\n          fc.constant('email_matching'),\n          fc.constant('magic_link'),\n          fc.string().filter(s => !['email_matching', 'magic_link'].includes(s))\n        ),\n        async (guestId, authMethod) => {\n          const isValidAuthMethod = ['email_matching', 'magic_link'].includes(authMethod);\n\n          if (isValidAuthMethod) {\n            // Mock successful update\n            mockSupabase.from.mockReturnValue({\n              update: jest.fn().mockReturnValue({\n                eq: jest.fn().mockReturnValue({\n                  select: jest.fn().mockReturnValue({\n                    single: jest.fn().mockResolvedValue({\n                      data: { id: guestId, auth_method: authMethod },\n                      error: null,\n                    }),\n                  }),\n                }),\n              }),\n            });\n\n            const result = await guestService.update(guestId, { authMethod });\n\n            // Property: Valid auth methods should succeed\n            expect(result.success).toBe(true);\n            if (result.success) {\n              expect(result.data.auth_method).toBe(authMethod);\n            }\n          } else {\n            // Property: Invalid auth methods should fail validation\n            const result = await guestService.update(guestId, { authMethod });\n            expect(result.success).toBe(false);\n            if (!result.success) {\n              expect(result.error.code).toBe('VALIDATION_ERROR');\n            }\n          }\n        }\n      ),\n      { numRuns: 100 }\n    );\n  });\n\n  /**\n   * Property: Bulk Auth Method Update Consistency\n   * \n   * When bulk updating auth methods, all guests should receive the same valid value\n   */\n  it('should consistently apply auth_method in bulk updates', () => {\n    fc.assert(\n      fc.property(\n        fc.array(fc.uuid(), { minLength: 1, maxLength: 50 }),\n        fc.constantFrom('email_matching', 'magic_link'),\n        async (guestIds, authMethod) => {\n          // Mock successful bulk update\n          const mockUpdatedGuests = guestIds.map(id => ({\n            id,\n            auth_method: authMethod,\n          }));\n\n          mockSupabase.from.mockReturnValue({\n            update: jest.fn().mockReturnValue({\n              in: jest.fn().mockReturnValue({\n                select: jest.fn().mockResolvedValue({\n                  data: mockUpdatedGuests,\n                  error: null,\n                }),\n              }),\n            }),\n          });\n\n          // Simulate bulk update (would be implemented in service)\n          const result = await Promise.all(\n            guestIds.map(id => guestService.update(id, { authMethod }))\n          );\n\n          // Property: All updates should succeed with consistent auth_method\n          result.forEach(r => {\n            expect(r.success).toBe(true);\n            if (r.success) {\n              expect(r.data.auth_method).toBe(authMethod);\n            }\n          });\n        }\n      ),\n      { numRuns: 50 }\n    );\n  });\n});\n"],"names":["jest","mock","createClient","fn","describe","mockSupabase","beforeEach","createMockSupabaseClient","clearAllMocks","it","fc","assert","property","record","firstName","string","minLength","maxLength","lastName","email","oneof","emailAddress","constant","ageType","constantFrom","guestType","groupId","uuid","authMethod","undefined","guestData","mockGuest","id","sample","auth_method","created_at","Date","toISOString","updated_at","from","mockReturnValue","insert","select","single","mockResolvedValue","data","error","result","guestService","create","expect","success","toBe","toContain","not","toBeNull","toBeUndefined","numRuns","defaultAuthMethod","filter","s","includes","guestId","isValidAuthMethod","update","eq","code","array","guestIds","mockUpdatedGuests","map","in","Promise","all","forEach","r"],"mappings":"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"}