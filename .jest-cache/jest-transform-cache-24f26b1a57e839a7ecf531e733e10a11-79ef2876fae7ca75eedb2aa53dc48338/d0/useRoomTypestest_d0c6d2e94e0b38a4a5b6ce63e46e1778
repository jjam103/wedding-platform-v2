cdc1640f8479d6314d47d9d6a8134501
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useRoomTypes = require("./useRoomTypes");
// Mock fetch globally
global.fetch = jest.fn();
describe('useRoomTypes', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        global.fetch.mockClear();
    });
    afterEach(()=>{
        jest.restoreAllMocks();
    });
    describe('loading states', ()=>{
        it('should start with loading true when accommodationId provided', ()=>{
            global.fetch.mockImplementation(()=>new Promise(()=>{}) // Never resolves
            );
            const { result } = (0, _react.renderHook)(()=>(0, _useRoomTypes.useRoomTypes)({
                    accommodationId: 'acc-1'
                }));
            expect(result.current.loading).toBe(true);
            expect(result.current.data).toEqual([]);
            expect(result.current.error).toBeNull();
        });
        it('should not fetch when accommodationId is missing', async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useRoomTypes.useRoomTypes)({}));
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(global.fetch).not.toHaveBeenCalled();
            expect(result.current.data).toEqual([]);
        });
        it('should set loading false after successful fetch', async ()=>{
            const mockData = [
                {
                    id: 'room-1',
                    accommodationId: 'acc-1',
                    name: 'Ocean View',
                    capacity: 2,
                    pricePerNight: 150,
                    checkInDate: '2025-06-14',
                    checkOutDate: '2025-06-16',
                    createdAt: '2025-01-01T00:00:00Z',
                    updatedAt: '2025-01-01T00:00:00Z'
                }
            ];
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockData
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useRoomTypes.useRoomTypes)({
                    accommodationId: 'acc-1'
                }));
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(result.current.data).toEqual(mockData);
            expect(result.current.error).toBeNull();
        });
        it('should set loading false after failed fetch', async ()=>{
            global.fetch.mockResolvedValueOnce({
                ok: false,
                json: async ()=>({
                        success: false,
                        error: {
                            message: 'Failed to fetch'
                        }
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useRoomTypes.useRoomTypes)({
                    accommodationId: 'acc-1'
                }));
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(result.current.data).toEqual([]);
            expect(result.current.error).toBeInstanceOf(Error);
        });
    });
    describe('error handling', ()=>{
        it('should handle network errors', async ()=>{
            global.fetch.mockRejectedValueOnce(new Error('Network error'));
            const { result } = (0, _react.renderHook)(()=>(0, _useRoomTypes.useRoomTypes)({
                    accommodationId: 'acc-1'
                }));
            await (0, _react.waitFor)(()=>{
                expect(result.current.error).toBeInstanceOf(Error);
            });
            expect(result.current.error?.message).toBe('Network error');
            expect(result.current.loading).toBe(false);
            expect(result.current.data).toEqual([]);
        });
        it('should handle API error responses', async ()=>{
            global.fetch.mockResolvedValueOnce({
                ok: false,
                json: async ()=>({
                        success: false,
                        error: {
                            message: 'Not found'
                        }
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useRoomTypes.useRoomTypes)({
                    accommodationId: 'acc-1'
                }));
            await (0, _react.waitFor)(()=>{
                expect(result.current.error).toBeInstanceOf(Error);
            });
            expect(result.current.error?.message).toBe('Not found');
        });
    });
    describe('data refetching', ()=>{
        it('should refetch data when refetch is called', async ()=>{
            const initialData = [
                {
                    id: 'room-1',
                    accommodationId: 'acc-1',
                    name: 'Ocean View',
                    capacity: 2,
                    pricePerNight: 150,
                    checkInDate: '2025-06-14',
                    checkOutDate: '2025-06-16',
                    createdAt: '2025-01-01T00:00:00Z',
                    updatedAt: '2025-01-01T00:00:00Z'
                }
            ];
            const updatedData = [
                ...initialData,
                {
                    id: 'room-2',
                    accommodationId: 'acc-1',
                    name: 'Suite',
                    capacity: 4,
                    pricePerNight: 250,
                    checkInDate: '2025-06-14',
                    checkOutDate: '2025-06-16',
                    createdAt: '2025-01-02T00:00:00Z',
                    updatedAt: '2025-01-02T00:00:00Z'
                }
            ];
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: initialData
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: updatedData
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useRoomTypes.useRoomTypes)({
                    accommodationId: 'acc-1'
                }));
            await (0, _react.waitFor)(()=>{
                expect(result.current.data).toEqual(initialData);
            });
            await result.current.refetch();
            await (0, _react.waitFor)(()=>{
                expect(result.current.data).toEqual(updatedData);
            });
        });
        it('should reset error state on refetch', async ()=>{
            global.fetch.mockRejectedValueOnce(new Error('Initial error')).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: []
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useRoomTypes.useRoomTypes)({
                    accommodationId: 'acc-1'
                }));
            await (0, _react.waitFor)(()=>{
                expect(result.current.error).toBeInstanceOf(Error);
            });
            await result.current.refetch();
            await (0, _react.waitFor)(()=>{
                expect(result.current.error).toBeNull();
            });
        });
    });
    describe('optimistic updates', ()=>{
        it('should optimistically add new room type on create', async ()=>{
            const existingData = [
                {
                    id: 'room-1',
                    accommodationId: 'acc-1',
                    name: 'Ocean View',
                    capacity: 2,
                    pricePerNight: 150,
                    checkInDate: '2025-06-14',
                    checkOutDate: '2025-06-16',
                    createdAt: '2025-01-01T00:00:00Z',
                    updatedAt: '2025-01-01T00:00:00Z'
                }
            ];
            const newRoomType = {
                id: 'room-2',
                accommodationId: 'acc-1',
                name: 'Suite',
                capacity: 4,
                pricePerNight: 250,
                checkInDate: '2025-06-14',
                checkOutDate: '2025-06-16',
                createdAt: '2025-01-02T00:00:00Z',
                updatedAt: '2025-01-02T00:00:00Z'
            };
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: existingData
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: newRoomType
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useRoomTypes.useRoomTypes)({
                    accommodationId: 'acc-1'
                }));
            await (0, _react.waitFor)(()=>{
                expect(result.current.data).toEqual(existingData);
            });
            let createResult;
            await (0, _react.waitFor)(async ()=>{
                createResult = await result.current.create({
                    name: 'Suite',
                    capacity: 4,
                    pricePerNight: 250,
                    checkInDate: '2025-06-14',
                    checkOutDate: '2025-06-16'
                });
            });
            expect(createResult.success).toBe(true);
            await (0, _react.waitFor)(()=>{
                expect(result.current.data).toHaveLength(2);
            });
            expect(result.current.data[1]).toEqual(newRoomType);
        });
        it('should include accommodationId in create request', async ()=>{
            const mockData = [
                {
                    id: 'room-1',
                    accommodationId: 'acc-1',
                    name: 'Ocean View',
                    capacity: 2,
                    pricePerNight: 150,
                    checkInDate: '2025-06-14',
                    checkOutDate: '2025-06-16',
                    createdAt: '2025-01-01T00:00:00Z',
                    updatedAt: '2025-01-01T00:00:00Z'
                }
            ];
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: mockData
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: {
                            id: 'room-2',
                            name: 'Suite'
                        }
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useRoomTypes.useRoomTypes)({
                    accommodationId: 'acc-1'
                }));
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            await result.current.create({
                name: 'Suite',
                capacity: 4,
                pricePerNight: 250
            });
            expect(global.fetch).toHaveBeenCalledWith('/api/admin/room-types', expect.objectContaining({
                method: 'POST',
                body: expect.stringContaining('"accommodationId":"acc-1"')
            }));
        });
        it('should optimistically update existing room type', async ()=>{
            const initialData = [
                {
                    id: 'room-1',
                    accommodationId: 'acc-1',
                    name: 'Ocean View',
                    capacity: 2,
                    pricePerNight: 150,
                    checkInDate: '2025-06-14',
                    checkOutDate: '2025-06-16',
                    createdAt: '2025-01-01T00:00:00Z',
                    updatedAt: '2025-01-01T00:00:00Z'
                }
            ];
            const updatedRoomType = {
                ...initialData[0],
                pricePerNight: 175,
                updatedAt: '2025-01-02T00:00:00Z'
            };
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: initialData
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: updatedRoomType
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useRoomTypes.useRoomTypes)({
                    accommodationId: 'acc-1'
                }));
            await (0, _react.waitFor)(()=>{
                expect(result.current.data[0].pricePerNight).toBe(150);
            });
            let updateResult;
            await (0, _react.waitFor)(async ()=>{
                updateResult = await result.current.update('room-1', {
                    pricePerNight: 175
                });
            });
            expect(updateResult.success).toBe(true);
            await (0, _react.waitFor)(()=>{
                expect(result.current.data[0].pricePerNight).toBe(175);
            });
        });
        it('should optimistically remove room type on delete', async ()=>{
            const initialData = [
                {
                    id: 'room-1',
                    accommodationId: 'acc-1',
                    name: 'Ocean View',
                    capacity: 2,
                    pricePerNight: 150,
                    checkInDate: '2025-06-14',
                    checkOutDate: '2025-06-16',
                    createdAt: '2025-01-01T00:00:00Z',
                    updatedAt: '2025-01-01T00:00:00Z'
                },
                {
                    id: 'room-2',
                    accommodationId: 'acc-1',
                    name: 'Suite',
                    capacity: 4,
                    pricePerNight: 250,
                    checkInDate: '2025-06-14',
                    checkOutDate: '2025-06-16',
                    createdAt: '2025-01-02T00:00:00Z',
                    updatedAt: '2025-01-02T00:00:00Z'
                }
            ];
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: initialData
                    })
            }).mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useRoomTypes.useRoomTypes)({
                    accommodationId: 'acc-1'
                }));
            await (0, _react.waitFor)(()=>{
                expect(result.current.data).toHaveLength(2);
            });
            let deleteResult;
            await (0, _react.waitFor)(async ()=>{
                deleteResult = await result.current.remove('room-1');
            });
            expect(deleteResult.success).toBe(true);
            await (0, _react.waitFor)(()=>{
                expect(result.current.data).toHaveLength(1);
            });
            expect(result.current.data[0].id).toBe('room-2');
        });
        it('should not update state on failed create', async ()=>{
            const initialData = [
                {
                    id: 'room-1',
                    accommodationId: 'acc-1',
                    name: 'Ocean View',
                    capacity: 2,
                    pricePerNight: 150,
                    checkInDate: '2025-06-14',
                    checkOutDate: '2025-06-16',
                    createdAt: '2025-01-01T00:00:00Z',
                    updatedAt: '2025-01-01T00:00:00Z'
                }
            ];
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        success: true,
                        data: initialData
                    })
            }).mockResolvedValueOnce({
                ok: false,
                json: async ()=>({
                        success: false,
                        error: {
                            message: 'Validation error'
                        }
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useRoomTypes.useRoomTypes)({
                    accommodationId: 'acc-1'
                }));
            await (0, _react.waitFor)(()=>{
                expect(result.current.data).toEqual(initialData);
            });
            const createResult = await result.current.create({
                name: 'Invalid Room'
            });
            expect(createResult.success).toBe(false);
            expect(createResult.error).toBe('Validation error');
            expect(result.current.data).toEqual(initialData);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvaG9va3MvdXNlUm9vbVR5cGVzLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVuZGVySG9vaywgd2FpdEZvciB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xuaW1wb3J0IHsgdXNlUm9vbVR5cGVzIH0gZnJvbSAnLi91c2VSb29tVHlwZXMnO1xuXG4vLyBNb2NrIGZldGNoIGdsb2JhbGx5XG5nbG9iYWwuZmV0Y2ggPSBqZXN0LmZuKCk7XG5cbmRlc2NyaWJlKCd1c2VSb29tVHlwZXMnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrQ2xlYXIoKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBqZXN0LnJlc3RvcmVBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnbG9hZGluZyBzdGF0ZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzdGFydCB3aXRoIGxvYWRpbmcgdHJ1ZSB3aGVuIGFjY29tbW9kYXRpb25JZCBwcm92aWRlZCcsICgpID0+IHtcbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT5cbiAgICAgICAgbmV3IFByb21pc2UoKCkgPT4ge30pIC8vIE5ldmVyIHJlc29sdmVzXG4gICAgICApO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PlxuICAgICAgICB1c2VSb29tVHlwZXMoeyBhY2NvbW1vZGF0aW9uSWQ6ICdhY2MtMScgfSlcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGEpLnRvRXF1YWwoW10pO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBub3QgZmV0Y2ggd2hlbiBhY2NvbW1vZGF0aW9uSWQgaXMgbWlzc2luZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZVJvb21UeXBlcyh7fSkpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChnbG9iYWwuZmV0Y2gpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YSkudG9FcXVhbChbXSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNldCBsb2FkaW5nIGZhbHNlIGFmdGVyIHN1Y2Nlc3NmdWwgZmV0Y2gnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRGF0YSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAncm9vbS0xJyxcbiAgICAgICAgICBhY2NvbW1vZGF0aW9uSWQ6ICdhY2MtMScsXG4gICAgICAgICAgbmFtZTogJ09jZWFuIFZpZXcnLFxuICAgICAgICAgIGNhcGFjaXR5OiAyLFxuICAgICAgICAgIHByaWNlUGVyTmlnaHQ6IDE1MCxcbiAgICAgICAgICBjaGVja0luRGF0ZTogJzIwMjUtMDYtMTQnLFxuICAgICAgICAgIGNoZWNrT3V0RGF0ZTogJzIwMjUtMDYtMTYnLFxuICAgICAgICAgIGNyZWF0ZWRBdDogJzIwMjUtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgICAgICB1cGRhdGVkQXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IG1vY2tEYXRhIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+XG4gICAgICAgIHVzZVJvb21UeXBlcyh7IGFjY29tbW9kYXRpb25JZDogJ2FjYy0xJyB9KVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YSkudG9FcXVhbChtb2NrRGF0YSk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3IpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNldCBsb2FkaW5nIGZhbHNlIGFmdGVyIGZhaWxlZCBmZXRjaCcsIGFzeW5jICgpID0+IHtcbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogZmFsc2UsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogJ0ZhaWxlZCB0byBmZXRjaCcgfSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT5cbiAgICAgICAgdXNlUm9vbVR5cGVzKHsgYWNjb21tb2RhdGlvbklkOiAnYWNjLTEnIH0pXG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhKS50b0VxdWFsKFtdKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZUluc3RhbmNlT2YoRXJyb3IpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZXJyb3IgaGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbmV0d29yayBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja1JlamVjdGVkVmFsdWVPbmNlKFxuICAgICAgICBuZXcgRXJyb3IoJ05ldHdvcmsgZXJyb3InKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT5cbiAgICAgICAgdXNlUm9vbVR5cGVzKHsgYWNjb21tb2RhdGlvbklkOiAnYWNjLTEnIH0pXG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlSW5zdGFuY2VPZihFcnJvcik7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yPy5tZXNzYWdlKS50b0JlKCdOZXR3b3JrIGVycm9yJyk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YSkudG9FcXVhbChbXSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBBUEkgZXJyb3IgcmVzcG9uc2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgKGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnTm90IGZvdW5kJyB9LFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PlxuICAgICAgICB1c2VSb29tVHlwZXMoeyBhY2NvbW1vZGF0aW9uSWQ6ICdhY2MtMScgfSlcbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3IpLnRvQmVJbnN0YW5jZU9mKEVycm9yKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3I/Lm1lc3NhZ2UpLnRvQmUoJ05vdCBmb3VuZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZGF0YSByZWZldGNoaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmVmZXRjaCBkYXRhIHdoZW4gcmVmZXRjaCBpcyBjYWxsZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbml0aWFsRGF0YSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAncm9vbS0xJyxcbiAgICAgICAgICBhY2NvbW1vZGF0aW9uSWQ6ICdhY2MtMScsXG4gICAgICAgICAgbmFtZTogJ09jZWFuIFZpZXcnLFxuICAgICAgICAgIGNhcGFjaXR5OiAyLFxuICAgICAgICAgIHByaWNlUGVyTmlnaHQ6IDE1MCxcbiAgICAgICAgICBjaGVja0luRGF0ZTogJzIwMjUtMDYtMTQnLFxuICAgICAgICAgIGNoZWNrT3V0RGF0ZTogJzIwMjUtMDYtMTYnLFxuICAgICAgICAgIGNyZWF0ZWRBdDogJzIwMjUtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgICAgICB1cGRhdGVkQXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCB1cGRhdGVkRGF0YSA9IFtcbiAgICAgICAgLi4uaW5pdGlhbERhdGEsXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3Jvb20tMicsXG4gICAgICAgICAgYWNjb21tb2RhdGlvbklkOiAnYWNjLTEnLFxuICAgICAgICAgIG5hbWU6ICdTdWl0ZScsXG4gICAgICAgICAgY2FwYWNpdHk6IDQsXG4gICAgICAgICAgcHJpY2VQZXJOaWdodDogMjUwLFxuICAgICAgICAgIGNoZWNrSW5EYXRlOiAnMjAyNS0wNi0xNCcsXG4gICAgICAgICAgY2hlY2tPdXREYXRlOiAnMjAyNS0wNi0xNicsXG4gICAgICAgICAgY3JlYXRlZEF0OiAnMjAyNS0wMS0wMlQwMDowMDowMFonLFxuICAgICAgICAgIHVwZGF0ZWRBdDogJzIwMjUtMDEtMDJUMDA6MDA6MDBaJyxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBpbml0aWFsRGF0YSB9KSxcbiAgICAgICAgfSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogdXBkYXRlZERhdGEgfSksXG4gICAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PlxuICAgICAgICB1c2VSb29tVHlwZXMoeyBhY2NvbW1vZGF0aW9uSWQ6ICdhY2MtMScgfSlcbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YSkudG9FcXVhbChpbml0aWFsRGF0YSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnQucmVmZXRjaCgpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGEpLnRvRXF1YWwodXBkYXRlZERhdGEpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlc2V0IGVycm9yIHN0YXRlIG9uIHJlZmV0Y2gnLCBhc3luYyAoKSA9PiB7XG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaylcbiAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJ0luaXRpYWwgZXJyb3InKSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogW10gfSksXG4gICAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PlxuICAgICAgICB1c2VSb29tVHlwZXMoeyBhY2NvbW1vZGF0aW9uSWQ6ICdhY2MtMScgfSlcbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3IpLnRvQmVJbnN0YW5jZU9mKEVycm9yKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5yZWZldGNoKCk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3IpLnRvQmVOdWxsKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ29wdGltaXN0aWMgdXBkYXRlcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIG9wdGltaXN0aWNhbGx5IGFkZCBuZXcgcm9vbSB0eXBlIG9uIGNyZWF0ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nRGF0YSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAncm9vbS0xJyxcbiAgICAgICAgICBhY2NvbW1vZGF0aW9uSWQ6ICdhY2MtMScsXG4gICAgICAgICAgbmFtZTogJ09jZWFuIFZpZXcnLFxuICAgICAgICAgIGNhcGFjaXR5OiAyLFxuICAgICAgICAgIHByaWNlUGVyTmlnaHQ6IDE1MCxcbiAgICAgICAgICBjaGVja0luRGF0ZTogJzIwMjUtMDYtMTQnLFxuICAgICAgICAgIGNoZWNrT3V0RGF0ZTogJzIwMjUtMDYtMTYnLFxuICAgICAgICAgIGNyZWF0ZWRBdDogJzIwMjUtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgICAgICB1cGRhdGVkQXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBuZXdSb29tVHlwZSA9IHtcbiAgICAgICAgaWQ6ICdyb29tLTInLFxuICAgICAgICBhY2NvbW1vZGF0aW9uSWQ6ICdhY2MtMScsXG4gICAgICAgIG5hbWU6ICdTdWl0ZScsXG4gICAgICAgIGNhcGFjaXR5OiA0LFxuICAgICAgICBwcmljZVBlck5pZ2h0OiAyNTAsXG4gICAgICAgIGNoZWNrSW5EYXRlOiAnMjAyNS0wNi0xNCcsXG4gICAgICAgIGNoZWNrT3V0RGF0ZTogJzIwMjUtMDYtMTYnLFxuICAgICAgICBjcmVhdGVkQXQ6ICcyMDI1LTAxLTAyVDAwOjAwOjAwWicsXG4gICAgICAgIHVwZGF0ZWRBdDogJzIwMjUtMDEtMDJUMDA6MDA6MDBaJyxcbiAgICAgIH07XG5cbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBleGlzdGluZ0RhdGEgfSksXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IG5ld1Jvb21UeXBlIH0pLFxuICAgICAgICB9KTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT5cbiAgICAgICAgdXNlUm9vbVR5cGVzKHsgYWNjb21tb2RhdGlvbklkOiAnYWNjLTEnIH0pXG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGEpLnRvRXF1YWwoZXhpc3RpbmdEYXRhKTtcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgY3JlYXRlUmVzdWx0O1xuICAgICAgYXdhaXQgd2FpdEZvcihhc3luYyAoKSA9PiB7XG4gICAgICAgIGNyZWF0ZVJlc3VsdCA9IGF3YWl0IHJlc3VsdC5jdXJyZW50LmNyZWF0ZSh7XG4gICAgICAgICAgbmFtZTogJ1N1aXRlJyxcbiAgICAgICAgICBjYXBhY2l0eTogNCxcbiAgICAgICAgICBwcmljZVBlck5pZ2h0OiAyNTAsXG4gICAgICAgICAgY2hlY2tJbkRhdGU6ICcyMDI1LTA2LTE0JyxcbiAgICAgICAgICBjaGVja091dERhdGU6ICcyMDI1LTA2LTE2JyxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KGNyZWF0ZVJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGEpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YVsxXSkudG9FcXVhbChuZXdSb29tVHlwZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGluY2x1ZGUgYWNjb21tb2RhdGlvbklkIGluIGNyZWF0ZSByZXF1ZXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0RhdGEgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3Jvb20tMScsXG4gICAgICAgICAgYWNjb21tb2RhdGlvbklkOiAnYWNjLTEnLFxuICAgICAgICAgIG5hbWU6ICdPY2VhbiBWaWV3JyxcbiAgICAgICAgICBjYXBhY2l0eTogMixcbiAgICAgICAgICBwcmljZVBlck5pZ2h0OiAxNTAsXG4gICAgICAgICAgY2hlY2tJbkRhdGU6ICcyMDI1LTA2LTE0JyxcbiAgICAgICAgICBjaGVja091dERhdGU6ICcyMDI1LTA2LTE2JyxcbiAgICAgICAgICBjcmVhdGVkQXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgICAgdXBkYXRlZEF0OiAnMjAyNS0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgKGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgIGpzb246IGFzeW5jICgpID0+ICh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IG1vY2tEYXRhIH0pLFxuICAgICAgICB9KVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGE6IHsgaWQ6ICdyb29tLTInLCBuYW1lOiAnU3VpdGUnIH0sXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PlxuICAgICAgICB1c2VSb29tVHlwZXMoeyBhY2NvbW1vZGF0aW9uSWQ6ICdhY2MtMScgfSlcbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnQuY3JlYXRlKHtcbiAgICAgICAgbmFtZTogJ1N1aXRlJyxcbiAgICAgICAgY2FwYWNpdHk6IDQsXG4gICAgICAgIHByaWNlUGVyTmlnaHQ6IDI1MCxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoZ2xvYmFsLmZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJy9hcGkvYWRtaW4vcm9vbS10eXBlcycsXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBib2R5OiBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnXCJhY2NvbW1vZGF0aW9uSWRcIjpcImFjYy0xXCInKSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG9wdGltaXN0aWNhbGx5IHVwZGF0ZSBleGlzdGluZyByb29tIHR5cGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbml0aWFsRGF0YSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAncm9vbS0xJyxcbiAgICAgICAgICBhY2NvbW1vZGF0aW9uSWQ6ICdhY2MtMScsXG4gICAgICAgICAgbmFtZTogJ09jZWFuIFZpZXcnLFxuICAgICAgICAgIGNhcGFjaXR5OiAyLFxuICAgICAgICAgIHByaWNlUGVyTmlnaHQ6IDE1MCxcbiAgICAgICAgICBjaGVja0luRGF0ZTogJzIwMjUtMDYtMTQnLFxuICAgICAgICAgIGNoZWNrT3V0RGF0ZTogJzIwMjUtMDYtMTYnLFxuICAgICAgICAgIGNyZWF0ZWRBdDogJzIwMjUtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgICAgICB1cGRhdGVkQXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCB1cGRhdGVkUm9vbVR5cGUgPSB7XG4gICAgICAgIC4uLmluaXRpYWxEYXRhWzBdLFxuICAgICAgICBwcmljZVBlck5pZ2h0OiAxNzUsXG4gICAgICAgIHVwZGF0ZWRBdDogJzIwMjUtMDEtMDJUMDA6MDA6MDBaJyxcbiAgICAgIH07XG5cbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBpbml0aWFsRGF0YSB9KSxcbiAgICAgICAgfSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogdXBkYXRlZFJvb21UeXBlIH0pLFxuICAgICAgICB9KTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT5cbiAgICAgICAgdXNlUm9vbVR5cGVzKHsgYWNjb21tb2RhdGlvbklkOiAnYWNjLTEnIH0pXG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGFbMF0ucHJpY2VQZXJOaWdodCkudG9CZSgxNTApO1xuICAgICAgfSk7XG5cbiAgICAgIGxldCB1cGRhdGVSZXN1bHQ7XG4gICAgICBhd2FpdCB3YWl0Rm9yKGFzeW5jICgpID0+IHtcbiAgICAgICAgdXBkYXRlUmVzdWx0ID0gYXdhaXQgcmVzdWx0LmN1cnJlbnQudXBkYXRlKCdyb29tLTEnLCB7XG4gICAgICAgICAgcHJpY2VQZXJOaWdodDogMTc1LFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QodXBkYXRlUmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YVswXS5wcmljZVBlck5pZ2h0KS50b0JlKDE3NSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgb3B0aW1pc3RpY2FsbHkgcmVtb3ZlIHJvb20gdHlwZSBvbiBkZWxldGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbml0aWFsRGF0YSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAncm9vbS0xJyxcbiAgICAgICAgICBhY2NvbW1vZGF0aW9uSWQ6ICdhY2MtMScsXG4gICAgICAgICAgbmFtZTogJ09jZWFuIFZpZXcnLFxuICAgICAgICAgIGNhcGFjaXR5OiAyLFxuICAgICAgICAgIHByaWNlUGVyTmlnaHQ6IDE1MCxcbiAgICAgICAgICBjaGVja0luRGF0ZTogJzIwMjUtMDYtMTQnLFxuICAgICAgICAgIGNoZWNrT3V0RGF0ZTogJzIwMjUtMDYtMTYnLFxuICAgICAgICAgIGNyZWF0ZWRBdDogJzIwMjUtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgICAgICB1cGRhdGVkQXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3Jvb20tMicsXG4gICAgICAgICAgYWNjb21tb2RhdGlvbklkOiAnYWNjLTEnLFxuICAgICAgICAgIG5hbWU6ICdTdWl0ZScsXG4gICAgICAgICAgY2FwYWNpdHk6IDQsXG4gICAgICAgICAgcHJpY2VQZXJOaWdodDogMjUwLFxuICAgICAgICAgIGNoZWNrSW5EYXRlOiAnMjAyNS0wNi0xNCcsXG4gICAgICAgICAgY2hlY2tPdXREYXRlOiAnMjAyNS0wNi0xNicsXG4gICAgICAgICAgY3JlYXRlZEF0OiAnMjAyNS0wMS0wMlQwMDowMDowMFonLFxuICAgICAgICAgIHVwZGF0ZWRBdDogJzIwMjUtMDEtMDJUMDA6MDA6MDBaJyxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBpbml0aWFsRGF0YSB9KSxcbiAgICAgICAgfSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSB9KSxcbiAgICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+XG4gICAgICAgIHVzZVJvb21UeXBlcyh7IGFjY29tbW9kYXRpb25JZDogJ2FjYy0xJyB9KVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICB9KTtcblxuICAgICAgbGV0IGRlbGV0ZVJlc3VsdDtcbiAgICAgIGF3YWl0IHdhaXRGb3IoYXN5bmMgKCkgPT4ge1xuICAgICAgICBkZWxldGVSZXN1bHQgPSBhd2FpdCByZXN1bHQuY3VycmVudC5yZW1vdmUoJ3Jvb20tMScpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChkZWxldGVSZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIFxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGFbMF0uaWQpLnRvQmUoJ3Jvb20tMicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBub3QgdXBkYXRlIHN0YXRlIG9uIGZhaWxlZCBjcmVhdGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbml0aWFsRGF0YSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAncm9vbS0xJyxcbiAgICAgICAgICBhY2NvbW1vZGF0aW9uSWQ6ICdhY2MtMScsXG4gICAgICAgICAgbmFtZTogJ09jZWFuIFZpZXcnLFxuICAgICAgICAgIGNhcGFjaXR5OiAyLFxuICAgICAgICAgIHByaWNlUGVyTmlnaHQ6IDE1MCxcbiAgICAgICAgICBjaGVja0luRGF0ZTogJzIwMjUtMDYtMTQnLFxuICAgICAgICAgIGNoZWNrT3V0RGF0ZTogJzIwMjUtMDYtMTYnLFxuICAgICAgICAgIGNyZWF0ZWRBdDogJzIwMjUtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgICAgICB1cGRhdGVkQXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaylcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogaW5pdGlhbERhdGEgfSksXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnVmFsaWRhdGlvbiBlcnJvcicgfSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+XG4gICAgICAgIHVzZVJvb21UeXBlcyh7IGFjY29tbW9kYXRpb25JZDogJ2FjYy0xJyB9KVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhKS50b0VxdWFsKGluaXRpYWxEYXRhKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjcmVhdGVSZXN1bHQgPSBhd2FpdCByZXN1bHQuY3VycmVudC5jcmVhdGUoe1xuICAgICAgICBuYW1lOiAnSW52YWxpZCBSb29tJyxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoY3JlYXRlUmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGNyZWF0ZVJlc3VsdC5lcnJvcikudG9CZSgnVmFsaWRhdGlvbiBlcnJvcicpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGEpLnRvRXF1YWwoaW5pdGlhbERhdGEpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImdsb2JhbCIsImZldGNoIiwiamVzdCIsImZuIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tDbGVhciIsImFmdGVyRWFjaCIsInJlc3RvcmVBbGxNb2NrcyIsIml0IiwibW9ja0ltcGxlbWVudGF0aW9uIiwiUHJvbWlzZSIsInJlc3VsdCIsInJlbmRlckhvb2siLCJ1c2VSb29tVHlwZXMiLCJhY2NvbW1vZGF0aW9uSWQiLCJleHBlY3QiLCJjdXJyZW50IiwibG9hZGluZyIsInRvQmUiLCJkYXRhIiwidG9FcXVhbCIsImVycm9yIiwidG9CZU51bGwiLCJ3YWl0Rm9yIiwibm90IiwidG9IYXZlQmVlbkNhbGxlZCIsIm1vY2tEYXRhIiwiaWQiLCJuYW1lIiwiY2FwYWNpdHkiLCJwcmljZVBlck5pZ2h0IiwiY2hlY2tJbkRhdGUiLCJjaGVja091dERhdGUiLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJtb2NrUmVzb2x2ZWRWYWx1ZU9uY2UiLCJvayIsImpzb24iLCJzdWNjZXNzIiwibWVzc2FnZSIsInRvQmVJbnN0YW5jZU9mIiwiRXJyb3IiLCJtb2NrUmVqZWN0ZWRWYWx1ZU9uY2UiLCJpbml0aWFsRGF0YSIsInVwZGF0ZWREYXRhIiwicmVmZXRjaCIsImV4aXN0aW5nRGF0YSIsIm5ld1Jvb21UeXBlIiwiY3JlYXRlUmVzdWx0IiwiY3JlYXRlIiwidG9IYXZlTGVuZ3RoIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJvYmplY3RDb250YWluaW5nIiwibWV0aG9kIiwiYm9keSIsInN0cmluZ0NvbnRhaW5pbmciLCJ1cGRhdGVkUm9vbVR5cGUiLCJ1cGRhdGVSZXN1bHQiLCJ1cGRhdGUiLCJkZWxldGVSZXN1bHQiLCJyZW1vdmUiXSwibWFwcGluZ3MiOiI7Ozs7dUJBQW9DOzhCQUNQO0FBRTdCLHNCQUFzQjtBQUN0QkEsT0FBT0MsS0FBSyxHQUFHQyxLQUFLQyxFQUFFO0FBRXRCQyxTQUFTLGdCQUFnQjtJQUN2QkMsV0FBVztRQUNUSCxLQUFLSSxhQUFhO1FBQ2pCTixPQUFPQyxLQUFLLENBQWVNLFNBQVM7SUFDdkM7SUFFQUMsVUFBVTtRQUNSTixLQUFLTyxlQUFlO0lBQ3RCO0lBRUFMLFNBQVMsa0JBQWtCO1FBQ3pCTSxHQUFHLGdFQUFnRTtZQUNoRVYsT0FBT0MsS0FBSyxDQUFlVSxrQkFBa0IsQ0FBQyxJQUM3QyxJQUFJQyxRQUFRLEtBQU8sR0FBRyxpQkFBaUI7O1lBR3pDLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUdDLElBQUFBLGlCQUFVLEVBQUMsSUFDNUJDLElBQUFBLDBCQUFZLEVBQUM7b0JBQUVDLGlCQUFpQjtnQkFBUTtZQUcxQ0MsT0FBT0osT0FBT0ssT0FBTyxDQUFDQyxPQUFPLEVBQUVDLElBQUksQ0FBQztZQUNwQ0gsT0FBT0osT0FBT0ssT0FBTyxDQUFDRyxJQUFJLEVBQUVDLE9BQU8sQ0FBQyxFQUFFO1lBQ3RDTCxPQUFPSixPQUFPSyxPQUFPLENBQUNLLEtBQUssRUFBRUMsUUFBUTtRQUN2QztRQUVBZCxHQUFHLG9EQUFvRDtZQUNyRCxNQUFNLEVBQUVHLE1BQU0sRUFBRSxH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