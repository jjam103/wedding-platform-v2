dfd1b0b4db20c8b03d42f188a3020bc3
"use strict";
jest.mock('@/services/itineraryService');
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = require("@testing-library/react");
const _ItineraryViewer = require("./ItineraryViewer");
const _itineraryService = /*#__PURE__*/ _interop_require_wildcard(require("../../services/itineraryService"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('ItineraryViewer', ()=>{
    const mockGuest = {
        id: 'guest-1',
        first_name: 'John',
        last_name: 'Doe',
        email: 'john@example.com'
    };
    const mockItinerary = {
        guest_id: 'guest-1',
        guest_name: 'John Doe',
        events: [
            {
                id: 'event-1',
                name: 'Wedding Ceremony',
                type: 'event',
                date: '2025-06-15',
                time: '2025-06-15T14:00:00Z',
                location: 'Beach Resort',
                description: 'Main ceremony',
                rsvp_status: 'attending',
                capacity: 100,
                attending_count: 95,
                rsvp_deadline: '2025-06-01'
            },
            {
                id: 'event-2',
                name: 'Reception',
                type: 'event',
                date: '2025-06-15',
                time: '2025-06-15T18:00:00Z',
                location: 'Beach Resort',
                rsvp_status: 'pending'
            }
        ],
        accommodation: {
            accommodation_name: 'Beach Resort',
            room_type: 'Deluxe Ocean View',
            check_in: '2025-06-14',
            check_out: '2025-06-16'
        },
        transportation: {
            airport_code: 'SJO',
            arrival_date: '2025-06-14T10:00:00Z',
            departure_date: '2025-06-16T15:00:00Z'
        },
        generated_at: '2025-01-01T00:00:00Z'
    };
    beforeEach(()=>{
        jest.clearAllMocks();
        _itineraryService.generateItinerary.mockResolvedValue({
            success: true,
            data: mockItinerary
        });
        _itineraryService.getCachedItinerary.mockResolvedValue({
            success: false,
            error: {
                code: 'NOT_FOUND',
                message: 'No cache'
            }
        });
        _itineraryService.cacheItinerary.mockResolvedValue({
            success: true,
            data: undefined
        });
    });
    describe('View Modes', ()=>{
        it('should render day-by-day view by default', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ItineraryViewer.ItineraryViewer, {
                guest: mockGuest
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByText('Wedding Ceremony')).toBeInTheDocument();
            });
            // Day-by-day button should be active
            const dayByDayButton = _react.screen.getByText('ðŸ“… Day-by-Day');
            expect(dayByDayButton).toHaveClass('bg-white');
        });
        it('should switch to calendar view when calendar button clicked', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ItineraryViewer.ItineraryViewer, {
                guest: mockGuest
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByText('Wedding Ceremony')).toBeInTheDocument();
            });
            const calendarButton = _react.screen.getByText('ðŸ“† Calendar');
            _react.fireEvent.click(calendarButton);
            // Calendar button should be active
            expect(calendarButton).toHaveClass('bg-white');
            // Should show calendar view text
            expect(_react.screen.getByText(/Calendar view showing events by month/i)).toBeInTheDocument();
        });
        it('should switch to list view when list button clicked', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ItineraryViewer.ItineraryViewer, {
                guest: mockGuest
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByText('Wedding Ceremony')).toBeInTheDocument();
            });
            const listButton = _react.screen.getByText('ðŸ“‹ List');
            _react.fireEvent.click(listButton);
            // List button should be active
            expect(listButton).toHaveClass('bg-white');
            // Events should still be visible in list format
            expect(_react.screen.getByText('Wedding Ceremony')).toBeInTheDocument();
        });
    });
    describe('Date Filtering', ()=>{
        it('should filter events by from date', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ItineraryViewer.ItineraryViewer, {
                guest: mockGuest
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByText('Wedding Ceremony')).toBeInTheDocument();
            });
            const fromInput = _react.screen.getByLabelText('From:');
            _react.fireEvent.change(fromInput, {
                target: {
                    value: '2025-06-16'
                }
            });
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Wedding Ceremony')).not.toBeInTheDocument();
            });
        });
        it('should filter events by to date', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ItineraryViewer.ItineraryViewer, {
                guest: mockGuest
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByText('Wedding Ceremony')).toBeInTheDocument();
            });
            const toInput = _react.screen.getByLabelText('To:');
            _react.fireEvent.change(toInput, {
                target: {
                    value: '2025-06-14'
                }
            });
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Wedding Ceremony')).not.toBeInTheDocument();
            });
        });
        it('should clear date filters when clear button clicked', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ItineraryViewer.ItineraryViewer, {
                guest: mockGuest
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByText('Wedding Ceremony')).toBeInTheDocument();
            });
            const fromInput = _react.screen.getByLabelText('From:');
            _react.fireEvent.change(fromInput, {
                target: {
                    value: '2025-06-16'
                }
            });
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.queryByText('Wedding Ceremony')).not.toBeInTheDocument();
            });
            const clearButton = _react.screen.getByText('Clear');
            _react.fireEvent.click(clearButton);
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByText('Wedding Ceremony')).toBeInTheDocument();
            });
        });
    });
    describe('PDF Export', ()=>{
        it('should call PDF export API when export button clicked', async ()=>{
            global.fetch = jest.fn().mockResolvedValue({
                ok: true,
                blob: jest.fn().mockResolvedValue(new Blob([
                    'pdf content'
                ]))
            });
            global.URL.createObjectURL = jest.fn().mockReturnValue('blob:mock-url');
            global.URL.revokeObjectURL = jest.fn();
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ItineraryViewer.ItineraryViewer, {
                guest: mockGuest
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByText('Wedding Ceremony')).toBeInTheDocument();
            });
            const exportButton = _react.screen.getByText('ðŸ“„ Export PDF');
            _react.fireEvent.click(exportButton);
            await (0, _react.waitFor)(()=>{
                expect(global.fetch).toHaveBeenCalledWith('/api/guest/itinerary/pdf');
            });
        });
    });
    describe('Capacity Warnings', ()=>{
        it('should display capacity warning when < 10% remaining', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ItineraryViewer.ItineraryViewer, {
                guest: mockGuest
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByText('Wedding Ceremony')).toBeInTheDocument();
            });
            // Event has 95/100 capacity (5% remaining)
            expect(_react.screen.getByText('âš ï¸ 5 spots left')).toBeInTheDocument();
        });
        it('should display full warning when capacity = 0', async ()=>{
            const fullItinerary = {
                ...mockItinerary,
                events: [
                    {
                        ...mockItinerary.events[0],
                        capacity: 100,
                        attending_count: 100
                    }
                ]
            };
            _itineraryService.generateItinerary.mockResolvedValue({
                success: true,
                data: fullItinerary
            });
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ItineraryViewer.ItineraryViewer, {
                guest: mockGuest
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByText('âš ï¸ Full')).toBeInTheDocument();
            });
        });
    });
    describe('Deadline Alerts', ()=>{
        it('should display deadline alert when < 7 days remaining', async ()=>{
            // Mock current date to be 6 days before deadline
            const mockDate = new Date('2025-05-26');
            jest.spyOn(global, 'Date').mockImplementation(()=>mockDate);
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ItineraryViewer.ItineraryViewer, {
                guest: mockGuest
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByText('â° 6 days left')).toBeInTheDocument();
            });
            jest.restoreAllMocks();
        });
    });
    describe('Quick RSVP Links', ()=>{
        it('should display "RSVP Now" link for pending events', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ItineraryViewer.ItineraryViewer, {
                guest: mockGuest
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByText('Reception')).toBeInTheDocument();
            });
            const rsvpLink = _react.screen.getByText('RSVP Now â†’');
            expect(rsvpLink).toHaveAttribute('href', '/guest/events/event-2/rsvp');
        });
        it('should display "Update RSVP" link for attending events', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ItineraryViewer.ItineraryViewer, {
                guest: mockGuest
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByText('Wedding Ceremony')).toBeInTheDocument();
            });
            const updateLink = _react.screen.getByText('Update RSVP â†’');
            expect(updateLink).toHaveAttribute('href', '/guest/events/event-1/rsvp');
        });
    });
    describe('Offline Mode', ()=>{
        it('should display offline notice when offline', async ()=>{
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ItineraryViewer.ItineraryViewer, {
                guest: mockGuest
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByText('Wedding Ceremony')).toBeInTheDocument();
            });
            // Simulate going offline
            (0, _react.fireEvent)(window, new Event('offline'));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByText('ðŸ“¡ Offline Mode')).toBeInTheDocument();
            });
        });
        it('should load from cache when available', async ()=>{
            _itineraryService.getCachedItinerary.mockResolvedValue({
                success: true,
                data: mockItinerary
            });
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ItineraryViewer.ItineraryViewer, {
                guest: mockGuest
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByText('Wedding Ceremony')).toBeInTheDocument();
            });
            expect(_itineraryService.getCachedItinerary).toHaveBeenCalledWith('guest-1');
        });
    });
    describe('Loading and Error States', ()=>{
        it('should display loading spinner while fetching itinerary', ()=>{
            _itineraryService.generateItinerary.mockImplementation(()=>new Promise(()=>{}) // Never resolves
            );
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ItineraryViewer.ItineraryViewer, {
                guest: mockGuest
            }));
            expect(_react.screen.getByRole('status', {
                hidden: true
            })).toBeInTheDocument();
        });
        it('should display error message when itinerary fetch fails', async ()=>{
            _itineraryService.generateItinerary.mockResolvedValue({
                success: false,
                error: {
                    code: 'DATABASE_ERROR',
                    message: 'Failed to load itinerary'
                }
            });
            (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_ItineraryViewer.ItineraryViewer, {
                guest: mockGuest
            }));
            await (0, _react.waitFor)(()=>{
                expect(_react.screen.getByText(/Failed to load itinerary/i)).toBeInTheDocument();
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvY29tcG9uZW50cy9ndWVzdC9JdGluZXJhcnlWaWV3ZXIudGVzdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVuZGVyLCBzY3JlZW4sIGZpcmVFdmVudCwgd2FpdEZvciB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xuaW1wb3J0IHsgSXRpbmVyYXJ5Vmlld2VyIH0gZnJvbSAnLi9JdGluZXJhcnlWaWV3ZXInO1xuaW1wb3J0ICogYXMgaXRpbmVyYXJ5U2VydmljZSBmcm9tICdAL3NlcnZpY2VzL2l0aW5lcmFyeVNlcnZpY2UnO1xuXG5qZXN0Lm1vY2soJ0Avc2VydmljZXMvaXRpbmVyYXJ5U2VydmljZScpO1xuXG5kZXNjcmliZSgnSXRpbmVyYXJ5Vmlld2VyJywgKCkgPT4ge1xuICBjb25zdCBtb2NrR3Vlc3QgPSB7XG4gICAgaWQ6ICdndWVzdC0xJyxcbiAgICBmaXJzdF9uYW1lOiAnSm9obicsXG4gICAgbGFzdF9uYW1lOiAnRG9lJyxcbiAgICBlbWFpbDogJ2pvaG5AZXhhbXBsZS5jb20nLFxuICB9O1xuXG4gIGNvbnN0IG1vY2tJdGluZXJhcnkgPSB7XG4gICAgZ3Vlc3RfaWQ6ICdndWVzdC0xJyxcbiAgICBndWVzdF9uYW1lOiAnSm9obiBEb2UnLFxuICAgIGV2ZW50czogW1xuICAgICAge1xuICAgICAgICBpZDogJ2V2ZW50LTEnLFxuICAgICAgICBuYW1lOiAnV2VkZGluZyBDZXJlbW9ueScsXG4gICAgICAgIHR5cGU6ICdldmVudCcgYXMgY29uc3QsXG4gICAgICAgIGRhdGU6ICcyMDI1LTA2LTE1JyxcbiAgICAgICAgdGltZTogJzIwMjUtMDYtMTVUMTQ6MDA6MDBaJyxcbiAgICAgICAgbG9jYXRpb246ICdCZWFjaCBSZXNvcnQnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ01haW4gY2VyZW1vbnknLFxuICAgICAgICByc3ZwX3N0YXR1czogJ2F0dGVuZGluZycsXG4gICAgICAgIGNhcGFjaXR5OiAxMDAsXG4gICAgICAgIGF0dGVuZGluZ19jb3VudDogOTUsXG4gICAgICAgIHJzdnBfZGVhZGxpbmU6ICcyMDI1LTA2LTAxJyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiAnZXZlbnQtMicsXG4gICAgICAgIG5hbWU6ICdSZWNlcHRpb24nLFxuICAgICAgICB0eXBlOiAnZXZlbnQnIGFzIGNvbnN0LFxuICAgICAgICBkYXRlOiAnMjAyNS0wNi0xNScsXG4gICAgICAgIHRpbWU6ICcyMDI1LTA2LTE1VDE4OjAwOjAwWicsXG4gICAgICAgIGxvY2F0aW9uOiAnQmVhY2ggUmVzb3J0JyxcbiAgICAgICAgcnN2cF9zdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgIH0sXG4gICAgXSxcbiAgICBhY2NvbW1vZGF0aW9uOiB7XG4gICAgICBhY2NvbW1vZGF0aW9uX25hbWU6ICdCZWFjaCBSZXNvcnQnLFxuICAgICAgcm9vbV90eXBlOiAnRGVsdXhlIE9jZWFuIFZpZXcnLFxuICAgICAgY2hlY2tfaW46ICcyMDI1LTA2LTE0JyxcbiAgICAgIGNoZWNrX291dDogJzIwMjUtMDYtMTYnLFxuICAgIH0sXG4gICAgdHJhbnNwb3J0YXRpb246IHtcbiAgICAgIGFpcnBvcnRfY29kZTogJ1NKTycsXG4gICAgICBhcnJpdmFsX2RhdGU6ICcyMDI1LTA2LTE0VDEwOjAwOjAwWicsXG4gICAgICBkZXBhcnR1cmVfZGF0ZTogJzIwMjUtMDYtMTZUMTU6MDA6MDBaJyxcbiAgICB9LFxuICAgIGdlbmVyYXRlZF9hdDogJzIwMjUtMDEtMDFUMDA6MDA6MDBaJyxcbiAgfTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICAoaXRpbmVyYXJ5U2VydmljZS5nZW5lcmF0ZUl0aW5lcmFyeSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBkYXRhOiBtb2NrSXRpbmVyYXJ5LFxuICAgIH0pO1xuICAgIChpdGluZXJhcnlTZXJ2aWNlLmdldENhY2hlZEl0aW5lcmFyeSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IHsgY29kZTogJ05PVF9GT1VORCcsIG1lc3NhZ2U6ICdObyBjYWNoZScgfSxcbiAgICB9KTtcbiAgICAoaXRpbmVyYXJ5U2VydmljZS5jYWNoZUl0aW5lcmFyeSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdWaWV3IE1vZGVzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmVuZGVyIGRheS1ieS1kYXkgdmlldyBieSBkZWZhdWx0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxJdGluZXJhcnlWaWV3ZXIgZ3Vlc3Q9e21vY2tHdWVzdCBhcyBhbnl9IC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdXZWRkaW5nIENlcmVtb255JykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gRGF5LWJ5LWRheSBidXR0b24gc2hvdWxkIGJlIGFjdGl2ZVxuICAgICAgY29uc3QgZGF5QnlEYXlCdXR0b24gPSBzY3JlZW4uZ2V0QnlUZXh0KCfwn5OFIERheS1ieS1EYXknKTtcbiAgICAgIGV4cGVjdChkYXlCeURheUJ1dHRvbikudG9IYXZlQ2xhc3MoJ2JnLXdoaXRlJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHN3aXRjaCB0byBjYWxlbmRhciB2aWV3IHdoZW4gY2FsZW5kYXIgYnV0dG9uIGNsaWNrZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPEl0aW5lcmFyeVZpZXdlciBndWVzdD17bW9ja0d1ZXN0IGFzIGFueX0gLz4pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ1dlZGRpbmcgQ2VyZW1vbnknKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjYWxlbmRhckJ1dHRvbiA9IHNjcmVlbi5nZXRCeVRleHQoJ/Cfk4YgQ2FsZW5kYXInKTtcbiAgICAgIGZpcmVFdmVudC5jbGljayhjYWxlbmRhckJ1dHRvbik7XG5cbiAgICAgIC8vIENhbGVuZGFyIGJ1dHRvbiBzaG91bGQgYmUgYWN0aXZlXG4gICAgICBleHBlY3QoY2FsZW5kYXJCdXR0b24pLnRvSGF2ZUNsYXNzKCdiZy13aGl0ZScpO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgc2hvdyBjYWxlbmRhciB2aWV3IHRleHRcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KC9DYWxlbmRhciB2aWV3IHNob3dpbmcgZXZlbnRzIGJ5IG1vbnRoL2kpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzd2l0Y2ggdG8gbGlzdCB2aWV3IHdoZW4gbGlzdCBidXR0b24gY2xpY2tlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8SXRpbmVyYXJ5Vmlld2VyIGd1ZXN0PXttb2NrR3Vlc3QgYXMgYW55fSAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnV2VkZGluZyBDZXJlbW9ueScpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGxpc3RCdXR0b24gPSBzY3JlZW4uZ2V0QnlUZXh0KCfwn5OLIExpc3QnKTtcbiAgICAgIGZpcmVFdmVudC5jbGljayhsaXN0QnV0dG9uKTtcblxuICAgICAgLy8gTGlzdCBidXR0b24gc2hvdWxkIGJlIGFjdGl2ZVxuICAgICAgZXhwZWN0KGxpc3RCdXR0b24pLnRvSGF2ZUNsYXNzKCdiZy13aGl0ZScpO1xuICAgICAgXG4gICAgICAvLyBFdmVudHMgc2hvdWxkIHN0aWxsIGJlIHZpc2libGUgaW4gbGlzdCBmb3JtYXRcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdXZWRkaW5nIENlcmVtb255JykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdEYXRlIEZpbHRlcmluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGZpbHRlciBldmVudHMgYnkgZnJvbSBkYXRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxJdGluZXJhcnlWaWV3ZXIgZ3Vlc3Q9e21vY2tHdWVzdCBhcyBhbnl9IC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdXZWRkaW5nIENlcmVtb255JykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZnJvbUlucHV0ID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KCdGcm9tOicpO1xuICAgICAgZmlyZUV2ZW50LmNoYW5nZShmcm9tSW5wdXQsIHsgdGFyZ2V0OiB7IHZhbHVlOiAnMjAyNS0wNi0xNicgfSB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4ucXVlcnlCeVRleHQoJ1dlZGRpbmcgQ2VyZW1vbnknKSkubm90LnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZmlsdGVyIGV2ZW50cyBieSB0byBkYXRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxJdGluZXJhcnlWaWV3ZXIgZ3Vlc3Q9e21vY2tHdWVzdCBhcyBhbnl9IC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdXZWRkaW5nIENlcmVtb255JykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdG9JbnB1dCA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dCgnVG86Jyk7XG4gICAgICBmaXJlRXZlbnQuY2hhbmdlKHRvSW5wdXQsIHsgdGFyZ2V0OiB7IHZhbHVlOiAnMjAyNS0wNi0xNCcgfSB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4ucXVlcnlCeVRleHQoJ1dlZGRpbmcgQ2VyZW1vbnknKSkubm90LnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY2xlYXIgZGF0ZSBmaWx0ZXJzIHdoZW4gY2xlYXIgYnV0dG9uIGNsaWNrZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPEl0aW5lcmFyeVZpZXdlciBndWVzdD17bW9ja0d1ZXN0IGFzIGFueX0gLz4pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ1dlZGRpbmcgQ2VyZW1vbnknKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBmcm9tSW5wdXQgPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoJ0Zyb206Jyk7XG4gICAgICBmaXJlRXZlbnQuY2hhbmdlKGZyb21JbnB1dCwgeyB0YXJnZXQ6IHsgdmFsdWU6ICcyMDI1LTA2LTE2JyB9IH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5VGV4dCgnV2VkZGluZyBDZXJlbW9ueScpKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjbGVhckJ1dHRvbiA9IHNjcmVlbi5nZXRCeVRleHQoJ0NsZWFyJyk7XG4gICAgICBmaXJlRXZlbnQuY2xpY2soY2xlYXJCdXR0b24pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ1dlZGRpbmcgQ2VyZW1vbnknKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUERGIEV4cG9ydCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNhbGwgUERGIGV4cG9ydCBBUEkgd2hlbiBleHBvcnQgYnV0dG9uIGNsaWNrZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBnbG9iYWwuZmV0Y2ggPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgYmxvYjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKG5ldyBCbG9iKFsncGRmIGNvbnRlbnQnXSkpLFxuICAgICAgfSk7XG5cbiAgICAgIGdsb2JhbC5VUkwuY3JlYXRlT2JqZWN0VVJMID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSgnYmxvYjptb2NrLXVybCcpO1xuICAgICAgZ2xvYmFsLlVSTC5yZXZva2VPYmplY3RVUkwgPSBqZXN0LmZuKCk7XG5cbiAgICAgIHJlbmRlcig8SXRpbmVyYXJ5Vmlld2VyIGd1ZXN0PXttb2NrR3Vlc3QgYXMgYW55fSAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnV2VkZGluZyBDZXJlbW9ueScpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGV4cG9ydEJ1dHRvbiA9IHNjcmVlbi5nZXRCeVRleHQoJ/Cfk4QgRXhwb3J0IFBERicpO1xuICAgICAgZmlyZUV2ZW50LmNsaWNrKGV4cG9ydEJ1dHRvbik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QoZ2xvYmFsLmZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2FwaS9ndWVzdC9pdGluZXJhcnkvcGRmJyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NhcGFjaXR5IFdhcm5pbmdzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZGlzcGxheSBjYXBhY2l0eSB3YXJuaW5nIHdoZW4gPCAxMCUgcmVtYWluaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxJdGluZXJhcnlWaWV3ZXIgZ3Vlc3Q9e21vY2tHdWVzdCBhcyBhbnl9IC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdXZWRkaW5nIENlcmVtb255JykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gRXZlbnQgaGFzIDk1LzEwMCBjYXBhY2l0eSAoNSUgcmVtYWluaW5nKVxuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ+KaoO+4jyA1IHNwb3RzIGxlZnQnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGlzcGxheSBmdWxsIHdhcm5pbmcgd2hlbiBjYXBhY2l0eSA9IDAnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBmdWxsSXRpbmVyYXJ5ID0ge1xuICAgICAgICAuLi5tb2NrSXRpbmVyYXJ5LFxuICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5tb2NrSXRpbmVyYXJ5LmV2ZW50c1swXSxcbiAgICAgICAgICAgIGNhcGFjaXR5OiAxMDAsXG4gICAgICAgICAgICBhdHRlbmRpbmdfY291bnQ6IDEwMCxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgfTtcblxuICAgICAgKGl0aW5lcmFyeVNlcnZpY2UuZ2VuZXJhdGVJdGluZXJhcnkgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IGZ1bGxJdGluZXJhcnksXG4gICAgICB9KTtcblxuICAgICAgcmVuZGVyKDxJdGluZXJhcnlWaWV3ZXIgZ3Vlc3Q9e21vY2tHdWVzdCBhcyBhbnl9IC8+KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCfimqDvuI8gRnVsbCcpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdEZWFkbGluZSBBbGVydHMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBkaXNwbGF5IGRlYWRsaW5lIGFsZXJ0IHdoZW4gPCA3IGRheXMgcmVtYWluaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBjdXJyZW50IGRhdGUgdG8gYmUgNiBkYXlzIGJlZm9yZSBkZWFkbGluZVxuICAgICAgY29uc3QgbW9ja0RhdGUgPSBuZXcgRGF0ZSgnMjAyNS0wNS0yNicpO1xuICAgICAgamVzdC5zcHlPbihnbG9iYWwsICdEYXRlJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IG1vY2tEYXRlIGFzIGFueSk7XG5cbiAgICAgIHJlbmRlcig8SXRpbmVyYXJ5Vmlld2VyIGd1ZXN0PXttb2NrR3Vlc3QgYXMgYW55fSAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgn4o+wIDYgZGF5cyBsZWZ0JykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgamVzdC5yZXN0b3JlQWxsTW9ja3MoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1F1aWNrIFJTVlAgTGlua3MnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBkaXNwbGF5IFwiUlNWUCBOb3dcIiBsaW5rIGZvciBwZW5kaW5nIGV2ZW50cycsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8SXRpbmVyYXJ5Vmlld2VyIGd1ZXN0PXttb2NrR3Vlc3QgYXMgYW55fSAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnUmVjZXB0aW9uJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcnN2cExpbmsgPSBzY3JlZW4uZ2V0QnlUZXh0KCdSU1ZQIE5vdyDihpInKTtcbiAgICAgIGV4cGVjdChyc3ZwTGluaykudG9IYXZlQXR0cmlidXRlKCdocmVmJywgJy9ndWVzdC9ldmVudHMvZXZlbnQtMi9yc3ZwJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRpc3BsYXkgXCJVcGRhdGUgUlNWUFwiIGxpbmsgZm9yIGF0dGVuZGluZyBldmVudHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPEl0aW5lcmFyeVZpZXdlciBndWVzdD17bW9ja0d1ZXN0IGFzIGFueX0gLz4pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ1dlZGRpbmcgQ2VyZW1vbnknKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB1cGRhdGVMaW5rID0gc2NyZWVuLmdldEJ5VGV4dCgnVXBkYXRlIFJTVlAg4oaSJyk7XG4gICAgICBleHBlY3QodXBkYXRlTGluaykudG9IYXZlQXR0cmlidXRlKCdocmVmJywgJy9ndWVzdC9ldmVudHMvZXZlbnQtMS9yc3ZwJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdPZmZsaW5lIE1vZGUnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBkaXNwbGF5IG9mZmxpbmUgbm90aWNlIHdoZW4gb2ZmbGluZScsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8SXRpbmVyYXJ5Vmlld2VyIGd1ZXN0PXttb2NrR3Vlc3QgYXMgYW55fSAvPik7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnV2VkZGluZyBDZXJlbW9ueScpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIGdvaW5nIG9mZmxpbmVcbiAgICAgIGZpcmVFdmVudCh3aW5kb3csIG5ldyBFdmVudCgnb2ZmbGluZScpKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCfwn5OhIE9mZmxpbmUgTW9kZScpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGxvYWQgZnJvbSBjYWNoZSB3aGVuIGF2YWlsYWJsZScsIGFzeW5jICgpID0+IHtcbiAgICAgIChpdGluZXJhcnlTZXJ2aWNlLmdldENhY2hlZEl0aW5lcmFyeSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YTogbW9ja0l0aW5lcmFyeSxcbiAgICAgIH0pO1xuXG4gICAgICByZW5kZXIoPEl0aW5lcmFyeVZpZXdlciBndWVzdD17bW9ja0d1ZXN0IGFzIGFueX0gLz4pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ1dlZGRpbmcgQ2VyZW1vbnknKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoaXRpbmVyYXJ5U2VydmljZS5nZXRDYWNoZWRJdGluZXJhcnkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdndWVzdC0xJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdMb2FkaW5nIGFuZCBFcnJvciBTdGF0ZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBkaXNwbGF5IGxvYWRpbmcgc3Bpbm5lciB3aGlsZSBmZXRjaGluZyBpdGluZXJhcnknLCAoKSA9PiB7XG4gICAgICAoaXRpbmVyYXJ5U2VydmljZS5nZW5lcmF0ZUl0aW5lcmFyeSBhcyBqZXN0Lk1vY2spLm1vY2tJbXBsZW1lbnRhdGlvbihcbiAgICAgICAgKCkgPT4gbmV3IFByb21pc2UoKCkgPT4ge30pIC8vIE5ldmVyIHJlc29sdmVzXG4gICAgICApO1xuXG4gICAgICByZW5kZXIoPEl0aW5lcmFyeVZpZXdlciBndWVzdD17bW9ja0d1ZXN0IGFzIGFueX0gLz4pO1xuXG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5Um9sZSgnc3RhdHVzJywgeyBoaWRkZW46IHRydWUgfSkpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRpc3BsYXkgZXJyb3IgbWVzc2FnZSB3aGVuIGl0aW5lcmFyeSBmZXRjaCBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgIChpdGluZXJhcnlTZXJ2aWNlLmdlbmVyYXRlSXRpbmVyYXJ5IGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IHsgY29kZTogJ0RBVEFCQVNFX0VSUk9SJywgbWVzc2FnZTogJ0ZhaWxlZCB0byBsb2FkIGl0aW5lcmFyeScgfSxcbiAgICAgIH0pO1xuXG4gICAgICByZW5kZXIoPEl0aW5lcmFyeVZpZXdlciBndWVzdD17bW9ja0d1ZXN0IGFzIGFueX0gLz4pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoL0ZhaWxlZCB0byBsb2FkIGl0aW5lcmFyeS9pKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiZGVzY3JpYmUiLCJtb2NrR3Vlc3QiLCJpZCIsImZpcnN0X25hbWUiLCJsYXN0X25hbWUiLCJlbWFpbCIsIm1vY2tJdGluZXJhcnkiLCJndWVzdF9pZCIsImd1ZXN0X25hbWUiLCJldmVudHMiLCJuYW1lIiwidHlwZSIsImRhdGUiLCJ0aW1lIiwibG9jYXRpb24iLCJkZXNjcmlwdGlvbiIsInJzdnBfc3RhdHVzIiwiY2FwYWNpdHkiLCJhdHRlbmRpbmdfY291bnQiLCJyc3ZwX2RlYWRsaW5lIiwiYWNjb21tb2RhdGlvbiIsImFjY29tbW9kYXRpb25fbmFtZSIsInJvb21fdHlwZSIsImNoZWNrX2luIiwiY2hlY2tfb3V0IiwidHJhbnNwb3J0YXRpb24iLCJhaXJwb3J0X2NvZGUiLCJhcnJpdmFsX2RhdGUiLCJkZXBhcnR1cmVfZGF0ZSIsImdlbmVyYXRlZF9hdCIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiaXRpbmVyYXJ5U2VydmljZSIsImdlbmVyYXRlSXRpbmVyYXJ5IiwibW9ja1Jlc29sdmVkVmFsdWUiLCJzdWNjZXNzIiwiZGF0YSIsImdldENhY2hlZEl0aW5lcmFyeSIsImVycm9yIiwiY29kZSIsIm1lc3NhZ2UiLCJjYWNoZUl0aW5lcmFyeSIsInVuZGVmaW5lZCIsIml0IiwicmVuZGVyIiwiSXRpbmVyYXJ5Vmlld2VyIiwiZ3Vlc3QiLCJ3YWl0Rm9yIiwiZXhwZWN0Iiwic2NyZWVuIiwiZ2V0QnlUZXh0IiwidG9CZUluVGhlRG9jdW1lbnQiLCJkYXlCeURheUJ1dHRvbiIsInRvSGF2ZUNsYXNzIiwiY2FsZW5kYXJCdXR0b24iLCJmaXJlRXZlbnQiLCJjbGljayIsImxpc3RCdXR0b24iLCJmcm9tSW5wdXQiLCJnZXRCeUxhYmVsVGV4dCIsImNoYW5nZSIsInRhcmdldCIsInZhbHVlIiwicXVlcnlCeVRleHQiLCJub3QiLCJ0b0lucHV0IiwiY2xlYXJCdXR0b24iLCJnbG9iYWwiLCJmZXRjaCIsImZuIiwib2siLCJibG9iIiwiQmxvYiIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsIm1vY2tSZXR1cm5WYWx1ZSIsInJldm9rZU9iamVjdFVSTCIsImV4cG9ydEJ1dHRvbiIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwiZnVsbEl0aW5lcmFyeSIsIm1vY2tEYXRlIiwiRGF0ZSIsInNweU9uIiwibW9ja0ltcGxlbWVudGF0aW9uIiwicmVzdG9yZUFsbE1vY2tzIiwicnN2cExpbmsiLCJ0b0hhdmVBdHRyaWJ1dGUiLCJ1cGRhdGVMaW5rIiwid2luZG93IiwiRXZlbnQiLCJQcm9taXNlIiwiZ2V0QnlSb2xlIiwiaGlkZGVuIl0sIm1hcHBpbmdzIjoiO0FBSUFBLEtBQUtDLElBQUksQ0FBQzs7Ozs7dUJBSnlDO2lDQUNuQjswRUFDRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSWxDQyxTQUFTLG1CQUFtQjtJQUMxQixNQUFNQyxZQUFZO1FBQ2hCQyxJQUFJO1FBQ0pDLFlBQVk7UUFDWkMsV0FBVztRQUNYQyxPQUFPO0lBQ1Q7SUFFQSxNQUFNQyxnQkFBZ0I7UUFDcEJDLFVBQVU7UUFDVkMsWUFBWTtRQUNaQyxRQUFRO1lBQ047Z0JBQ0VQLElBQUk7Z0JBQ0pRLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05DLFVBQVU7Z0JBQ1ZDLGFBQWE7Z0JBQ2JDLGFBQWE7Z0JBQ2JDLFVBQVU7Z0JBQ1ZDLGlCQUFpQjtnQkFDakJDLGVBQWU7WUFDakI7WUFDQTtnQkFDRWpCLElBQUk7Z0JBQ0pRLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05DLFVBQVU7Z0JBQ1ZFLGFBQWE7WUFDZjtTQUNEO1FBQ0RJLGVBQWU7WUFDYkMsb0JBQW9CO1lBQ3BCQyxXQUFXO1lBQ1hDLFVBQVU7WUFDVkMsV0FBVztRQUNiO1FBQ0FDLGdCQUFnQjtZQUNkQyxjQUFjO1lBQ2RDLGNBQWM7WUFDZEMsZ0JBQWdCO1FBQ2xCO1FBQ0FDLGNBQWM7SUFDaEI7SUFFQUMsV0FBVztRQUNUaEMsS0FBS2lDLGFBQWE7UUFDakJDLGtCQUFpQkMsaUJBQWlC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