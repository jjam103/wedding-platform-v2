669ff8889d673881fa04f8419d096eed
"use strict";
// Mock dependencies
jest.mock('@/services/rsvpManagementService');
jest.mock('@/lib/apiHelpers');
jest.mock('@/lib/rateLimit');
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _route = require("./route");
const _rsvpManagementService = /*#__PURE__*/ _interop_require_wildcard(require("../../../../../services/rsvpManagementService"));
const _apiHelpers = /*#__PURE__*/ _interop_require_wildcard(require("../../../../../lib/apiHelpers"));
const _rateLimit = /*#__PURE__*/ _interop_require_wildcard(require("../../../../../lib/rateLimit"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('GET /api/admin/rsvps/export', ()=>{
    const mockUserId = 'user-123';
    const mockWithAuth = _apiHelpers.withAuth;
    const mockRateLimitMiddleware = _rateLimit.rateLimitMiddleware;
    const mockGetRateLimitHeaders = _rateLimit.getRateLimitHeaders;
    const mockExportRSVPsToCSV = _rsvpManagementService.exportRSVPsToCSV;
    beforeEach(()=>{
        jest.clearAllMocks();
        // Default: withAuth calls the handler with userId
        mockWithAuth.mockImplementation(async (handler)=>{
            return await handler(mockUserId);
        });
        // Default: rate limit allows request
        mockRateLimitMiddleware.mockReturnValue({
            success: true,
            data: {
                allowed: true,
                limit: 1,
                remaining: 0,
                reset: Math.floor(Date.now() / 1000) + 60
            }
        });
        // Default: rate limit headers
        mockGetRateLimitHeaders.mockReturnValue({
            'X-RateLimit-Limit': '1',
            'X-RateLimit-Remaining': '0',
            'X-RateLimit-Reset': String(Math.floor(Date.now() / 1000) + 60)
        });
    });
    describe('Success Cases', ()=>{
        it('should export RSVPs to CSV when authenticated with valid filters', async ()=>{
            const mockCSV = 'RSVP ID,Guest First Name,Guest Last Name\nrsvp-1,John,Doe';
            mockExportRSVPsToCSV.mockResolvedValue({
                success: true,
                data: mockCSV
            });
            const request = new Request('http://localhost:3000/api/admin/rsvps/export?eventId=event-123&status=attending');
            const response = await (0, _route.GET)(request);
            expect(response.status).toBe(200);
            expect(response.headers.get('Content-Type')).toBe('text/csv; charset=utf-8');
            expect(response.headers.get('Content-Disposition')).toMatch(/^attachment; filename="rsvps-export-\d{4}-\d{2}-\d{2}\.csv"$/);
            const csvContent = await response.text();
            expect(csvContent).toBe(mockCSV);
            // Verify service was called with correct filters
            expect(mockExportRSVPsToCSV).toHaveBeenCalledWith({
                eventId: 'event-123',
                status: 'attending'
            });
        });
        it('should export all RSVPs when no filters provided', async ()=>{
            const mockCSV = 'RSVP ID,Guest First Name,Guest Last Name\nrsvp-1,John,Doe\nrsvp-2,Jane,Smith';
            mockExportRSVPsToCSV.mockResolvedValue({
                success: true,
                data: mockCSV
            });
            const request = new Request('http://localhost:3000/api/admin/rsvps/export');
            const response = await (0, _route.GET)(request);
            expect(response.status).toBe(200);
            expect(mockExportRSVPsToCSV).toHaveBeenCalledWith({});
        });
        it('should include rate limit headers in successful response', async ()=>{
            mockExportRSVPsToCSV.mockResolvedValue({
                success: true,
                data: 'CSV content'
            });
            const request = new Request('http://localhost:3000/api/admin/rsvps/export');
            const response = await (0, _route.GET)(request);
            expect(response.status).toBe(200);
            expect(response.headers.get('X-RateLimit-Limit')).toBe('1');
            expect(response.headers.get('X-RateLimit-Remaining')).toBe('0');
            expect(response.headers.has('X-RateLimit-Reset')).toBe(true);
        });
        it('should support multiple filter combinations', async ()=>{
            mockExportRSVPsToCSV.mockResolvedValue({
                success: true,
                data: 'CSV content'
            });
            const request = new Request('http://localhost:3000/api/admin/rsvps/export?eventId=event-123&activityId=activity-456&status=attending&searchQuery=john');
            const response = await (0, _route.GET)(request);
            expect(response.status).toBe(200);
            expect(mockExportRSVPsToCSV).toHaveBeenCalledWith({
                eventId: 'event-123',
                activityId: 'activity-456',
                status: 'attending',
                searchQuery: 'john'
            });
        });
    });
    describe('Validation Errors', ()=>{
        it('should return 400 when eventId is not a valid UUID', async ()=>{
            const request = new Request('http://localhost:3000/api/admin/rsvps/export?eventId=invalid-uuid');
            const response = await (0, _route.GET)(request);
            expect(response.status).toBe(400);
            const data = await response.json();
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('VALIDATION_ERROR');
            expect(mockExportRSVPsToCSV).not.toHaveBeenCalled();
        });
        it('should return 400 when status is invalid', async ()=>{
            const request = new Request('http://localhost:3000/api/admin/rsvps/export?status=invalid-status');
            const response = await (0, _route.GET)(request);
            expect(response.status).toBe(400);
            const data = await response.json();
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('VALIDATION_ERROR');
            expect(mockExportRSVPsToCSV).not.toHaveBeenCalled();
        });
        it('should return 400 when searchQuery exceeds max length', async ()=>{
            const longQuery = 'a'.repeat(101);
            const request = new Request(`http://localhost:3000/api/admin/rsvps/export?searchQuery=${longQuery}`);
            const response = await (0, _route.GET)(request);
            expect(response.status).toBe(400);
            const data = await response.json();
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('VALIDATION_ERROR');
            expect(mockExportRSVPsToCSV).not.toHaveBeenCalled();
        });
    });
    describe('Rate Limiting', ()=>{
        it('should return 429 when rate limit exceeded', async ()=>{
            mockRateLimitMiddleware.mockReturnValue({
                success: false,
                error: {
                    code: 'RATE_LIMIT_EXCEEDED',
                    message: 'Too many requests. Please try again later.',
                    details: {
                        limit: 1,
                        remaining: 0,
                        reset: Math.floor(Date.now() / 1000) + 60,
                        retryAfter: 60
                    }
                }
            });
            mockGetRateLimitHeaders.mockReturnValue({
                'X-RateLimit-Limit': '1',
                'X-RateLimit-Remaining': '0',
                'X-RateLimit-Reset': String(Math.floor(Date.now() / 1000) + 60),
                'Retry-After': '60'
            });
            const request = new Request('http://localhost:3000/api/admin/rsvps/export');
            const response = await (0, _route.GET)(request);
            expect(response.status).toBe(429);
            const data = await response.json();
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('RATE_LIMIT_EXCEEDED');
            expect(response.headers.get('Retry-After')).toBe('60');
            expect(mockExportRSVPsToCSV).not.toHaveBeenCalled();
        });
        it('should enforce 1 request per minute rate limit', async ()=>{
            mockExportRSVPsToCSV.mockResolvedValue({
                success: true,
                data: 'CSV content'
            });
            const request = new Request('http://localhost:3000/api/admin/rsvps/export');
            await (0, _route.GET)(request);
            // Verify rate limit was checked with correct parameters
            expect(mockRateLimitMiddleware).toHaveBeenCalledWith(mockUserId, 'api:rsvps:export', {
                maxRequests: 1,
                windowMs: 60 * 1000
            });
        });
    });
    describe('Service Errors', ()=>{
        it('should return 500 when service returns database error', async ()=>{
            mockExportRSVPsToCSV.mockResolvedValue({
                success: false,
                error: {
                    code: 'DATABASE_ERROR',
                    message: 'Database connection failed'
                }
            });
            const request = new Request('http://localhost:3000/api/admin/rsvps/export');
            const response = await (0, _route.GET)(request);
            expect(response.status).toBe(500);
            const data = await response.json();
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('DATABASE_ERROR');
        });
        it('should return 400 when service returns validation error', async ()=>{
            mockExportRSVPsToCSV.mockResolvedValue({
                success: false,
                error: {
                    code: 'VALIDATION_ERROR',
                    message: 'Invalid filter parameters'
                }
            });
            const request = new Request('http://localhost:3000/api/admin/rsvps/export');
            const response = await (0, _route.GET)(request);
            expect(response.status).toBe(400);
            const data = await response.json();
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('VALIDATION_ERROR');
        });
    });
    describe('Authentication', ()=>{
        it('should return 401 when not authenticated', async ()=>{
            mockWithAuth.mockImplementation(async ()=>{
                return new Response(JSON.stringify({
                    success: false,
                    error: {
                        code: 'UNAUTHORIZED',
                        message: 'Authentication required'
                    }
                }), {
                    status: 401
                });
            });
            const request = new Request('http://localhost:3000/api/admin/rsvps/export');
            const response = await (0, _route.GET)(request);
            expect(response.status).toBe(401);
            const data = await response.json();
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('UNAUTHORIZED');
            expect(mockExportRSVPsToCSV).not.toHaveBeenCalled();
        });
    });
    describe('Error Handling', ()=>{
        it('should return 500 when unexpected error occurs', async ()=>{
            mockExportRSVPsToCSV.mockRejectedValue(new Error('Unexpected error'));
            const request = new Request('http://localhost:3000/api/admin/rsvps/export');
            const response = await (0, _route.GET)(request);
            expect(response.status).toBe(500);
            const data = await response.json();
            expect(data.success).toBe(false);
            expect(data.error.code).toBe('INTERNAL_ERROR');
        });
    });
    describe('CSV Response Format', ()=>{
        it('should set correct Content-Type header', async ()=>{
            mockExportRSVPsToCSV.mockResolvedValue({
                success: true,
                data: 'CSV content'
            });
            const request = new Request('http://localhost:3000/api/admin/rsvps/export');
            const response = await (0, _route.GET)(request);
            expect(response.headers.get('Content-Type')).toBe('text/csv; charset=utf-8');
        });
        it('should set Content-Disposition header with filename', async ()=>{
            mockExportRSVPsToCSV.mockResolvedValue({
                success: true,
                data: 'CSV content'
            });
            const request = new Request('http://localhost:3000/api/admin/rsvps/export');
            const response = await (0, _route.GET)(request);
            const contentDisposition = response.headers.get('Content-Disposition');
            expect(contentDisposition).toMatch(/^attachment; filename="rsvps-export-\d{4}-\d{2}-\d{2}\.csv"$/);
        });
        it('should set Cache-Control header to prevent caching', async ()=>{
            mockExportRSVPsToCSV.mockResolvedValue({
                success: true,
                data: 'CSV content'
            });
            const request = new Request('http://localhost:3000/api/admin/rsvps/export');
            const response = await (0, _route.GET)(request);
            expect(response.headers.get('Cache-Control')).toBe('no-cache, no-store, must-revalidate');
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvYXBwL2FwaS9hZG1pbi9yc3Zwcy9leHBvcnQvcm91dGUudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHRVQgfSBmcm9tICcuL3JvdXRlJztcbmltcG9ydCAqIGFzIHJzdnBNYW5hZ2VtZW50U2VydmljZSBmcm9tICdAL3NlcnZpY2VzL3JzdnBNYW5hZ2VtZW50U2VydmljZSc7XG5pbXBvcnQgKiBhcyBhcGlIZWxwZXJzIGZyb20gJ0AvbGliL2FwaUhlbHBlcnMnO1xuaW1wb3J0ICogYXMgcmF0ZUxpbWl0IGZyb20gJ0AvbGliL3JhdGVMaW1pdCc7XG5cbi8vIE1vY2sgZGVwZW5kZW5jaWVzXG5qZXN0Lm1vY2soJ0Avc2VydmljZXMvcnN2cE1hbmFnZW1lbnRTZXJ2aWNlJyk7XG5qZXN0Lm1vY2soJ0AvbGliL2FwaUhlbHBlcnMnKTtcbmplc3QubW9jaygnQC9saWIvcmF0ZUxpbWl0Jyk7XG5cbmRlc2NyaWJlKCdHRVQgL2FwaS9hZG1pbi9yc3Zwcy9leHBvcnQnLCAoKSA9PiB7XG4gIGNvbnN0IG1vY2tVc2VySWQgPSAndXNlci0xMjMnO1xuICBjb25zdCBtb2NrV2l0aEF1dGggPSBhcGlIZWxwZXJzLndpdGhBdXRoIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGFwaUhlbHBlcnMud2l0aEF1dGg+O1xuICBjb25zdCBtb2NrUmF0ZUxpbWl0TWlkZGxld2FyZSA9IHJhdGVMaW1pdC5yYXRlTGltaXRNaWRkbGV3YXJlIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIHJhdGVMaW1pdC5yYXRlTGltaXRNaWRkbGV3YXJlPjtcbiAgY29uc3QgbW9ja0dldFJhdGVMaW1pdEhlYWRlcnMgPSByYXRlTGltaXQuZ2V0UmF0ZUxpbWl0SGVhZGVycyBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiByYXRlTGltaXQuZ2V0UmF0ZUxpbWl0SGVhZGVycz47XG4gIGNvbnN0IG1vY2tFeHBvcnRSU1ZQc1RvQ1NWID0gcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmV4cG9ydFJTVlBzVG9DU1YgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgcnN2cE1hbmFnZW1lbnRTZXJ2aWNlLmV4cG9ydFJTVlBzVG9DU1Y+O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIFxuICAgIC8vIERlZmF1bHQ6IHdpdGhBdXRoIGNhbGxzIHRoZSBoYW5kbGVyIHdpdGggdXNlcklkXG4gICAgbW9ja1dpdGhBdXRoLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoaGFuZGxlcikgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IGhhbmRsZXIobW9ja1VzZXJJZCk7XG4gICAgfSk7XG5cbiAgICAvLyBEZWZhdWx0OiByYXRlIGxpbWl0IGFsbG93cyByZXF1ZXN0XG4gICAgbW9ja1JhdGVMaW1pdE1pZGRsZXdhcmUubW9ja1JldHVyblZhbHVlKHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGFsbG93ZWQ6IHRydWUsXG4gICAgICAgIGxpbWl0OiAxLFxuICAgICAgICByZW1haW5pbmc6IDAsXG4gICAgICAgIHJlc2V0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSArIDYwLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIERlZmF1bHQ6IHJhdGUgbGltaXQgaGVhZGVyc1xuICAgIG1vY2tHZXRSYXRlTGltaXRIZWFkZXJzLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAnWC1SYXRlTGltaXQtTGltaXQnOiAnMScsXG4gICAgICAnWC1SYXRlTGltaXQtUmVtYWluaW5nJzogJzAnLFxuICAgICAgJ1gtUmF0ZUxpbWl0LVJlc2V0JzogU3RyaW5nKE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApICsgNjApLFxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU3VjY2VzcyBDYXNlcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGV4cG9ydCBSU1ZQcyB0byBDU1Ygd2hlbiBhdXRoZW50aWNhdGVkIHdpdGggdmFsaWQgZmlsdGVycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tDU1YgPSAnUlNWUCBJRCxHdWVzdCBGaXJzdCBOYW1lLEd1ZXN0IExhc3QgTmFtZVxcbnJzdnAtMSxKb2huLERvZSc7XG4gICAgICBtb2NrRXhwb3J0UlNWUHNUb0NTVi5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IG1vY2tDU1YsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL3JzdnBzL2V4cG9ydD9ldmVudElkPWV2ZW50LTEyMyZzdGF0dXM9YXR0ZW5kaW5nJyk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IEdFVChyZXF1ZXN0KTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSkudG9CZSgndGV4dC9jc3Y7IGNoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIGV4cGVjdChyZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1EaXNwb3NpdGlvbicpKS50b01hdGNoKC9eYXR0YWNobWVudDsgZmlsZW5hbWU9XCJyc3Zwcy1leHBvcnQtXFxkezR9LVxcZHsyfS1cXGR7Mn1cXC5jc3ZcIiQvKTtcbiAgICAgIFxuICAgICAgY29uc3QgY3N2Q29udGVudCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIGV4cGVjdChjc3ZDb250ZW50KS50b0JlKG1vY2tDU1YpO1xuXG4gICAgICAvLyBWZXJpZnkgc2VydmljZSB3YXMgY2FsbGVkIHdpdGggY29ycmVjdCBmaWx0ZXJzXG4gICAgICBleHBlY3QobW9ja0V4cG9ydFJTVlBzVG9DU1YpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgZXZlbnRJZDogJ2V2ZW50LTEyMycsXG4gICAgICAgIHN0YXR1czogJ2F0dGVuZGluZycsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZXhwb3J0IGFsbCBSU1ZQcyB3aGVuIG5vIGZpbHRlcnMgcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQ1NWID0gJ1JTVlAgSUQsR3Vlc3QgRmlyc3QgTmFtZSxHdWVzdCBMYXN0IE5hbWVcXG5yc3ZwLTEsSm9obixEb2VcXG5yc3ZwLTIsSmFuZSxTbWl0aCc7XG4gICAgICBtb2NrRXhwb3J0UlNWUHNUb0NTVi5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IG1vY2tDU1YsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL3JzdnBzL2V4cG9ydCcpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBHRVQocmVxdWVzdCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgIGV4cGVjdChtb2NrRXhwb3J0UlNWUHNUb0NTVikudG9IYXZlQmVlbkNhbGxlZFdpdGgoe30pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBpbmNsdWRlIHJhdGUgbGltaXQgaGVhZGVycyBpbiBzdWNjZXNzZnVsIHJlc3BvbnNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4cG9ydFJTVlBzVG9DU1YubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiAnQ1NWIGNvbnRlbnQnLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9yc3Zwcy9leHBvcnQnKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUKHJlcXVlc3QpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QocmVzcG9uc2UuaGVhZGVycy5nZXQoJ1gtUmF0ZUxpbWl0LUxpbWl0JykpLnRvQmUoJzEnKTtcbiAgICAgIGV4cGVjdChyZXNwb25zZS5oZWFkZXJzLmdldCgnWC1SYXRlTGltaXQtUmVtYWluaW5nJykpLnRvQmUoJzAnKTtcbiAgICAgIGV4cGVjdChyZXNwb25zZS5oZWFkZXJzLmhhcygnWC1SYXRlTGltaXQtUmVzZXQnKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc3VwcG9ydCBtdWx0aXBsZSBmaWx0ZXIgY29tYmluYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4cG9ydFJTVlBzVG9DU1YubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiAnQ1NWIGNvbnRlbnQnLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChcbiAgICAgICAgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vcnN2cHMvZXhwb3J0P2V2ZW50SWQ9ZXZlbnQtMTIzJmFjdGl2aXR5SWQ9YWN0aXZpdHktNDU2JnN0YXR1cz1hdHRlbmRpbmcmc2VhcmNoUXVlcnk9am9obidcbiAgICAgICk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IEdFVChyZXF1ZXN0KTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KG1vY2tFeHBvcnRSU1ZQc1RvQ1NWKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIGV2ZW50SWQ6ICdldmVudC0xMjMnLFxuICAgICAgICBhY3Rpdml0eUlkOiAnYWN0aXZpdHktNDU2JyxcbiAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyxcbiAgICAgICAgc2VhcmNoUXVlcnk6ICdqb2huJyxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnVmFsaWRhdGlvbiBFcnJvcnMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAwIHdoZW4gZXZlbnRJZCBpcyBub3QgYSB2YWxpZCBVVUlEJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL3JzdnBzL2V4cG9ydD9ldmVudElkPWludmFsaWQtdXVpZCcpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBHRVQocmVxdWVzdCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yLmNvZGUpLnRvQmUoJ1ZBTElEQVRJT05fRVJST1InKTtcbiAgICAgIGV4cGVjdChtb2NrRXhwb3J0UlNWUHNUb0NTVikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMCB3aGVuIHN0YXR1cyBpcyBpbnZhbGlkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL3JzdnBzL2V4cG9ydD9zdGF0dXM9aW52YWxpZC1zdGF0dXMnKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUKHJlcXVlc3QpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5jb2RlKS50b0JlKCdWQUxJREFUSU9OX0VSUk9SJyk7XG4gICAgICBleHBlY3QobW9ja0V4cG9ydFJTVlBzVG9DU1YpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiA0MDAgd2hlbiBzZWFyY2hRdWVyeSBleGNlZWRzIG1heCBsZW5ndGgnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsb25nUXVlcnkgPSAnYScucmVwZWF0KDEwMSk7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vcnN2cHMvZXhwb3J0P3NlYXJjaFF1ZXJ5PSR7bG9uZ1F1ZXJ5fWApO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBHRVQocmVxdWVzdCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yLmNvZGUpLnRvQmUoJ1ZBTElEQVRJT05fRVJST1InKTtcbiAgICAgIGV4cGVjdChtb2NrRXhwb3J0UlNWUHNUb0NTVikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JhdGUgTGltaXRpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gNDI5IHdoZW4gcmF0ZSBsaW1pdCBleGNlZWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tSYXRlTGltaXRNaWRkbGV3YXJlLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgIGNvZGU6ICdSQVRFX0xJTUlUX0VYQ0VFREVEJyxcbiAgICAgICAgICBtZXNzYWdlOiAnVG9vIG1hbnkgcmVxdWVzdHMuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJyxcbiAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICBsaW1pdDogMSxcbiAgICAgICAgICAgIHJlbWFpbmluZzogMCxcbiAgICAgICAgICAgIHJlc2V0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSArIDYwLFxuICAgICAgICAgICAgcmV0cnlBZnRlcjogNjAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrR2V0UmF0ZUxpbWl0SGVhZGVycy5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAnWC1SYXRlTGltaXQtTGltaXQnOiAnMScsXG4gICAgICAgICdYLVJhdGVMaW1pdC1SZW1haW5pbmcnOiAnMCcsXG4gICAgICAgICdYLVJhdGVMaW1pdC1SZXNldCc6IFN0cmluZyhNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSArIDYwKSxcbiAgICAgICAgJ1JldHJ5LUFmdGVyJzogJzYwJyxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vcnN2cHMvZXhwb3J0Jyk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IEdFVChyZXF1ZXN0KTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MjkpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IuY29kZSkudG9CZSgnUkFURV9MSU1JVF9FWENFRURFRCcpO1xuICAgICAgZXhwZWN0KHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdSZXRyeS1BZnRlcicpKS50b0JlKCc2MCcpO1xuICAgICAgZXhwZWN0KG1vY2tFeHBvcnRSU1ZQc1RvQ1NWKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBlbmZvcmNlIDEgcmVxdWVzdCBwZXIgbWludXRlIHJhdGUgbGltaXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRXhwb3J0UlNWUHNUb0NTVi5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6ICdDU1YgY29udGVudCcsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL3JzdnBzL2V4cG9ydCcpO1xuICAgICAgYXdhaXQgR0VUKHJlcXVlc3QpO1xuXG4gICAgICAvLyBWZXJpZnkgcmF0ZSBsaW1pdCB3YXMgY2hlY2tlZCB3aXRoIGNvcnJlY3QgcGFyYW1ldGVyc1xuICAgICAgZXhwZWN0KG1vY2tSYXRlTGltaXRNaWRkbGV3YXJlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgbW9ja1VzZXJJZCxcbiAgICAgICAgJ2FwaTpyc3ZwczpleHBvcnQnLFxuICAgICAgICB7IG1heFJlcXVlc3RzOiAxLCB3aW5kb3dNczogNjAgKiAxMDAwIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTZXJ2aWNlIEVycm9ycycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiA1MDAgd2hlbiBzZXJ2aWNlIHJldHVybnMgZGF0YWJhc2UgZXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRXhwb3J0UlNWUHNUb0NTVi5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgIGNvZGU6ICdEQVRBQkFTRV9FUlJPUicsXG4gICAgICAgICAgbWVzc2FnZTogJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vcnN2cHMvZXhwb3J0Jyk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IEdFVChyZXF1ZXN0KTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg1MDApO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IuY29kZSkudG9CZSgnREFUQUJBU0VfRVJST1InKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwMCB3aGVuIHNlcnZpY2UgcmV0dXJucyB2YWxpZGF0aW9uIGVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4cG9ydFJTVlBzVG9DU1YubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICBjb2RlOiAnVkFMSURBVElPTl9FUlJPUicsXG4gICAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgZmlsdGVyIHBhcmFtZXRlcnMnLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9yc3Zwcy9leHBvcnQnKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUKHJlcXVlc3QpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5jb2RlKS50b0JlKCdWQUxJREFUSU9OX0VSUk9SJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBdXRoZW50aWNhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiA0MDEgd2hlbiBub3QgYXV0aGVudGljYXRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tXaXRoQXV0aC5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKFxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IHsgY29kZTogJ1VOQVVUSE9SSVpFRCcsIG1lc3NhZ2U6ICdBdXRoZW50aWNhdGlvbiByZXF1aXJlZCcgfSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7IHN0YXR1czogNDAxIH1cbiAgICAgICAgKSBhcyBhbnk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL3JzdnBzL2V4cG9ydCcpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBHRVQocmVxdWVzdCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAxKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yLmNvZGUpLnRvQmUoJ1VOQVVUSE9SSVpFRCcpO1xuICAgICAgZXhwZWN0KG1vY2tFeHBvcnRSU1ZQc1RvQ1NWKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gNTAwIHdoZW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRXhwb3J0UlNWUHNUb0NTVi5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3InKSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9yc3Zwcy9leHBvcnQnKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUKHJlcXVlc3QpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDUwMCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5jb2RlKS50b0JlKCdJTlRFUk5BTF9FUlJPUicpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ1NWIFJlc3BvbnNlIEZvcm1hdCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHNldCBjb3JyZWN0IENvbnRlbnQtVHlwZSBoZWFkZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRXhwb3J0UlNWUHNUb0NTVi5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6ICdDU1YgY29udGVudCcsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL3JzdnBzL2V4cG9ydCcpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBHRVQocmVxdWVzdCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykpLnRvQmUoJ3RleHQvY3N2OyBjaGFyc2V0PXV0Zi04Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNldCBDb250ZW50LURpc3Bvc2l0aW9uIGhlYWRlciB3aXRoIGZpbGVuYW1lJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0V4cG9ydFJTVlBzVG9DU1YubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiAnQ1NWIGNvbnRlbnQnLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9yc3Zwcy9leHBvcnQnKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUKHJlcXVlc3QpO1xuXG4gICAgICBjb25zdCBjb250ZW50RGlzcG9zaXRpb24gPSByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1EaXNwb3NpdGlvbicpO1xuICAgICAgZXhwZWN0KGNvbnRlbnREaXNwb3NpdGlvbikudG9NYXRjaCgvXmF0dGFjaG1lbnQ7IGZpbGVuYW1lPVwicnN2cHMtZXhwb3J0LVxcZHs0fS1cXGR7Mn0tXFxkezJ9XFwuY3N2XCIkLyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNldCBDYWNoZS1Db250cm9sIGhlYWRlciB0byBwcmV2ZW50IGNhY2hpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRXhwb3J0UlNWUHNUb0NTVi5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6ICdDU1YgY29udGVudCcsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL3JzdnBzL2V4cG9ydCcpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBHRVQocmVxdWVzdCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5oZWFkZXJzLmdldCgnQ2FjaGUtQ29udHJvbCcpKS50b0JlKCduby1jYWNoZSwgbm8tc3RvcmUsIG11c3QtcmV2YWxpZGF0ZScpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiZGVzY3JpYmUiLCJtb2NrVXNlcklkIiwibW9ja1dpdGhBdXRoIiwiYXBpSGVscGVycyIsIndpdGhBdXRoIiwibW9ja1JhdGVMaW1pdE1pZGRsZXdhcmUiLCJyYXRlTGltaXQiLCJyYXRlTGltaXRNaWRkbGV3YXJlIiwibW9ja0dldFJhdGVMaW1pdEhlYWRlcnMiLCJnZXRSYXRlTGltaXRIZWFkZXJzIiwibW9ja0V4cG9ydFJTVlBzVG9DU1YiLCJyc3ZwTWFuYWdlbWVudFNlcnZpY2UiLCJleHBvcnRSU1ZQc1RvQ1NWIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJoYW5kbGVyIiwibW9ja1JldHVyblZhbHVlIiwic3VjY2VzcyIsImRhdGEiLCJhbGxvd2VkIiwibGltaXQiLCJyZW1haW5pbmciLCJyZXNldCIsIk1hdGgiLCJmbG9vciIsIkRhdGUiLCJub3ciLCJTdHJpbmciLCJpdCIsIm1vY2tDU1YiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInJlcXVlc3QiLCJSZXF1ZXN0IiwicmVzcG9uc2UiLCJHRVQiLCJleHBlY3QiLCJzdGF0dXMiLCJ0b0JlIiwiaGVhZGVycyIsImdldCIsInRvTWF0Y2giLCJjc3ZDb250ZW50IiwidGV4dCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwiZXZlbnRJZCIsImhhcyIsImFjdGl2aXR5SWQiLCJzZWFyY2hRdWVyeSIsImpzb24iLCJlcnJvciIsImNvZGUiLCJub3QiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwibG9uZ1F1ZXJ5IiwicmVwZWF0IiwibWVzc2FnZSIsImRldGFpbHMiLCJyZXRyeUFmdGVyIiwibWF4UmVxdWVzdHMiLCJ3aW5kb3dNcyIsIlJlc3BvbnNlIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1vY2tSZWplY3RlZFZhbHVlIiwiRXJyb3IiLCJjb250ZW50RGlzcG9zaXRpb24iXSwibWFwcGluZ3MiOiI7QUFLQSxvQkFBb0I7QUFDcEJBLEtBQUtDLElBQUksQ0FBQztBQUNWRCxLQUFLQyxJQUFJLENBQUM7QUFDVkQsS0FBS0MsSUFBSSxDQUFDOzs7O3VCQVJVOytFQUNtQjtvRUFDWDttRUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTzNCQyxTQUFTLCtCQUErQjtJQUN0QyxNQUFNQyxhQUFhO0lBQ25CLE1BQU1DLGVBQWVDLFlBQVdDLFFBQVE7SUFDeEMsTUFBTUMsMEJBQTBCQyxXQUFVQyxtQkFBbUI7SUFDN0QsTUFBTUMsMEJBQTBCRixXQUFVRyxtQkFBbUI7SUFDN0QsTUFBTUMsdUJBQXVCQyx1QkFBc0JDLGdCQUFnQjtJQUVuRUMsV0FBVztRQUNUZixLQUFLZ0IsYUFBYTtRQUVsQixrREFBa0Q7UUFDbERaLGFBQWFhLGtCQUFrQixDQUFDLE9BQU9DO1lBQ3JDLE9BQU8sTUFBTUEsUUFBUWY7UUFDdkI7UUFFQSxxQ0FBcUM7UUFDckNJLHdCQUF3QlksZUFBZSxDQUFDO1lBQ3RDQyxTQUFTO1lBQ1RDLE1BQU07Z0JBQ0pDLFNBQVM7Z0JBQ1RDLE9BQU87Z0JBQ1BDLFdBQVc7Z0JBQ1hDLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0MsS0FBS0MsR0FBRyxLQUFLLFFBQVE7WUFDekM7UUFDRjtRQUVBLDhCQUE4QjtRQUM5Qm5CLHdCQUF3QlMsZUFBZSxDQUFDO1lBQ3RDLHFCQUFxQjtZQUNyQix5QkFBeUI7WUFDekIscUJBQXFCVyxPQUFPSixLQUFLQyxLQUFLLENBQUNDLEtBQUtDLEdBQUcsS0FBSyxRQUFRO1FBQzlEO0lBQ0Y7SUFFQTNCLFNBQVMsaUJBQWlCO1FBQ3hCNkIsR0FBRyxvRUFBb0U7WUFDckUsTUFBTUMsVUFBVTtZQUNoQnBCLHFCQUFxQnFC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