c97941f13fc809e24e0a5b4651b4d045
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
// Set environment variables FIRST
process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://test.supabase.co';
process.env.SUPABASE_SERVICE_ROLE_KEY = 'test-service-role-key';
// Mock sanitization utilities
_globals.jest.mock('@/utils/sanitization', ()=>({
        sanitizeInput: _globals.jest.fn((input)=>input.trim())
    }));
// Mock types and error codes
_globals.jest.mock('@/types', ()=>({
        ERROR_CODES: {
            VALIDATION_ERROR: 'VALIDATION_ERROR',
            DATABASE_ERROR: 'DATABASE_ERROR',
            UNKNOWN_ERROR: 'UNKNOWN_ERROR',
            NOT_FOUND: 'NOT_FOUND',
            DUPLICATE_ENTRY: 'DUPLICATE_ENTRY',
            CAPACITY_EXCEEDED: 'CAPACITY_EXCEEDED'
        }
    }));
// Mock Supabase with shared client instance (Pattern A)
_globals.jest.mock('@supabase/supabase-js', ()=>{
    const mockFrom = _globals.jest.fn();
    const mockSupabaseClient = {
        from: mockFrom
    };
    return {
        createClient: _globals.jest.fn(()=>mockSupabaseClient),
        __mockFrom: mockFrom
    };
});
// Import service using require() AFTER mocking (Pattern A requirement)
const rsvpServiceModule = require('./rsvpService');
const rsvpService = rsvpServiceModule;
// Get the mocked from function
const { __mockFrom: mockFrom } = require('@supabase/supabase-js');
(0, _globals.describe)('rsvpService', ()=>{
    (0, _globals.beforeEach)(()=>{
        _globals.jest.clearAllMocks();
        // Set up environment variables
        process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://test.supabase.co';
        process.env.SUPABASE_SERVICE_ROLE_KEY = 'test-service-role-key';
    });
    (0, _globals.describe)('create', ()=>{
        const validData = {
            guest_id: '123e4567-e89b-12d3-a456-426614174000',
            event_id: '123e4567-e89b-12d3-a456-426614174001',
            status: 'attending',
            guest_count: 2,
            dietary_notes: 'Vegetarian',
            special_requirements: 'Wheelchair accessible',
            notes: 'Looking forward to it!'
        };
        (0, _globals.it)('should return success with RSVP data when valid input provided', async ()=>{
            const mockRSVP = {
                id: 'rsvp-1',
                guest_id: validData.guest_id,
                event_id: validData.event_id,
                activity_id: null,
                status: 'attending',
                guest_count: 2,
                dietary_notes: 'Vegetarian',
                special_requirements: 'Wheelchair accessible',
                notes: 'Looking forward to it!',
                responded_at: '2024-01-01T12:00:00Z',
                created_at: '2024-01-01T00:00:00Z',
                updated_at: '2024-01-01T00:00:00Z'
            };
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: mockRSVP,
                error: null
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockInsert = _globals.jest.fn().mockReturnValue({
                select: mockSelect
            });
            mockFrom.mockReturnValue({
                insert: mockInsert
            });
            const result = await rsvpService.create(validData);
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.id).toBe('rsvp-1');
                (0, _globals.expect)(result.data.guest_id).toBe(validData.guest_id);
                (0, _globals.expect)(result.data.status).toBe('attending');
                (0, _globals.expect)(result.data.guest_count).toBe(2);
            }
        });
        (0, _globals.it)('should return VALIDATION_ERROR when guest_id is missing', async ()=>{
            const invalidData = {
                ...validData,
                guest_id: ''
            };
            const result = await rsvpService.create(invalidData);
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        (0, _globals.it)('should return VALIDATION_ERROR when both event_id and activity_id are provided', async ()=>{
            const invalidData = {
                ...validData,
                activity_id: '123e4567-e89b-12d3-a456-426614174002'
            };
            const result = await rsvpService.create(invalidData);
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        (0, _globals.it)('should return VALIDATION_ERROR when neither event_id nor activity_id are provided', async ()=>{
            const invalidData = {
                ...validData
            };
            delete invalidData.event_id;
            const result = await rsvpService.create(invalidData);
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('VALIDATION_ERROR');
            }
        });
        (0, _globals.it)('should return DUPLICATE_ENTRY when RSVP already exists', async ()=>{
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: null,
                error: {
                    code: '23505',
                    message: 'Unique constraint violation'
                }
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockInsert = _globals.jest.fn().mockReturnValue({
                select: mockSelect
            });
            mockFrom.mockReturnValue({
                insert: mockInsert
            });
            const result = await rsvpService.create(validData);
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('DUPLICATE_ENTRY');
            }
        });
        (0, _globals.it)('should return DATABASE_ERROR when insert fails', async ()=>{
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: null,
                error: {
                    message: 'Connection failed'
                }
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockInsert = _globals.jest.fn().mockReturnValue({
                select: mockSelect
            });
            mockFrom.mockReturnValue({
                insert: mockInsert
            });
            const result = await rsvpService.create(validData);
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('DATABASE_ERROR');
            }
        });
        (0, _globals.it)('should sanitize input to prevent XSS attacks', async ()=>{
            const maliciousData = {
                ...validData,
                dietary_notes: '<script>alert("xss")</script>Vegetarian',
                special_requirements: '<img src=x onerror=alert(1)>Wheelchair',
                notes: '<svg onload=alert(1)>Notes'
            };
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: {
                    id: 'rsvp-1',
                    dietary_notes: 'Vegetarian',
                    special_requirements: 'Wheelchair',
                    notes: 'Notes'
                },
                error: null
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockInsert = _globals.jest.fn().mockReturnValue({
                select: mockSelect
            });
            mockFrom.mockReturnValue({
                insert: mockInsert
            });
            const result = await rsvpService.create(maliciousData);
            (0, _globals.expect)(result.success).toBe(true);
            // Verify sanitization was called
            const { sanitizeInput } = require('@/utils/sanitization');
            (0, _globals.expect)(sanitizeInput).toHaveBeenCalledWith(maliciousData.dietary_notes);
            (0, _globals.expect)(sanitizeInput).toHaveBeenCalledWith(maliciousData.special_requirements);
            (0, _globals.expect)(sanitizeInput).toHaveBeenCalledWith(maliciousData.notes);
        });
        (0, _globals.it)('should set responded_at when status is not pending', async ()=>{
            const attendingData = {
                ...validData,
                status: 'attending'
            };
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: {
                    id: 'rsvp-1',
                    status: 'attending',
                    responded_at: '2024-01-01T12:00:00Z'
                },
                error: null
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockInsert = _globals.jest.fn().mockReturnValue({
                select: mockSelect
            });
            mockFrom.mockReturnValue({
                insert: mockInsert
            });
            const result = await rsvpService.create(attendingData);
            (0, _globals.expect)(result.success).toBe(true);
            (0, _globals.expect)(mockInsert).toHaveBeenCalledWith(_globals.expect.objectContaining({
                status: 'attending',
                responded_at: _globals.expect.any(String)
            }));
        });
        (0, _globals.it)('should not set responded_at when status is pending', async ()=>{
            const pendingData = {
                ...validData,
                status: 'pending'
            };
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: {
                    id: 'rsvp-1',
                    status: 'pending',
                    responded_at: null
                },
                error: null
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockInsert = _globals.jest.fn().mockReturnValue({
                select: mockSelect
            });
            mockFrom.mockReturnValue({
                insert: mockInsert
            });
            const result = await rsvpService.create(pendingData);
            (0, _globals.expect)(result.success).toBe(true);
            (0, _globals.expect)(mockInsert).toHaveBeenCalledWith(_globals.expect.objectContaining({
                status: 'pending',
                responded_at: undefined
            }));
        });
    });
    (0, _globals.describe)('get', ()=>{
        (0, _globals.it)('should return success with RSVP data when RSVP exists', async ()=>{
            const mockRSVP = {
                id: 'rsvp-1',
                guest_id: '123e4567-e89b-12d3-a456-426614174000',
                event_id: '123e4567-e89b-12d3-a456-426614174001',
                activity_id: null,
                status: 'attending',
                guest_count: 1,
                dietary_notes: null,
                special_requirements: null,
                notes: null,
                responded_at: '2024-01-01T12:00:00Z',
                created_at: '2024-01-01T00:00:00Z',
                updated_at: '2024-01-01T00:00:00Z'
            };
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: mockRSVP,
                error: null
            });
            const mockEq = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await rsvpService.get('rsvp-1');
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.id).toBe('rsvp-1');
                (0, _globals.expect)(result.data.status).toBe('attending');
            }
        });
        (0, _globals.it)('should return NOT_FOUND when RSVP does not exist', async ()=>{
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: null,
                error: {
                    code: 'PGRST116'
                }
            });
            const mockEq = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await rsvpService.get('nonexistent-id');
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('NOT_FOUND');
            }
        });
        (0, _globals.it)('should return DATABASE_ERROR when database query fails', async ()=>{
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: null,
                error: {
                    message: 'Connection failed'
                }
            });
            const mockEq = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await rsvpService.get('rsvp-1');
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('DATABASE_ERROR');
            }
        });
    });
    (0, _globals.describe)('update', ()=>{
        const updateData = {
            status: 'declined',
            dietary_notes: 'No dietary restrictions',
            notes: 'Cannot attend due to conflict'
        };
        (0, _globals.it)('should return success with updated RSVP data when valid input provided', async ()=>{
            const mockUpdatedRSVP = {
                id: 'rsvp-1',
                guest_id: '123e4567-e89b-12d3-a456-426614174000',
                event_id: '123e4567-e89b-12d3-a456-426614174001',
                activity_id: null,
                status: 'declined',
                guest_count: 1,
                dietary_notes: 'No dietary restrictions',
                special_requirements: null,
                notes: 'Cannot attend due to conflict',
                responded_at: '2024-01-02T12:00:00Z',
                created_at: '2024-01-01T00:00:00Z',
                updated_at: '2024-01-02T00:00:00Z'
            };
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: mockUpdatedRSVP,
                error: null
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockEq = _globals.jest.fn().mockReturnValue({
                select: mockSelect
            });
            const mockUpdate = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                update: mockUpdate
            });
            const result = await rsvpService.update('rsvp-1', updateData);
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.status).toBe('declined');
                (0, _globals.expect)(result.data.dietary_notes).toBe('No dietary restrictions');
                (0, _globals.expect)(result.data.notes).toBe('Cannot attend due to conflict');
            }
        });
        (0, _globals.it)('should set responded_at when status changes from pending', async ()=>{
            const statusUpdate = {
                status: 'attending'
            };
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: {
                    id: 'rsvp-1',
                    status: 'attending',
                    responded_at: '2024-01-02T12:00:00Z'
                },
                error: null
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockEq = _globals.jest.fn().mockReturnValue({
                select: mockSelect
            });
            const mockUpdate = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                update: mockUpdate
            });
            const result = await rsvpService.update('rsvp-1', statusUpdate);
            (0, _globals.expect)(result.success).toBe(true);
            (0, _globals.expect)(mockUpdate).toHaveBeenCalledWith(_globals.expect.objectContaining({
                status: 'attending',
                responded_at: _globals.expect.any(String)
            }));
        });
        (0, _globals.it)('should return NOT_FOUND when RSVP to update does not exist', async ()=>{
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: null,
                error: {
                    code: 'PGRST116'
                }
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockEq = _globals.jest.fn().mockReturnValue({
                select: mockSelect
            });
            const mockUpdate = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                update: mockUpdate
            });
            const result = await rsvpService.update('nonexistent-id', updateData);
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('NOT_FOUND');
            }
        });
        (0, _globals.it)('should return DATABASE_ERROR when update fails', async ()=>{
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: null,
                error: {
                    message: 'Update failed'
                }
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockEq = _globals.jest.fn().mockReturnValue({
                select: mockSelect
            });
            const mockUpdate = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                update: mockUpdate
            });
            const result = await rsvpService.update('rsvp-1', updateData);
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('DATABASE_ERROR');
            }
        });
    });
    (0, _globals.describe)('deleteRSVP', ()=>{
        (0, _globals.it)('should return success when RSVP is deleted successfully', async ()=>{
            const mockEq = _globals.jest.fn().mockResolvedValue({
                error: null
            });
            const mockDelete = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                delete: mockDelete
            });
            const result = await rsvpService.deleteRSVP('rsvp-1');
            (0, _globals.expect)(result.success).toBe(true);
        });
        (0, _globals.it)('should return DATABASE_ERROR when delete fails', async ()=>{
            const mockEq = _globals.jest.fn().mockResolvedValue({
                error: {
                    message: 'Delete failed'
                }
            });
            const mockDelete = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                delete: mockDelete
            });
            const result = await rsvpService.deleteRSVP('rsvp-1');
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('DATABASE_ERROR');
            }
        });
    });
    (0, _globals.describe)('list', ()=>{
        (0, _globals.it)('should return success with paginated RSVPs when valid filters provided', async ()=>{
            const mockRSVPs = [
                {
                    id: 'rsvp-1',
                    guest_id: '123e4567-e89b-12d3-a456-426614174000',
                    event_id: '123e4567-e89b-12d3-a456-426614174001',
                    activity_id: null,
                    status: 'attending',
                    guest_count: 1,
                    dietary_notes: null,
                    special_requirements: null,
                    notes: null,
                    responded_at: '2024-01-01T12:00:00Z',
                    created_at: '2024-01-01T00:00:00Z',
                    updated_at: '2024-01-01T00:00:00Z'
                },
                {
                    id: 'rsvp-2',
                    guest_id: '123e4567-e89b-12d3-a456-426614174002',
                    event_id: '123e4567-e89b-12d3-a456-426614174001',
                    activity_id: null,
                    status: 'declined',
                    guest_count: 1,
                    dietary_notes: null,
                    special_requirements: null,
                    notes: 'Cannot attend',
                    responded_at: '2024-01-02T12:00:00Z',
                    created_at: '2024-01-02T00:00:00Z',
                    updated_at: '2024-01-02T00:00:00Z'
                }
            ];
            const mockOrder = _globals.jest.fn().mockResolvedValue({
                data: mockRSVPs,
                error: null,
                count: 2
            });
            const mockRange = _globals.jest.fn().mockReturnValue({
                order: mockOrder
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                range: mockRange
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const filters = {
                page: 1,
                page_size: 10
            };
            const result = await rsvpService.list(filters);
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.rsvps).toHaveLength(2);
                (0, _globals.expect)(result.data.total).toBe(2);
            }
        });
        (0, _globals.it)('should filter by guest_id when provided', async ()=>{
            const filters = {
                guest_id: '123e4567-e89b-12d3-a456-426614174000',
                page: 1,
                page_size: 10
            };
            const mockOrder = _globals.jest.fn().mockResolvedValue({
                data: [],
                error: null,
                count: 0
            });
            const mockRange = _globals.jest.fn().mockReturnValue({
                order: mockOrder
            });
            const mockEq = _globals.jest.fn().mockReturnValue({
                range: mockRange
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await rsvpService.list(filters);
            (0, _globals.expect)(mockEq).toHaveBeenCalledWith('guest_id', '123e4567-e89b-12d3-a456-426614174000');
            (0, _globals.expect)(result.success).toBe(true);
        });
        (0, _globals.it)('should filter by status when provided', async ()=>{
            const filters = {
                status: 'attending',
                page: 1,
                page_size: 10
            };
            const mockOrder = _globals.jest.fn().mockResolvedValue({
                data: [],
                error: null,
                count: 0
            });
            const mockRange = _globals.jest.fn().mockReturnValue({
                order: mockOrder
            });
            const mockEq = _globals.jest.fn().mockReturnValue({
                range: mockRange
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await rsvpService.list(filters);
            (0, _globals.expect)(mockEq).toHaveBeenCalledWith('status', 'attending');
            (0, _globals.expect)(result.success).toBe(true);
        });
        (0, _globals.it)('should return DATABASE_ERROR when query fails', async ()=>{
            const mockOrder = _globals.jest.fn().mockResolvedValue({
                data: null,
                error: {
                    message: 'Connection failed'
                }
            });
            const mockRange = _globals.jest.fn().mockReturnValue({
                order: mockOrder
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                range: mockRange
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await rsvpService.list();
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('DATABASE_ERROR');
            }
        });
    });
    (0, _globals.describe)('calculateActivityCapacity', ()=>{
        (0, _globals.it)('should return success with capacity information when activity exists', async ()=>{
            const mockActivity = {
                capacity: 50,
                name: 'Beach Volleyball'
            };
            const mockRSVPs = [
                {
                    guest_count: 2
                },
                {
                    guest_count: 3
                },
                {
                    guest_count: 1
                }
            ];
            // Mock activity query (first call)
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: mockActivity,
                error: null
            });
            const mockEq1 = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockSelect1 = _globals.jest.fn().mockReturnValue({
                eq: mockEq1
            });
            // Mock RSVPs query (second call)
            const mockEq3 = _globals.jest.fn().mockResolvedValue({
                data: mockRSVPs,
                error: null
            });
            const mockEq2 = _globals.jest.fn().mockReturnValue({
                eq: mockEq3
            });
            const mockSelect2 = _globals.jest.fn().mockReturnValue({
                eq: mockEq2
            });
            let callCount = 0;
            mockFrom.mockImplementation((table)=>{
                if (table === 'activities') {
                    return {
                        select: mockSelect1
                    };
                } else if (table === 'rsvps') {
                    return {
                        select: mockSelect2
                    };
                }
                return {};
            });
            const result = await rsvpService.calculateActivityCapacity('activity-1');
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.capacity).toBe(50);
                (0, _globals.expect)(result.data.attending_count).toBe(6); // 2 + 3 + 1
                (0, _globals.expect)(result.data.available).toBe(44); // 50 - 6
            }
        });
        (0, _globals.it)('should handle activities with no capacity limit', async ()=>{
            const mockActivity = {
                capacity: null,
                name: 'Open Activity'
            };
            const mockRSVPs = [
                {
                    guest_count: 5
                },
                {
                    guest_count: 3
                }
            ];
            // Mock activity query
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: mockActivity,
                error: null
            });
            const mockEq1 = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockSelect1 = _globals.jest.fn().mockReturnValue({
                eq: mockEq1
            });
            // Mock RSVPs query
            const mockEq3 = _globals.jest.fn().mockResolvedValue({
                data: mockRSVPs,
                error: null
            });
            const mockEq2 = _globals.jest.fn().mockReturnValue({
                eq: mockEq3
            });
            const mockSelect2 = _globals.jest.fn().mockReturnValue({
                eq: mockEq2
            });
            mockFrom.mockImplementation((table)=>{
                if (table === 'activities') {
                    return {
                        select: mockSelect1
                    };
                } else if (table === 'rsvps') {
                    return {
                        select: mockSelect2
                    };
                }
                return {};
            });
            const result = await rsvpService.calculateActivityCapacity('activity-1');
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.capacity).toBeNull();
                (0, _globals.expect)(result.data.attending_count).toBe(8); // 5 + 3
                (0, _globals.expect)(result.data.available).toBeNull();
            }
        });
        (0, _globals.it)('should return DATABASE_ERROR when activity query fails', async ()=>{
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: null,
                error: {
                    message: 'Activity not found'
                }
            });
            const mockEq = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockSelect = _globals.jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await rsvpService.calculateActivityCapacity('nonexistent-activity');
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('DATABASE_ERROR');
            }
        });
    });
    (0, _globals.describe)('generateCapacityAlerts', ()=>{
        (0, _globals.it)('should return success with alerts for activities approaching capacity', async ()=>{
            const mockActivities = [
                {
                    id: 'activity-1',
                    name: 'Beach Volleyball',
                    capacity: 10
                },
                {
                    id: 'activity-2',
                    name: 'Snorkeling',
                    capacity: 20
                }
            ];
            // Mock activities query (first call)
            // Query: await supabase.from('activities').select('id, name, capacity').not('capacity', 'is', null).eq('status', 'published')
            // The final .eq() must return a Promise that resolves to { data, error }
            const mockEq2 = _globals.jest.fn().mockResolvedValue({
                data: mockActivities,
                error: null
            });
            const mockEq1 = _globals.jest.fn().mockImplementation(()=>mockEq2()); // Call mockEq2 to get the promise
            const mockNot = _globals.jest.fn().mockReturnValue({
                eq: mockEq1
            });
            const mockSelect1 = _globals.jest.fn().mockReturnValue({
                not: mockNot
            });
            // For calculateActivityCapacity calls, we need to mock multiple sequences
            // Activity 1: 9/10 (90% - warning)
            const mockSingle1 = _globals.jest.fn().mockResolvedValue({
                data: {
                    capacity: 10,
                    name: 'Beach Volleyball'
                },
                error: null
            });
            const mockEqA1 = _globals.jest.fn().mockReturnValue({
                single: mockSingle1
            });
            const mockSelectA1 = _globals.jest.fn().mockReturnValue({
                eq: mockEqA1
            });
            const mockEqR1b = _globals.jest.fn().mockResolvedValue({
                data: [
                    {
                        guest_count: 4
                    },
                    {
                        guest_count: 3
                    },
                    {
                        guest_count: 2
                    }
                ],
                error: null
            });
            const mockEqR1a = _globals.jest.fn().mockReturnValue({
                eq: mockEqR1b
            });
            const mockSelectR1 = _globals.jest.fn().mockReturnValue({
                eq: mockEqR1a
            });
            // Activity 2: 20/20 (100% - full)
            const mockSingle2 = _globals.jest.fn().mockResolvedValue({
                data: {
                    capacity: 20,
                    name: 'Snorkeling'
                },
                error: null
            });
            const mockEqA2 = _globals.jest.fn().mockReturnValue({
                single: mockSingle2
            });
            const mockSelectA2 = _globals.jest.fn().mockReturnValue({
                eq: mockEqA2
            });
            const mockEqR2b = _globals.jest.fn().mockResolvedValue({
                data: Array(20).fill({
                    guest_count: 1
                }),
                error: null
            });
            const mockEqR2a = _globals.jest.fn().mockReturnValue({
                eq: mockEqR2b
            });
            const mockSelectR2 = _globals.jest.fn().mockReturnValue({
                eq: mockEqR2a
            });
            let callCount = 0;
            mockFrom.mockImplementation((table)=>{
                callCount++;
                if (table === 'activities' && callCount === 1) {
                    return {
                        select: mockSelect1
                    };
                } else if (table === 'activities' && callCount === 2) {
                    return {
                        select: mockSelectA1
                    };
                } else if (table === 'rsvps' && callCount === 3) {
                    return {
                        select: mockSelectR1
                    };
                } else if (table === 'activities' && callCount === 4) {
                    return {
                        select: mockSelectA2
                    };
                } else if (table === 'rsvps' && callCount === 5) {
                    return {
                        select: mockSelectR2
                    };
                }
                return {};
            });
            const result = await rsvpService.generateCapacityAlerts(0.9);
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data).toHaveLength(2);
                const warningAlert = result.data.find((alert)=>alert.alert_level === 'warning');
                (0, _globals.expect)(warningAlert).toBeDefined();
                (0, _globals.expect)(warningAlert?.activity_name).toBe('Beach Volleyball');
                (0, _globals.expect)(warningAlert?.utilization_percentage).toBe(90);
                const fullAlert = result.data.find((alert)=>alert.alert_level === 'full');
                (0, _globals.expect)(fullAlert).toBeDefined();
                (0, _globals.expect)(fullAlert?.activity_name).toBe('Snorkeling');
                (0, _globals.expect)(fullAlert?.utilization_percentage).toBe(100);
            }
        });
        (0, _globals.it)('should return empty array when no activities exceed threshold', async ()=>{
            const mockActivities = [
                {
                    id: 'activity-1',
                    name: 'Beach Volleyball',
                    capacity: 10
                }
            ];
            // Mock activities query
            const mockEq2 = _globals.jest.fn().mockResolvedValue({
                data: mockActivities,
                error: null
            });
            const mockEq1 = _globals.jest.fn().mockImplementation(()=>mockEq2()); // Call mockEq2 to get the promise
            const mockNot = _globals.jest.fn().mockReturnValue({
                eq: mockEq1
            });
            const mockSelect1 = _globals.jest.fn().mockReturnValue({
                not: mockNot
            });
            // Mock capacity calculation - only 5/10 (50%)
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: {
                    capacity: 10,
                    name: 'Beach Volleyball'
                },
                error: null
            });
            const mockEqA = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockSelectA = _globals.jest.fn().mockReturnValue({
                eq: mockEqA
            });
            const mockEqRb = _globals.jest.fn().mockResolvedValue({
                data: [
                    {
                        guest_count: 5
                    }
                ],
                error: null
            });
            const mockEqRa = _globals.jest.fn().mockReturnValue({
                eq: mockEqRb
            });
            const mockSelectR = _globals.jest.fn().mockReturnValue({
                eq: mockEqRa
            });
            let callCount = 0;
            mockFrom.mockImplementation((table)=>{
                callCount++;
                if (table === 'activities' && callCount === 1) {
                    return {
                        select: mockSelect1
                    };
                } else if (table === 'activities' && callCount === 2) {
                    return {
                        select: mockSelectA
                    };
                } else if (table === 'rsvps' && callCount === 3) {
                    return {
                        select: mockSelectR
                    };
                }
                return {};
            });
            const result = await rsvpService.generateCapacityAlerts(0.9);
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data).toHaveLength(0);
            }
        });
    });
    (0, _globals.describe)('checkCapacityAvailable', ()=>{
        (0, _globals.it)('should return available true when capacity is sufficient', async ()=>{
            const mockActivity = {
                capacity: 10,
                name: 'Activity'
            };
            const mockRSVPs = [
                {
                    guest_count: 5
                }
            ]; // 5 attending, 5 available
            // Mock activity query
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: mockActivity,
                error: null
            });
            const mockEqA = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockSelectA = _globals.jest.fn().mockReturnValue({
                eq: mockEqA
            });
            // Mock RSVPs query
            const mockEqRb = _globals.jest.fn().mockResolvedValue({
                data: mockRSVPs,
                error: null
            });
            const mockEqRa = _globals.jest.fn().mockReturnValue({
                eq: mockEqRb
            });
            const mockSelectR = _globals.jest.fn().mockReturnValue({
                eq: mockEqRa
            });
            mockFrom.mockImplementation((table)=>{
                if (table === 'activities') {
                    return {
                        select: mockSelectA
                    };
                } else if (table === 'rsvps') {
                    return {
                        select: mockSelectR
                    };
                }
                return {};
            });
            const result = await rsvpService.checkCapacityAvailable('activity-1', 3);
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.available).toBe(true);
                (0, _globals.expect)(result.data.message).toContain('5 spots remaining');
            }
        });
        (0, _globals.it)('should return available false when capacity would be exceeded', async ()=>{
            const mockActivity = {
                capacity: 10,
                name: 'Activity'
            };
            const mockRSVPs = [
                {
                    guest_count: 8
                }
            ]; // 8 attending, 2 available
            // Mock activity query
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: mockActivity,
                error: null
            });
            const mockEqA = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockSelectA = _globals.jest.fn().mockReturnValue({
                eq: mockEqA
            });
            // Mock RSVPs query
            const mockEqRb = _globals.jest.fn().mockResolvedValue({
                data: mockRSVPs,
                error: null
            });
            const mockEqRa = _globals.jest.fn().mockReturnValue({
                eq: mockEqRb
            });
            const mockSelectR = _globals.jest.fn().mockReturnValue({
                eq: mockEqRa
            });
            mockFrom.mockImplementation((table)=>{
                if (table === 'activities') {
                    return {
                        select: mockSelectA
                    };
                } else if (table === 'rsvps') {
                    return {
                        select: mockSelectR
                    };
                }
                return {};
            });
            const result = await rsvpService.checkCapacityAvailable('activity-1', 5);
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.available).toBe(false);
                (0, _globals.expect)(result.data.message).toContain('cannot add 5 more guest(s)');
            }
        });
        (0, _globals.it)('should return available true when no capacity limit is set', async ()=>{
            const mockActivity = {
                capacity: null,
                name: 'Open Activity'
            };
            const mockRSVPs = [
                {
                    guest_count: 100
                }
            ];
            // Mock activity query
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: mockActivity,
                error: null
            });
            const mockEqA = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockSelectA = _globals.jest.fn().mockReturnValue({
                eq: mockEqA
            });
            // Mock RSVPs query
            const mockEqRb = _globals.jest.fn().mockResolvedValue({
                data: mockRSVPs,
                error: null
            });
            const mockEqRa = _globals.jest.fn().mockReturnValue({
                eq: mockEqRb
            });
            const mockSelectR = _globals.jest.fn().mockReturnValue({
                eq: mockEqRa
            });
            mockFrom.mockImplementation((table)=>{
                if (table === 'activities') {
                    return {
                        select: mockSelectA
                    };
                } else if (table === 'rsvps') {
                    return {
                        select: mockSelectR
                    };
                }
                return {};
            });
            const result = await rsvpService.checkCapacityAvailable('activity-1', 50);
            (0, _globals.expect)(result.success).toBe(true);
            if (result.success) {
                (0, _globals.expect)(result.data.available).toBe(true);
                (0, _globals.expect)(result.data.message).toContain('No capacity limit');
            }
        });
    });
    (0, _globals.describe)('enforceCapacityLimit', ()=>{
        (0, _globals.it)('should return success when capacity limit is not exceeded', async ()=>{
            const mockActivity = {
                capacity: 10,
                name: 'Activity'
            };
            const mockRSVPs = [
                {
                    guest_count: 5
                }
            ]; // 5 attending
            // Mock activity query
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: mockActivity,
                error: null
            });
            const mockEqA = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockSelectA = _globals.jest.fn().mockReturnValue({
                eq: mockEqA
            });
            // Mock RSVPs query
            const mockEqRb = _globals.jest.fn().mockResolvedValue({
                data: mockRSVPs,
                error: null
            });
            const mockEqRa = _globals.jest.fn().mockReturnValue({
                eq: mockEqRb
            });
            const mockSelectR = _globals.jest.fn().mockReturnValue({
                eq: mockEqRa
            });
            mockFrom.mockImplementation((table)=>{
                if (table === 'activities') {
                    return {
                        select: mockSelectA
                    };
                } else if (table === 'rsvps') {
                    return {
                        select: mockSelectR
                    };
                }
                return {};
            });
            const result = await rsvpService.enforceCapacityLimit('activity-1', 3);
            (0, _globals.expect)(result.success).toBe(true);
        });
        (0, _globals.it)('should return CAPACITY_EXCEEDED when limit would be exceeded', async ()=>{
            const mockActivity = {
                capacity: 10,
                name: 'Activity'
            };
            const mockRSVPs = [
                {
                    guest_count: 8
                }
            ]; // 8 attending
            // Mock activity query
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: mockActivity,
                error: null
            });
            const mockEqA = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockSelectA = _globals.jest.fn().mockReturnValue({
                eq: mockEqA
            });
            // Mock RSVPs query
            const mockEqRb = _globals.jest.fn().mockResolvedValue({
                data: mockRSVPs,
                error: null
            });
            const mockEqRa = _globals.jest.fn().mockReturnValue({
                eq: mockEqRb
            });
            const mockSelectR = _globals.jest.fn().mockReturnValue({
                eq: mockEqRa
            });
            mockFrom.mockImplementation((table)=>{
                if (table === 'activities') {
                    return {
                        select: mockSelectA
                    };
                } else if (table === 'rsvps') {
                    return {
                        select: mockSelectR
                    };
                }
                return {};
            });
            const result = await rsvpService.enforceCapacityLimit('activity-1', 5);
            (0, _globals.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, _globals.expect)(result.error.code).toBe('CAPACITY_EXCEEDED');
                (0, _globals.expect)(result.error.message).toContain('13/10');
            }
        });
        (0, _globals.it)('should account for existing RSVP when updating', async ()=>{
            const mockActivity = {
                capacity: 10,
                name: 'Activity'
            };
            const mockRSVPs = [
                {
                    guest_count: 8
                }
            ]; // 8 attending
            const mockExistingRSVP = {
                guest_count: 3,
                status: 'attending'
            };
            // Mock activity query (first call)
            const mockSingle1 = _globals.jest.fn().mockResolvedValue({
                data: mockActivity,
                error: null
            });
            const mockEqA = _globals.jest.fn().mockReturnValue({
                single: mockSingle1
            });
            const mockSelectA = _globals.jest.fn().mockReturnValue({
                eq: mockEqA
            });
            // Mock RSVPs query (second call)
            const mockEqRb = _globals.jest.fn().mockResolvedValue({
                data: mockRSVPs,
                error: null
            });
            const mockEqRa = _globals.jest.fn().mockReturnValue({
                eq: mockEqRb
            });
            const mockSelectR = _globals.jest.fn().mockReturnValue({
                eq: mockEqRa
            });
            // Mock existing RSVP query (third call)
            const mockSingle2 = _globals.jest.fn().mockResolvedValue({
                data: mockExistingRSVP,
                error: null
            });
            const mockEqE = _globals.jest.fn().mockReturnValue({
                single: mockSingle2
            });
            const mockSelectE = _globals.jest.fn().mockReturnValue({
                eq: mockEqE
            });
            let callCount = 0;
            mockFrom.mockImplementation((table)=>{
                callCount++;
                if (table === 'activities') {
                    return {
                        select: mockSelectA
                    };
                } else if (table === 'rsvps' && callCount === 2) {
                    return {
                        select: mockSelectR
                    };
                } else if (table === 'rsvps' && callCount === 3) {
                    return {
                        select: mockSelectE
                    };
                }
                return {};
            });
            // New total: 8 - 3 + 4 = 9 (within limit)
            const result = await rsvpService.enforceCapacityLimit('activity-1', 4, 'existing-rsvp-id');
            (0, _globals.expect)(result.success).toBe(true);
        });
        (0, _globals.it)('should return success when no capacity limit is set', async ()=>{
            const mockActivity = {
                capacity: null,
                name: 'Open Activity'
            };
            const mockRSVPs = [
                {
                    guest_count: 100
                }
            ];
            // Mock activity query
            const mockSingle = _globals.jest.fn().mockResolvedValue({
                data: mockActivity,
                error: null
            });
            const mockEqA = _globals.jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockSelectA = _globals.jest.fn().mockReturnValue({
                eq: mockEqA
            });
            // Mock RSVPs query
            const mockEqRb = _globals.jest.fn().mockResolvedValue({
                data: mockRSVPs,
                error: null
            });
            const mockEqRa = _globals.jest.fn().mockReturnValue({
                eq: mockEqRb
            });
            const mockSelectR = _globals.jest.fn().mockReturnValue({
                eq: mockEqRa
            });
            mockFrom.mockImplementation((table)=>{
                if (table === 'activities') {
                    return {
                        select: mockSelectA
                    };
                } else if (table === 'rsvps') {
                    return {
                        select: mockSelectR
                    };
                }
                return {};
            });
            const result = await rsvpService.enforceCapacityLimit('activity-1', 50);
            (0, _globals.expect)(result.success).toBe(true);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvcnN2cFNlcnZpY2UudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZXNjcmliZSwgaXQsIGV4cGVjdCwgamVzdCwgYmVmb3JlRWFjaCB9IGZyb20gJ0BqZXN0L2dsb2JhbHMnO1xuaW1wb3J0IHR5cGUgeyBDcmVhdGVSU1ZQRFRPLCBVcGRhdGVSU1ZQRFRPLCBMaXN0UlNWUHNEVE8gfSBmcm9tICdAL3NjaGVtYXMvcnN2cFNjaGVtYXMnO1xuXG4vLyBTZXQgZW52aXJvbm1lbnQgdmFyaWFibGVzIEZJUlNUXG5wcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwgPSAnaHR0cHM6Ly90ZXN0LnN1cGFiYXNlLmNvJztcbnByb2Nlc3MuZW52LlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkgPSAndGVzdC1zZXJ2aWNlLXJvbGUta2V5JztcblxuLy8gTW9jayBzYW5pdGl6YXRpb24gdXRpbGl0aWVzXG5qZXN0Lm1vY2soJ0AvdXRpbHMvc2FuaXRpemF0aW9uJywgKCkgPT4gKHtcbiAgc2FuaXRpemVJbnB1dDogamVzdC5mbigoaW5wdXQ6IHN0cmluZykgPT4gaW5wdXQudHJpbSgpKSxcbn0pKTtcblxuLy8gTW9jayB0eXBlcyBhbmQgZXJyb3IgY29kZXNcbmplc3QubW9jaygnQC90eXBlcycsICgpID0+ICh7XG4gIEVSUk9SX0NPREVTOiB7XG4gICAgVkFMSURBVElPTl9FUlJPUjogJ1ZBTElEQVRJT05fRVJST1InLFxuICAgIERBVEFCQVNFX0VSUk9SOiAnREFUQUJBU0VfRVJST1InLFxuICAgIFVOS05PV05fRVJST1I6ICdVTktOT1dOX0VSUk9SJyxcbiAgICBOT1RfRk9VTkQ6ICdOT1RfRk9VTkQnLFxuICAgIERVUExJQ0FURV9FTlRSWTogJ0RVUExJQ0FURV9FTlRSWScsXG4gICAgQ0FQQUNJVFlfRVhDRUVERUQ6ICdDQVBBQ0lUWV9FWENFRURFRCcsXG4gIH0sXG59KSk7XG5cbi8vIE1vY2sgU3VwYWJhc2Ugd2l0aCBzaGFyZWQgY2xpZW50IGluc3RhbmNlIChQYXR0ZXJuIEEpXG5qZXN0Lm1vY2soJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcycsICgpID0+IHtcbiAgY29uc3QgbW9ja0Zyb20gPSBqZXN0LmZuKCk7XG4gIGNvbnN0IG1vY2tTdXBhYmFzZUNsaWVudCA9IHtcbiAgICBmcm9tOiBtb2NrRnJvbSxcbiAgfTtcbiAgXG4gIHJldHVybiB7XG4gICAgY3JlYXRlQ2xpZW50OiBqZXN0LmZuKCgpID0+IG1vY2tTdXBhYmFzZUNsaWVudCksXG4gICAgX19tb2NrRnJvbTogbW9ja0Zyb20sXG4gIH07XG59KTtcblxuLy8gSW1wb3J0IHNlcnZpY2UgdXNpbmcgcmVxdWlyZSgpIEFGVEVSIG1vY2tpbmcgKFBhdHRlcm4gQSByZXF1aXJlbWVudClcbmNvbnN0IHJzdnBTZXJ2aWNlTW9kdWxlID0gcmVxdWlyZSgnLi9yc3ZwU2VydmljZScpO1xuY29uc3QgcnN2cFNlcnZpY2UgPSByc3ZwU2VydmljZU1vZHVsZTtcblxuLy8gR2V0IHRoZSBtb2NrZWQgZnJvbSBmdW5jdGlvblxuY29uc3QgeyBfX21vY2tGcm9tOiBtb2NrRnJvbSB9ID0gcmVxdWlyZSgnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJyk7XG5cbmRlc2NyaWJlKCdyc3ZwU2VydmljZScsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgXG4gICAgLy8gU2V0IHVwIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCA9ICdodHRwczovL3Rlc3Quc3VwYWJhc2UuY28nO1xuICAgIHByb2Nlc3MuZW52LlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkgPSAndGVzdC1zZXJ2aWNlLXJvbGUta2V5JztcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NyZWF0ZScsICgpID0+IHtcbiAgICBjb25zdCB2YWxpZERhdGE6IENyZWF0ZVJTVlBEVE8gPSB7XG4gICAgICBndWVzdF9pZDogJzEyM2U0NTY3LWU4OWItMTJkMy1hNDU2LTQyNjYxNDE3NDAwMCcsXG4gICAgICBldmVudF9pZDogJzEyM2U0NTY3LWU4OWItMTJkMy1hNDU2LTQyNjYxNDE3NDAwMScsXG4gICAgICBzdGF0dXM6ICdhdHRlbmRpbmcnLFxuICAgICAgZ3Vlc3RfY291bnQ6IDIsXG4gICAgICBkaWV0YXJ5X25vdGVzOiAnVmVnZXRhcmlhbicsXG4gICAgICBzcGVjaWFsX3JlcXVpcmVtZW50czogJ1doZWVsY2hhaXIgYWNjZXNzaWJsZScsXG4gICAgICBub3RlczogJ0xvb2tpbmcgZm9yd2FyZCB0byBpdCEnLFxuICAgIH07XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIHdpdGggUlNWUCBkYXRhIHdoZW4gdmFsaWQgaW5wdXQgcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUlNWUCA9IHtcbiAgICAgICAgaWQ6ICdyc3ZwLTEnLFxuICAgICAgICBndWVzdF9pZDogdmFsaWREYXRhLmd1ZXN0X2lkLFxuICAgICAgICBldmVudF9pZDogdmFsaWREYXRhLmV2ZW50X2lkLFxuICAgICAgICBhY3Rpdml0eV9pZDogbnVsbCxcbiAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyxcbiAgICAgICAgZ3Vlc3RfY291bnQ6IDIsXG4gICAgICAgIGRpZXRhcnlfbm90ZXM6ICdWZWdldGFyaWFuJyxcbiAgICAgICAgc3BlY2lhbF9yZXF1aXJlbWVudHM6ICdXaGVlbGNoYWlyIGFjY2Vzc2libGUnLFxuICAgICAgICBub3RlczogJ0xvb2tpbmcgZm9yd2FyZCB0byBpdCEnLFxuICAgICAgICByZXNwb25kZWRfYXQ6ICcyMDI0LTAxLTAxVDEyOjAwOjAwWicsXG4gICAgICAgIGNyZWF0ZWRfYXQ6ICcyMDI0LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgIHVwZGF0ZWRfYXQ6ICcyMDI0LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbW9ja1JTVlAsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHNpbmdsZTogbW9ja1NpbmdsZSB9KTtcbiAgICAgIGNvbnN0IG1vY2tJbnNlcnQgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0pO1xuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHsgaW5zZXJ0OiBtb2NrSW5zZXJ0IH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwU2VydmljZS5jcmVhdGUodmFsaWREYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5pZCkudG9CZSgncnN2cC0xJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5ndWVzdF9pZCkudG9CZSh2YWxpZERhdGEuZ3Vlc3RfaWQpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuc3RhdHVzKS50b0JlKCdhdHRlbmRpbmcnKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmd1ZXN0X2NvdW50KS50b0JlKDIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gVkFMSURBVElPTl9FUlJPUiB3aGVuIGd1ZXN0X2lkIGlzIG1pc3NpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkRGF0YSA9IHsgLi4udmFsaWREYXRhLCBndWVzdF9pZDogJycgfTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBTZXJ2aWNlLmNyZWF0ZShpbnZhbGlkRGF0YSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnVkFMSURBVElPTl9FUlJPUicpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gVkFMSURBVElPTl9FUlJPUiB3aGVuIGJvdGggZXZlbnRfaWQgYW5kIGFjdGl2aXR5X2lkIGFyZSBwcm92aWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWREYXRhID0geyBcbiAgICAgICAgLi4udmFsaWREYXRhLCBcbiAgICAgICAgYWN0aXZpdHlfaWQ6ICcxMjNlNDU2Ny1lODliLTEyZDMtYTQ1Ni00MjY2MTQxNzQwMDInIFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBTZXJ2aWNlLmNyZWF0ZShpbnZhbGlkRGF0YSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnVkFMSURBVElPTl9FUlJPUicpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gVkFMSURBVElPTl9FUlJPUiB3aGVuIG5laXRoZXIgZXZlbnRfaWQgbm9yIGFjdGl2aXR5X2lkIGFyZSBwcm92aWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWREYXRhID0geyAuLi52YWxpZERhdGEgfTtcbiAgICAgIGRlbGV0ZSBpbnZhbGlkRGF0YS5ldmVudF9pZDtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBTZXJ2aWNlLmNyZWF0ZShpbnZhbGlkRGF0YSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnVkFMSURBVElPTl9FUlJPUicpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gRFVQTElDQVRFX0VOVFJZIHdoZW4gUlNWUCBhbHJlYWR5IGV4aXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogeyBjb2RlOiAnMjM1MDUnLCBtZXNzYWdlOiAnVW5pcXVlIGNvbnN0cmFpbnQgdmlvbGF0aW9uJyB9LFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHNpbmdsZTogbW9ja1NpbmdsZSB9KTtcbiAgICAgIGNvbnN0IG1vY2tJbnNlcnQgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0pO1xuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHsgaW5zZXJ0OiBtb2NrSW5zZXJ0IH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwU2VydmljZS5jcmVhdGUodmFsaWREYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdEVVBMSUNBVEVfRU5UUlknKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIERBVEFCQVNFX0VSUk9SIHdoZW4gaW5zZXJ0IGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6ICdDb25uZWN0aW9uIGZhaWxlZCcgfSxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzaW5nbGU6IG1vY2tTaW5nbGUgfSk7XG4gICAgICBjb25zdCBtb2NrSW5zZXJ0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHNlbGVjdDogbW9ja1NlbGVjdCB9KTtcbiAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZSh7IGluc2VydDogbW9ja0luc2VydCB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cFNlcnZpY2UuY3JlYXRlKHZhbGlkRGF0YSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnREFUQUJBU0VfRVJST1InKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc2FuaXRpemUgaW5wdXQgdG8gcHJldmVudCBYU1MgYXR0YWNrcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1hbGljaW91c0RhdGEgPSB7XG4gICAgICAgIC4uLnZhbGlkRGF0YSxcbiAgICAgICAgZGlldGFyeV9ub3RlczogJzxzY3JpcHQ+YWxlcnQoXCJ4c3NcIik8L3NjcmlwdD5WZWdldGFyaWFuJyxcbiAgICAgICAgc3BlY2lhbF9yZXF1aXJlbWVudHM6ICc8aW1nIHNyYz14IG9uZXJyb3I9YWxlcnQoMSk+V2hlZWxjaGFpcicsXG4gICAgICAgIG5vdGVzOiAnPHN2ZyBvbmxvYWQ9YWxlcnQoMSk+Tm90ZXMnLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpZDogJ3JzdnAtMScsXG4gICAgICAgICAgZGlldGFyeV9ub3RlczogJ1ZlZ2V0YXJpYW4nLFxuICAgICAgICAgIHNwZWNpYWxfcmVxdWlyZW1lbnRzOiAnV2hlZWxjaGFpcicsXG4gICAgICAgICAgbm90ZXM6ICdOb3RlcycsXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHNpbmdsZTogbW9ja1NpbmdsZSB9KTtcbiAgICAgIGNvbnN0IG1vY2tJbnNlcnQgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0pO1xuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHsgaW5zZXJ0OiBtb2NrSW5zZXJ0IH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwU2VydmljZS5jcmVhdGUobWFsaWNpb3VzRGF0YSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IHNhbml0aXphdGlvbiB3YXMgY2FsbGVkXG4gICAgICBjb25zdCB7IHNhbml0aXplSW5wdXQgfSA9IHJlcXVpcmUoJ0AvdXRpbHMvc2FuaXRpemF0aW9uJyk7XG4gICAgICBleHBlY3Qoc2FuaXRpemVJbnB1dCkudG9IYXZlQmVlbkNhbGxlZFdpdGgobWFsaWNpb3VzRGF0YS5kaWV0YXJ5X25vdGVzKTtcbiAgICAgIGV4cGVjdChzYW5pdGl6ZUlucHV0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChtYWxpY2lvdXNEYXRhLnNwZWNpYWxfcmVxdWlyZW1lbnRzKTtcbiAgICAgIGV4cGVjdChzYW5pdGl6ZUlucHV0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChtYWxpY2lvdXNEYXRhLm5vdGVzKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc2V0IHJlc3BvbmRlZF9hdCB3aGVuIHN0YXR1cyBpcyBub3QgcGVuZGluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGF0dGVuZGluZ0RhdGEgPSB7IC4uLnZhbGlkRGF0YSwgc3RhdHVzOiAnYXR0ZW5kaW5nJyBhcyBjb25zdCB9O1xuXG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlkOiAncnN2cC0xJyxcbiAgICAgICAgICBzdGF0dXM6ICdhdHRlbmRpbmcnLFxuICAgICAgICAgIHJlc3BvbmRlZF9hdDogJzIwMjQtMDEtMDFUMTI6MDA6MDBaJyxcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2luZ2xlOiBtb2NrU2luZ2xlIH0pO1xuICAgICAgY29uc3QgbW9ja0luc2VydCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBpbnNlcnQ6IG1vY2tJbnNlcnQgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBTZXJ2aWNlLmNyZWF0ZShhdHRlbmRpbmdEYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KG1vY2tJbnNlcnQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyxcbiAgICAgICAgICByZXNwb25kZWRfYXQ6IGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG5vdCBzZXQgcmVzcG9uZGVkX2F0IHdoZW4gc3RhdHVzIGlzIHBlbmRpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwZW5kaW5nRGF0YSA9IHsgLi4udmFsaWREYXRhLCBzdGF0dXM6ICdwZW5kaW5nJyBhcyBjb25zdCB9O1xuXG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlkOiAncnN2cC0xJyxcbiAgICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgICAgICByZXNwb25kZWRfYXQ6IG51bGwsXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHNpbmdsZTogbW9ja1NpbmdsZSB9KTtcbiAgICAgIGNvbnN0IG1vY2tJbnNlcnQgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0pO1xuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHsgaW5zZXJ0OiBtb2NrSW5zZXJ0IH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwU2VydmljZS5jcmVhdGUocGVuZGluZ0RhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QobW9ja0luc2VydCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgICAgICByZXNwb25kZWRfYXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2VzcyB3aXRoIFJTVlAgZGF0YSB3aGVuIFJTVlAgZXhpc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1JTVlAgPSB7XG4gICAgICAgIGlkOiAncnN2cC0xJyxcbiAgICAgICAgZ3Vlc3RfaWQ6ICcxMjNlNDU2Ny1lODliLTEyZDMtYTQ1Ni00MjY2MTQxNzQwMDAnLFxuICAgICAgICBldmVudF9pZDogJzEyM2U0NTY3LWU4OWItMTJkMy1hNDU2LTQyNjYxNDE3NDAwMScsXG4gICAgICAgIGFjdGl2aXR5X2lkOiBudWxsLFxuICAgICAgICBzdGF0dXM6ICdhdHRlbmRpbmcnLFxuICAgICAgICBndWVzdF9jb3VudDogMSxcbiAgICAgICAgZGlldGFyeV9ub3RlczogbnVsbCxcbiAgICAgICAgc3BlY2lhbF9yZXF1aXJlbWVudHM6IG51bGwsXG4gICAgICAgIG5vdGVzOiBudWxsLFxuICAgICAgICByZXNwb25kZWRfYXQ6ICcyMDI0LTAxLTAxVDEyOjAwOjAwWicsXG4gICAgICAgIGNyZWF0ZWRfYXQ6ICcyMDI0LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgIHVwZGF0ZWRfYXQ6ICcyMDI0LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbW9ja1JTVlAsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2luZ2xlOiBtb2NrU2luZ2xlIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxIH0pO1xuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwU2VydmljZS5nZXQoJ3JzdnAtMScpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmlkKS50b0JlKCdyc3ZwLTEnKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnN0YXR1cykudG9CZSgnYXR0ZW5kaW5nJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBOT1RfRk9VTkQgd2hlbiBSU1ZQIGRvZXMgbm90IGV4aXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiB7IGNvZGU6ICdQR1JTVDExNicgfSxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHNpbmdsZTogbW9ja1NpbmdsZSB9KTtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcSB9KTtcbiAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZSh7IHNlbGVjdDogbW9ja1NlbGVjdCB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cFNlcnZpY2UuZ2V0KCdub25leGlzdGVudC1pZCcpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ05PVF9GT1VORCcpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gREFUQUJBU0VfRVJST1Igd2hlbiBkYXRhYmFzZSBxdWVyeSBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnQ29ubmVjdGlvbiBmYWlsZWQnIH0sXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzaW5nbGU6IG1vY2tTaW5nbGUgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXEgfSk7XG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBTZXJ2aWNlLmdldCgncnN2cC0xJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnREFUQUJBU0VfRVJST1InKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3VwZGF0ZScsICgpID0+IHtcbiAgICBjb25zdCB1cGRhdGVEYXRhOiBVcGRhdGVSU1ZQRFRPID0ge1xuICAgICAgc3RhdHVzOiAnZGVjbGluZWQnLFxuICAgICAgZGlldGFyeV9ub3RlczogJ05vIGRpZXRhcnkgcmVzdHJpY3Rpb25zJyxcbiAgICAgIG5vdGVzOiAnQ2Fubm90IGF0dGVuZCBkdWUgdG8gY29uZmxpY3QnLFxuICAgIH07XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIHdpdGggdXBkYXRlZCBSU1ZQIGRhdGEgd2hlbiB2YWxpZCBpbnB1dCBwcm92aWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tVcGRhdGVkUlNWUCA9IHtcbiAgICAgICAgaWQ6ICdyc3ZwLTEnLFxuICAgICAgICBndWVzdF9pZDogJzEyM2U0NTY3LWU4OWItMTJkMy1hNDU2LTQyNjYxNDE3NDAwMCcsXG4gICAgICAgIGV2ZW50X2lkOiAnMTIzZTQ1NjctZTg5Yi0xMmQzLWE0NTYtNDI2NjE0MTc0MDAxJyxcbiAgICAgICAgYWN0aXZpdHlfaWQ6IG51bGwsXG4gICAgICAgIHN0YXR1czogJ2RlY2xpbmVkJyxcbiAgICAgICAgZ3Vlc3RfY291bnQ6IDEsXG4gICAgICAgIGRpZXRhcnlfbm90ZXM6ICdObyBkaWV0YXJ5IHJlc3RyaWN0aW9ucycsXG4gICAgICAgIHNwZWNpYWxfcmVxdWlyZW1lbnRzOiBudWxsLFxuICAgICAgICBub3RlczogJ0Nhbm5vdCBhdHRlbmQgZHVlIHRvIGNvbmZsaWN0JyxcbiAgICAgICAgcmVzcG9uZGVkX2F0OiAnMjAyNC0wMS0wMlQxMjowMDowMFonLFxuICAgICAgICBjcmVhdGVkX2F0OiAnMjAyNC0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICB1cGRhdGVkX2F0OiAnMjAyNC0wMS0wMlQwMDowMDowMFonLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG1vY2tVcGRhdGVkUlNWUCxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2luZ2xlOiBtb2NrU2luZ2xlIH0pO1xuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHNlbGVjdDogbW9ja1NlbGVjdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tVcGRhdGUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcSB9KTtcbiAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZSh7IHVwZGF0ZTogbW9ja1VwZGF0ZSB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cFNlcnZpY2UudXBkYXRlKCdyc3ZwLTEnLCB1cGRhdGVEYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5zdGF0dXMpLnRvQmUoJ2RlY2xpbmVkJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5kaWV0YXJ5X25vdGVzKS50b0JlKCdObyBkaWV0YXJ5IHJlc3RyaWN0aW9ucycpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEubm90ZXMpLnRvQmUoJ0Nhbm5vdCBhdHRlbmQgZHVlIHRvIGNvbmZsaWN0Jyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNldCByZXNwb25kZWRfYXQgd2hlbiBzdGF0dXMgY2hhbmdlcyBmcm9tIHBlbmRpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzdGF0dXNVcGRhdGUgPSB7IHN0YXR1czogJ2F0dGVuZGluZycgYXMgY29uc3QgfTtcblxuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpZDogJ3JzdnAtMScsXG4gICAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyxcbiAgICAgICAgICByZXNwb25kZWRfYXQ6ICcyMDI0LTAxLTAyVDEyOjAwOjAwWicsXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHNpbmdsZTogbW9ja1NpbmdsZSB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG4gICAgICBjb25zdCBtb2NrVXBkYXRlID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXEgfSk7XG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoeyB1cGRhdGU6IG1vY2tVcGRhdGUgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBTZXJ2aWNlLnVwZGF0ZSgncnN2cC0xJywgc3RhdHVzVXBkYXRlKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KG1vY2tVcGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyxcbiAgICAgICAgICByZXNwb25kZWRfYXQ6IGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBOT1RfRk9VTkQgd2hlbiBSU1ZQIHRvIHVwZGF0ZSBkb2VzIG5vdCBleGlzdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogeyBjb2RlOiAnUEdSU1QxMTYnIH0sXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2luZ2xlOiBtb2NrU2luZ2xlIH0pO1xuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHNlbGVjdDogbW9ja1NlbGVjdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tVcGRhdGUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcSB9KTtcbiAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZSh7IHVwZGF0ZTogbW9ja1VwZGF0ZSB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cFNlcnZpY2UudXBkYXRlKCdub25leGlzdGVudC1pZCcsIHVwZGF0ZURhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ05PVF9GT1VORCcpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gREFUQUJBU0VfRVJST1Igd2hlbiB1cGRhdGUgZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogJ1VwZGF0ZSBmYWlsZWQnIH0sXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2luZ2xlOiBtb2NrU2luZ2xlIH0pO1xuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHNlbGVjdDogbW9ja1NlbGVjdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tVcGRhdGUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcSB9KTtcbiAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZSh7IHVwZGF0ZTogbW9ja1VwZGF0ZSB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cFNlcnZpY2UudXBkYXRlKCdyc3ZwLTEnLCB1cGRhdGVEYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdEQVRBQkFTRV9FUlJPUicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZGVsZXRlUlNWUCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIHdoZW4gUlNWUCBpcyBkZWxldGVkIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrRGVsZXRlID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXEgfSk7XG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBkZWxldGU6IG1vY2tEZWxldGUgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBTZXJ2aWNlLmRlbGV0ZVJTVlAoJ3JzdnAtMScpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBEQVRBQkFTRV9FUlJPUiB3aGVuIGRlbGV0ZSBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6ICdEZWxldGUgZmFpbGVkJyB9LFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrRGVsZXRlID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXEgfSk7XG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBkZWxldGU6IG1vY2tEZWxldGUgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBTZXJ2aWNlLmRlbGV0ZVJTVlAoJ3JzdnAtMScpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ0RBVEFCQVNFX0VSUk9SJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdsaXN0JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3Mgd2l0aCBwYWdpbmF0ZWQgUlNWUHMgd2hlbiB2YWxpZCBmaWx0ZXJzIHByb3ZpZGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1JTVlBzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdyc3ZwLTEnLFxuICAgICAgICAgIGd1ZXN0X2lkOiAnMTIzZTQ1NjctZTg5Yi0xMmQzLWE0NTYtNDI2NjE0MTc0MDAwJyxcbiAgICAgICAgICBldmVudF9pZDogJzEyM2U0NTY3LWU4OWItMTJkMy1hNDU2LTQyNjYxNDE3NDAwMScsXG4gICAgICAgICAgYWN0aXZpdHlfaWQ6IG51bGwsXG4gICAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyxcbiAgICAgICAgICBndWVzdF9jb3VudDogMSxcbiAgICAgICAgICBkaWV0YXJ5X25vdGVzOiBudWxsLFxuICAgICAgICAgIHNwZWNpYWxfcmVxdWlyZW1lbnRzOiBudWxsLFxuICAgICAgICAgIG5vdGVzOiBudWxsLFxuICAgICAgICAgIHJlc3BvbmRlZF9hdDogJzIwMjQtMDEtMDFUMTI6MDA6MDBaJyxcbiAgICAgICAgICBjcmVhdGVkX2F0OiAnMjAyNC0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6ICcyMDI0LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3JzdnAtMicsXG4gICAgICAgICAgZ3Vlc3RfaWQ6ICcxMjNlNDU2Ny1lODliLTEyZDMtYTQ1Ni00MjY2MTQxNzQwMDInLFxuICAgICAgICAgIGV2ZW50X2lkOiAnMTIzZTQ1NjctZTg5Yi0xMmQzLWE0NTYtNDI2NjE0MTc0MDAxJyxcbiAgICAgICAgICBhY3Rpdml0eV9pZDogbnVsbCxcbiAgICAgICAgICBzdGF0dXM6ICdkZWNsaW5lZCcsXG4gICAgICAgICAgZ3Vlc3RfY291bnQ6IDEsXG4gICAgICAgICAgZGlldGFyeV9ub3RlczogbnVsbCxcbiAgICAgICAgICBzcGVjaWFsX3JlcXVpcmVtZW50czogbnVsbCxcbiAgICAgICAgICBub3RlczogJ0Nhbm5vdCBhdHRlbmQnLFxuICAgICAgICAgIHJlc3BvbmRlZF9hdDogJzIwMjQtMDEtMDJUMTI6MDA6MDBaJyxcbiAgICAgICAgICBjcmVhdGVkX2F0OiAnMjAyNC0wMS0wMlQwMDowMDowMFonLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6ICcyMDI0LTAxLTAyVDAwOjAwOjAwWicsXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBtb2NrT3JkZXIgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBtb2NrUlNWUHMsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICBjb3VudDogMixcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbW9ja1JhbmdlID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IG9yZGVyOiBtb2NrT3JkZXIgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHJhbmdlOiBtb2NrUmFuZ2UgfSk7XG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG5cbiAgICAgIGNvbnN0IGZpbHRlcnM6IFBhcnRpYWw8TGlzdFJTVlBzRFRPPiA9IHsgcGFnZTogMSwgcGFnZV9zaXplOiAxMCB9O1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cFNlcnZpY2UubGlzdChmaWx0ZXJzKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5yc3ZwcykudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudG90YWwpLnRvQmUoMik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGZpbHRlciBieSBndWVzdF9pZCB3aGVuIHByb3ZpZGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZmlsdGVyczogUGFydGlhbDxMaXN0UlNWUHNEVE8+ID0ge1xuICAgICAgICBndWVzdF9pZDogJzEyM2U0NTY3LWU4OWItMTJkMy1hNDU2LTQyNjYxNDE3NDAwMCcsXG4gICAgICAgIHBhZ2U6IDEsXG4gICAgICAgIHBhZ2Vfc2l6ZTogMTAsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrT3JkZXIgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIGNvdW50OiAwLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrUmFuZ2UgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgb3JkZXI6IG1vY2tPcmRlciB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyByYW5nZTogbW9ja1JhbmdlIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxIH0pO1xuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwU2VydmljZS5saXN0KGZpbHRlcnMpO1xuXG4gICAgICBleHBlY3QobW9ja0VxKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnZ3Vlc3RfaWQnLCAnMTIzZTQ1NjctZTg5Yi0xMmQzLWE0NTYtNDI2NjE0MTc0MDAwJyk7XG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGZpbHRlciBieSBzdGF0dXMgd2hlbiBwcm92aWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGZpbHRlcnM6IFBhcnRpYWw8TGlzdFJTVlBzRFRPPiA9IHtcbiAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyxcbiAgICAgICAgcGFnZTogMSxcbiAgICAgICAgcGFnZV9zaXplOiAxMCxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1vY2tPcmRlciA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgY291bnQ6IDAsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tSYW5nZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBvcmRlcjogbW9ja09yZGVyIH0pO1xuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHJhbmdlOiBtb2NrUmFuZ2UgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXEgfSk7XG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBTZXJ2aWNlLmxpc3QoZmlsdGVycyk7XG5cbiAgICAgIGV4cGVjdChtb2NrRXEpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdzdGF0dXMnLCAnYXR0ZW5kaW5nJyk7XG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBEQVRBQkFTRV9FUlJPUiB3aGVuIHF1ZXJ5IGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja09yZGVyID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogJ0Nvbm5lY3Rpb24gZmFpbGVkJyB9LFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrUmFuZ2UgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgb3JkZXI6IG1vY2tPcmRlciB9KTtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgcmFuZ2U6IG1vY2tSYW5nZSB9KTtcbiAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZSh7IHNlbGVjdDogbW9ja1NlbGVjdCB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cFNlcnZpY2UubGlzdCgpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ0RBVEFCQVNFX0VSUk9SJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdjYWxjdWxhdGVBY3Rpdml0eUNhcGFjaXR5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3Mgd2l0aCBjYXBhY2l0eSBpbmZvcm1hdGlvbiB3aGVuIGFjdGl2aXR5IGV4aXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tBY3Rpdml0eSA9IHtcbiAgICAgICAgY2FwYWNpdHk6IDUwLFxuICAgICAgICBuYW1lOiAnQmVhY2ggVm9sbGV5YmFsbCcsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrUlNWUHMgPSBbXG4gICAgICAgIHsgZ3Vlc3RfY291bnQ6IDIgfSxcbiAgICAgICAgeyBndWVzdF9jb3VudDogMyB9LFxuICAgICAgICB7IGd1ZXN0X2NvdW50OiAxIH0sXG4gICAgICBdO1xuXG4gICAgICAvLyBNb2NrIGFjdGl2aXR5IHF1ZXJ5IChmaXJzdCBjYWxsKVxuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG1vY2tBY3Rpdml0eSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcTEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2luZ2xlOiBtb2NrU2luZ2xlIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdDEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcTEgfSk7XG5cbiAgICAgIC8vIE1vY2sgUlNWUHMgcXVlcnkgKHNlY29uZCBjYWxsKVxuICAgICAgY29uc3QgbW9ja0VxMyA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG1vY2tSU1ZQcyxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcTIgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcTMgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0MiA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxMiB9KTtcblxuICAgICAgbGV0IGNhbGxDb3VudCA9IDA7XG4gICAgICBtb2NrRnJvbS5tb2NrSW1wbGVtZW50YXRpb24oKHRhYmxlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKHRhYmxlID09PSAnYWN0aXZpdGllcycpIHtcbiAgICAgICAgICByZXR1cm4geyBzZWxlY3Q6IG1vY2tTZWxlY3QxIH07XG4gICAgICAgIH0gZWxzZSBpZiAodGFibGUgPT09ICdyc3ZwcycpIHtcbiAgICAgICAgICByZXR1cm4geyBzZWxlY3Q6IG1vY2tTZWxlY3QyIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBTZXJ2aWNlLmNhbGN1bGF0ZUFjdGl2aXR5Q2FwYWNpdHkoJ2FjdGl2aXR5LTEnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5jYXBhY2l0eSkudG9CZSg1MCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5hdHRlbmRpbmdfY291bnQpLnRvQmUoNik7IC8vIDIgKyAzICsgMVxuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuYXZhaWxhYmxlKS50b0JlKDQ0KTsgLy8gNTAgLSA2XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBhY3Rpdml0aWVzIHdpdGggbm8gY2FwYWNpdHkgbGltaXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQWN0aXZpdHkgPSB7XG4gICAgICAgIGNhcGFjaXR5OiBudWxsLFxuICAgICAgICBuYW1lOiAnT3BlbiBBY3Rpdml0eScsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrUlNWUHMgPSBbXG4gICAgICAgIHsgZ3Vlc3RfY291bnQ6IDUgfSxcbiAgICAgICAgeyBndWVzdF9jb3VudDogMyB9LFxuICAgICAgXTtcblxuICAgICAgLy8gTW9jayBhY3Rpdml0eSBxdWVyeVxuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG1vY2tBY3Rpdml0eSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcTEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2luZ2xlOiBtb2NrU2luZ2xlIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdDEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcTEgfSk7XG5cbiAgICAgIC8vIE1vY2sgUlNWUHMgcXVlcnlcbiAgICAgIGNvbnN0IG1vY2tFcTMgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBtb2NrUlNWUHMsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrRXEyID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXEzIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdDIgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcTIgfSk7XG5cbiAgICAgIG1vY2tGcm9tLm1vY2tJbXBsZW1lbnRhdGlvbigodGFibGU6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAodGFibGUgPT09ICdhY3Rpdml0aWVzJykge1xuICAgICAgICAgIHJldHVybiB7IHNlbGVjdDogbW9ja1NlbGVjdDEgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWJsZSA9PT0gJ3JzdnBzJykge1xuICAgICAgICAgIHJldHVybiB7IHNlbGVjdDogbW9ja1NlbGVjdDIgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cFNlcnZpY2UuY2FsY3VsYXRlQWN0aXZpdHlDYXBhY2l0eSgnYWN0aXZpdHktMScpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmNhcGFjaXR5KS50b0JlTnVsbCgpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuYXR0ZW5kaW5nX2NvdW50KS50b0JlKDgpOyAvLyA1ICsgM1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuYXZhaWxhYmxlKS50b0JlTnVsbCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gREFUQUJBU0VfRVJST1Igd2hlbiBhY3Rpdml0eSBxdWVyeSBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnQWN0aXZpdHkgbm90IGZvdW5kJyB9LFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2luZ2xlOiBtb2NrU2luZ2xlIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxIH0pO1xuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwU2VydmljZS5jYWxjdWxhdGVBY3Rpdml0eUNhcGFjaXR5KCdub25leGlzdGVudC1hY3Rpdml0eScpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ0RBVEFCQVNFX0VSUk9SJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZW5lcmF0ZUNhcGFjaXR5QWxlcnRzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3Mgd2l0aCBhbGVydHMgZm9yIGFjdGl2aXRpZXMgYXBwcm9hY2hpbmcgY2FwYWNpdHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQWN0aXZpdGllcyA9IFtcbiAgICAgICAgeyBpZDogJ2FjdGl2aXR5LTEnLCBuYW1lOiAnQmVhY2ggVm9sbGV5YmFsbCcsIGNhcGFjaXR5OiAxMCB9LFxuICAgICAgICB7IGlkOiAnYWN0aXZpdHktMicsIG5hbWU6ICdTbm9ya2VsaW5nJywgY2FwYWNpdHk6IDIwIH0sXG4gICAgICBdO1xuXG4gICAgICAvLyBNb2NrIGFjdGl2aXRpZXMgcXVlcnkgKGZpcnN0IGNhbGwpXG4gICAgICAvLyBRdWVyeTogYXdhaXQgc3VwYWJhc2UuZnJvbSgnYWN0aXZpdGllcycpLnNlbGVjdCgnaWQsIG5hbWUsIGNhcGFjaXR5Jykubm90KCdjYXBhY2l0eScsICdpcycsIG51bGwpLmVxKCdzdGF0dXMnLCAncHVibGlzaGVkJylcbiAgICAgIC8vIFRoZSBmaW5hbCAuZXEoKSBtdXN0IHJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB7IGRhdGEsIGVycm9yIH1cbiAgICAgIGNvbnN0IG1vY2tFcTIgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBtb2NrQWN0aXZpdGllcyxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcTEgPSBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IG1vY2tFcTIoKSk7IC8vIENhbGwgbW9ja0VxMiB0byBnZXQgdGhlIHByb21pc2VcbiAgICAgIGNvbnN0IG1vY2tOb3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcTEgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0MSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBub3Q6IG1vY2tOb3QgfSk7XG5cbiAgICAgIC8vIEZvciBjYWxjdWxhdGVBY3Rpdml0eUNhcGFjaXR5IGNhbGxzLCB3ZSBuZWVkIHRvIG1vY2sgbXVsdGlwbGUgc2VxdWVuY2VzXG4gICAgICAvLyBBY3Rpdml0eSAxOiA5LzEwICg5MCUgLSB3YXJuaW5nKVxuICAgICAgY29uc3QgbW9ja1NpbmdsZTEgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IGNhcGFjaXR5OiAxMCwgbmFtZTogJ0JlYWNoIFZvbGxleWJhbGwnIH0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrRXFBMSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzaW5nbGU6IG1vY2tTaW5nbGUxIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdEExID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXFBMSB9KTtcblxuICAgICAgY29uc3QgbW9ja0VxUjFiID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogW3sgZ3Vlc3RfY291bnQ6IDQgfSwgeyBndWVzdF9jb3VudDogMyB9LCB7IGd1ZXN0X2NvdW50OiAyIH1dLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbW9ja0VxUjFhID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXFSMWIgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0UjEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcVIxYSB9KTtcblxuICAgICAgLy8gQWN0aXZpdHkgMjogMjAvMjAgKDEwMCUgLSBmdWxsKVxuICAgICAgY29uc3QgbW9ja1NpbmdsZTIgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IGNhcGFjaXR5OiAyMCwgbmFtZTogJ1Nub3JrZWxpbmcnIH0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrRXFBMiA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzaW5nbGU6IG1vY2tTaW5nbGUyIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdEEyID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXFBMiB9KTtcblxuICAgICAgY29uc3QgbW9ja0VxUjJiID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogQXJyYXkoMjApLmZpbGwoeyBndWVzdF9jb3VudDogMSB9KSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcVIyYSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxUjJiIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdFIyID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXFSMmEgfSk7XG5cbiAgICAgIGxldCBjYWxsQ291bnQgPSAwO1xuICAgICAgbW9ja0Zyb20ubW9ja0ltcGxlbWVudGF0aW9uKCh0YWJsZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNhbGxDb3VudCsrO1xuICAgICAgICBpZiAodGFibGUgPT09ICdhY3Rpdml0aWVzJyAmJiBjYWxsQ291bnQgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4geyBzZWxlY3Q6IG1vY2tTZWxlY3QxIH07XG4gICAgICAgIH0gZWxzZSBpZiAodGFibGUgPT09ICdhY3Rpdml0aWVzJyAmJiBjYWxsQ291bnQgPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4geyBzZWxlY3Q6IG1vY2tTZWxlY3RBMSB9O1xuICAgICAgICB9IGVsc2UgaWYgKHRhYmxlID09PSAncnN2cHMnICYmIGNhbGxDb3VudCA9PT0gMykge1xuICAgICAgICAgIHJldHVybiB7IHNlbGVjdDogbW9ja1NlbGVjdFIxIH07XG4gICAgICAgIH0gZWxzZSBpZiAodGFibGUgPT09ICdhY3Rpdml0aWVzJyAmJiBjYWxsQ291bnQgPT09IDQpIHtcbiAgICAgICAgICByZXR1cm4geyBzZWxlY3Q6IG1vY2tTZWxlY3RBMiB9O1xuICAgICAgICB9IGVsc2UgaWYgKHRhYmxlID09PSAncnN2cHMnICYmIGNhbGxDb3VudCA9PT0gNSkge1xuICAgICAgICAgIHJldHVybiB7IHNlbGVjdDogbW9ja1NlbGVjdFIyIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBTZXJ2aWNlLmdlbmVyYXRlQ2FwYWNpdHlBbGVydHMoMC45KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YSkudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgICBcbiAgICAgICAgY29uc3Qgd2FybmluZ0FsZXJ0ID0gcmVzdWx0LmRhdGEuZmluZCgoYWxlcnQ6IGFueSkgPT4gYWxlcnQuYWxlcnRfbGV2ZWwgPT09ICd3YXJuaW5nJyk7XG4gICAgICAgIGV4cGVjdCh3YXJuaW5nQWxlcnQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgIGV4cGVjdCh3YXJuaW5nQWxlcnQ/LmFjdGl2aXR5X25hbWUpLnRvQmUoJ0JlYWNoIFZvbGxleWJhbGwnKTtcbiAgICAgICAgZXhwZWN0KHdhcm5pbmdBbGVydD8udXRpbGl6YXRpb25fcGVyY2VudGFnZSkudG9CZSg5MCk7XG5cbiAgICAgICAgY29uc3QgZnVsbEFsZXJ0ID0gcmVzdWx0LmRhdGEuZmluZCgoYWxlcnQ6IGFueSkgPT4gYWxlcnQuYWxlcnRfbGV2ZWwgPT09ICdmdWxsJyk7XG4gICAgICAgIGV4cGVjdChmdWxsQWxlcnQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgIGV4cGVjdChmdWxsQWxlcnQ/LmFjdGl2aXR5X25hbWUpLnRvQmUoJ1Nub3JrZWxpbmcnKTtcbiAgICAgICAgZXhwZWN0KGZ1bGxBbGVydD8udXRpbGl6YXRpb25fcGVyY2VudGFnZSkudG9CZSgxMDApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZW1wdHkgYXJyYXkgd2hlbiBubyBhY3Rpdml0aWVzIGV4Y2VlZCB0aHJlc2hvbGQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQWN0aXZpdGllcyA9IFtcbiAgICAgICAgeyBpZDogJ2FjdGl2aXR5LTEnLCBuYW1lOiAnQmVhY2ggVm9sbGV5YmFsbCcsIGNhcGFjaXR5OiAxMCB9LFxuICAgICAgXTtcblxuICAgICAgLy8gTW9jayBhY3Rpdml0aWVzIHF1ZXJ5XG4gICAgICBjb25zdCBtb2NrRXEyID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbW9ja0FjdGl2aXRpZXMsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrRXExID0gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiBtb2NrRXEyKCkpOyAvLyBDYWxsIG1vY2tFcTIgdG8gZ2V0IHRoZSBwcm9taXNlXG4gICAgICBjb25zdCBtb2NrTm90ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXExIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdDEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgbm90OiBtb2NrTm90IH0pO1xuXG4gICAgICAvLyBNb2NrIGNhcGFjaXR5IGNhbGN1bGF0aW9uIC0gb25seSA1LzEwICg1MCUpXG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogeyBjYXBhY2l0eTogMTAsIG5hbWU6ICdCZWFjaCBWb2xsZXliYWxsJyB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbW9ja0VxQSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzaW5nbGU6IG1vY2tTaW5nbGUgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0QSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxQSB9KTtcblxuICAgICAgY29uc3QgbW9ja0VxUmIgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBbeyBndWVzdF9jb3VudDogNSB9XSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcVJhID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXFSYiB9KTtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3RSID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXFSYSB9KTtcblxuICAgICAgbGV0IGNhbGxDb3VudCA9IDA7XG4gICAgICBtb2NrRnJvbS5tb2NrSW1wbGVtZW50YXRpb24oKHRhYmxlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY2FsbENvdW50Kys7XG4gICAgICAgIGlmICh0YWJsZSA9PT0gJ2FjdGl2aXRpZXMnICYmIGNhbGxDb3VudCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiB7IHNlbGVjdDogbW9ja1NlbGVjdDEgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWJsZSA9PT0gJ2FjdGl2aXRpZXMnICYmIGNhbGxDb3VudCA9PT0gMikge1xuICAgICAgICAgIHJldHVybiB7IHNlbGVjdDogbW9ja1NlbGVjdEEgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWJsZSA9PT0gJ3JzdnBzJyAmJiBjYWxsQ291bnQgPT09IDMpIHtcbiAgICAgICAgICByZXR1cm4geyBzZWxlY3Q6IG1vY2tTZWxlY3RSIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBTZXJ2aWNlLmdlbmVyYXRlQ2FwYWNpdHlBbGVydHMoMC45KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YSkudG9IYXZlTGVuZ3RoKDApO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnY2hlY2tDYXBhY2l0eUF2YWlsYWJsZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBhdmFpbGFibGUgdHJ1ZSB3aGVuIGNhcGFjaXR5IGlzIHN1ZmZpY2llbnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQWN0aXZpdHkgPSB7IGNhcGFjaXR5OiAxMCwgbmFtZTogJ0FjdGl2aXR5JyB9O1xuICAgICAgY29uc3QgbW9ja1JTVlBzID0gW3sgZ3Vlc3RfY291bnQ6IDUgfV07IC8vIDUgYXR0ZW5kaW5nLCA1IGF2YWlsYWJsZVxuXG4gICAgICAvLyBNb2NrIGFjdGl2aXR5IHF1ZXJ5XG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbW9ja0FjdGl2aXR5LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbW9ja0VxQSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzaW5nbGU6IG1vY2tTaW5nbGUgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0QSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxQSB9KTtcblxuICAgICAgLy8gTW9jayBSU1ZQcyBxdWVyeVxuICAgICAgY29uc3QgbW9ja0VxUmIgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBtb2NrUlNWUHMsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrRXFSYSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxUmIgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0UiA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxUmEgfSk7XG5cbiAgICAgIG1vY2tGcm9tLm1vY2tJbXBsZW1lbnRhdGlvbigodGFibGU6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAodGFibGUgPT09ICdhY3Rpdml0aWVzJykge1xuICAgICAgICAgIHJldHVybiB7IHNlbGVjdDogbW9ja1NlbGVjdEEgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWJsZSA9PT0gJ3JzdnBzJykge1xuICAgICAgICAgIHJldHVybiB7IHNlbGVjdDogbW9ja1NlbGVjdFIgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cFNlcnZpY2UuY2hlY2tDYXBhY2l0eUF2YWlsYWJsZSgnYWN0aXZpdHktMScsIDMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmF2YWlsYWJsZSkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLm1lc3NhZ2UpLnRvQ29udGFpbignNSBzcG90cyByZW1haW5pbmcnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGF2YWlsYWJsZSBmYWxzZSB3aGVuIGNhcGFjaXR5IHdvdWxkIGJlIGV4Y2VlZGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0FjdGl2aXR5ID0geyBjYXBhY2l0eTogMTAsIG5hbWU6ICdBY3Rpdml0eScgfTtcbiAgICAgIGNvbnN0IG1vY2tSU1ZQcyA9IFt7IGd1ZXN0X2NvdW50OiA4IH1dOyAvLyA4IGF0dGVuZGluZywgMiBhdmFpbGFibGVcblxuICAgICAgLy8gTW9jayBhY3Rpdml0eSBxdWVyeVxuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG1vY2tBY3Rpdml0eSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcUEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2luZ2xlOiBtb2NrU2luZ2xlIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdEEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcUEgfSk7XG5cbiAgICAgIC8vIE1vY2sgUlNWUHMgcXVlcnlcbiAgICAgIGNvbnN0IG1vY2tFcVJiID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbW9ja1JTVlBzLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbW9ja0VxUmEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcVJiIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdFIgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcVJhIH0pO1xuXG4gICAgICBtb2NrRnJvbS5tb2NrSW1wbGVtZW50YXRpb24oKHRhYmxlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKHRhYmxlID09PSAnYWN0aXZpdGllcycpIHtcbiAgICAgICAgICByZXR1cm4geyBzZWxlY3Q6IG1vY2tTZWxlY3RBIH07XG4gICAgICAgIH0gZWxzZSBpZiAodGFibGUgPT09ICdyc3ZwcycpIHtcbiAgICAgICAgICByZXR1cm4geyBzZWxlY3Q6IG1vY2tTZWxlY3RSIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJzdnBTZXJ2aWNlLmNoZWNrQ2FwYWNpdHlBdmFpbGFibGUoJ2FjdGl2aXR5LTEnLCA1KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5hdmFpbGFibGUpLnRvQmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEubWVzc2FnZSkudG9Db250YWluKCdjYW5ub3QgYWRkIDUgbW9yZSBndWVzdChzKScpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gYXZhaWxhYmxlIHRydWUgd2hlbiBubyBjYXBhY2l0eSBsaW1pdCBpcyBzZXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQWN0aXZpdHkgPSB7IGNhcGFjaXR5OiBudWxsLCBuYW1lOiAnT3BlbiBBY3Rpdml0eScgfTtcbiAgICAgIGNvbnN0IG1vY2tSU1ZQcyA9IFt7IGd1ZXN0X2NvdW50OiAxMDAgfV07XG5cbiAgICAgIC8vIE1vY2sgYWN0aXZpdHkgcXVlcnlcbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBtb2NrQWN0aXZpdHksXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrRXFBID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHNpbmdsZTogbW9ja1NpbmdsZSB9KTtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3RBID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXFBIH0pO1xuXG4gICAgICAvLyBNb2NrIFJTVlBzIHF1ZXJ5XG4gICAgICBjb25zdCBtb2NrRXFSYiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG1vY2tSU1ZQcyxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcVJhID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXFSYiB9KTtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3RSID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXFSYSB9KTtcblxuICAgICAgbW9ja0Zyb20ubW9ja0ltcGxlbWVudGF0aW9uKCh0YWJsZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmICh0YWJsZSA9PT0gJ2FjdGl2aXRpZXMnKSB7XG4gICAgICAgICAgcmV0dXJuIHsgc2VsZWN0OiBtb2NrU2VsZWN0QSB9O1xuICAgICAgICB9IGVsc2UgaWYgKHRhYmxlID09PSAncnN2cHMnKSB7XG4gICAgICAgICAgcmV0dXJuIHsgc2VsZWN0OiBtb2NrU2VsZWN0UiB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwU2VydmljZS5jaGVja0NhcGFjaXR5QXZhaWxhYmxlKCdhY3Rpdml0eS0xJywgNTApO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmF2YWlsYWJsZSkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLm1lc3NhZ2UpLnRvQ29udGFpbignTm8gY2FwYWNpdHkgbGltaXQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2VuZm9yY2VDYXBhY2l0eUxpbWl0JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3Mgd2hlbiBjYXBhY2l0eSBsaW1pdCBpcyBub3QgZXhjZWVkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQWN0aXZpdHkgPSB7IGNhcGFjaXR5OiAxMCwgbmFtZTogJ0FjdGl2aXR5JyB9O1xuICAgICAgY29uc3QgbW9ja1JTVlBzID0gW3sgZ3Vlc3RfY291bnQ6IDUgfV07IC8vIDUgYXR0ZW5kaW5nXG5cbiAgICAgIC8vIE1vY2sgYWN0aXZpdHkgcXVlcnlcbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBtb2NrQWN0aXZpdHksXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrRXFBID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHNpbmdsZTogbW9ja1NpbmdsZSB9KTtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3RBID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXFBIH0pO1xuXG4gICAgICAvLyBNb2NrIFJTVlBzIHF1ZXJ5XG4gICAgICBjb25zdCBtb2NrRXFSYiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG1vY2tSU1ZQcyxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcVJhID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXFSYiB9KTtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3RSID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXFSYSB9KTtcblxuICAgICAgbW9ja0Zyb20ubW9ja0ltcGxlbWVudGF0aW9uKCh0YWJsZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmICh0YWJsZSA9PT0gJ2FjdGl2aXRpZXMnKSB7XG4gICAgICAgICAgcmV0dXJuIHsgc2VsZWN0OiBtb2NrU2VsZWN0QSB9O1xuICAgICAgICB9IGVsc2UgaWYgKHRhYmxlID09PSAncnN2cHMnKSB7XG4gICAgICAgICAgcmV0dXJuIHsgc2VsZWN0OiBtb2NrU2VsZWN0UiB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwU2VydmljZS5lbmZvcmNlQ2FwYWNpdHlMaW1pdCgnYWN0aXZpdHktMScsIDMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBDQVBBQ0lUWV9FWENFRURFRCB3aGVuIGxpbWl0IHdvdWxkIGJlIGV4Y2VlZGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0FjdGl2aXR5ID0geyBjYXBhY2l0eTogMTAsIG5hbWU6ICdBY3Rpdml0eScgfTtcbiAgICAgIGNvbnN0IG1vY2tSU1ZQcyA9IFt7IGd1ZXN0X2NvdW50OiA4IH1dOyAvLyA4IGF0dGVuZGluZ1xuXG4gICAgICAvLyBNb2NrIGFjdGl2aXR5IHF1ZXJ5XG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbW9ja0FjdGl2aXR5LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbW9ja0VxQSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzaW5nbGU6IG1vY2tTaW5nbGUgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0QSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxQSB9KTtcblxuICAgICAgLy8gTW9jayBSU1ZQcyBxdWVyeVxuICAgICAgY29uc3QgbW9ja0VxUmIgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBtb2NrUlNWUHMsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrRXFSYSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxUmIgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0UiA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxUmEgfSk7XG5cbiAgICAgIG1vY2tGcm9tLm1vY2tJbXBsZW1lbnRhdGlvbigodGFibGU6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAodGFibGUgPT09ICdhY3Rpdml0aWVzJykge1xuICAgICAgICAgIHJldHVybiB7IHNlbGVjdDogbW9ja1NlbGVjdEEgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWJsZSA9PT0gJ3JzdnBzJykge1xuICAgICAgICAgIHJldHVybiB7IHNlbGVjdDogbW9ja1NlbGVjdFIgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnN2cFNlcnZpY2UuZW5mb3JjZUNhcGFjaXR5TGltaXQoJ2FjdGl2aXR5LTEnLCA1KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdDQVBBQ0lUWV9FWENFRURFRCcpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignMTMvMTAnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYWNjb3VudCBmb3IgZXhpc3RpbmcgUlNWUCB3aGVuIHVwZGF0aW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0FjdGl2aXR5ID0geyBjYXBhY2l0eTogMTAsIG5hbWU6ICdBY3Rpdml0eScgfTtcbiAgICAgIGNvbnN0IG1vY2tSU1ZQcyA9IFt7IGd1ZXN0X2NvdW50OiA4IH1dOyAvLyA4IGF0dGVuZGluZ1xuICAgICAgY29uc3QgbW9ja0V4aXN0aW5nUlNWUCA9IHsgZ3Vlc3RfY291bnQ6IDMsIHN0YXR1czogJ2F0dGVuZGluZycgfTtcblxuICAgICAgLy8gTW9jayBhY3Rpdml0eSBxdWVyeSAoZmlyc3QgY2FsbClcbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUxID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbW9ja0FjdGl2aXR5LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbW9ja0VxQSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzaW5nbGU6IG1vY2tTaW5nbGUxIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdEEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcUEgfSk7XG5cbiAgICAgIC8vIE1vY2sgUlNWUHMgcXVlcnkgKHNlY29uZCBjYWxsKVxuICAgICAgY29uc3QgbW9ja0VxUmIgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBtb2NrUlNWUHMsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrRXFSYSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxUmIgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0UiA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxUmEgfSk7XG5cbiAgICAgIC8vIE1vY2sgZXhpc3RpbmcgUlNWUCBxdWVyeSAodGhpcmQgY2FsbClcbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUyID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbW9ja0V4aXN0aW5nUlNWUCxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcUUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2luZ2xlOiBtb2NrU2luZ2xlMiB9KTtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3RFID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXFFIH0pO1xuXG4gICAgICBsZXQgY2FsbENvdW50ID0gMDtcbiAgICAgIG1vY2tGcm9tLm1vY2tJbXBsZW1lbnRhdGlvbigodGFibGU6IHN0cmluZykgPT4ge1xuICAgICAgICBjYWxsQ291bnQrKztcbiAgICAgICAgaWYgKHRhYmxlID09PSAnYWN0aXZpdGllcycpIHtcbiAgICAgICAgICByZXR1cm4geyBzZWxlY3Q6IG1vY2tTZWxlY3RBIH07XG4gICAgICAgIH0gZWxzZSBpZiAodGFibGUgPT09ICdyc3ZwcycgJiYgY2FsbENvdW50ID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIHsgc2VsZWN0OiBtb2NrU2VsZWN0UiB9O1xuICAgICAgICB9IGVsc2UgaWYgKHRhYmxlID09PSAncnN2cHMnICYmIGNhbGxDb3VudCA9PT0gMykge1xuICAgICAgICAgIHJldHVybiB7IHNlbGVjdDogbW9ja1NlbGVjdEUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgICB9KTtcblxuICAgICAgLy8gTmV3IHRvdGFsOiA4IC0gMyArIDQgPSA5ICh3aXRoaW4gbGltaXQpXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwU2VydmljZS5lbmZvcmNlQ2FwYWNpdHlMaW1pdCgnYWN0aXZpdHktMScsIDQsICdleGlzdGluZy1yc3ZwLWlkJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3Mgd2hlbiBubyBjYXBhY2l0eSBsaW1pdCBpcyBzZXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQWN0aXZpdHkgPSB7IGNhcGFjaXR5OiBudWxsLCBuYW1lOiAnT3BlbiBBY3Rpdml0eScgfTtcbiAgICAgIGNvbnN0IG1vY2tSU1ZQcyA9IFt7IGd1ZXN0X2NvdW50OiAxMDAgfV07XG5cbiAgICAgIC8vIE1vY2sgYWN0aXZpdHkgcXVlcnlcbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBtb2NrQWN0aXZpdHksXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrRXFBID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHNpbmdsZTogbW9ja1NpbmdsZSB9KTtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3RBID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXFBIH0pO1xuXG4gICAgICAvLyBNb2NrIFJTVlBzIHF1ZXJ5XG4gICAgICBjb25zdCBtb2NrRXFSYiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG1vY2tSU1ZQcyxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcVJhID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXFSYiB9KTtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3RSID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXFSYSB9KTtcblxuICAgICAgbW9ja0Zyb20ubW9ja0ltcGxlbWVudGF0aW9uKCh0YWJsZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmICh0YWJsZSA9PT0gJ2FjdGl2aXRpZXMnKSB7XG4gICAgICAgICAgcmV0dXJuIHsgc2VsZWN0OiBtb2NrU2VsZWN0QSB9O1xuICAgICAgICB9IGVsc2UgaWYgKHRhYmxlID09PSAncnN2cHMnKSB7XG4gICAgICAgICAgcmV0dXJuIHsgc2VsZWN0OiBtb2NrU2VsZWN0UiB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByc3ZwU2VydmljZS5lbmZvcmNlQ2FwYWNpdHlMaW1pdCgnYWN0aXZpdHktMScsIDUwKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwiU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSIsImplc3QiLCJtb2NrIiwic2FuaXRpemVJbnB1dCIsImZuIiwiaW5wdXQiLCJ0cmltIiwiRVJST1JfQ09ERVMiLCJWQUxJREFUSU9OX0VSUk9SIiwiREFUQUJBU0VfRVJST1IiLCJVTktOT1dOX0VSUk9SIiwiTk9UX0ZPVU5EIiwiRFVQTElDQVRFX0VOVFJZIiwiQ0FQQUNJVFlfRVhDRUVERUQiLCJtb2NrRnJvbSIsIm1vY2tTdXBhYmFzZUNsaWVudCIsImZyb20iLCJjcmVhdGVDbGllbnQiLCJfX21vY2tGcm9tIiwicnN2cFNlcnZpY2VNb2R1bGUiLCJyZXF1aXJlIiwicnN2cFNlcnZpY2UiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwidmFsaWREYXRhIiwiZ3Vlc3RfaWQiLCJldmVudF9pZCIsInN0YXR1cyIsImd1ZXN0X2NvdW50IiwiZGlldGFyeV9ub3RlcyIsInNwZWNpYWxfcmVxdWlyZW1lbnRzIiwibm90ZXMiLCJpdCIsIm1vY2tSU1ZQIiwiaWQiLCJhY3Rpdml0eV9pZCIsInJlc3BvbmRlZF9hdCIsImNyZWF0ZWRfYXQiLCJ1cGRhdGVkX2F0IiwibW9ja1NpbmdsZSIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiZGF0YSIsImVycm9yIiwibW9ja1NlbGVjdCIsIm1vY2tSZXR1cm5WYWx1ZSIsInNpbmdsZSIsIm1vY2tJbnNlcnQiLCJzZWxlY3QiLCJpbnNlcnQiLCJyZXN1bHQiLCJjcmVhdGUiLCJleHBlY3QiLCJzdWNjZXNzIiwidG9CZSIsImludmFsaWREYXRhIiwiY29kZSIsIm1lc3NhZ2UiLCJtYWxpY2lvdXNEYXRhIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJhdHRlbmRpbmdEYXRhIiwib2JqZWN0Q29udGFpbmluZyIsImFueSIsIlN0cmluZyIsInBlbmRpbmdEYXRhIiwidW5kZWZpbmVkIiwibW9ja0VxIiwiZXEiLCJnZXQiLCJ1cGRhdGVEYXRhIiwibW9ja1VwZGF0ZWRSU1ZQIiwibW9ja1VwZGF0ZSIsInVwZGF0ZSIsInN0YXR1c1VwZGF0ZSIsIm1vY2tEZWxldGUiLCJkZWxldGUiLCJkZWxldGVSU1ZQIiwibW9ja1JTVlBzIiwibW9ja09yZGVyIiwiY291bnQiLCJtb2NrUmFuZ2UiLCJvcmRlciIsInJhbmdlIiwiZmlsdGVycyIsInBhZ2UiLCJwYWdlX3NpemUiLCJsaXN0IiwicnN2cHMiLCJ0b0hhdmVMZW5ndGgiLCJ0b3RhbCIsIm1vY2tBY3Rpdml0eSIsImNhcGFjaXR5IiwibmFtZSIsIm1vY2tFcTEiLCJtb2NrU2VsZWN0MSIsIm1vY2tFcTMiLCJtb2NrRXEyIiwibW9ja1NlbGVjdDIiLCJjYWxsQ291bnQiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJ0YWJsZSIsImNhbGN1bGF0ZUFjdGl2aXR5Q2FwYWNpdHkiLCJhdHRlbmRpbmdfY291bnQiLCJhdmFpbGFibGUiLCJ0b0JlTnVsbCIsIm1vY2tBY3Rpdml0aWVzIiwibW9ja05vdCIsIm5vdCIsIm1vY2tTaW5nbGUxIiwibW9ja0VxQTEiLCJtb2NrU2VsZWN0QTEiLCJtb2NrRXFSMWIiLCJtb2NrRXFSMWEiLCJtb2NrU2VsZWN0UjEiLCJtb2NrU2luZ2xlMiIsIm1vY2tFcUEyIiwibW9ja1NlbGVjdEEyIiwibW9ja0VxUjJiIiwiQXJyYXkiLCJmaWxsIiwibW9ja0VxUjJhIiwibW9ja1NlbGVjdFIyIiwiZ2VuZXJhdGVDYXBhY2l0eUFsZXJ0cyIsIndhcm5pbmdBbGVydCIsImZpbmQiLCJhbGVydCIsImFsZXJ0X2xldmVsIiwidG9CZURlZmluZWQiLCJhY3Rpdml0eV9uYW1lIiwidXRpbGl6YXRpb25fcGVyY2VudGFnZSIsImZ1bGxBbGVydCIsIm1vY2tFcUEiLCJtb2NrU2VsZWN0QSIsIm1vY2tFcVJiIiwibW9ja0VxUmEiLCJtb2NrU2VsZWN0UiIsImNoZWNrQ2FwYWNpdHlBdmFpbGFibGUiLCJ0b0NvbnRhaW4iLCJlbmZvcmNlQ2FwYWNpdHlMaW1pdCIsIm1vY2tFeGlzdGluZ1JTVlAiLCJtb2NrRXFFIiwibW9ja1NlbGVjdEUiXSwibWFwcGluZ3MiOiI7Ozs7eUJBQXVEO0FBR3ZELGtDQUFrQztBQUNsQ0EsUUFBUUMsR0FBRyxDQUFDQyx3QkFB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