b553e27609a9f379b27ebfd86e2f2dc4
"use strict";
// Mock Supabase before importing the service
jest.mock('@/lib/supabase', ()=>({
        supabase: {
            from: jest.fn()
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _cronService = require("./cronService");
// Get the mocked supabase client
const { supabase } = require('@/lib/supabase');
const mockFrom = supabase.from;
describe('cronService', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe('executeCronJob', ()=>{
        it('should return success when job function completes successfully', async ()=>{
            const mockJobFunction = jest.fn().mockResolvedValue({
                itemsProcessed: 10,
                itemsFailed: 0
            });
            // Mock successful job log creation
            const mockJobLog = {
                id: 'job-log-123',
                job_type: 'rsvp_deadline_reminders',
                status: 'running',
                started_at: '2024-01-01T10:00:00Z'
            };
            const mockSingle = jest.fn().mockResolvedValue({
                data: mockJobLog,
                error: null
            });
            const mockSelect = jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockInsert = jest.fn().mockReturnValue({
                select: mockSelect
            });
            const mockEq = jest.fn().mockResolvedValue({
                data: null,
                error: null
            });
            const mockUpdate = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValueOnce({
                insert: mockInsert
            }) // For startJobLog
            .mockReturnValueOnce({
                update: mockUpdate
            }); // For completeJobLog
            const result = await (0, _cronService.executeCronJob)('rsvp_deadline_reminders', mockJobFunction);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.jobType).toBe('rsvp_deadline_reminders');
                expect(result.data.status).toBe('completed');
                expect(result.data.itemsProcessed).toBe(10);
                expect(result.data.itemsFailed).toBe(0);
            }
            expect(mockJobFunction).toHaveBeenCalled();
        });
        it('should return success with completed status when job has failures', async ()=>{
            const mockJobFunction = jest.fn().mockResolvedValue({
                itemsProcessed: 8,
                itemsFailed: 2
            });
            const mockJobLog = {
                id: 'job-log-123',
                job_type: 'scheduled_email_processing',
                status: 'running',
                started_at: '2024-01-01T10:00:00Z'
            };
            const mockSingle = jest.fn().mockResolvedValue({
                data: mockJobLog,
                error: null
            });
            const mockSelect = jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockInsert = jest.fn().mockReturnValue({
                select: mockSelect
            });
            const mockEq = jest.fn().mockResolvedValue({
                data: null,
                error: null
            });
            const mockUpdate = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValueOnce({
                insert: mockInsert
            }).mockReturnValueOnce({
                update: mockUpdate
            });
            const result = await (0, _cronService.executeCronJob)('scheduled_email_processing', mockJobFunction);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.status).toBe('completed');
                expect(result.data.itemsProcessed).toBe(8);
                expect(result.data.itemsFailed).toBe(2);
            }
        });
        it('should return DATABASE_ERROR when job log creation fails', async ()=>{
            const mockJobFunction = jest.fn();
            const mockSingle = jest.fn().mockResolvedValue({
                data: null,
                error: {
                    message: 'Database connection failed',
                    code: 'CONNECTION_ERROR'
                }
            });
            const mockSelect = jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockInsert = jest.fn().mockReturnValue({
                select: mockSelect
            });
            mockFrom.mockReturnValue({
                insert: mockInsert
            });
            const result = await (0, _cronService.executeCronJob)('temp_file_cleanup', mockJobFunction);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('DATABASE_ERROR');
            }
            expect(mockJobFunction).not.toHaveBeenCalled();
        });
        it('should return CRON_JOB_ERROR when job function throws error', async ()=>{
            const mockJobFunction = jest.fn().mockRejectedValue(new Error('Job failed'));
            const mockJobLog = {
                id: 'job-log-123',
                job_type: 'expired_session_cleanup',
                status: 'running',
                started_at: '2024-01-01T10:00:00Z'
            };
            const mockSingle = jest.fn().mockResolvedValue({
                data: mockJobLog,
                error: null
            });
            const mockSelect = jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockInsert = jest.fn().mockReturnValue({
                select: mockSelect
            });
            const mockEq = jest.fn().mockResolvedValue({
                data: null,
                error: null
            });
            const mockUpdate = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValueOnce({
                insert: mockInsert
            }).mockReturnValueOnce({
                update: mockUpdate
            });
            const result = await (0, _cronService.executeCronJob)('expired_session_cleanup', mockJobFunction);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('CRON_JOB_ERROR');
                expect(result.error.message).toContain('Job failed');
            }
        });
        it('should update job log with failure when job function fails', async ()=>{
            const mockJobFunction = jest.fn().mockRejectedValue(new Error('Job failed'));
            const mockJobLog = {
                id: 'job-log-123',
                job_type: 'expired_session_cleanup',
                status: 'running',
                started_at: '2024-01-01T10:00:00Z'
            };
            const mockSingle = jest.fn().mockResolvedValue({
                data: mockJobLog,
                error: null
            });
            const mockSelect = jest.fn().mockReturnValue({
                single: mockSingle
            });
            const mockInsert = jest.fn().mockReturnValue({
                select: mockSelect
            });
            const mockEq = jest.fn().mockResolvedValue({
                data: null,
                error: null
            });
            const mockUpdate = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValueOnce({
                insert: mockInsert
            }).mockReturnValueOnce({
                update: mockUpdate
            });
            await (0, _cronService.executeCronJob)('expired_session_cleanup', mockJobFunction);
            // Verify update was called with failure status
            expect(mockUpdate).toHaveBeenCalledWith({
                status: 'failed',
                completed_at: expect.any(String),
                duration_ms: expect.any(Number),
                items_processed: 0,
                items_failed: 0,
                error_message: 'Job failed'
            });
        });
    });
    describe('getJobLogs', ()=>{
        it('should return success with job logs when no filters provided', async ()=>{
            const mockLogs = [
                {
                    id: 'log-1',
                    job_type: 'rsvp_deadline_reminders',
                    status: 'completed',
                    started_at: '2024-01-01T10:00:00Z',
                    completed_at: '2024-01-01T10:05:00Z',
                    duration_ms: 300000,
                    items_processed: 10,
                    items_failed: 0
                },
                {
                    id: 'log-2',
                    job_type: 'temp_file_cleanup',
                    status: 'completed',
                    started_at: '2024-01-01T11:00:00Z',
                    completed_at: '2024-01-01T11:02:00Z',
                    duration_ms: 120000,
                    items_processed: 5,
                    items_failed: 0
                }
            ];
            const mockLimit = jest.fn().mockResolvedValue({
                data: mockLogs,
                error: null
            });
            const mockOrder = jest.fn().mockReturnValue({
                limit: mockLimit
            });
            const mockSelect = jest.fn().mockReturnValue({
                order: mockOrder
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await (0, _cronService.getJobLogs)();
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data).toEqual(mockLogs);
            }
        });
        it.skip('should return success with filtered job logs when job type provided', async ()=>{
            const mockLogs = [
                {
                    id: 'log-1',
                    job_type: 'rsvp_deadline_reminders',
                    status: 'completed',
                    started_at: '2024-01-01T10:00:00Z',
                    completed_at: '2024-01-01T10:05:00Z',
                    duration_ms: 300000,
                    items_processed: 10,
                    items_failed: 0
                }
            ];
            // Mock the query chain: from -> select -> order -> limit -> eq
            // The final query object is awaited directly with destructuring
            const mockQuery = {
                then: jest.fn().mockResolvedValue({
                    data: mockLogs,
                    error: null
                }),
                eq: jest.fn().mockReturnThis()
            };
            const mockLimit = jest.fn().mockReturnValue(mockQuery);
            const mockOrder = jest.fn().mockReturnValue({
                limit: mockLimit
            });
            const mockSelect = jest.fn().mockReturnValue({
                order: mockOrder
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await (0, _cronService.getJobLogs)('rsvp_deadline_reminders', 50);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data).toEqual(mockLogs);
            }
        });
        it('should return DATABASE_ERROR when query fails', async ()=>{
            const mockLimit = jest.fn().mockResolvedValue({
                data: null,
                error: {
                    message: 'Database connection failed',
                    code: 'CONNECTION_ERROR'
                }
            });
            const mockOrder = jest.fn().mockReturnValue({
                limit: mockLimit
            });
            const mockSelect = jest.fn().mockReturnValue({
                order: mockOrder
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await (0, _cronService.getJobLogs)();
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('DATABASE_ERROR');
            }
        });
        it('should return success with empty array when no data returned', async ()=>{
            const mockLimit = jest.fn().mockResolvedValue({
                data: null,
                error: null
            });
            const mockOrder = jest.fn().mockReturnValue({
                limit: mockLimit
            });
            const mockSelect = jest.fn().mockReturnValue({
                order: mockOrder
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await (0, _cronService.getJobLogs)();
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data).toEqual([]);
            }
        });
    });
    describe('getJobStats', ()=>{
        it('should return success with job statistics when logs exist', async ()=>{
            const mockLogs = [
                {
                    status: 'completed',
                    duration_ms: 1000,
                    items_processed: 5,
                    items_failed: 0
                },
                {
                    status: 'completed',
                    duration_ms: 2000,
                    items_processed: 3,
                    items_failed: 1
                },
                {
                    status: 'failed',
                    duration_ms: 500,
                    items_processed: 0,
                    items_failed: 2
                }
            ];
            const mockSelect = jest.fn().mockResolvedValue({
                data: mockLogs,
                error: null
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await (0, _cronService.getJobStats)();
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.totalExecutions).toBe(3);
                expect(result.data.successfulExecutions).toBe(2);
                expect(result.data.failedExecutions).toBe(1);
                expect(result.data.averageDurationMs).toBeCloseTo(1166.67, 2); // (1000+2000+500)/3
                expect(result.data.totalItemsProcessed).toBe(8);
                expect(result.data.totalItemsFailed).toBe(3);
            }
        });
        it('should return success with zero stats when no logs exist', async ()=>{
            const mockSelect = jest.fn().mockResolvedValue({
                data: [],
                error: null
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await (0, _cronService.getJobStats)();
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.totalExecutions).toBe(0);
                expect(result.data.successfulExecutions).toBe(0);
                expect(result.data.failedExecutions).toBe(0);
                expect(result.data.averageDurationMs).toBe(0);
                expect(result.data.totalItemsProcessed).toBe(0);
                expect(result.data.totalItemsFailed).toBe(0);
            }
        });
        it('should apply job type filter when provided', async ()=>{
            const mockEq = jest.fn().mockResolvedValue({
                data: [],
                error: null
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            await (0, _cronService.getJobStats)('rsvp_deadline_reminders');
            expect(mockEq).toHaveBeenCalledWith('job_type', 'rsvp_deadline_reminders');
        });
        it('should apply since filter when provided', async ()=>{
            const mockGte = jest.fn().mockResolvedValue({
                data: [],
                error: null
            });
            const mockSelect = jest.fn().mockReturnValue({
                gte: mockGte
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            await (0, _cronService.getJobStats)(undefined, '2024-01-01T00:00:00Z');
            expect(mockGte).toHaveBeenCalledWith('started_at', '2024-01-01T00:00:00Z');
        });
        it('should return DATABASE_ERROR when query fails', async ()=>{
            const mockSelect = jest.fn().mockResolvedValue({
                data: null,
                error: {
                    message: 'Database connection failed',
                    code: 'CONNECTION_ERROR'
                }
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await (0, _cronService.getJobStats)();
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('DATABASE_ERROR');
            }
        });
    });
    describe('isJobRunning', ()=>{
        it('should return success with true when job is running', async ()=>{
            const mockLimit = jest.fn().mockResolvedValue({
                data: [
                    {
                        id: 'job-1',
                        status: 'running'
                    }
                ],
                error: null
            });
            const mockEq2 = jest.fn().mockReturnValue({
                limit: mockLimit
            });
            const mockEq1 = jest.fn().mockReturnValue({
                eq: mockEq2
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq1
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await (0, _cronService.isJobRunning)('rsvp_deadline_reminders');
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data).toBe(true);
            }
        });
        it('should return success with false when job is not running', async ()=>{
            const mockLimit = jest.fn().mockResolvedValue({
                data: [],
                error: null
            });
            const mockEq2 = jest.fn().mockReturnValue({
                limit: mockLimit
            });
            const mockEq1 = jest.fn().mockReturnValue({
                eq: mockEq2
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq1
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await (0, _cronService.isJobRunning)('scheduled_email_processing');
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data).toBe(false);
            }
        });
        it('should return DATABASE_ERROR when query fails', async ()=>{
            const mockLimit = jest.fn().mockResolvedValue({
                data: null,
                error: {
                    message: 'Database connection failed',
                    code: 'CONNECTION_ERROR'
                }
            });
            const mockEq2 = jest.fn().mockReturnValue({
                limit: mockLimit
            });
            const mockEq1 = jest.fn().mockReturnValue({
                eq: mockEq2
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq1
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await (0, _cronService.isJobRunning)('temp_file_cleanup');
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.code).toBe('DATABASE_ERROR');
            }
        });
        it('should return success with false when no data returned', async ()=>{
            const mockLimit = jest.fn().mockResolvedValue({
                data: [],
                error: null
            });
            const mockEq2 = jest.fn().mockReturnValue({
                limit: mockLimit
            });
            const mockEq1 = jest.fn().mockReturnValue({
                eq: mockEq2
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq1
            });
            mockFrom.mockReturnValue({
                select: mockSelect
            });
            const result = await (0, _cronService.isJobRunning)('temp_file_cleanup');
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data).toBe(false);
            }
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvY3JvblNlcnZpY2UudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBNb2NrIFN1cGFiYXNlIGJlZm9yZSBpbXBvcnRpbmcgdGhlIHNlcnZpY2Vcbmplc3QubW9jaygnQC9saWIvc3VwYWJhc2UnLCAoKSA9PiAoe1xuICBzdXBhYmFzZToge1xuICAgIGZyb206IGplc3QuZm4oKSxcbiAgfSxcbn0pKTtcblxuaW1wb3J0IHtcbiAgZXhlY3V0ZUNyb25Kb2IsXG4gIGdldEpvYkxvZ3MsXG4gIGdldEpvYlN0YXRzLFxuICBpc0pvYlJ1bm5pbmcsXG59IGZyb20gJy4vY3JvblNlcnZpY2UnO1xuXG4vLyBHZXQgdGhlIG1vY2tlZCBzdXBhYmFzZSBjbGllbnRcbmNvbnN0IHsgc3VwYWJhc2UgfSA9IHJlcXVpcmUoJ0AvbGliL3N1cGFiYXNlJyk7XG5jb25zdCBtb2NrRnJvbSA9IHN1cGFiYXNlLmZyb20gYXMgamVzdC5Nb2NrO1xuXG5kZXNjcmliZSgnY3JvblNlcnZpY2UnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnZXhlY3V0ZUNyb25Kb2InLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2VzcyB3aGVuIGpvYiBmdW5jdGlvbiBjb21wbGV0ZXMgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0pvYkZ1bmN0aW9uID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgaXRlbXNQcm9jZXNzZWQ6IDEwLFxuICAgICAgICBpdGVtc0ZhaWxlZDogMCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgam9iIGxvZyBjcmVhdGlvblxuICAgICAgY29uc3QgbW9ja0pvYkxvZyA9IHtcbiAgICAgICAgaWQ6ICdqb2ItbG9nLTEyMycsXG4gICAgICAgIGpvYl90eXBlOiAncnN2cF9kZWFkbGluZV9yZW1pbmRlcnMnLFxuICAgICAgICBzdGF0dXM6ICdydW5uaW5nJyxcbiAgICAgICAgc3RhcnRlZF9hdDogJzIwMjQtMDEtMDFUMTA6MDA6MDBaJyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBkYXRhOiBtb2NrSm9iTG9nLCBlcnJvcjogbnVsbCB9KTtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2luZ2xlOiBtb2NrU2luZ2xlIH0pO1xuICAgICAgY29uc3QgbW9ja0luc2VydCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH0pO1xuICAgICAgY29uc3QgbW9ja1VwZGF0ZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxIH0pO1xuXG4gICAgICBtb2NrRnJvbVxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSh7IGluc2VydDogbW9ja0luc2VydCB9KSAvLyBGb3Igc3RhcnRKb2JMb2dcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoeyB1cGRhdGU6IG1vY2tVcGRhdGUgfSk7IC8vIEZvciBjb21wbGV0ZUpvYkxvZ1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjdXRlQ3JvbkpvYigncnN2cF9kZWFkbGluZV9yZW1pbmRlcnMnLCBtb2NrSm9iRnVuY3Rpb24pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmpvYlR5cGUpLnRvQmUoJ3JzdnBfZGVhZGxpbmVfcmVtaW5kZXJzJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5zdGF0dXMpLnRvQmUoJ2NvbXBsZXRlZCcpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuaXRlbXNQcm9jZXNzZWQpLnRvQmUoMTApO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuaXRlbXNGYWlsZWQpLnRvQmUoMCk7XG4gICAgICB9XG4gICAgICBleHBlY3QobW9ja0pvYkZ1bmN0aW9uKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIHdpdGggY29tcGxldGVkIHN0YXR1cyB3aGVuIGpvYiBoYXMgZmFpbHVyZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrSm9iRnVuY3Rpb24gPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBpdGVtc1Byb2Nlc3NlZDogOCxcbiAgICAgICAgaXRlbXNGYWlsZWQ6IDIsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja0pvYkxvZyA9IHtcbiAgICAgICAgaWQ6ICdqb2ItbG9nLTEyMycsXG4gICAgICAgIGpvYl90eXBlOiAnc2NoZWR1bGVkX2VtYWlsX3Byb2Nlc3NpbmcnLFxuICAgICAgICBzdGF0dXM6ICdydW5uaW5nJyxcbiAgICAgICAgc3RhcnRlZF9hdDogJzIwMjQtMDEtMDFUMTA6MDA6MDBaJyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBkYXRhOiBtb2NrSm9iTG9nLCBlcnJvcjogbnVsbCB9KTtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2luZ2xlOiBtb2NrU2luZ2xlIH0pO1xuICAgICAgY29uc3QgbW9ja0luc2VydCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH0pO1xuICAgICAgY29uc3QgbW9ja1VwZGF0ZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBlcTogbW9ja0VxIH0pO1xuXG4gICAgICBtb2NrRnJvbVxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSh7IGluc2VydDogbW9ja0luc2VydCB9KVxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSh7IHVwZGF0ZTogbW9ja1VwZGF0ZSB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhlY3V0ZUNyb25Kb2IoJ3NjaGVkdWxlZF9lbWFpbF9wcm9jZXNzaW5nJywgbW9ja0pvYkZ1bmN0aW9uKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5zdGF0dXMpLnRvQmUoJ2NvbXBsZXRlZCcpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuaXRlbXNQcm9jZXNzZWQpLnRvQmUoOCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5pdGVtc0ZhaWxlZCkudG9CZSgyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIERBVEFCQVNFX0VSUk9SIHdoZW4gam9iIGxvZyBjcmVhdGlvbiBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tKb2JGdW5jdGlvbiA9IGplc3QuZm4oKTtcblxuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6ICdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcsIGNvZGU6ICdDT05ORUNUSU9OX0VSUk9SJyB9LFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHNpbmdsZTogbW9ja1NpbmdsZSB9KTtcbiAgICAgIGNvbnN0IG1vY2tJbnNlcnQgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0pO1xuXG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBpbnNlcnQ6IG1vY2tJbnNlcnQgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4ZWN1dGVDcm9uSm9iKCd0ZW1wX2ZpbGVfY2xlYW51cCcsIG1vY2tKb2JGdW5jdGlvbik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuY29kZSkudG9CZSgnREFUQUJBU0VfRVJST1InKTtcbiAgICAgIH1cbiAgICAgIGV4cGVjdChtb2NrSm9iRnVuY3Rpb24pLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBDUk9OX0pPQl9FUlJPUiB3aGVuIGpvYiBmdW5jdGlvbiB0aHJvd3MgZXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrSm9iRnVuY3Rpb24gPSBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdKb2IgZmFpbGVkJykpO1xuXG4gICAgICBjb25zdCBtb2NrSm9iTG9nID0ge1xuICAgICAgICBpZDogJ2pvYi1sb2ctMTIzJyxcbiAgICAgICAgam9iX3R5cGU6ICdleHBpcmVkX3Nlc3Npb25fY2xlYW51cCcsXG4gICAgICAgIHN0YXR1czogJ3J1bm5pbmcnLFxuICAgICAgICBzdGFydGVkX2F0OiAnMjAyNC0wMS0wMVQxMDowMDowMFonLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRhdGE6IG1vY2tKb2JMb2csIGVycm9yOiBudWxsIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzaW5nbGU6IG1vY2tTaW5nbGUgfSk7XG4gICAgICBjb25zdCBtb2NrSW5zZXJ0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHNlbGVjdDogbW9ja1NlbGVjdCB9KTtcblxuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZGF0YTogbnVsbCwgZXJyb3I6IG51bGwgfSk7XG4gICAgICBjb25zdCBtb2NrVXBkYXRlID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXEgfSk7XG5cbiAgICAgIG1vY2tGcm9tXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKHsgaW5zZXJ0OiBtb2NrSW5zZXJ0IH0pXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKHsgdXBkYXRlOiBtb2NrVXBkYXRlIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjdXRlQ3JvbkpvYignZXhwaXJlZF9zZXNzaW9uX2NsZWFudXAnLCBtb2NrSm9iRnVuY3Rpb24pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ0NST05fSk9CX0VSUk9SJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9Db250YWluKCdKb2IgZmFpbGVkJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHVwZGF0ZSBqb2IgbG9nIHdpdGggZmFpbHVyZSB3aGVuIGpvYiBmdW5jdGlvbiBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tKb2JGdW5jdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0pvYiBmYWlsZWQnKSk7XG5cbiAgICAgIGNvbnN0IG1vY2tKb2JMb2cgPSB7XG4gICAgICAgIGlkOiAnam9iLWxvZy0xMjMnLFxuICAgICAgICBqb2JfdHlwZTogJ2V4cGlyZWRfc2Vzc2lvbl9jbGVhbnVwJyxcbiAgICAgICAgc3RhdHVzOiAncnVubmluZycsXG4gICAgICAgIHN0YXJ0ZWRfYXQ6ICcyMDI0LTAxLTAxVDEwOjAwOjAwWicsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZGF0YTogbW9ja0pvYkxvZywgZXJyb3I6IG51bGwgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHNpbmdsZTogbW9ja1NpbmdsZSB9KTtcbiAgICAgIGNvbnN0IG1vY2tJbnNlcnQgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0pO1xuXG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBkYXRhOiBudWxsLCBlcnJvcjogbnVsbCB9KTtcbiAgICAgIGNvbnN0IG1vY2tVcGRhdGUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcSB9KTtcblxuICAgICAgbW9ja0Zyb21cbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoeyBpbnNlcnQ6IG1vY2tJbnNlcnQgfSlcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoeyB1cGRhdGU6IG1vY2tVcGRhdGUgfSk7XG5cbiAgICAgIGF3YWl0IGV4ZWN1dGVDcm9uSm9iKCdleHBpcmVkX3Nlc3Npb25fY2xlYW51cCcsIG1vY2tKb2JGdW5jdGlvbik7XG5cbiAgICAgIC8vIFZlcmlmeSB1cGRhdGUgd2FzIGNhbGxlZCB3aXRoIGZhaWx1cmUgc3RhdHVzXG4gICAgICBleHBlY3QobW9ja1VwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICBzdGF0dXM6ICdmYWlsZWQnLFxuICAgICAgICBjb21wbGV0ZWRfYXQ6IGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgZHVyYXRpb25fbXM6IGV4cGVjdC5hbnkoTnVtYmVyKSxcbiAgICAgICAgaXRlbXNfcHJvY2Vzc2VkOiAwLFxuICAgICAgICBpdGVtc19mYWlsZWQ6IDAsXG4gICAgICAgIGVycm9yX21lc3NhZ2U6ICdKb2IgZmFpbGVkJyxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0Sm9iTG9ncycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIHdpdGggam9iIGxvZ3Mgd2hlbiBubyBmaWx0ZXJzIHByb3ZpZGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0xvZ3MgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ2xvZy0xJyxcbiAgICAgICAgICBqb2JfdHlwZTogJ3JzdnBfZGVhZGxpbmVfcmVtaW5kZXJzJyxcbiAgICAgICAgICBzdGF0dXM6ICdjb21wbGV0ZWQnLFxuICAgICAgICAgIHN0YXJ0ZWRfYXQ6ICcyMDI0LTAxLTAxVDEwOjAwOjAwWicsXG4gICAgICAgICAgY29tcGxldGVkX2F0OiAnMjAyNC0wMS0wMVQxMDowNTowMFonLFxuICAgICAgICAgIGR1cmF0aW9uX21zOiAzMDAwMDAsXG4gICAgICAgICAgaXRlbXNfcHJvY2Vzc2VkOiAxMCxcbiAgICAgICAgICBpdGVtc19mYWlsZWQ6IDAsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ2xvZy0yJyxcbiAgICAgICAgICBqb2JfdHlwZTogJ3RlbXBfZmlsZV9jbGVhbnVwJyxcbiAgICAgICAgICBzdGF0dXM6ICdjb21wbGV0ZWQnLFxuICAgICAgICAgIHN0YXJ0ZWRfYXQ6ICcyMDI0LTAxLTAxVDExOjAwOjAwWicsXG4gICAgICAgICAgY29tcGxldGVkX2F0OiAnMjAyNC0wMS0wMVQxMTowMjowMFonLFxuICAgICAgICAgIGR1cmF0aW9uX21zOiAxMjAwMDAsXG4gICAgICAgICAgaXRlbXNfcHJvY2Vzc2VkOiA1LFxuICAgICAgICAgIGl0ZW1zX2ZhaWxlZDogMCxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IG1vY2tMaW1pdCA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRhdGE6IG1vY2tMb2dzLCBlcnJvcjogbnVsbCB9KTtcbiAgICAgIGNvbnN0IG1vY2tPcmRlciA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBsaW1pdDogbW9ja0xpbWl0IH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBvcmRlcjogbW9ja09yZGVyIH0pO1xuXG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldEpvYkxvZ3MoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YSkudG9FcXVhbChtb2NrTG9ncyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdC5za2lwKCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3Mgd2l0aCBmaWx0ZXJlZCBqb2IgbG9ncyB3aGVuIGpvYiB0eXBlIHByb3ZpZGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0xvZ3MgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ2xvZy0xJyxcbiAgICAgICAgICBqb2JfdHlwZTogJ3JzdnBfZGVhZGxpbmVfcmVtaW5kZXJzJyxcbiAgICAgICAgICBzdGF0dXM6ICdjb21wbGV0ZWQnLFxuICAgICAgICAgIHN0YXJ0ZWRfYXQ6ICcyMDI0LTAxLTAxVDEwOjAwOjAwWicsXG4gICAgICAgICAgY29tcGxldGVkX2F0OiAnMjAyNC0wMS0wMVQxMDowNTowMFonLFxuICAgICAgICAgIGR1cmF0aW9uX21zOiAzMDAwMDAsXG4gICAgICAgICAgaXRlbXNfcHJvY2Vzc2VkOiAxMCxcbiAgICAgICAgICBpdGVtc19mYWlsZWQ6IDAsXG4gICAgICAgIH0sXG4gICAgICBdO1xuXG4gICAgICAvLyBNb2NrIHRoZSBxdWVyeSBjaGFpbjogZnJvbSAtPiBzZWxlY3QgLT4gb3JkZXIgLT4gbGltaXQgLT4gZXFcbiAgICAgIC8vIFRoZSBmaW5hbCBxdWVyeSBvYmplY3QgaXMgYXdhaXRlZCBkaXJlY3RseSB3aXRoIGRlc3RydWN0dXJpbmdcbiAgICAgIGNvbnN0IG1vY2tRdWVyeSA9IHtcbiAgICAgICAgdGhlbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZGF0YTogbW9ja0xvZ3MsIGVycm9yOiBudWxsIH0pLFxuICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBtb2NrTGltaXQgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKG1vY2tRdWVyeSk7XG4gICAgICBjb25zdCBtb2NrT3JkZXIgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgbGltaXQ6IG1vY2tMaW1pdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgb3JkZXI6IG1vY2tPcmRlciB9KTtcblxuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRKb2JMb2dzKCdyc3ZwX2RlYWRsaW5lX3JlbWluZGVycycsIDUwKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YSkudG9FcXVhbChtb2NrTG9ncyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBEQVRBQkFTRV9FUlJPUiB3aGVuIHF1ZXJ5IGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0xpbWl0ID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJywgY29kZTogJ0NPTk5FQ1RJT05fRVJST1InIH0sXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tPcmRlciA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBsaW1pdDogbW9ja0xpbWl0IH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBvcmRlcjogbW9ja09yZGVyIH0pO1xuXG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldEpvYkxvZ3MoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdEQVRBQkFTRV9FUlJPUicpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2VzcyB3aXRoIGVtcHR5IGFycmF5IHdoZW4gbm8gZGF0YSByZXR1cm5lZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tMaW1pdCA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH0pO1xuICAgICAgY29uc3QgbW9ja09yZGVyID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGxpbWl0OiBtb2NrTGltaXQgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IG9yZGVyOiBtb2NrT3JkZXIgfSk7XG5cbiAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZSh7IHNlbGVjdDogbW9ja1NlbGVjdCB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0Sm9iTG9ncygpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhKS50b0VxdWFsKFtdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldEpvYlN0YXRzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3Mgd2l0aCBqb2Igc3RhdGlzdGljcyB3aGVuIGxvZ3MgZXhpc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrTG9ncyA9IFtcbiAgICAgICAgeyBzdGF0dXM6ICdjb21wbGV0ZWQnLCBkdXJhdGlvbl9tczogMTAwMCwgaXRlbXNfcHJvY2Vzc2VkOiA1LCBpdGVtc19mYWlsZWQ6IDAgfSxcbiAgICAgICAgeyBzdGF0dXM6ICdjb21wbGV0ZWQnLCBkdXJhdGlvbl9tczogMjAwMCwgaXRlbXNfcHJvY2Vzc2VkOiAzLCBpdGVtc19mYWlsZWQ6IDEgfSxcbiAgICAgICAgeyBzdGF0dXM6ICdmYWlsZWQnLCBkdXJhdGlvbl9tczogNTAwLCBpdGVtc19wcm9jZXNzZWQ6IDAsIGl0ZW1zX2ZhaWxlZDogMiB9LFxuICAgICAgXTtcblxuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRhdGE6IG1vY2tMb2dzLCBlcnJvcjogbnVsbCB9KTtcbiAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZSh7IHNlbGVjdDogbW9ja1NlbGVjdCB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0Sm9iU3RhdHMoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS50b3RhbEV4ZWN1dGlvbnMpLnRvQmUoMyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5zdWNjZXNzZnVsRXhlY3V0aW9ucykudG9CZSgyKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmZhaWxlZEV4ZWN1dGlvbnMpLnRvQmUoMSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5hdmVyYWdlRHVyYXRpb25NcykudG9CZUNsb3NlVG8oMTE2Ni42NywgMik7IC8vICgxMDAwKzIwMDArNTAwKS8zXG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS50b3RhbEl0ZW1zUHJvY2Vzc2VkKS50b0JlKDgpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudG90YWxJdGVtc0ZhaWxlZCkudG9CZSgzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3Mgd2l0aCB6ZXJvIHN0YXRzIHdoZW4gbm8gbG9ncyBleGlzdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBkYXRhOiBbXSwgZXJyb3I6IG51bGwgfSk7XG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldEpvYlN0YXRzKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudG90YWxFeGVjdXRpb25zKS50b0JlKDApO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuc3VjY2Vzc2Z1bEV4ZWN1dGlvbnMpLnRvQmUoMCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5mYWlsZWRFeGVjdXRpb25zKS50b0JlKDApO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuYXZlcmFnZUR1cmF0aW9uTXMpLnRvQmUoMCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS50b3RhbEl0ZW1zUHJvY2Vzc2VkKS50b0JlKDApO1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEudG90YWxJdGVtc0ZhaWxlZCkudG9CZSgwKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYXBwbHkgam9iIHR5cGUgZmlsdGVyIHdoZW4gcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBkYXRhOiBbXSwgZXJyb3I6IG51bGwgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXEgfSk7XG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG5cbiAgICAgIGF3YWl0IGdldEpvYlN0YXRzKCdyc3ZwX2RlYWRsaW5lX3JlbWluZGVycycpO1xuXG4gICAgICBleHBlY3QobW9ja0VxKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnam9iX3R5cGUnLCAncnN2cF9kZWFkbGluZV9yZW1pbmRlcnMnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYXBwbHkgc2luY2UgZmlsdGVyIHdoZW4gcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrR3RlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZGF0YTogW10sIGVycm9yOiBudWxsIH0pO1xuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBndGU6IG1vY2tHdGUgfSk7XG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG5cbiAgICAgIGF3YWl0IGdldEpvYlN0YXRzKHVuZGVmaW5lZCwgJzIwMjQtMDEtMDFUMDA6MDA6MDBaJyk7XG5cbiAgICAgIGV4cGVjdChtb2NrR3RlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnc3RhcnRlZF9hdCcsICcyMDI0LTAxLTAxVDAwOjAwOjAwWicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gREFUQUJBU0VfRVJST1Igd2hlbiBxdWVyeSBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnLCBjb2RlOiAnQ09OTkVDVElPTl9FUlJPUicgfSxcbiAgICAgIH0pO1xuICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlKHsgc2VsZWN0OiBtb2NrU2VsZWN0IH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRKb2JTdGF0cygpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmNvZGUpLnRvQmUoJ0RBVEFCQVNFX0VSUk9SJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdpc0pvYlJ1bm5pbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2VzcyB3aXRoIHRydWUgd2hlbiBqb2IgaXMgcnVubmluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tMaW1pdCA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IFt7IGlkOiAnam9iLTEnLCBzdGF0dXM6ICdydW5uaW5nJyB9XSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcTIgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgbGltaXQ6IG1vY2tMaW1pdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcTEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcTIgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXExIH0pO1xuXG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGlzSm9iUnVubmluZygncnN2cF9kZWFkbGluZV9yZW1pbmRlcnMnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YSkudG9CZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3Mgd2l0aCBmYWxzZSB3aGVuIGpvYiBpcyBub3QgcnVubmluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tMaW1pdCA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRhdGE6IFtdLCBlcnJvcjogbnVsbCB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcTIgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgbGltaXQ6IG1vY2tMaW1pdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcTEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcTIgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXExIH0pO1xuXG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGlzSm9iUnVubmluZygnc2NoZWR1bGVkX2VtYWlsX3Byb2Nlc3NpbmcnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YSkudG9CZShmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBEQVRBQkFTRV9FUlJPUiB3aGVuIHF1ZXJ5IGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0xpbWl0ID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJywgY29kZTogJ0NPTk5FQ1RJT05fRVJST1InIH0sXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcTIgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgbGltaXQ6IG1vY2tMaW1pdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcTEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcTIgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXExIH0pO1xuXG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGlzSm9iUnVubmluZygndGVtcF9maWxlX2NsZWFudXAnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5jb2RlKS50b0JlKCdEQVRBQkFTRV9FUlJPUicpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2VzcyB3aXRoIGZhbHNlIHdoZW4gbm8gZGF0YSByZXR1cm5lZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tMaW1pdCA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRhdGE6IFtdLCBlcnJvcjogbnVsbCB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcTIgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgbGltaXQ6IG1vY2tMaW1pdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcTEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZXE6IG1vY2tFcTIgfSk7XG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGVxOiBtb2NrRXExIH0pO1xuXG4gICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWUoeyBzZWxlY3Q6IG1vY2tTZWxlY3QgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGlzSm9iUnVubmluZygndGVtcF9maWxlX2NsZWFudXAnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YSkudG9CZShmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwic3VwYWJhc2UiLCJmcm9tIiwiZm4iLCJyZXF1aXJlIiwibW9ja0Zyb20iLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiaXQiLCJtb2NrSm9iRnVuY3Rpb24iLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsIml0ZW1zUHJvY2Vzc2VkIiwiaXRlbXNGYWlsZWQiLCJtb2NrSm9iTG9nIiwiaWQiLCJqb2JfdHlwZSIsInN0YXR1cyIsInN0YXJ0ZWRfYXQiLCJtb2NrU2luZ2xlIiwiZGF0YSIsImVycm9yIiwibW9ja1NlbGVjdCIsIm1vY2tSZXR1cm5WYWx1ZSIsInNpbmdsZSIsIm1vY2tJbnNlcnQiLCJzZWxlY3QiLCJtb2NrRXEiLCJtb2NrVXBkYXRlIiwiZXEiLCJtb2NrUmV0dXJuVmFsdWVPbmNlIiwiaW5zZXJ0IiwidXBkYXRlIiwicmVzdWx0IiwiZXhlY3V0ZUNyb25Kb2IiLCJleHBlY3QiLCJzdWNjZXNzIiwidG9CZSIsImpvYlR5cGUiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwibWVzc2FnZSIsImNvZGUiLCJub3QiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIkVycm9yIiwidG9Db250YWluIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJjb21wbGV0ZWRfYXQiLCJhbnkiLCJTdHJpbmciLCJkdXJhdGlvbl9tcyIsIk51bWJlciIsIml0ZW1zX3Byb2Nlc3NlZCIsIml0ZW1zX2ZhaWxlZCIsImVycm9yX21lc3NhZ2UiLCJtb2NrTG9ncyIsIm1vY2tMaW1pdCIsIm1vY2tPcmRlciIsImxpbWl0Iiwib3JkZXIiLCJnZXRKb2JMb2dzIiwidG9FcXVhbCIsInNraXAiLCJtb2NrUXVlcnkiLCJ0aGVuIiwibW9ja1JldHVyblRoaXMiLCJnZXRKb2JTdGF0cyIsInRvdGFsRXhlY3V0aW9ucyIsInN1Y2Nlc3NmdWxFeGVjdXRpb25zIiwiZmFpbGVkRXhlY3V0aW9ucyIsImF2ZXJhZ2VEdXJhdGlvbk1zIiwidG9CZUNsb3NlVG8iLCJ0b3RhbEl0ZW1zUHJvY2Vzc2VkIiwidG90YWxJdGVtc0ZhaWxlZCIsIm1vY2tHdGUiLCJndGUiLCJ1bmRlZmluZWQiLCJtb2NrRXEyIiwibW9ja0VxMSIsImlzSm9iUnVubmluZyJdLCJtYXBwaW5ncyI6IjtBQUFBLDZDQUE2QztBQUM3Q0EsS0FBS0MsSUFBSSxDQUFDLGtCQUFrQixJQUFPLENBQUE7UUFDakNDLFVBQVU7WUFDUkMsTUFBTUgsS0FBS0ksRUFBRTtRQUNmO0lBQ0YsQ0FBQTs7Ozs2QkFPTztBQUVQLGlDQUFpQztBQUNqQyxNQUFNLEVBQUVGLFFBQVEsRUFBRSxHQUFHRyxRQUFRO0FBQzdCLE1BQU1DLFdBQVdKLFNBQVNDLElBQUk7QUFFOUJJLFNBQVMsZUFBZTtJQUN0QkMsV0FBVztRQUNUUixLQUFLUyxhQUFhO0lBQ3BCO0lBRUFGLFNBQVMsa0JBQWtCO1FBQ3pCRyxHQUFHLGtFQUFrRTtZQUNuRSxNQUFNQyxrQkFBa0JYLEtBQUtJLEVBQUUsR0FBR1EsaUJBQWlCLENBQUM7Z0JBQ2xEQyxnQkFBZ0I7Z0JBQ2hCQyxhQUFhO1lBQ2Y7WUFFQSxtQ0FBbUM7WUFDbkMsTUFBTUMsYUFBYTtnQkFDakJDLElBQUk7Z0JBQ0pDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JDLFlBQVk7WUFDZDtZQUVBLE1BQU1DLGFBQWFwQixLQUFLSSxFQUFFLEdBQUdRLGlCQUFpQixDQUFDO2dCQUFFUyxNQUFNTjtnQkFBWU8sT0FBTztZQUFLO1lBQy9FLE1BQU1DLGFBQWF2QixLQUFLSSxFQUFFLEdBQUdvQixlQUFlLENBQUM7Z0JBQUVDLFFBQVFMO1lBQVc7WUFDbEUsTUFBTU0sYUFBYTFCLEtBQUtJLEVBQUUsR0FBR29CLGVBQWUsQ0FBQztnQkFBRUcsUUFBUUo7WUFBVztZQUVsRSxNQUFNSyxTQUFTNUIsS0FBS0ksRUFBRSxHQUFHUSxpQkFBaUIsQ0FBQztnQkFBRVMsTUFBTTtnQkFBTUMsT0FBTztZQUFLO1lBQ3JFLE1BQU1PLGFBQWE3QixLQUFLSSxFQUFFLEdB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