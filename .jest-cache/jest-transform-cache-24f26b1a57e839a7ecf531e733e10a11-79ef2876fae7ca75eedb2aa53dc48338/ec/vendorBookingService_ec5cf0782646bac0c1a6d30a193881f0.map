{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/services/vendorBookingService.ts"],"sourcesContent":["/**\n * Vendor Booking Service\n * \n * Handles vendor-to-activity/event associations and cost propagation\n * when vendor information changes.\n * \n * Requirements: 8.2, 8.4, 8.9, 8.10\n */\n\nimport { createClient } from '@supabase/supabase-js';\nimport {\n  createVendorBookingSchema,\n  updateVendorBookingSchema,\n  vendorBookingFilterSchema,\n  type CreateVendorBookingDTO,\n  type UpdateVendorBookingDTO,\n  type VendorBookingFilterDTO,\n  type VendorBooking,\n  type PaginatedVendorBookings,\n  type VendorBookingWithDetails,\n} from '../schemas/vendorBookingSchemas';\nimport { sanitizeInput } from '../utils/sanitization';\n\n// Result type for consistent error handling\ntype Result<T> =\n  | { success: true; data: T }\n  | { success: false; error: { code: string; message: string; details?: unknown } };\n\n// Initialize Supabase client\nconst supabase = createClient(\n  process.env.NEXT_PUBLIC_SUPABASE_URL!,\n  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n);\n\n/**\n * Creates a new vendor booking linking a vendor to an activity or event.\n * \n * @param data - Booking data including vendor ID, activity/event ID, and booking date\n * @returns Result containing the created booking or error details\n * \n * @example\n * const result = await vendorBookingService.create({\n *   vendorId: 'vendor-uuid',\n *   activityId: 'activity-uuid',\n *   bookingDate: '2025-06-15',\n * });\n */\nexport async function create(data: CreateVendorBookingDTO): Promise<Result<VendorBooking>> {\n  try {\n    // 1. Validate\n    const validation = createVendorBookingSchema.safeParse(data);\n    if (!validation.success) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Validation failed',\n          details: validation.error.issues,\n        },\n      };\n    }\n\n    // 2. Sanitize user input\n    const sanitized = {\n      ...validation.data,\n      notes: validation.data.notes ? sanitizeInput(validation.data.notes) : null,\n    };\n\n    // 3. Database operation\n    const { data: booking, error } = await supabase\n      .from('vendor_bookings')\n      .insert({\n        vendor_id: sanitized.vendorId,\n        activity_id: sanitized.activityId,\n        event_id: sanitized.eventId,\n        booking_date: sanitized.bookingDate,\n        notes: sanitized.notes,\n      })\n      .select()\n      .single();\n\n    if (error) {\n      return {\n        success: false,\n        error: {\n          code: 'DATABASE_ERROR',\n          message: error.message,\n          details: error,\n        },\n      };\n    }\n\n    return {\n      success: true,\n      data: mapBookingFromDb(booking),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error occurred',\n      },\n    };\n  }\n}\n\n/**\n * Retrieves a vendor booking by ID.\n * \n * @param id - Booking UUID\n * @returns Result containing the booking or error details\n */\nexport async function get(id: string): Promise<Result<VendorBooking>> {\n  try {\n    const { data: booking, error } = await supabase\n      .from('vendor_bookings')\n      .select('*')\n      .eq('id', id)\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return {\n          success: false,\n          error: {\n            code: 'NOT_FOUND',\n            message: 'Vendor booking not found',\n          },\n        };\n      }\n      return {\n        success: false,\n        error: {\n          code: 'DATABASE_ERROR',\n          message: error.message,\n          details: error,\n        },\n      };\n    }\n\n    return {\n      success: true,\n      data: mapBookingFromDb(booking),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error occurred',\n      },\n    };\n  }\n}\n\n/**\n * Updates an existing vendor booking.\n * \n * @param id - Booking UUID\n * @param data - Partial booking data to update\n * @returns Result containing the updated booking or error details\n */\nexport async function update(id: string, data: UpdateVendorBookingDTO): Promise<Result<VendorBooking>> {\n  try {\n    // 1. Validate\n    const validation = updateVendorBookingSchema.safeParse(data);\n    if (!validation.success) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Validation failed',\n          details: validation.error.issues,\n        },\n      };\n    }\n\n    // 2. Sanitize user input\n    const sanitized: Record<string, unknown> = {};\n    if (validation.data.notes !== undefined) {\n      sanitized.notes = validation.data.notes ? sanitizeInput(validation.data.notes) : null;\n    }\n    if (validation.data.vendorId !== undefined) {\n      sanitized.vendor_id = validation.data.vendorId;\n    }\n    if (validation.data.activityId !== undefined) {\n      sanitized.activity_id = validation.data.activityId;\n    }\n    if (validation.data.eventId !== undefined) {\n      sanitized.event_id = validation.data.eventId;\n    }\n    if (validation.data.bookingDate !== undefined) {\n      sanitized.booking_date = validation.data.bookingDate;\n    }\n\n    // 3. Database operation\n    const { data: booking, error } = await supabase\n      .from('vendor_bookings')\n      .update(sanitized)\n      .eq('id', id)\n      .select()\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return {\n          success: false,\n          error: {\n            code: 'NOT_FOUND',\n            message: 'Vendor booking not found',\n          },\n        };\n      }\n      return {\n        success: false,\n        error: {\n          code: 'DATABASE_ERROR',\n          message: error.message,\n          details: error,\n        },\n      };\n    }\n\n    return {\n      success: true,\n      data: mapBookingFromDb(booking),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error occurred',\n      },\n    };\n  }\n}\n\n/**\n * Deletes a vendor booking from the system.\n * \n * @param id - Booking UUID\n * @returns Result indicating success or error details\n */\nexport async function deleteBooking(id: string): Promise<Result<void>> {\n  try {\n    const { error } = await supabase\n      .from('vendor_bookings')\n      .delete()\n      .eq('id', id);\n\n    if (error) {\n      return {\n        success: false,\n        error: {\n          code: 'DATABASE_ERROR',\n          message: error.message,\n          details: error,\n        },\n      };\n    }\n\n    return { success: true, data: undefined };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error occurred',\n      },\n    };\n  }\n}\n\n/**\n * Lists vendor bookings with optional filtering and pagination.\n * \n * @param filters - Optional filters for vendor, activity, event, and pagination\n * @returns Result containing paginated booking list or error details\n */\nexport async function list(filters: VendorBookingFilterDTO = {}): Promise<Result<PaginatedVendorBookings>> {\n  try {\n    // Validate filters\n    const validation = vendorBookingFilterSchema.safeParse(filters);\n    if (!validation.success) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Invalid filters',\n          details: validation.error.issues,\n        },\n      };\n    }\n\n    const { vendorId, activityId, eventId, page = 1, pageSize = 50 } = validation.data;\n\n    // Build query\n    let query = supabase.from('vendor_bookings').select('*', { count: 'exact' });\n\n    if (vendorId) {\n      query = query.eq('vendor_id', vendorId);\n    }\n    if (activityId) {\n      query = query.eq('activity_id', activityId);\n    }\n    if (eventId) {\n      query = query.eq('event_id', eventId);\n    }\n\n    // Apply pagination\n    const from = (page - 1) * pageSize;\n    const to = from + pageSize - 1;\n    query = query.range(from, to).order('booking_date', { ascending: true });\n\n    const { data: bookings, error, count } = await query;\n\n    if (error) {\n      return {\n        success: false,\n        error: {\n          code: 'DATABASE_ERROR',\n          message: error.message,\n          details: error,\n        },\n      };\n    }\n\n    const total = count || 0;\n    const totalPages = Math.ceil(total / pageSize);\n\n    return {\n      success: true,\n      data: {\n        bookings: bookings.map(mapBookingFromDb),\n        total,\n        page,\n        pageSize,\n        totalPages,\n      },\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error occurred',\n      },\n    };\n  }\n}\n\n/**\n * Gets vendor bookings with full details including vendor and activity/event names.\n * \n * @param filters - Optional filters for vendor, activity, event\n * @returns Result containing bookings with details or error details\n */\nexport async function listWithDetails(filters: VendorBookingFilterDTO = {}): Promise<Result<VendorBookingWithDetails[]>> {\n  try {\n    // Validate filters\n    const validation = vendorBookingFilterSchema.safeParse(filters);\n    if (!validation.success) {\n      return {\n        success: false,\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Invalid filters',\n          details: validation.error.issues,\n        },\n      };\n    }\n\n    const { vendorId, activityId, eventId } = validation.data;\n\n    // Build query with joins\n    let query = supabase\n      .from('vendor_bookings')\n      .select(`\n        *,\n        vendors (id, name, category),\n        activities (id, name),\n        events (id, name)\n      `);\n\n    if (vendorId) {\n      query = query.eq('vendor_id', vendorId);\n    }\n    if (activityId) {\n      query = query.eq('activity_id', activityId);\n    }\n    if (eventId) {\n      query = query.eq('event_id', eventId);\n    }\n\n    const { data: bookings, error } = await query.order('booking_date', { ascending: true });\n\n    if (error) {\n      return {\n        success: false,\n        error: {\n          code: 'DATABASE_ERROR',\n          message: error.message,\n          details: error,\n        },\n      };\n    }\n\n    const bookingsWithDetails: VendorBookingWithDetails[] = bookings.map((booking: any) => ({\n      id: booking.id,\n      vendorId: booking.vendor_id,\n      vendorName: booking.vendors?.name || 'Unknown',\n      vendorCategory: booking.vendors?.category || 'other',\n      activityId: booking.activity_id,\n      activityName: booking.activities?.name || null,\n      eventId: booking.event_id,\n      eventName: booking.events?.name || null,\n      bookingDate: booking.booking_date,\n      notes: booking.notes,\n      createdAt: booking.created_at,\n    }));\n\n    return {\n      success: true,\n      data: bookingsWithDetails,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error occurred',\n      },\n    };\n  }\n}\n\n/**\n * Gets all bookings for a specific vendor.\n * \n * @param vendorId - Vendor UUID\n * @returns Result containing vendor's bookings or error details\n */\nexport async function getVendorBookings(vendorId: string): Promise<Result<VendorBookingWithDetails[]>> {\n  return listWithDetails({ vendorId });\n}\n\n/**\n * Gets all bookings for a specific activity.\n * \n * @param activityId - Activity UUID\n * @returns Result containing activity's bookings or error details\n */\nexport async function getActivityBookings(activityId: string): Promise<Result<VendorBookingWithDetails[]>> {\n  return listWithDetails({ activityId });\n}\n\n/**\n * Gets all bookings for a specific event.\n * \n * @param eventId - Event UUID\n * @returns Result containing event's bookings or error details\n */\nexport async function getEventBookings(eventId: string): Promise<Result<VendorBookingWithDetails[]>> {\n  return listWithDetails({ eventId });\n}\n\n/**\n * Propagates vendor cost changes to all related bookings.\n * This is called when a vendor's cost is updated to ensure\n * budget calculations reflect the new cost.\n * \n * @param vendorId - Vendor UUID\n * @returns Result indicating success or error details\n */\nexport async function propagateVendorCostChange(vendorId: string): Promise<Result<void>> {\n  try {\n    // Get all bookings for this vendor\n    const bookingsResult = await getVendorBookings(vendorId);\n    if (!bookingsResult.success) {\n      return bookingsResult as Result<void>;\n    }\n\n    // Note: In a real implementation, this would trigger recalculation\n    // of budget totals for all activities/events associated with this vendor.\n    // For now, we just return success as the budget service will\n    // recalculate on-demand when requested.\n\n    return { success: true, data: undefined };\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        code: 'UNKNOWN_ERROR',\n        message: error instanceof Error ? error.message : 'Unknown error occurred',\n      },\n    };\n  }\n}\n\n/**\n * Maps database booking record to VendorBooking type.\n */\nfunction mapBookingFromDb(dbBooking: any): VendorBooking {\n  return {\n    id: dbBooking.id,\n    vendorId: dbBooking.vendor_id,\n    activityId: dbBooking.activity_id,\n    eventId: dbBooking.event_id,\n    bookingDate: dbBooking.booking_date,\n    notes: dbBooking.notes,\n    createdAt: dbBooking.created_at,\n  };\n}\n"],"names":["create","deleteBooking","get","getActivityBookings","getEventBookings","getVendorBookings","list","listWithDetails","propagateVendorCostChange","update","supabase","createClient","process","env","NEXT_PUBLIC_SUPABASE_URL","NEXT_PUBLIC_SUPABASE_ANON_KEY","data","validation","createVendorBookingSchema","safeParse","success","error","code","message","details","issues","sanitized","notes","sanitizeInput","booking","from","insert","vendor_id","vendorId","activity_id","activityId","event_id","eventId","booking_date","bookingDate","select","single","mapBookingFromDb","Error","id","eq","updateVendorBookingSchema","undefined","delete","filters","vendorBookingFilterSchema","page","pageSize","query","count","to","range","order","ascending","bookings","total","totalPages","Math","ceil","map","bookingsWithDetails","vendorName","vendors","name","vendorCategory","category","activityName","activities","eventName","events","createdAt","created_at","bookingsResult","dbBooking"],"mappings":"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"}