3e158ff3b7b46fc3c99cfc6f512333cd
/**
 * All Routes Smoke Tests
 * 
 * Quick validation that all API routes respond without crashing.
 * These tests don't validate business logic, just that:
 * - Routes exist
 * - They return proper HTTP status codes
 * - They don't crash with 500 errors
 * - They return JSON responses
 * 
 * Run these tests frequently to catch broken routes early.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _testServer = require("../helpers/testServer");
// All API routes in the application
const API_ROUTES = {
    // Admin routes
    admin: [
        '/api/admin/locations',
        '/api/admin/guests',
        '/api/admin/guest-groups',
        '/api/admin/events',
        '/api/admin/activities',
        '/api/admin/accommodations',
        '/api/admin/room-types',
        '/api/admin/vendors',
        '/api/admin/budget',
        '/api/admin/photos',
        '/api/admin/emails',
        '/api/admin/content-pages',
        '/api/admin/home-page',
        '/api/admin/rsvps',
        '/api/admin/rsvp-analytics',
        '/api/admin/transportation',
        '/api/admin/audit-logs',
        '/api/admin/settings'
    ],
    // Guest routes
    guest: [
        '/api/guest/rsvp',
        '/api/guest/profile'
    ],
    // Public routes
    public: [
        '/api/health'
    ]
};
describe('Smoke Tests - All API Routes', ()=>{
    let serverUrl;
    beforeAll(async ()=>{
        serverUrl = await (0, _testServer.startTestServer)();
    }, 60000);
    afterAll(async ()=>{
        await (0, _testServer.stopTestServer)();
    }, 10000);
    describe('Admin Routes', ()=>{
        API_ROUTES.admin.forEach((route)=>{
            it(`${route} should respond`, async ()=>{
                const response = await fetch(`${serverUrl}${route}`);
                // Should not crash (500 error)
                expect(response.status).not.toBe(500);
                // Should return JSON
                const contentType = response.headers.get('content-type');
                expect(contentType).toContain('application/json');
                // Should have proper error structure if not authenticated
                if (response.status === 401) {
                    const data = await response.json();
                    expect(data.success).toBe(false);
                    expect(data.error).toBeDefined();
                    expect(data.error.code).toBe('UNAUTHORIZED');
                }
            });
        });
    });
    describe('Guest Routes', ()=>{
        API_ROUTES.guest.forEach((route)=>{
            it(`${route} should respond`, async ()=>{
                const response = await fetch(`${serverUrl}${route}`);
                // Should not crash
                expect(response.status).not.toBe(500);
                // Should return JSON
                const contentType = response.headers.get('content-type');
                expect(contentType).toContain('application/json');
            });
        });
    });
    describe('Public Routes', ()=>{
        API_ROUTES.public.forEach((route)=>{
            it(`${route} should respond`, async ()=>{
                const response = await fetch(`${serverUrl}${route}`);
                // Should be accessible
                expect(response.ok).toBe(true);
                // Should return JSON
                const contentType = response.headers.get('content-type');
                expect(contentType).toContain('application/json');
            });
        });
    });
    describe('Dynamic Routes', ()=>{
        it('should handle dynamic route params', async ()=>{
            const dynamicRoutes = [
                '/api/admin/locations/test-id',
                '/api/admin/guests/test-id',
                '/api/admin/events/test-id',
                '/api/admin/accommodations/test-id/room-types'
            ];
            for (const route of dynamicRoutes){
                const response = await fetch(`${serverUrl}${route}`);
                // Should not crash with params error
                expect(response.status).not.toBe(500);
                // Should return 401 (auth) or 404 (not found), not 500 (crash)
                expect([
                    401,
                    404
                ]).toContain(response.status);
            }
        });
    });
    describe('HTTP Methods', ()=>{
        it('should handle GET requests', async ()=>{
            const response = await fetch(`${serverUrl}/api/admin/locations`);
            expect([
                200,
                401
            ]).toContain(response.status);
        });
        it('should handle POST requests', async ()=>{
            const response = await fetch(`${serverUrl}/api/admin/locations`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    name: 'Test'
                })
            });
            expect([
                200,
                201,
                400,
                401
            ]).toContain(response.status);
        });
        it('should handle PUT requests', async ()=>{
            const response = await fetch(`${serverUrl}/api/admin/locations/test-id`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    name: 'Test'
                })
            });
            expect([
                200,
                400,
                401,
                404
            ]).toContain(response.status);
        });
        it('should handle DELETE requests', async ()=>{
            const response = await fetch(`${serverUrl}/api/admin/locations/test-id`, {
                method: 'DELETE'
            });
            expect([
                200,
                401,
                404
            ]).toContain(response.status);
        });
    });
    describe('Error Responses', ()=>{
        it('should return proper error structure', async ()=>{
            const response = await fetch(`${serverUrl}/api/admin/locations`);
            const data = await response.json();
            if (!data.success) {
                expect(data.error).toBeDefined();
                expect(data.error.code).toBeDefined();
                expect(data.error.message).toBeDefined();
                expect(typeof data.error.code).toBe('string');
                expect(typeof data.error.message).toBe('string');
            }
        });
    });
});
/**
 * Performance Benchmarks
 * 
 * Track response times to catch performance regressions
 */ describe('Smoke Tests - Performance', ()=>{
    let serverUrl;
    beforeAll(async ()=>{
        serverUrl = await (0, _testServer.startTestServer)();
    }, 60000);
    afterAll(async ()=>{
        await (0, _testServer.stopTestServer)();
    }, 10000);
    it('should respond within reasonable time', async ()=>{
        const start = Date.now();
        await fetch(`${serverUrl}/api/health`);
        const duration = Date.now() - start;
        // Should respond within 1 second
        expect(duration).toBeLessThan(1000);
    });
    it('should handle concurrent requests', async ()=>{
        const requests = Array(10).fill(null).map(()=>fetch(`${serverUrl}/api/health`));
        const responses = await Promise.all(requests);
        // All should succeed
        responses.forEach((response)=>{
            expect(response.ok).toBe(true);
        });
    });
}); /**
 * NOTE: These are smoke tests, not comprehensive tests.
 * They verify routes exist and respond, but don't test:
 * - Business logic
 * - Data validation
 * - Authentication flows
 * - Database operations
 * 
 * For comprehensive testing, see:
 * - Unit tests (business logic)
 * - Integration tests (API + database)
 * - E2E tests (complete workflows)
 */ 

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvX190ZXN0c19fL3Ntb2tlL2FsbFJvdXRlcy5zbW9rZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQWxsIFJvdXRlcyBTbW9rZSBUZXN0c1xuICogXG4gKiBRdWljayB2YWxpZGF0aW9uIHRoYXQgYWxsIEFQSSByb3V0ZXMgcmVzcG9uZCB3aXRob3V0IGNyYXNoaW5nLlxuICogVGhlc2UgdGVzdHMgZG9uJ3QgdmFsaWRhdGUgYnVzaW5lc3MgbG9naWMsIGp1c3QgdGhhdDpcbiAqIC0gUm91dGVzIGV4aXN0XG4gKiAtIFRoZXkgcmV0dXJuIHByb3BlciBIVFRQIHN0YXR1cyBjb2Rlc1xuICogLSBUaGV5IGRvbid0IGNyYXNoIHdpdGggNTAwIGVycm9yc1xuICogLSBUaGV5IHJldHVybiBKU09OIHJlc3BvbnNlc1xuICogXG4gKiBSdW4gdGhlc2UgdGVzdHMgZnJlcXVlbnRseSB0byBjYXRjaCBicm9rZW4gcm91dGVzIGVhcmx5LlxuICovXG5cbmltcG9ydCB7IHN0YXJ0VGVzdFNlcnZlciwgc3RvcFRlc3RTZXJ2ZXIsIGdldFRlc3RTZXJ2ZXJVcmwgfSBmcm9tICcuLi9oZWxwZXJzL3Rlc3RTZXJ2ZXInO1xuXG4vLyBBbGwgQVBJIHJvdXRlcyBpbiB0aGUgYXBwbGljYXRpb25cbmNvbnN0IEFQSV9ST1VURVMgPSB7XG4gIC8vIEFkbWluIHJvdXRlc1xuICBhZG1pbjogW1xuICAgICcvYXBpL2FkbWluL2xvY2F0aW9ucycsXG4gICAgJy9hcGkvYWRtaW4vZ3Vlc3RzJyxcbiAgICAnL2FwaS9hZG1pbi9ndWVzdC1ncm91cHMnLFxuICAgICcvYXBpL2FkbWluL2V2ZW50cycsXG4gICAgJy9hcGkvYWRtaW4vYWN0aXZpdGllcycsXG4gICAgJy9hcGkvYWRtaW4vYWNjb21tb2RhdGlvbnMnLFxuICAgICcvYXBpL2FkbWluL3Jvb20tdHlwZXMnLFxuICAgICcvYXBpL2FkbWluL3ZlbmRvcnMnLFxuICAgICcvYXBpL2FkbWluL2J1ZGdldCcsXG4gICAgJy9hcGkvYWRtaW4vcGhvdG9zJyxcbiAgICAnL2FwaS9hZG1pbi9lbWFpbHMnLFxuICAgICcvYXBpL2FkbWluL2NvbnRlbnQtcGFnZXMnLFxuICAgICcvYXBpL2FkbWluL2hvbWUtcGFnZScsXG4gICAgJy9hcGkvYWRtaW4vcnN2cHMnLFxuICAgICcvYXBpL2FkbWluL3JzdnAtYW5hbHl0aWNzJyxcbiAgICAnL2FwaS9hZG1pbi90cmFuc3BvcnRhdGlvbicsXG4gICAgJy9hcGkvYWRtaW4vYXVkaXQtbG9ncycsXG4gICAgJy9hcGkvYWRtaW4vc2V0dGluZ3MnLFxuICBdLFxuICBcbiAgLy8gR3Vlc3Qgcm91dGVzXG4gIGd1ZXN0OiBbXG4gICAgJy9hcGkvZ3Vlc3QvcnN2cCcsXG4gICAgJy9hcGkvZ3Vlc3QvcHJvZmlsZScsXG4gIF0sXG4gIFxuICAvLyBQdWJsaWMgcm91dGVzXG4gIHB1YmxpYzogW1xuICAgICcvYXBpL2hlYWx0aCcsXG4gIF0sXG59O1xuXG5kZXNjcmliZSgnU21va2UgVGVzdHMgLSBBbGwgQVBJIFJvdXRlcycsICgpID0+IHtcbiAgbGV0IHNlcnZlclVybDogc3RyaW5nO1xuICBcbiAgYmVmb3JlQWxsKGFzeW5jICgpID0+IHtcbiAgICBzZXJ2ZXJVcmwgPSBhd2FpdCBzdGFydFRlc3RTZXJ2ZXIoKTtcbiAgfSwgNjAwMDApO1xuICBcbiAgYWZ0ZXJBbGwoYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IHN0b3BUZXN0U2VydmVyKCk7XG4gIH0sIDEwMDAwKTtcbiAgXG4gIGRlc2NyaWJlKCdBZG1pbiBSb3V0ZXMnLCAoKSA9PiB7XG4gICAgQVBJX1JPVVRFUy5hZG1pbi5mb3JFYWNoKHJvdXRlID0+IHtcbiAgICAgIGl0KGAke3JvdXRlfSBzaG91bGQgcmVzcG9uZGAsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtzZXJ2ZXJVcmx9JHtyb3V0ZX1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3VsZCBub3QgY3Jhc2ggKDUwMCBlcnJvcilcbiAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykubm90LnRvQmUoNTAwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3VsZCByZXR1cm4gSlNPTlxuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcbiAgICAgICAgZXhwZWN0KGNvbnRlbnRUeXBlKS50b0NvbnRhaW4oJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3VsZCBoYXZlIHByb3BlciBlcnJvciBzdHJ1Y3R1cmUgaWYgbm90IGF1dGhlbnRpY2F0ZWRcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZURlZmluZWQoKTtcbiAgICAgICAgICBleHBlY3QoZGF0YS5lcnJvci5jb2RlKS50b0JlKCdVTkFVVEhPUklaRUQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICBcbiAgZGVzY3JpYmUoJ0d1ZXN0IFJvdXRlcycsICgpID0+IHtcbiAgICBBUElfUk9VVEVTLmd1ZXN0LmZvckVhY2gocm91dGUgPT4ge1xuICAgICAgaXQoYCR7cm91dGV9IHNob3VsZCByZXNwb25kYCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3NlcnZlclVybH0ke3JvdXRlfWApO1xuICAgICAgICBcbiAgICAgICAgLy8gU2hvdWxkIG5vdCBjcmFzaFxuICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS5ub3QudG9CZSg1MDApO1xuICAgICAgICBcbiAgICAgICAgLy8gU2hvdWxkIHJldHVybiBKU09OXG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuICAgICAgICBleHBlY3QoY29udGVudFR5cGUpLnRvQ29udGFpbignYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICBcbiAgZGVzY3JpYmUoJ1B1YmxpYyBSb3V0ZXMnLCAoKSA9PiB7XG4gICAgQVBJX1JPVVRFUy5wdWJsaWMuZm9yRWFjaChyb3V0ZSA9PiB7XG4gICAgICBpdChgJHtyb3V0ZX0gc2hvdWxkIHJlc3BvbmRgLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7c2VydmVyVXJsfSR7cm91dGV9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTaG91bGQgYmUgYWNjZXNzaWJsZVxuICAgICAgICBleHBlY3QocmVzcG9uc2Uub2spLnRvQmUodHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTaG91bGQgcmV0dXJuIEpTT05cbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG4gICAgICAgIGV4cGVjdChjb250ZW50VHlwZSkudG9Db250YWluKCdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIFxuICBkZXNjcmliZSgnRHluYW1pYyBSb3V0ZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZHluYW1pYyByb3V0ZSBwYXJhbXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkeW5hbWljUm91dGVzID0gW1xuICAgICAgICAnL2FwaS9hZG1pbi9sb2NhdGlvbnMvdGVzdC1pZCcsXG4gICAgICAgICcvYXBpL2FkbWluL2d1ZXN0cy90ZXN0LWlkJyxcbiAgICAgICAgJy9hcGkvYWRtaW4vZXZlbnRzL3Rlc3QtaWQnLFxuICAgICAgICAnL2FwaS9hZG1pbi9hY2NvbW1vZGF0aW9ucy90ZXN0LWlkL3Jvb20tdHlwZXMnLFxuICAgICAgXTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCByb3V0ZSBvZiBkeW5hbWljUm91dGVzKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7c2VydmVyVXJsfSR7cm91dGV9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTaG91bGQgbm90IGNyYXNoIHdpdGggcGFyYW1zIGVycm9yXG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLm5vdC50b0JlKDUwMCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTaG91bGQgcmV0dXJuIDQwMSAoYXV0aCkgb3IgNDA0IChub3QgZm91bmQpLCBub3QgNTAwIChjcmFzaClcbiAgICAgICAgZXhwZWN0KFs0MDEsIDQwNF0pLnRvQ29udGFpbihyZXNwb25zZS5zdGF0dXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgXG4gIGRlc2NyaWJlKCdIVFRQIE1ldGhvZHMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgR0VUIHJlcXVlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtzZXJ2ZXJVcmx9L2FwaS9hZG1pbi9sb2NhdGlvbnNgKTtcbiAgICAgIGV4cGVjdChbMjAwLCA0MDFdKS50b0NvbnRhaW4ocmVzcG9uc2Uuc3RhdHVzKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBQT1NUIHJlcXVlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtzZXJ2ZXJVcmx9L2FwaS9hZG1pbi9sb2NhdGlvbnNgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBuYW1lOiAnVGVzdCcgfSksXG4gICAgICB9KTtcbiAgICAgIGV4cGVjdChbMjAwLCAyMDEsIDQwMCwgNDAxXSkudG9Db250YWluKHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgfSk7XG4gICAgXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgUFVUIHJlcXVlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtzZXJ2ZXJVcmx9L2FwaS9hZG1pbi9sb2NhdGlvbnMvdGVzdC1pZGAsIHtcbiAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgbmFtZTogJ1Rlc3QnIH0pLFxuICAgICAgfSk7XG4gICAgICBleHBlY3QoWzIwMCwgNDAwLCA0MDEsIDQwNF0pLnRvQ29udGFpbihyZXNwb25zZS5zdGF0dXMpO1xuICAgIH0pO1xuICAgIFxuICAgIGl0KCdzaG91bGQgaGFuZGxlIERFTEVURSByZXF1ZXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7c2VydmVyVXJsfS9hcGkvYWRtaW4vbG9jYXRpb25zL3Rlc3QtaWRgLCB7XG4gICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICB9KTtcbiAgICAgIGV4cGVjdChbMjAwLCA0MDEsIDQwNF0pLnRvQ29udGFpbihyZXNwb25zZS5zdGF0dXMpO1xuICAgIH0pO1xuICB9KTtcbiAgXG4gIGRlc2NyaWJlKCdFcnJvciBSZXNwb25zZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gcHJvcGVyIGVycm9yIHN0cnVjdHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7c2VydmVyVXJsfS9hcGkvYWRtaW4vbG9jYXRpb25zYCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgXG4gICAgICBpZiAoIWRhdGEuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZURlZmluZWQoKTtcbiAgICAgICAgZXhwZWN0KGRhdGEuZXJyb3IuY29kZSkudG9CZURlZmluZWQoKTtcbiAgICAgICAgZXhwZWN0KGRhdGEuZXJyb3IubWVzc2FnZSkudG9CZURlZmluZWQoKTtcbiAgICAgICAgZXhwZWN0KHR5cGVvZiBkYXRhLmVycm9yLmNvZGUpLnRvQmUoJ3N0cmluZycpO1xuICAgICAgICBleHBlY3QodHlwZW9mIGRhdGEuZXJyb3IubWVzc2FnZSkudG9CZSgnc3RyaW5nJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbi8qKlxuICogUGVyZm9ybWFuY2UgQmVuY2htYXJrc1xuICogXG4gKiBUcmFjayByZXNwb25zZSB0aW1lcyB0byBjYXRjaCBwZXJmb3JtYW5jZSByZWdyZXNzaW9uc1xuICovXG5kZXNjcmliZSgnU21va2UgVGVzdHMgLSBQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgbGV0IHNlcnZlclVybDogc3RyaW5nO1xuICBcbiAgYmVmb3JlQWxsKGFzeW5jICgpID0+IHtcbiAgICBzZXJ2ZXJVcmwgPSBhd2FpdCBzdGFydFRlc3RTZXJ2ZXIoKTtcbiAgfSwgNjAwMDApO1xuICBcbiAgYWZ0ZXJBbGwoYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IHN0b3BUZXN0U2VydmVyKCk7XG4gIH0sIDEwMDAwKTtcbiAgXG4gIGl0KCdzaG91bGQgcmVzcG9uZCB3aXRoaW4gcmVhc29uYWJsZSB0aW1lJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBhd2FpdCBmZXRjaChgJHtzZXJ2ZXJVcmx9L2FwaS9oZWFsdGhgKTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydDtcbiAgICBcbiAgICAvLyBTaG91bGQgcmVzcG9uZCB3aXRoaW4gMSBzZWNvbmRcbiAgICBleHBlY3QoZHVyYXRpb24pLnRvQmVMZXNzVGhhbigxMDAwKTtcbiAgfSk7XG4gIFxuICBpdCgnc2hvdWxkIGhhbmRsZSBjb25jdXJyZW50IHJlcXVlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlcXVlc3RzID0gQXJyYXkoMTApLmZpbGwobnVsbCkubWFwKCgpID0+XG4gICAgICBmZXRjaChgJHtzZXJ2ZXJVcmx9L2FwaS9oZWFsdGhgKVxuICAgICk7XG4gICAgXG4gICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVxdWVzdHMpO1xuICAgIFxuICAgIC8vIEFsbCBzaG91bGQgc3VjY2VlZFxuICAgIHJlc3BvbnNlcy5mb3JFYWNoKHJlc3BvbnNlID0+IHtcbiAgICAgIGV4cGVjdChyZXNwb25zZS5vaykudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBOT1RFOiBUaGVzZSBhcmUgc21va2UgdGVzdHMsIG5vdCBjb21wcmVoZW5zaXZlIHRlc3RzLlxuICogVGhleSB2ZXJpZnkgcm91dGVzIGV4aXN0IGFuZCByZXNwb25kLCBidXQgZG9uJ3QgdGVzdDpcbiAqIC0gQnVzaW5lc3MgbG9naWNcbiAqIC0gRGF0YSB2YWxpZGF0aW9uXG4gKiAtIEF1dGhlbnRpY2F0aW9uIGZsb3dzXG4gKiAtIERhdGFiYXNlIG9wZXJhdGlvbnNcbiAqIFxuICogRm9yIGNvbXByZWhlbnNpdmUgdGVzdGluZywgc2VlOlxuICogLSBVbml0IHRlc3RzIChidXNpbmVzcyBsb2dpYylcbiAqIC0gSW50ZWdyYXRpb24gdGVzdHMgKEFQSSArIGRhdGFiYXNlKVxuICogLSBFMkUgdGVzdHMgKGNvbXBsZXRlIHdvcmtmbG93cylcbiAqL1xuIl0sIm5hbWVzIjpbIkFQSV9ST1VURVMiLCJhZG1pbiIsImd1ZXN0IiwicHVibGljIiwiZGVzY3JpYmUiLCJzZXJ2ZXJVcmwiLCJiZWZvcmVBbGwiLCJzdGFydFRlc3RTZXJ2ZXIiLCJhZnRlckFsbCIsInN0b3BUZXN0U2VydmVyIiwiZm9yRWFjaCIsInJvdXRlIiwiaXQiLCJyZXNwb25zZSIsImZldGNoIiwiZXhwZWN0Iiwic3RhdHVzIiwibm90IiwidG9CZSIsImNvbnRlbnRUeXBlIiwiaGVhZGVycyIsImdldCIsInRvQ29udGFpbiIsImRhdGEiLCJqc29uIiwic3VjY2VzcyIsImVycm9yIiwidG9CZURlZmluZWQiLCJjb2RlIiwib2siLCJkeW5hbWljUm91dGVzIiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJuYW1lIiwibWVzc2FnZSIsInN0YXJ0IiwiRGF0ZSIsIm5vdyIsImR1cmF0aW9uIiwidG9CZUxlc3NUaGFuIiwicmVxdWVzdHMiLCJBcnJheSIsImZpbGwiLCJtYXAiLCJyZXNwb25zZXMiLCJQcm9taXNlIiwiYWxsIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Q0FXQzs7Ozs0QkFFaUU7QUFFbEUsb0NBQW9DO0FBQ3BDLE1BQU1BLGFBQWE7SUFDakIsZUFBZTtJQUNmQyxPQUFPO1FBQ0w7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0Q7SUFFRCxlQUFlO0lBQ2ZDLE9BQU87UUFDTDtRQUNBO0tBQ0Q7SUFFRCxnQkFBZ0I7SUFDaEJDLFFBQVE7UUFDTjtLQUNEO0FBQ0g7QUFFQUMsU0FBUyxnQ0FBZ0M7SUFDdkMsSUFBSUM7SUFFSkMsVUFBVTtRQUNSRCxZQUFZLE1BQU1FLElBQUFBLDJCQUFlO0lBQ25DLEdBQUc7SUFFSEMsU0FBUztRQUNQLE1BQU1DLElBQUFBLDBCQUFjO0lBQ3RCLEdBQUc7SUFFSEwsU0FBUyxnQkFBZ0I7UUFDdkJKLFdBQVdDLEtBQUssQ0FBQ1MsT0FBTyxDQUFDQyxDQUFBQTtZQUN2QkMsR0FBRyxHQUFHRCxNQUFNLGVBQWUsQ0FBQyxFQUFFO2dCQUM1QixNQUFNRSxXQUFXLE1BQU1DLE1BQU0sR0FBR1QsWUFBWU0sT0FBTztnQkFFbkQsK0JBQStCO2dCQUMvQkksT0FBT0YsU0FBU0csTUFBTSxFQUFFQyxHQUFHLENBQUNDLElBQUksQ0FBQztnQkFFakMscUJBQXFCO2dCQUNyQixNQUFNQyxjQUFjTixTQUFTTyxPQUFPLENBQUNDLEdBQUcsQ0FBQztnQkFDekNOLE9BQU9JLGFBQWFHLFNBQVMsQ0FBQztnQkFFOUIsMERBQTBEO2dCQUMxRCxJQUFJVCxTQUFTRyxNQUFNLEtBQUssS0FBSztvQkFDM0IsTUFBTU8sT0FBTyxNQUFNVixTQUFTVyxJQUFJO29CQUNoQ1QsT0FBT1EsS0FBS0UsT0FBTyxFQUFFUCxJQUFJLENBQUM7b0JBQzFCSCxPQUFPUSxLQUFLRyxLQUFLLEVBQUVDLFdBQVc7b0JBQzlCWixPQUFPUSxLQUFLRyxLQUFLLENBQUNFLElBQUksRUFBRVYsSUFBSSxDQUFDO2dCQUMvQjtZQUNGO1FBQ0Y7SUFDRjtJQUVBZCxTQUFTLGdCQUFnQjtRQUN2QkosV0FBV0UsS0FBSyxDQUFDUSxPQUFPLENBQUNDLENBQUFBO1lBQ3ZCQyxHQUFHLEdBQUdELE1BQU0sZUFBZSxDQUFDLEVBQUU7Z0JBQzVCLE1BQU1FLFdBQVcsTUFBTUMsTUFBTSxHQUFHVCxZQUFZTSxPQUFPO2dCQUVuRCxtQkFBbUI7Z0JBQ25CSSxPQUFPRixTQUFTRyxNQUFNLEVBQUVDLEdBQUcsQ0FBQ0MsSUFBSSxDQUFDO2dCQUVqQyxxQkFBcUI7Z0JBQ3JCLE1BQU1DLGNBQWNOLFNBQVNPLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDO2dCQUN6Q04sT0FBT0ksYUFBYUcsU0FBUyxDQUFDO1lBQ2hDO1FBQ0Y7SUFDRjtJQUVBbEIsU0FBUyxpQkFBaUI7UUFDeEJKLFdBQVdHLE1BQU0sQ0FBQ08sT0FBTyxDQUFDQyxDQUFBQTtZQUN4QkMsR0FBRyxHQUFHRCxNQUFNLGVBQWUsQ0FBQyxFQUFFO2dCQUM1QixNQUFNRSxXQUFXLE1BQU1DLE1BQU0sR0FBR1QsWUFBWU0sT0FBTztnQkFFbkQsdUJBQXVCO2dCQUN2QkksT0FBT0YsU0FBU2dCLEVBQUUsRUFBRVgsSUFBSSxDQUFDO2dCQUV6QixxQkFBcUI7Z0JBQ3JCLE1BQU1DLGNBQWNOLFNBQVNPLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDO2dCQUN6Q04sT0FBT0ksYUFBYUcsU0FBUyxDQUFDO1lBQ2hDO1FBQ0Y7SUFDRjtJQUVBbEIsU0FBUyxrQkFBa0I7UUFDekJRLEdBQUcsc0NBQXNDO1lBQ3ZDLE1BQU1rQixnQkFBZ0I7Z0JBQ3BCO2dCQUNBO2dCQUNBO2dCQUNBO2FBQ0Q7WUFFRCxLQUFLLE1BQU1uQixTQUFTbUIsY0FBZTtnQkFDakMsTUFBTWpCLFdBQVcsTUFBTUMsTUFBTSxHQUFHVCxZQUFZTSxPQUFPO2dCQUVuRCxxQ0FBcUM7Z0JBQ3JDSSxPQUFPRixTQUFTRyxNQUFNLEVBQUVDLEdBQUcsQ0FBQ0MsSUFBSSxDQUFDO2dCQUVqQywrREFBK0Q7Z0JBQy9ESCxPQUFPO29CQUFDO29CQUFLO2lCQUFJLEVBQUVPLFNBQVMsQ0FBQ1QsU0FBU0csTUFBTTtZQUM5QztRQUNGO0lBQ0Y7SUFFQVosU0FBUyxnQkFBZ0I7UUFDdkJRLEdBQUcsOEJBQThCO1lBQy9CLE1BQU1DLFdBQVcsTUFBTUMsTUFBTSxHQUFHVCxVQUFVLG9CQUFvQixDQUFDO1lBQy9EVSxPQUFPO2dCQUFDO2dCQUFLO2FBQUksRUFBRU8sU0FBUyxDQUFDVCxTQUFTRyxNQUFNO1FBQzlDO1FBRUFKLEdBQUcsK0JBQStCO1lBQ2hDLE1BQU1DLFdBQVcsTUFBTUMsTUFBTSxHQUFHVCxVQUFVLG9CQUFvQixDQUFDLEVBQUU7Z0JBQy9EMEIsUUFBUTtnQkFDUlgsU0FBUztvQkFBRSxnQkFBZ0I7Z0JBQW1CO2dCQUM5Q1ksTUFBTUMsS0FBS0MsU0FBUyxDQUFDO29CQUFFQyxNQUFNO2dCQUFPO1lBQ3RDO1lBQ0FwQixPQUFPO2dCQUFDO2dCQUFLO2dCQUFLO2dCQUFLO2FBQUksRUFBRU8sU0FBUyxDQUFDVCxTQUFTRyxNQUFNO1FBQ3hEO1FBRUFKLEdBQUcsOEJBQThCO1lBQy9CLE1BQU1DLFdBQVcsTUFBTUMsTUFBTSxHQUFHVCxVQUFVLDRCQUE0QixDQUFDLEVBQUU7Z0JBQ3ZFMEIsUUFBUTtnQkFDUlgsU0FBUztvQkFBRSxnQkFBZ0I7Z0JBQW1CO2dCQUM5Q1ksTUFBTUMsS0FBS0MsU0FBUyxDQUFDO29CQUFFQyxNQUFNO2dCQUFPO1lBQ3RDO1lBQ0FwQixPQUFPO2dCQUFDO2dCQUFLO2dCQUFLO2dCQUFLO2FBQUksRUFBRU8sU0FBUyxDQUFDVCxTQUFTRyxNQUFNO1FBQ3hEO1FBRUFKLEdBQUcsaUNBQWlDO1lBQ2xDLE1BQU1DLFdBQVcsTUFBTUMsTUFBTSxHQUFHVCxVQUFVLDRCQUE0QixDQUFDLEVBQUU7Z0JBQ3ZFMEIsUUFBUTtZQUNWO1lBQ0FoQixPQUFPO2dCQUFDO2dCQUFLO2dCQUFLO2FBQUksRUFBRU8sU0FBUyxDQUFDVCxTQUFTRyxNQUFNO1FBQ25EO0lBQ0Y7SUFFQVosU0FBUyxtQkFBbUI7UUFDMUJRLEdBQUcsd0NBQXdDO1lBQ3pDLE1BQU1DLFdBQVcsTUFBTUMsTUFBTSxHQUFHVCxVQUFVLG9CQUFvQixDQUFDO1lBQy9ELE1BQU1rQixPQUFPLE1BQU1WLFNBQVNXLElBQUk7WUFFaEMsSUFBSSxDQUFDRCxLQUFLRSxPQUFPLEVBQUU7Z0JBQ2pCVixPQUFPUSxLQUFLRyxLQUFLLEVBQUVDLFdBQVc7Z0JBQzlCWixPQUFPUSxLQUFLRyxLQUFLLENBQUNFLElBQUksRUFBRUQsV0FBVztnQkFDbkNaLE9BQU9RLEtBQUtHLEtBQUssQ0FBQ1UsT0FBTyxFQUFFVCxXQUFXO2dCQUN0Q1osT0FBTyxPQUFPUSxLQUFLRyxLQUFLLENBQUNFLElBQUksRUFBRVYsSUFBSSxDQUFDO2dCQUNwQ0gsT0FBTyxPQUFPUSxLQUFLRyxLQUFLLENBQUNVLE9BQU8sRUFBRWxCLElBQUksQ0FBQztZQUN6QztRQUNGO0lBQ0Y7QUFDRjtBQUVBOzs7O0NBSUMsR0FDRGQsU0FBUyw2QkFBNkI7SUFDcEMsSUFBSUM7SUFFSkMsVUFBVTtRQUNSRCxZQUFZLE1BQU1FLElBQUFBLDJCQUFlO0lBQ25DLEdBQUc7SUFFSEMsU0FBUztRQUNQLE1BQU1DLElBQUFBLDBCQUFjO0lBQ3RCLEdBQUc7SUFFSEcsR0FBRyx5Q0FBeUM7UUFDMUMsTUFBTXlCLFFBQVFDLEtBQUtDLEdBQUc7UUFDdEIsTUFBTXpCLE1BQU0sR0FBR1QsVUFBVSxXQUFXLENBQUM7UUFDckMsTUFBTW1DLFdBQVdGLEtBQUtDLEdBQUcsS0FBS0Y7UUFFOUIsaUNBQWlDO1FBQ2pDdEIsT0FBT3lCLFVBQVVDLFlBQVksQ0FBQztJQUNoQztJQUVBN0IsR0FBRyxxQ0FBcUM7UUFDdEMsTUFBTThCLFdBQVdDLE1BQU0sSUFBSUMsSUFBSSxDQUFDLE1BQU1DLEdBQUcsQ0FBQyxJQUN4Qy9CLE1BQU0sR0FBR1QsVUFBVSxXQUFXLENBQUM7UUFHakMsTUFBTXlDLFlBQVksTUFBTUMsUUFBUUMsR0FBRyxDQUFDTjtRQUVwQyxxQkFBcUI7UUFDckJJLFVBQVVwQyxPQUFPLENBQUNHLENBQUFBO1lBQ2hCRSxPQUFPRixTQUFTZ0IsRUFBRSxFQUFFWCxJQUFJLENBQUM7UUFDM0I7SUFDRjtBQUNGLElBRUE7Ozs7Ozs7Ozs7OztDQVlDIn0=