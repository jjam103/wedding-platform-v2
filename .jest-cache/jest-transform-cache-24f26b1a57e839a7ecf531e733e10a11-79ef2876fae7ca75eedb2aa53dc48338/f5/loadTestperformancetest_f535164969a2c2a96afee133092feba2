302e10952ac9cc923a644e50ca37656d
/**
 * Performance Test Suite: Load Testing
 * 
 * Tests system performance under load with:
 * - 100 concurrent users
 * - Bulk operations (100+ guests)
 * - API response time measurements
 * - Database query performance monitoring
 * 
 * Task: 24.4
 */ "use strict";
jest.mock('@/lib/supabase', ()=>({
        createClient: jest.fn(()=>mockSupabase)
    }));
// Mock external services
jest.mock('@/services/b2Service', ()=>({
        b2Service: {
            uploadPhoto: jest.fn().mockResolvedValue({
                success: true,
                data: {
                    url: 'https://cdn.example.com/photo.jpg'
                }
            })
        }
    }));
jest.mock('@/services/emailService', ()=>({
        emailService: {
            send: jest.fn().mockResolvedValue({
                success: true,
                data: {
                    id: 'email-1'
                }
            })
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _guestService = /*#__PURE__*/ _interop_require_wildcard(require("../../services/guestService"));
const _rsvpService = /*#__PURE__*/ _interop_require_wildcard(require("../../services/rsvpService"));
const _eventService = /*#__PURE__*/ _interop_require_wildcard(require("../../services/eventService"));
const _activityService = /*#__PURE__*/ _interop_require_wildcard(require("../../services/activityService"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const guestService = _guestService;
const rsvpService = _rsvpService;
const eventService = _eventService;
const activityService = _activityService;
// Mock Supabase client
const mockSupabase = {
    from: jest.fn().mockReturnThis(),
    select: jest.fn().mockReturnThis(),
    insert: jest.fn().mockReturnThis(),
    update: jest.fn().mockReturnThis(),
    delete: jest.fn().mockReturnThis(),
    eq: jest.fn().mockReturnThis(),
    in: jest.fn().mockReturnThis(),
    range: jest.fn().mockReturnThis(),
    single: jest.fn(),
    auth: {
        getSession: jest.fn().mockResolvedValue({
            data: {
                session: {
                    user: {
                        id: 'user-1'
                    }
                }
            },
            error: null
        })
    }
};
describe('Performance: Load Testing', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe('Concurrent User Load (100 users)', ()=>{
        it('should handle 100 concurrent guest reads within 2 seconds', async ()=>{
            mockSupabase.single.mockResolvedValue({
                data: {
                    id: 'guest-1',
                    firstName: 'John',
                    lastName: 'Doe',
                    email: 'john@example.com',
                    groupId: 'group-1',
                    ageType: 'adult',
                    guestType: 'wedding_guest'
                },
                error: null
            });
            const startTime = performance.now();
            // Simulate 100 concurrent users reading guest data
            const promises = Array(100).fill(null).map((_, i)=>guestService.get(`guest-${i % 10}`));
            const results = await Promise.all(promises);
            const endTime = performance.now();
            const duration = endTime - startTime;
            expect(duration).toBeLessThan(2000);
            expect(results.every((r)=>r.success)).toBe(true);
            expect(results).toHaveLength(100);
        });
        it('should handle 100 concurrent RSVP submissions within 3 seconds', async ()=>{
            mockSupabase.single.mockResolvedValue({
                data: {
                    id: 'rsvp-1',
                    guestId: 'guest-1',
                    eventId: 'event-1',
                    status: 'attending',
                    guestCount: 2
                },
                error: null
            });
            const startTime = performance.now();
            // Simulate 100 concurrent RSVP submissions
            const promises = Array(100).fill(null).map((_, i)=>rsvpService.create({
                    guestId: `guest-${i}`,
                    eventId: 'event-1',
                    status: 'attending',
                    guestCount: 2
                }));
            const results = await Promise.all(promises);
            const endTime = performance.now();
            const duration = endTime - startTime;
            expect(duration).toBeLessThan(3000);
            expect(results.every((r)=>r.success)).toBe(true);
            expect(results).toHaveLength(100);
        });
        it('should handle 100 concurrent event list requests within 2.5 seconds', async ()=>{
            const mockEvents = Array(20).fill(null).map((_, i)=>({
                    id: `event-${i}`,
                    name: `Event ${i}`,
                    startDate: new Date().toISOString(),
                    status: 'published'
                }));
            mockSupabase.select.mockResolvedValue({
                data: mockEvents,
                error: null,
                count: 20
            });
            const startTime = performance.now();
            // Simulate 100 concurrent users viewing event list
            const promises = Array(100).fill(null).map(()=>eventService.list({
                    page: 1,
                    pageSize: 20
                }));
            const results = await Promise.all(promises);
            const endTime = performance.now();
            const duration = endTime - startTime;
            expect(duration).toBeLessThan(2500);
            expect(results.every((r)=>r.success)).toBe(true);
            expect(results).toHaveLength(100);
        });
        it('should handle mixed concurrent operations within 3 seconds', async ()=>{
            mockSupabase.single.mockResolvedValue({
                data: {
                    id: 'test-1'
                },
                error: null
            });
            mockSupabase.select.mockResolvedValue({
                data: [
                    {
                        id: 'test-1'
                    }
                ],
                error: null
            });
            const startTime = performance.now();
            // Simulate 100 concurrent mixed operations
            const promises = Array(100).fill(null).map((_, i)=>{
                const operation = i % 4;
                switch(operation){
                    case 0:
                        return guestService.get(`guest-${i}`);
                    case 1:
                        return eventService.list({
                            page: 1,
                            pageSize: 10
                        });
                    case 2:
                        return activityService.list({
                            page: 1,
                            pageSize: 10
                        });
                    case 3:
                        return rsvpService.list({
                            guestId: `guest-${i}`
                        });
                    default:
                        return guestService.get(`guest-${i}`);
                }
            });
            const results = await Promise.all(promises);
            const endTime = performance.now();
            const duration = endTime - startTime;
            expect(duration).toBeLessThan(3000);
            expect(results.every((r)=>r.success)).toBe(true);
            expect(results).toHaveLength(100);
        });
    });
    describe('Bulk Operations (100+ guests)', ()=>{
        it('should create 100 guests within 1 second', async ()=>{
            const guests = Array(100).fill(null).map((_, i)=>({
                    firstName: `Guest${i}`,
                    lastName: 'Doe',
                    email: `guest${i}@example.com`,
                    groupId: 'group-1',
                    ageType: 'adult',
                    guestType: 'wedding_guest'
                }));
            mockSupabase.select.mockResolvedValue({
                data: guests.map((g, i)=>({
                        id: `guest-${i}`,
                        ...g
                    })),
                error: null
            });
            const startTime = performance.now();
            const result = await guestService.bulkCreate(guests);
            const endTime = performance.now();
            const duration = endTime - startTime;
            expect(duration).toBeLessThan(1000);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data).toHaveLength(100);
            }
        });
        it('should update 150 guests within 1.5 seconds', async ()=>{
            const updates = Array(150).fill(null).map((_, i)=>({
                    id: `guest-${i}`,
                    firstName: `Updated${i}`
                }));
            mockSupabase.select.mockResolvedValue({
                data: updates,
                error: null
            });
            const startTime = performance.now();
            const result = await guestService.bulkUpdate(updates);
            const endTime = performance.now();
            const duration = endTime - startTime;
            expect(duration).toBeLessThan(1500);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data).toHaveLength(150);
            }
        });
        it('should delete 100 guests within 800ms', async ()=>{
            const guestIds = Array(100).fill(null).map((_, i)=>`guest-${i}`);
            mockSupabase.select.mockResolvedValue({
                data: null,
                error: null
            });
            const startTime = performance.now();
            const result = await guestService.bulkDelete(guestIds);
            const endTime = performance.now();
            const duration = endTime - startTime;
            expect(duration).toBeLessThan(800);
            expect(result.success).toBe(true);
        });
        it('should export 200 guests to CSV within 500ms', async ()=>{
            const guests = Array(200).fill(null).map((_, i)=>({
                    id: `guest-${i}`,
                    firstName: `Guest${i}`,
                    lastName: 'Doe',
                    email: `guest${i}@example.com`,
                    groupId: 'group-1',
                    ageType: 'adult',
                    guestType: 'wedding_guest'
                }));
            mockSupabase.select.mockResolvedValue({
                data: guests,
                error: null
            });
            const startTime = performance.now();
            const result = await guestService.exportToCSV({
                groupId: 'group-1'
            });
            const endTime = performance.now();
            const duration = endTime - startTime;
            expect(duration).toBeLessThan(500);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data.split('\n').length).toBeGreaterThan(200);
            }
        });
        it('should import 100 guests from CSV within 1.2 seconds', async ()=>{
            const csvData = Array(100).fill(null).map((_, i)=>`Guest${i},Doe,guest${i}@example.com,group-1,adult,wedding_guest`).join('\n');
            const csvWithHeaders = `firstName,lastName,email,groupId,ageType,guestType\n${csvData}`;
            mockSupabase.select.mockResolvedValue({
                data: Array(100).fill(null).map((_, i)=>({
                        id: `guest-${i}`
                    })),
                error: null
            });
            const startTime = performance.now();
            const result = await guestService.importFromCSV(csvWithHeaders);
            const endTime = performance.now();
            const duration = endTime - startTime;
            expect(duration).toBeLessThan(1200);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.data).toHaveLength(100);
            }
        });
        it('should handle bulk RSVP creation for 120 guests within 1 second', async ()=>{
            const rsvps = Array(120).fill(null).map((_, i)=>({
                    guestId: `guest-${i}`,
                    eventId: 'event-1',
                    status: 'attending',
                    guestCount: 2
                }));
            mockSupabase.select.mockResolvedValue({
                data: rsvps.map((r, i)=>({
                        id: `rsvp-${i}`,
                        ...r
                    })),
                error: null
            });
            const startTime = performance.now();
            // Simulate bulk RSVP creation
            const promises = rsvps.map((rsvp)=>rsvpService.create(rsvp));
            const results = await Promise.all(promises);
            const endTime = performance.now();
            const duration = endTime - startTime;
            expect(duration).toBeLessThan(1000);
            expect(results.every((r)=>r.success)).toBe(true);
            expect(results).toHaveLength(120);
        });
    });
    describe('API Response Time Measurements', ()=>{
        it('should respond to GET /api/guests/:id within 100ms', async ()=>{
            mockSupabase.single.mockResolvedValue({
                data: {
                    id: 'guest-1',
                    firstName: 'John',
                    lastName: 'Doe'
                },
                error: null
            });
            const measurements = [];
            // Take 10 measurements
            for(let i = 0; i < 10; i++){
                const startTime = performance.now();
                await guestService.get('guest-1');
                const endTime = performance.now();
                measurements.push(endTime - startTime);
            }
            const avgResponseTime = measurements.reduce((sum, t)=>sum + t, 0) / measurements.length;
            const maxResponseTime = Math.max(...measurements);
            expect(avgResponseTime).toBeLessThan(100);
            expect(maxResponseTime).toBeLessThan(150);
        });
        it('should respond to POST /api/guests within 150ms', async ()=>{
            mockSupabase.single.mockResolvedValue({
                data: {
                    id: 'guest-1',
                    firstName: 'John',
                    lastName: 'Doe'
                },
                error: null
            });
            const measurements = [];
            // Take 10 measurements
            for(let i = 0; i < 10; i++){
                const startTime = performance.now();
                await guestService.create({
                    firstName: 'John',
                    lastName: 'Doe',
                    email: 'john@example.com',
                    groupId: 'group-1',
                    ageType: 'adult',
                    guestType: 'wedding_guest'
                });
                const endTime = performance.now();
                measurements.push(endTime - startTime);
            }
            const avgResponseTime = measurements.reduce((sum, t)=>sum + t, 0) / measurements.length;
            const maxResponseTime = Math.max(...measurements);
            expect(avgResponseTime).toBeLessThan(150);
            expect(maxResponseTime).toBeLessThan(200);
        });
        it('should respond to PUT /api/guests/:id within 120ms', async ()=>{
            mockSupabase.single.mockResolvedValue({
                data: {
                    id: 'guest-1',
                    firstName: 'Jane'
                },
                error: null
            });
            const measurements = [];
            // Take 10 measurements
            for(let i = 0; i < 10; i++){
                const startTime = performance.now();
                await guestService.update('guest-1', {
                    firstName: 'Jane'
                });
                const endTime = performance.now();
                measurements.push(endTime - startTime);
            }
            const avgResponseTime = measurements.reduce((sum, t)=>sum + t, 0) / measurements.length;
            const maxResponseTime = Math.max(...measurements);
            expect(avgResponseTime).toBeLessThan(120);
            expect(maxResponseTime).toBeLessThan(180);
        });
        it('should respond to DELETE /api/guests/:id within 80ms', async ()=>{
            mockSupabase.single.mockResolvedValue({
                data: null,
                error: null
            });
            const measurements = [];
            // Take 10 measurements
            for(let i = 0; i < 10; i++){
                const startTime = performance.now();
                await guestService.delete('guest-1');
                const endTime = performance.now();
                measurements.push(endTime - startTime);
            }
            const avgResponseTime = measurements.reduce((sum, t)=>sum + t, 0) / measurements.length;
            const maxResponseTime = Math.max(...measurements);
            expect(avgResponseTime).toBeLessThan(80);
            expect(maxResponseTime).toBeLessThan(120);
        });
        it('should respond to GET /api/guests (list) within 200ms', async ()=>{
            const mockGuests = Array(50).fill(null).map((_, i)=>({
                    id: `guest-${i}`,
                    firstName: `Guest${i}`,
                    lastName: 'Doe'
                }));
            mockSupabase.select.mockResolvedValue({
                data: mockGuests,
                error: null,
                count: 50
            });
            const measurements = [];
            // Take 10 measurements
            for(let i = 0; i < 10; i++){
                const startTime = performance.now();
                await guestService.list({
                    page: 1,
                    pageSize: 50
                });
                const endTime = performance.now();
                measurements.push(endTime - startTime);
            }
            const avgResponseTime = measurements.reduce((sum, t)=>sum + t, 0) / measurements.length;
            const maxResponseTime = Math.max(...measurements);
            expect(avgResponseTime).toBeLessThan(200);
            expect(maxResponseTime).toBeLessThan(300);
        });
        it('should measure response time percentiles', async ()=>{
            mockSupabase.single.mockResolvedValue({
                data: {
                    id: 'guest-1'
                },
                error: null
            });
            const measurements = [];
            // Take 100 measurements
            for(let i = 0; i < 100; i++){
                const startTime = performance.now();
                await guestService.get('guest-1');
                const endTime = performance.now();
                measurements.push(endTime - startTime);
            }
            measurements.sort((a, b)=>a - b);
            const p50 = measurements[Math.floor(measurements.length * 0.5)];
            const p95 = measurements[Math.floor(measurements.length * 0.95)];
            const p99 = measurements[Math.floor(measurements.length * 0.99)];
            expect(p50).toBeLessThan(100); // Median under 100ms
            expect(p95).toBeLessThan(150); // 95th percentile under 150ms
            expect(p99).toBeLessThan(200); // 99th percentile under 200ms
        });
    });
    describe('Database Query Performance', ()=>{
        it('should execute simple SELECT query within 30ms', async ()=>{
            mockSupabase.single.mockResolvedValue({
                data: {
                    id: 'guest-1',
                    firstName: 'John'
                },
                error: null
            });
            const measurements = [];
            for(let i = 0; i < 20; i++){
                const startTime = performance.now();
                await mockSupabase.from('guests').select('*').eq('id', 'guest-1').single();
                const endTime = performance.now();
                measurements.push(endTime - startTime);
            }
            const avgQueryTime = measurements.reduce((sum, t)=>sum + t, 0) / measurements.length;
            expect(avgQueryTime).toBeLessThan(30);
        });
        it('should execute filtered SELECT query within 50ms', async ()=>{
            const mockData = Array(20).fill(null).map((_, i)=>({
                    id: `guest-${i}`,
                    groupId: 'group-1'
                }));
            mockSupabase.select.mockResolvedValue({
                data: mockData,
                error: null
            });
            const measurements = [];
            for(let i = 0; i < 20; i++){
                const startTime = performance.now();
                await mockSupabase.from('guests').select('*').eq('group_id', 'group-1');
                const endTime = performance.now();
                measurements.push(endTime - startTime);
            }
            const avgQueryTime = measurements.reduce((sum, t)=>sum + t, 0) / measurements.length;
            expect(avgQueryTime).toBeLessThan(50);
        });
        it('should execute paginated query within 80ms', async ()=>{
            const mockData = Array(50).fill(null).map((_, i)=>({
                    id: `guest-${i}`
                }));
            mockSupabase.select.mockResolvedValue({
                data: mockData,
                error: null,
                count: 100
            });
            const measurements = [];
            for(let i = 0; i < 20; i++){
                const startTime = performance.now();
                await mockSupabase.from('guests').select('*', {
                    count: 'exact'
                }).range(0, 49);
                const endTime = performance.now();
                measurements.push(endTime - startTime);
            }
            const avgQueryTime = measurements.reduce((sum, t)=>sum + t, 0) / measurements.length;
            expect(avgQueryTime).toBeLessThan(80);
        });
        it('should execute JOIN query within 100ms', async ()=>{
            const mockData = Array(30).fill(null).map((_, i)=>({
                    id: `rsvp-${i}`,
                    guest: {
                        firstName: `Guest${i}`,
                        lastName: 'Doe'
                    },
                    event: {
                        name: 'Wedding Ceremony'
                    }
                }));
            mockSupabase.select.mockResolvedValue({
                data: mockData,
                error: null
            });
            const measurements = [];
            for(let i = 0; i < 20; i++){
                const startTime = performance.now();
                await mockSupabase.from('rsvps').select('*, guests(*), events(*)').eq('event_id', 'event-1');
                const endTime = performance.now();
                measurements.push(endTime - startTime);
            }
            const avgQueryTime = measurements.reduce((sum, t)=>sum + t, 0) / measurements.length;
            expect(avgQueryTime).toBeLessThan(100);
        });
        it('should execute aggregate query within 60ms', async ()=>{
            mockSupabase.select.mockResolvedValue({
                data: [
                    {
                        count: 150
                    }
                ],
                error: null
            });
            const measurements = [];
            for(let i = 0; i < 20; i++){
                const startTime = performance.now();
                await mockSupabase.from('guests').select('*', {
                    count: 'exact',
                    head: true
                }).eq('group_id', 'group-1');
                const endTime = performance.now();
                measurements.push(endTime - startTime);
            }
            const avgQueryTime = measurements.reduce((sum, t)=>sum + t, 0) / measurements.length;
            expect(avgQueryTime).toBeLessThan(60);
        });
        it('should execute INSERT query within 40ms', async ()=>{
            mockSupabase.single.mockResolvedValue({
                data: {
                    id: 'guest-1',
                    firstName: 'John'
                },
                error: null
            });
            const measurements = [];
            for(let i = 0; i < 20; i++){
                const startTime = performance.now();
                await mockSupabase.from('guests').insert({
                    firstName: 'John',
                    lastName: 'Doe'
                }).select().single();
                const endTime = performance.now();
                measurements.push(endTime - startTime);
            }
            const avgQueryTime = measurements.reduce((sum, t)=>sum + t, 0) / measurements.length;
            expect(avgQueryTime).toBeLessThan(40);
        });
        it('should execute UPDATE query within 35ms', async ()=>{
            mockSupabase.single.mockResolvedValue({
                data: {
                    id: 'guest-1',
                    firstName: 'Jane'
                },
                error: null
            });
            const measurements = [];
            for(let i = 0; i < 20; i++){
                const startTime = performance.now();
                await mockSupabase.from('guests').update({
                    firstName: 'Jane'
                }).eq('id', 'guest-1').select().single();
                const endTime = performance.now();
                measurements.push(endTime - startTime);
            }
            const avgQueryTime = measurements.reduce((sum, t)=>sum + t, 0) / measurements.length;
            expect(avgQueryTime).toBeLessThan(35);
        });
        it('should execute DELETE query within 30ms', async ()=>{
            mockSupabase.single.mockResolvedValue({
                data: null,
                error: null
            });
            const measurements = [];
            for(let i = 0; i < 20; i++){
                const startTime = performance.now();
                await mockSupabase.from('guests').delete().eq('id', 'guest-1');
                const endTime = performance.now();
                measurements.push(endTime - startTime);
            }
            const avgQueryTime = measurements.reduce((sum, t)=>sum + t, 0) / measurements.length;
            expect(avgQueryTime).toBeLessThan(30);
        });
    });
    describe('Throughput Measurements', ()=>{
        it('should handle 500 requests per second', async ()=>{
            mockSupabase.single.mockResolvedValue({
                data: {
                    id: 'guest-1'
                },
                error: null
            });
            const startTime = performance.now();
            const requests = 500;
            const promises = Array(requests).fill(null).map(()=>guestService.get('guest-1'));
            await Promise.all(promises);
            const endTime = performance.now();
            const duration = (endTime - startTime) / 1000; // Convert to seconds
            const throughput = requests / duration;
            expect(throughput).toBeGreaterThan(500);
        });
        it('should maintain throughput under sustained load', async ()=>{
            mockSupabase.single.mockResolvedValue({
                data: {
                    id: 'guest-1'
                },
                error: null
            });
            const measurements = [];
            // Run 5 batches of 100 requests
            for(let batch = 0; batch < 5; batch++){
                const startTime = performance.now();
                const promises = Array(100).fill(null).map(()=>guestService.get('guest-1'));
                await Promise.all(promises);
                const endTime = performance.now();
                const duration = (endTime - startTime) / 1000;
                const throughput = 100 / duration;
                measurements.push(throughput);
            }
            // All batches should maintain similar throughput
            const avgThroughput = measurements.reduce((sum, t)=>sum + t, 0) / measurements.length;
            const minThroughput = Math.min(...measurements);
            expect(avgThroughput).toBeGreaterThan(500);
            expect(minThroughput).toBeGreaterThan(400); // No more than 20% degradation
        });
    });
    describe('Resource Utilization', ()=>{
        it('should not exceed memory limits under load', async ()=>{
            mockSupabase.single.mockResolvedValue({
                data: {
                    id: 'guest-1',
                    firstName: 'John'
                },
                error: null
            });
            const initialMemory = process.memoryUsage().heapUsed;
            // Perform 500 operations
            for(let i = 0; i < 500; i++){
                await guestService.get('guest-1');
            }
            const finalMemory = process.memoryUsage().heapUsed;
            const memoryIncrease = (finalMemory - initialMemory) / (1024 * 1024); // MB
            // Memory increase should be minimal (less than 20MB)
            expect(memoryIncrease).toBeLessThan(20);
        });
        it('should handle large result sets efficiently', async ()=>{
            const largeDataset = Array(1000).fill(null).map((_, i)=>({
                    id: `guest-${i}`,
                    firstName: `Guest${i}`,
                    lastName: 'Doe',
                    email: `guest${i}@example.com`
                }));
            mockSupabase.select.mockResolvedValue({
                data: largeDataset,
                error: null
            });
            const initialMemory = process.memoryUsage().heapUsed;
            const startTime = performance.now();
            await guestService.list({
                page: 1,
                pageSize: 1000
            });
            const endTime = performance.now();
            const finalMemory = process.memoryUsage().heapUsed;
            const duration = endTime - startTime;
            const memoryIncrease = (finalMemory - initialMemory) / (1024 * 1024);
            expect(duration).toBeLessThan(500);
            expect(memoryIncrease).toBeLessThan(50);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvX190ZXN0c19fL3BlcmZvcm1hbmNlL2xvYWRUZXN0LnBlcmZvcm1hbmNlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQZXJmb3JtYW5jZSBUZXN0IFN1aXRlOiBMb2FkIFRlc3RpbmdcbiAqIFxuICogVGVzdHMgc3lzdGVtIHBlcmZvcm1hbmNlIHVuZGVyIGxvYWQgd2l0aDpcbiAqIC0gMTAwIGNvbmN1cnJlbnQgdXNlcnNcbiAqIC0gQnVsayBvcGVyYXRpb25zICgxMDArIGd1ZXN0cylcbiAqIC0gQVBJIHJlc3BvbnNlIHRpbWUgbWVhc3VyZW1lbnRzXG4gKiAtIERhdGFiYXNlIHF1ZXJ5IHBlcmZvcm1hbmNlIG1vbml0b3JpbmdcbiAqIFxuICogVGFzazogMjQuNFxuICovXG5cbmltcG9ydCAqIGFzIGd1ZXN0U2VydmljZU1vZHVsZSBmcm9tICdAL3NlcnZpY2VzL2d1ZXN0U2VydmljZSc7XG5pbXBvcnQgKiBhcyByc3ZwU2VydmljZU1vZHVsZSBmcm9tICdAL3NlcnZpY2VzL3JzdnBTZXJ2aWNlJztcbmltcG9ydCAqIGFzIGV2ZW50U2VydmljZU1vZHVsZSBmcm9tICdAL3NlcnZpY2VzL2V2ZW50U2VydmljZSc7XG5pbXBvcnQgKiBhcyBhY3Rpdml0eVNlcnZpY2VNb2R1bGUgZnJvbSAnQC9zZXJ2aWNlcy9hY3Rpdml0eVNlcnZpY2UnO1xuXG5jb25zdCBndWVzdFNlcnZpY2UgPSBndWVzdFNlcnZpY2VNb2R1bGU7XG5jb25zdCByc3ZwU2VydmljZSA9IHJzdnBTZXJ2aWNlTW9kdWxlO1xuY29uc3QgZXZlbnRTZXJ2aWNlID0gZXZlbnRTZXJ2aWNlTW9kdWxlO1xuY29uc3QgYWN0aXZpdHlTZXJ2aWNlID0gYWN0aXZpdHlTZXJ2aWNlTW9kdWxlO1xuXG4vLyBNb2NrIFN1cGFiYXNlIGNsaWVudFxuY29uc3QgbW9ja1N1cGFiYXNlID0ge1xuICBmcm9tOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgaW5zZXJ0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgdXBkYXRlOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgZGVsZXRlOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICBpbjogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gIHJhbmdlOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgc2luZ2xlOiBqZXN0LmZuKCksXG4gIGF1dGg6IHtcbiAgICBnZXRTZXNzaW9uOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgZGF0YTogeyBzZXNzaW9uOiB7IHVzZXI6IHsgaWQ6ICd1c2VyLTEnIH0gfSB9LFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgfSksXG4gIH0sXG59O1xuXG5qZXN0Lm1vY2soJ0AvbGliL3N1cGFiYXNlJywgKCkgPT4gKHtcbiAgY3JlYXRlQ2xpZW50OiBqZXN0LmZuKCgpID0+IG1vY2tTdXBhYmFzZSksXG59KSk7XG5cbi8vIE1vY2sgZXh0ZXJuYWwgc2VydmljZXNcbmplc3QubW9jaygnQC9zZXJ2aWNlcy9iMlNlcnZpY2UnLCAoKSA9PiAoe1xuICBiMlNlcnZpY2U6IHtcbiAgICB1cGxvYWRQaG90bzogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBkYXRhOiB7IHVybDogJ2h0dHBzOi8vY2RuLmV4YW1wbGUuY29tL3Bob3RvLmpwZycgfSxcbiAgICB9KSxcbiAgfSxcbn0pKTtcblxuamVzdC5tb2NrKCdAL3NlcnZpY2VzL2VtYWlsU2VydmljZScsICgpID0+ICh7XG4gIGVtYWlsU2VydmljZToge1xuICAgIHNlbmQ6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgZGF0YTogeyBpZDogJ2VtYWlsLTEnIH0sXG4gICAgfSksXG4gIH0sXG59KSk7XG5cbmRlc2NyaWJlKCdQZXJmb3JtYW5jZTogTG9hZCBUZXN0aW5nJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbmN1cnJlbnQgVXNlciBMb2FkICgxMDAgdXNlcnMpJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIDEwMCBjb25jdXJyZW50IGd1ZXN0IHJlYWRzIHdpdGhpbiAyIHNlY29uZHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2Uuc2luZ2xlLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlkOiAnZ3Vlc3QtMScsXG4gICAgICAgICAgZmlyc3ROYW1lOiAnSm9obicsXG4gICAgICAgICAgbGFzdE5hbWU6ICdEb2UnLFxuICAgICAgICAgIGVtYWlsOiAnam9obkBleGFtcGxlLmNvbScsXG4gICAgICAgICAgZ3JvdXBJZDogJ2dyb3VwLTEnLFxuICAgICAgICAgIGFnZVR5cGU6ICdhZHVsdCcsXG4gICAgICAgICAgZ3Vlc3RUeXBlOiAnd2VkZGluZ19ndWVzdCcsXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAvLyBTaW11bGF0ZSAxMDAgY29uY3VycmVudCB1c2VycyByZWFkaW5nIGd1ZXN0IGRhdGFcbiAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkoMTAwKVxuICAgICAgICAuZmlsbChudWxsKVxuICAgICAgICAubWFwKChfLCBpKSA9PiBndWVzdFNlcnZpY2UuZ2V0KGBndWVzdC0ke2kgJSAxMH1gKSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcblxuICAgICAgZXhwZWN0KGR1cmF0aW9uKS50b0JlTGVzc1RoYW4oMjAwMCk7XG4gICAgICBleHBlY3QocmVzdWx0cy5ldmVyeSgocikgPT4gci5zdWNjZXNzKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHRzKS50b0hhdmVMZW5ndGgoMTAwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIDEwMCBjb25jdXJyZW50IFJTVlAgc3VibWlzc2lvbnMgd2l0aGluIDMgc2Vjb25kcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWQ6ICdyc3ZwLTEnLFxuICAgICAgICAgIGd1ZXN0SWQ6ICdndWVzdC0xJyxcbiAgICAgICAgICBldmVudElkOiAnZXZlbnQtMScsXG4gICAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyxcbiAgICAgICAgICBndWVzdENvdW50OiAyLFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgLy8gU2ltdWxhdGUgMTAwIGNvbmN1cnJlbnQgUlNWUCBzdWJtaXNzaW9uc1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBBcnJheSgxMDApXG4gICAgICAgIC5maWxsKG51bGwpXG4gICAgICAgIC5tYXAoKF8sIGkpID0+XG4gICAgICAgICAgcnN2cFNlcnZpY2UuY3JlYXRlKHtcbiAgICAgICAgICAgIGd1ZXN0SWQ6IGBndWVzdC0ke2l9YCxcbiAgICAgICAgICAgIGV2ZW50SWQ6ICdldmVudC0xJyxcbiAgICAgICAgICAgIHN0YXR1czogJ2F0dGVuZGluZycsXG4gICAgICAgICAgICBndWVzdENvdW50OiAyLFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcblxuICAgICAgZXhwZWN0KGR1cmF0aW9uKS50b0JlTGVzc1RoYW4oMzAwMCk7XG4gICAgICBleHBlY3QocmVzdWx0cy5ldmVyeSgocikgPT4gci5zdWNjZXNzKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHRzKS50b0hhdmVMZW5ndGgoMTAwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIDEwMCBjb25jdXJyZW50IGV2ZW50IGxpc3QgcmVxdWVzdHMgd2l0aGluIDIuNSBzZWNvbmRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0V2ZW50cyA9IEFycmF5KDIwKVxuICAgICAgICAuZmlsbChudWxsKVxuICAgICAgICAubWFwKChfLCBpKSA9PiAoe1xuICAgICAgICAgIGlkOiBgZXZlbnQtJHtpfWAsXG4gICAgICAgICAgbmFtZTogYEV2ZW50ICR7aX1gLFxuICAgICAgICAgIHN0YXJ0RGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHN0YXR1czogJ3B1Ymxpc2hlZCcsXG4gICAgICAgIH0pKTtcblxuICAgICAgbW9ja1N1cGFiYXNlLnNlbGVjdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG1vY2tFdmVudHMsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICBjb3VudDogMjAsXG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIDEwMCBjb25jdXJyZW50IHVzZXJzIHZpZXdpbmcgZXZlbnQgbGlzdFxuICAgICAgY29uc3QgcHJvbWlzZXMgPSBBcnJheSgxMDApXG4gICAgICAgIC5maWxsKG51bGwpXG4gICAgICAgIC5tYXAoKCkgPT4gZXZlbnRTZXJ2aWNlLmxpc3QoeyBwYWdlOiAxLCBwYWdlU2l6ZTogMjAgfSkpO1xuXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG5cbiAgICAgIGV4cGVjdChkdXJhdGlvbikudG9CZUxlc3NUaGFuKDI1MDApO1xuICAgICAgZXhwZWN0KHJlc3VsdHMuZXZlcnkoKHIpID0+IHIuc3VjY2VzcykpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0cykudG9IYXZlTGVuZ3RoKDEwMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtaXhlZCBjb25jdXJyZW50IG9wZXJhdGlvbnMgd2l0aGluIDMgc2Vjb25kcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IGlkOiAndGVzdC0xJyB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogW3sgaWQ6ICd0ZXN0LTEnIH1dLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgLy8gU2ltdWxhdGUgMTAwIGNvbmN1cnJlbnQgbWl4ZWQgb3BlcmF0aW9uc1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBBcnJheSgxMDApXG4gICAgICAgIC5maWxsKG51bGwpXG4gICAgICAgIC5tYXAoKF8sIGkpID0+IHtcbiAgICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBpICUgNDtcbiAgICAgICAgICBzd2l0Y2ggKG9wZXJhdGlvbikge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICByZXR1cm4gZ3Vlc3RTZXJ2aWNlLmdldChgZ3Vlc3QtJHtpfWApO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICByZXR1cm4gZXZlbnRTZXJ2aWNlLmxpc3QoeyBwYWdlOiAxLCBwYWdlU2l6ZTogMTAgfSk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHJldHVybiBhY3Rpdml0eVNlcnZpY2UubGlzdCh7IHBhZ2U6IDEsIHBhZ2VTaXplOiAxMCB9KTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgcmV0dXJuIHJzdnBTZXJ2aWNlLmxpc3QoeyBndWVzdElkOiBgZ3Vlc3QtJHtpfWAgfSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gZ3Vlc3RTZXJ2aWNlLmdldChgZ3Vlc3QtJHtpfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcblxuICAgICAgZXhwZWN0KGR1cmF0aW9uKS50b0JlTGVzc1RoYW4oMzAwMCk7XG4gICAgICBleHBlY3QocmVzdWx0cy5ldmVyeSgocikgPT4gci5zdWNjZXNzKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHRzKS50b0hhdmVMZW5ndGgoMTAwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0J1bGsgT3BlcmF0aW9ucyAoMTAwKyBndWVzdHMpJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY3JlYXRlIDEwMCBndWVzdHMgd2l0aGluIDEgc2Vjb25kJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZ3Vlc3RzID0gQXJyYXkoMTAwKVxuICAgICAgICAuZmlsbChudWxsKVxuICAgICAgICAubWFwKChfLCBpKSA9PiAoe1xuICAgICAgICAgIGZpcnN0TmFtZTogYEd1ZXN0JHtpfWAsXG4gICAgICAgICAgbGFzdE5hbWU6ICdEb2UnLFxuICAgICAgICAgIGVtYWlsOiBgZ3Vlc3Qke2l9QGV4YW1wbGUuY29tYCxcbiAgICAgICAgICBncm91cElkOiAnZ3JvdXAtMScsXG4gICAgICAgICAgYWdlVHlwZTogJ2FkdWx0JyBhcyBjb25zdCxcbiAgICAgICAgICBndWVzdFR5cGU6ICd3ZWRkaW5nX2d1ZXN0JyBhcyBjb25zdCxcbiAgICAgICAgfSkpO1xuXG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogZ3Vlc3RzLm1hcCgoZywgaSkgPT4gKHsgaWQ6IGBndWVzdC0ke2l9YCwgLi4uZyB9KSksXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBndWVzdFNlcnZpY2UuYnVsa0NyZWF0ZShndWVzdHMpO1xuXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG5cbiAgICAgIGV4cGVjdChkdXJhdGlvbikudG9CZUxlc3NUaGFuKDEwMDApO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YSkudG9IYXZlTGVuZ3RoKDEwMCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHVwZGF0ZSAxNTAgZ3Vlc3RzIHdpdGhpbiAxLjUgc2Vjb25kcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZXMgPSBBcnJheSgxNTApXG4gICAgICAgIC5maWxsKG51bGwpXG4gICAgICAgIC5tYXAoKF8sIGkpID0+ICh7XG4gICAgICAgICAgaWQ6IGBndWVzdC0ke2l9YCxcbiAgICAgICAgICBmaXJzdE5hbWU6IGBVcGRhdGVkJHtpfWAsXG4gICAgICAgIH0pKTtcblxuICAgICAgbW9ja1N1cGFiYXNlLnNlbGVjdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHVwZGF0ZXMsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBndWVzdFNlcnZpY2UuYnVsa1VwZGF0ZSh1cGRhdGVzKTtcblxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuXG4gICAgICBleHBlY3QoZHVyYXRpb24pLnRvQmVMZXNzVGhhbigxNTAwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEpLnRvSGF2ZUxlbmd0aCgxNTApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBkZWxldGUgMTAwIGd1ZXN0cyB3aXRoaW4gODAwbXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBndWVzdElkcyA9IEFycmF5KDEwMClcbiAgICAgICAgLmZpbGwobnVsbClcbiAgICAgICAgLm1hcCgoXywgaSkgPT4gYGd1ZXN0LSR7aX1gKTtcblxuICAgICAgbW9ja1N1cGFiYXNlLnNlbGVjdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBndWVzdFNlcnZpY2UuYnVsa0RlbGV0ZShndWVzdElkcyk7XG5cbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcblxuICAgICAgZXhwZWN0KGR1cmF0aW9uKS50b0JlTGVzc1RoYW4oODAwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZXhwb3J0IDIwMCBndWVzdHMgdG8gQ1NWIHdpdGhpbiA1MDBtcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGd1ZXN0cyA9IEFycmF5KDIwMClcbiAgICAgICAgLmZpbGwobnVsbClcbiAgICAgICAgLm1hcCgoXywgaSkgPT4gKHtcbiAgICAgICAgICBpZDogYGd1ZXN0LSR7aX1gLFxuICAgICAgICAgIGZpcnN0TmFtZTogYEd1ZXN0JHtpfWAsXG4gICAgICAgICAgbGFzdE5hbWU6ICdEb2UnLFxuICAgICAgICAgIGVtYWlsOiBgZ3Vlc3Qke2l9QGV4YW1wbGUuY29tYCxcbiAgICAgICAgICBncm91cElkOiAnZ3JvdXAtMScsXG4gICAgICAgICAgYWdlVHlwZTogJ2FkdWx0JyBhcyBjb25zdCxcbiAgICAgICAgICBndWVzdFR5cGU6ICd3ZWRkaW5nX2d1ZXN0JyBhcyBjb25zdCxcbiAgICAgICAgfSkpO1xuXG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogZ3Vlc3RzLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ3Vlc3RTZXJ2aWNlLmV4cG9ydFRvQ1NWKHsgZ3JvdXBJZDogJ2dyb3VwLTEnIH0pO1xuXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG5cbiAgICAgIGV4cGVjdChkdXJhdGlvbikudG9CZUxlc3NUaGFuKDUwMCk7XG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLnNwbGl0KCdcXG4nKS5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigyMDApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBpbXBvcnQgMTAwIGd1ZXN0cyBmcm9tIENTViB3aXRoaW4gMS4yIHNlY29uZHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjc3ZEYXRhID0gQXJyYXkoMTAwKVxuICAgICAgICAuZmlsbChudWxsKVxuICAgICAgICAubWFwKFxuICAgICAgICAgIChfLCBpKSA9PlxuICAgICAgICAgICAgYEd1ZXN0JHtpfSxEb2UsZ3Vlc3Qke2l9QGV4YW1wbGUuY29tLGdyb3VwLTEsYWR1bHQsd2VkZGluZ19ndWVzdGBcbiAgICAgICAgKVxuICAgICAgICAuam9pbignXFxuJyk7XG5cbiAgICAgIGNvbnN0IGNzdldpdGhIZWFkZXJzID0gYGZpcnN0TmFtZSxsYXN0TmFtZSxlbWFpbCxncm91cElkLGFnZVR5cGUsZ3Vlc3RUeXBlXFxuJHtjc3ZEYXRhfWA7XG5cbiAgICAgIG1vY2tTdXBhYmFzZS5zZWxlY3QubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBBcnJheSgxMDApXG4gICAgICAgICAgLmZpbGwobnVsbClcbiAgICAgICAgICAubWFwKChfLCBpKSA9PiAoeyBpZDogYGd1ZXN0LSR7aX1gIH0pKSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGd1ZXN0U2VydmljZS5pbXBvcnRGcm9tQ1NWKGNzdldpdGhIZWFkZXJzKTtcblxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuXG4gICAgICBleHBlY3QoZHVyYXRpb24pLnRvQmVMZXNzVGhhbigxMjAwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEpLnRvSGF2ZUxlbmd0aCgxMDApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYnVsayBSU1ZQIGNyZWF0aW9uIGZvciAxMjAgZ3Vlc3RzIHdpdGhpbiAxIHNlY29uZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJzdnBzID0gQXJyYXkoMTIwKVxuICAgICAgICAuZmlsbChudWxsKVxuICAgICAgICAubWFwKChfLCBpKSA9PiAoe1xuICAgICAgICAgIGd1ZXN0SWQ6IGBndWVzdC0ke2l9YCxcbiAgICAgICAgICBldmVudElkOiAnZXZlbnQtMScsXG4gICAgICAgICAgc3RhdHVzOiAnYXR0ZW5kaW5nJyBhcyBjb25zdCxcbiAgICAgICAgICBndWVzdENvdW50OiAyLFxuICAgICAgICB9KSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZS5zZWxlY3QubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiByc3Zwcy5tYXAoKHIsIGkpID0+ICh7IGlkOiBgcnN2cC0ke2l9YCwgLi4uciB9KSksXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBidWxrIFJTVlAgY3JlYXRpb25cbiAgICAgIGNvbnN0IHByb21pc2VzID0gcnN2cHMubWFwKChyc3ZwKSA9PiByc3ZwU2VydmljZS5jcmVhdGUocnN2cCkpO1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuXG4gICAgICBleHBlY3QoZHVyYXRpb24pLnRvQmVMZXNzVGhhbigxMDAwKTtcbiAgICAgIGV4cGVjdChyZXN1bHRzLmV2ZXJ5KChyKSA9PiByLnN1Y2Nlc3MpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdHMpLnRvSGF2ZUxlbmd0aCgxMjApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQVBJIFJlc3BvbnNlIFRpbWUgTWVhc3VyZW1lbnRzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmVzcG9uZCB0byBHRVQgL2FwaS9ndWVzdHMvOmlkIHdpdGhpbiAxMDBtcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWQ6ICdndWVzdC0xJyxcbiAgICAgICAgICBmaXJzdE5hbWU6ICdKb2huJyxcbiAgICAgICAgICBsYXN0TmFtZTogJ0RvZScsXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1lYXN1cmVtZW50czogbnVtYmVyW10gPSBbXTtcblxuICAgICAgLy8gVGFrZSAxMCBtZWFzdXJlbWVudHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgYXdhaXQgZ3Vlc3RTZXJ2aWNlLmdldCgnZ3Vlc3QtMScpO1xuICAgICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIG1lYXN1cmVtZW50cy5wdXNoKGVuZFRpbWUgLSBzdGFydFRpbWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdmdSZXNwb25zZVRpbWUgPVxuICAgICAgICBtZWFzdXJlbWVudHMucmVkdWNlKChzdW0sIHQpID0+IHN1bSArIHQsIDApIC8gbWVhc3VyZW1lbnRzLmxlbmd0aDtcbiAgICAgIGNvbnN0IG1heFJlc3BvbnNlVGltZSA9IE1hdGgubWF4KC4uLm1lYXN1cmVtZW50cyk7XG5cbiAgICAgIGV4cGVjdChhdmdSZXNwb25zZVRpbWUpLnRvQmVMZXNzVGhhbigxMDApO1xuICAgICAgZXhwZWN0KG1heFJlc3BvbnNlVGltZSkudG9CZUxlc3NUaGFuKDE1MCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlc3BvbmQgdG8gUE9TVCAvYXBpL2d1ZXN0cyB3aXRoaW4gMTUwbXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2Uuc2luZ2xlLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlkOiAnZ3Vlc3QtMScsXG4gICAgICAgICAgZmlyc3ROYW1lOiAnSm9obicsXG4gICAgICAgICAgbGFzdE5hbWU6ICdEb2UnLFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtZWFzdXJlbWVudHM6IG51bWJlcltdID0gW107XG5cbiAgICAgIC8vIFRha2UgMTAgbWVhc3VyZW1lbnRzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGF3YWl0IGd1ZXN0U2VydmljZS5jcmVhdGUoe1xuICAgICAgICAgIGZpcnN0TmFtZTogJ0pvaG4nLFxuICAgICAgICAgIGxhc3ROYW1lOiAnRG9lJyxcbiAgICAgICAgICBlbWFpbDogJ2pvaG5AZXhhbXBsZS5jb20nLFxuICAgICAgICAgIGdyb3VwSWQ6ICdncm91cC0xJyxcbiAgICAgICAgICBhZ2VUeXBlOiAnYWR1bHQnLFxuICAgICAgICAgIGd1ZXN0VHlwZTogJ3dlZGRpbmdfZ3Vlc3QnLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBtZWFzdXJlbWVudHMucHVzaChlbmRUaW1lIC0gc3RhcnRUaW1lKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXZnUmVzcG9uc2VUaW1lID1cbiAgICAgICAgbWVhc3VyZW1lbnRzLnJlZHVjZSgoc3VtLCB0KSA9PiBzdW0gKyB0LCAwKSAvIG1lYXN1cmVtZW50cy5sZW5ndGg7XG4gICAgICBjb25zdCBtYXhSZXNwb25zZVRpbWUgPSBNYXRoLm1heCguLi5tZWFzdXJlbWVudHMpO1xuXG4gICAgICBleHBlY3QoYXZnUmVzcG9uc2VUaW1lKS50b0JlTGVzc1RoYW4oMTUwKTtcbiAgICAgIGV4cGVjdChtYXhSZXNwb25zZVRpbWUpLnRvQmVMZXNzVGhhbigyMDApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXNwb25kIHRvIFBVVCAvYXBpL2d1ZXN0cy86aWQgd2l0aGluIDEyMG1zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N1cGFiYXNlLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpZDogJ2d1ZXN0LTEnLFxuICAgICAgICAgIGZpcnN0TmFtZTogJ0phbmUnLFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtZWFzdXJlbWVudHM6IG51bWJlcltdID0gW107XG5cbiAgICAgIC8vIFRha2UgMTAgbWVhc3VyZW1lbnRzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGF3YWl0IGd1ZXN0U2VydmljZS51cGRhdGUoJ2d1ZXN0LTEnLCB7IGZpcnN0TmFtZTogJ0phbmUnIH0pO1xuICAgICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIG1lYXN1cmVtZW50cy5wdXNoKGVuZFRpbWUgLSBzdGFydFRpbWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdmdSZXNwb25zZVRpbWUgPVxuICAgICAgICBtZWFzdXJlbWVudHMucmVkdWNlKChzdW0sIHQpID0+IHN1bSArIHQsIDApIC8gbWVhc3VyZW1lbnRzLmxlbmd0aDtcbiAgICAgIGNvbnN0IG1heFJlc3BvbnNlVGltZSA9IE1hdGgubWF4KC4uLm1lYXN1cmVtZW50cyk7XG5cbiAgICAgIGV4cGVjdChhdmdSZXNwb25zZVRpbWUpLnRvQmVMZXNzVGhhbigxMjApO1xuICAgICAgZXhwZWN0KG1heFJlc3BvbnNlVGltZSkudG9CZUxlc3NUaGFuKDE4MCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlc3BvbmQgdG8gREVMRVRFIC9hcGkvZ3Vlc3RzLzppZCB3aXRoaW4gODBtcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtZWFzdXJlbWVudHM6IG51bWJlcltdID0gW107XG5cbiAgICAgIC8vIFRha2UgMTAgbWVhc3VyZW1lbnRzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGF3YWl0IGd1ZXN0U2VydmljZS5kZWxldGUoJ2d1ZXN0LTEnKTtcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBtZWFzdXJlbWVudHMucHVzaChlbmRUaW1lIC0gc3RhcnRUaW1lKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXZnUmVzcG9uc2VUaW1lID1cbiAgICAgICAgbWVhc3VyZW1lbnRzLnJlZHVjZSgoc3VtLCB0KSA9PiBzdW0gKyB0LCAwKSAvIG1lYXN1cmVtZW50cy5sZW5ndGg7XG4gICAgICBjb25zdCBtYXhSZXNwb25zZVRpbWUgPSBNYXRoLm1heCguLi5tZWFzdXJlbWVudHMpO1xuXG4gICAgICBleHBlY3QoYXZnUmVzcG9uc2VUaW1lKS50b0JlTGVzc1RoYW4oODApO1xuICAgICAgZXhwZWN0KG1heFJlc3BvbnNlVGltZSkudG9CZUxlc3NUaGFuKDEyMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlc3BvbmQgdG8gR0VUIC9hcGkvZ3Vlc3RzIChsaXN0KSB3aXRoaW4gMjAwbXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrR3Vlc3RzID0gQXJyYXkoNTApXG4gICAgICAgIC5maWxsKG51bGwpXG4gICAgICAgIC5tYXAoKF8sIGkpID0+ICh7XG4gICAgICAgICAgaWQ6IGBndWVzdC0ke2l9YCxcbiAgICAgICAgICBmaXJzdE5hbWU6IGBHdWVzdCR7aX1gLFxuICAgICAgICAgIGxhc3ROYW1lOiAnRG9lJyxcbiAgICAgICAgfSkpO1xuXG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbW9ja0d1ZXN0cyxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIGNvdW50OiA1MCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtZWFzdXJlbWVudHM6IG51bWJlcltdID0gW107XG5cbiAgICAgIC8vIFRha2UgMTAgbWVhc3VyZW1lbnRzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGF3YWl0IGd1ZXN0U2VydmljZS5saXN0KHsgcGFnZTogMSwgcGFnZVNpemU6IDUwIH0pO1xuICAgICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIG1lYXN1cmVtZW50cy5wdXNoKGVuZFRpbWUgLSBzdGFydFRpbWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdmdSZXNwb25zZVRpbWUgPVxuICAgICAgICBtZWFzdXJlbWVudHMucmVkdWNlKChzdW0sIHQpID0+IHN1bSArIHQsIDApIC8gbWVhc3VyZW1lbnRzLmxlbmd0aDtcbiAgICAgIGNvbnN0IG1heFJlc3BvbnNlVGltZSA9IE1hdGgubWF4KC4uLm1lYXN1cmVtZW50cyk7XG5cbiAgICAgIGV4cGVjdChhdmdSZXNwb25zZVRpbWUpLnRvQmVMZXNzVGhhbigyMDApO1xuICAgICAgZXhwZWN0KG1heFJlc3BvbnNlVGltZSkudG9CZUxlc3NUaGFuKDMwMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG1lYXN1cmUgcmVzcG9uc2UgdGltZSBwZXJjZW50aWxlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IGlkOiAnZ3Vlc3QtMScgfSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbWVhc3VyZW1lbnRzOiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICAvLyBUYWtlIDEwMCBtZWFzdXJlbWVudHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGF3YWl0IGd1ZXN0U2VydmljZS5nZXQoJ2d1ZXN0LTEnKTtcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBtZWFzdXJlbWVudHMucHVzaChlbmRUaW1lIC0gc3RhcnRUaW1lKTtcbiAgICAgIH1cblxuICAgICAgbWVhc3VyZW1lbnRzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcblxuICAgICAgY29uc3QgcDUwID0gbWVhc3VyZW1lbnRzW01hdGguZmxvb3IobWVhc3VyZW1lbnRzLmxlbmd0aCAqIDAuNSldO1xuICAgICAgY29uc3QgcDk1ID0gbWVhc3VyZW1lbnRzW01hdGguZmxvb3IobWVhc3VyZW1lbnRzLmxlbmd0aCAqIDAuOTUpXTtcbiAgICAgIGNvbnN0IHA5OSA9IG1lYXN1cmVtZW50c1tNYXRoLmZsb29yKG1lYXN1cmVtZW50cy5sZW5ndGggKiAwLjk5KV07XG5cbiAgICAgIGV4cGVjdChwNTApLnRvQmVMZXNzVGhhbigxMDApOyAvLyBNZWRpYW4gdW5kZXIgMTAwbXNcbiAgICAgIGV4cGVjdChwOTUpLnRvQmVMZXNzVGhhbigxNTApOyAvLyA5NXRoIHBlcmNlbnRpbGUgdW5kZXIgMTUwbXNcbiAgICAgIGV4cGVjdChwOTkpLnRvQmVMZXNzVGhhbigyMDApOyAvLyA5OXRoIHBlcmNlbnRpbGUgdW5kZXIgMjAwbXNcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0RhdGFiYXNlIFF1ZXJ5IFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZXhlY3V0ZSBzaW1wbGUgU0VMRUNUIHF1ZXJ5IHdpdGhpbiAzMG1zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N1cGFiYXNlLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgaWQ6ICdndWVzdC0xJywgZmlyc3ROYW1lOiAnSm9obicgfSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbWVhc3VyZW1lbnRzOiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIwOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGF3YWl0IG1vY2tTdXBhYmFzZS5mcm9tKCdndWVzdHMnKS5zZWxlY3QoJyonKS5lcSgnaWQnLCAnZ3Vlc3QtMScpLnNpbmdsZSgpO1xuICAgICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIG1lYXN1cmVtZW50cy5wdXNoKGVuZFRpbWUgLSBzdGFydFRpbWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdmdRdWVyeVRpbWUgPVxuICAgICAgICBtZWFzdXJlbWVudHMucmVkdWNlKChzdW0sIHQpID0+IHN1bSArIHQsIDApIC8gbWVhc3VyZW1lbnRzLmxlbmd0aDtcblxuICAgICAgZXhwZWN0KGF2Z1F1ZXJ5VGltZSkudG9CZUxlc3NUaGFuKDMwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZXhlY3V0ZSBmaWx0ZXJlZCBTRUxFQ1QgcXVlcnkgd2l0aGluIDUwbXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRGF0YSA9IEFycmF5KDIwKVxuICAgICAgICAuZmlsbChudWxsKVxuICAgICAgICAubWFwKChfLCBpKSA9PiAoeyBpZDogYGd1ZXN0LSR7aX1gLCBncm91cElkOiAnZ3JvdXAtMScgfSkpO1xuXG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbW9ja0RhdGEsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1lYXN1cmVtZW50czogbnVtYmVyW10gPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBhd2FpdCBtb2NrU3VwYWJhc2UuZnJvbSgnZ3Vlc3RzJykuc2VsZWN0KCcqJykuZXEoJ2dyb3VwX2lkJywgJ2dyb3VwLTEnKTtcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBtZWFzdXJlbWVudHMucHVzaChlbmRUaW1lIC0gc3RhcnRUaW1lKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXZnUXVlcnlUaW1lID1cbiAgICAgICAgbWVhc3VyZW1lbnRzLnJlZHVjZSgoc3VtLCB0KSA9PiBzdW0gKyB0LCAwKSAvIG1lYXN1cmVtZW50cy5sZW5ndGg7XG5cbiAgICAgIGV4cGVjdChhdmdRdWVyeVRpbWUpLnRvQmVMZXNzVGhhbig1MCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGV4ZWN1dGUgcGFnaW5hdGVkIHF1ZXJ5IHdpdGhpbiA4MG1zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0RhdGEgPSBBcnJheSg1MClcbiAgICAgICAgLmZpbGwobnVsbClcbiAgICAgICAgLm1hcCgoXywgaSkgPT4gKHsgaWQ6IGBndWVzdC0ke2l9YCB9KSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZS5zZWxlY3QubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBtb2NrRGF0YSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIGNvdW50OiAxMDAsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbWVhc3VyZW1lbnRzOiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIwOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGF3YWl0IG1vY2tTdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdndWVzdHMnKVxuICAgICAgICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnIH0pXG4gICAgICAgICAgLnJhbmdlKDAsIDQ5KTtcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBtZWFzdXJlbWVudHMucHVzaChlbmRUaW1lIC0gc3RhcnRUaW1lKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXZnUXVlcnlUaW1lID1cbiAgICAgICAgbWVhc3VyZW1lbnRzLnJlZHVjZSgoc3VtLCB0KSA9PiBzdW0gKyB0LCAwKSAvIG1lYXN1cmVtZW50cy5sZW5ndGg7XG5cbiAgICAgIGV4cGVjdChhdmdRdWVyeVRpbWUpLnRvQmVMZXNzVGhhbig4MCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGV4ZWN1dGUgSk9JTiBxdWVyeSB3aXRoaW4gMTAwbXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRGF0YSA9IEFycmF5KDMwKVxuICAgICAgICAuZmlsbChudWxsKVxuICAgICAgICAubWFwKChfLCBpKSA9PiAoe1xuICAgICAgICAgIGlkOiBgcnN2cC0ke2l9YCxcbiAgICAgICAgICBndWVzdDogeyBmaXJzdE5hbWU6IGBHdWVzdCR7aX1gLCBsYXN0TmFtZTogJ0RvZScgfSxcbiAgICAgICAgICBldmVudDogeyBuYW1lOiAnV2VkZGluZyBDZXJlbW9ueScgfSxcbiAgICAgICAgfSkpO1xuXG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbW9ja0RhdGEsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1lYXN1cmVtZW50czogbnVtYmVyW10gPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBhd2FpdCBtb2NrU3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgncnN2cHMnKVxuICAgICAgICAgIC5zZWxlY3QoJyosIGd1ZXN0cygqKSwgZXZlbnRzKCopJylcbiAgICAgICAgICAuZXEoJ2V2ZW50X2lkJywgJ2V2ZW50LTEnKTtcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBtZWFzdXJlbWVudHMucHVzaChlbmRUaW1lIC0gc3RhcnRUaW1lKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXZnUXVlcnlUaW1lID1cbiAgICAgICAgbWVhc3VyZW1lbnRzLnJlZHVjZSgoc3VtLCB0KSA9PiBzdW0gKyB0LCAwKSAvIG1lYXN1cmVtZW50cy5sZW5ndGg7XG5cbiAgICAgIGV4cGVjdChhdmdRdWVyeVRpbWUpLnRvQmVMZXNzVGhhbigxMDApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBleGVjdXRlIGFnZ3JlZ2F0ZSBxdWVyeSB3aXRoaW4gNjBtcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5zZWxlY3QubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBbeyBjb3VudDogMTUwIH1dLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtZWFzdXJlbWVudHM6IG51bWJlcltdID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgYXdhaXQgbW9ja1N1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2d1ZXN0cycpXG4gICAgICAgICAgLnNlbGVjdCgnKicsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSlcbiAgICAgICAgICAuZXEoJ2dyb3VwX2lkJywgJ2dyb3VwLTEnKTtcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBtZWFzdXJlbWVudHMucHVzaChlbmRUaW1lIC0gc3RhcnRUaW1lKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXZnUXVlcnlUaW1lID1cbiAgICAgICAgbWVhc3VyZW1lbnRzLnJlZHVjZSgoc3VtLCB0KSA9PiBzdW0gKyB0LCAwKSAvIG1lYXN1cmVtZW50cy5sZW5ndGg7XG5cbiAgICAgIGV4cGVjdChhdmdRdWVyeVRpbWUpLnRvQmVMZXNzVGhhbig2MCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGV4ZWN1dGUgSU5TRVJUIHF1ZXJ5IHdpdGhpbiA0MG1zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N1cGFiYXNlLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgaWQ6ICdndWVzdC0xJywgZmlyc3ROYW1lOiAnSm9obicgfSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbWVhc3VyZW1lbnRzOiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIwOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGF3YWl0IG1vY2tTdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdndWVzdHMnKVxuICAgICAgICAgIC5pbnNlcnQoeyBmaXJzdE5hbWU6ICdKb2huJywgbGFzdE5hbWU6ICdEb2UnIH0pXG4gICAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIG1lYXN1cmVtZW50cy5wdXNoKGVuZFRpbWUgLSBzdGFydFRpbWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdmdRdWVyeVRpbWUgPVxuICAgICAgICBtZWFzdXJlbWVudHMucmVkdWNlKChzdW0sIHQpID0+IHN1bSArIHQsIDApIC8gbWVhc3VyZW1lbnRzLmxlbmd0aDtcblxuICAgICAgZXhwZWN0KGF2Z1F1ZXJ5VGltZSkudG9CZUxlc3NUaGFuKDQwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZXhlY3V0ZSBVUERBVEUgcXVlcnkgd2l0aGluIDM1bXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2Uuc2luZ2xlLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogeyBpZDogJ2d1ZXN0LTEnLCBmaXJzdE5hbWU6ICdKYW5lJyB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtZWFzdXJlbWVudHM6IG51bWJlcltdID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgYXdhaXQgbW9ja1N1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2d1ZXN0cycpXG4gICAgICAgICAgLnVwZGF0ZSh7IGZpcnN0TmFtZTogJ0phbmUnIH0pXG4gICAgICAgICAgLmVxKCdpZCcsICdndWVzdC0xJylcbiAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgbWVhc3VyZW1lbnRzLnB1c2goZW5kVGltZSAtIHN0YXJ0VGltZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF2Z1F1ZXJ5VGltZSA9XG4gICAgICAgIG1lYXN1cmVtZW50cy5yZWR1Y2UoKHN1bSwgdCkgPT4gc3VtICsgdCwgMCkgLyBtZWFzdXJlbWVudHMubGVuZ3RoO1xuXG4gICAgICBleHBlY3QoYXZnUXVlcnlUaW1lKS50b0JlTGVzc1RoYW4oMzUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBleGVjdXRlIERFTEVURSBxdWVyeSB3aXRoaW4gMzBtcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtZWFzdXJlbWVudHM6IG51bWJlcltdID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgYXdhaXQgbW9ja1N1cGFiYXNlLmZyb20oJ2d1ZXN0cycpLmRlbGV0ZSgpLmVxKCdpZCcsICdndWVzdC0xJyk7XG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgbWVhc3VyZW1lbnRzLnB1c2goZW5kVGltZSAtIHN0YXJ0VGltZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF2Z1F1ZXJ5VGltZSA9XG4gICAgICAgIG1lYXN1cmVtZW50cy5yZWR1Y2UoKHN1bSwgdCkgPT4gc3VtICsgdCwgMCkgLyBtZWFzdXJlbWVudHMubGVuZ3RoO1xuXG4gICAgICBleHBlY3QoYXZnUXVlcnlUaW1lKS50b0JlTGVzc1RoYW4oMzApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnVGhyb3VnaHB1dCBNZWFzdXJlbWVudHMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgNTAwIHJlcXVlc3RzIHBlciBzZWNvbmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2Uuc2luZ2xlLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogeyBpZDogJ2d1ZXN0LTEnIH0sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgcmVxdWVzdHMgPSA1MDA7XG5cbiAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkocmVxdWVzdHMpXG4gICAgICAgIC5maWxsKG51bGwpXG4gICAgICAgIC5tYXAoKCkgPT4gZ3Vlc3RTZXJ2aWNlLmdldCgnZ3Vlc3QtMScpKTtcblxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IChlbmRUaW1lIC0gc3RhcnRUaW1lKSAvIDEwMDA7IC8vIENvbnZlcnQgdG8gc2Vjb25kc1xuXG4gICAgICBjb25zdCB0aHJvdWdocHV0ID0gcmVxdWVzdHMgLyBkdXJhdGlvbjtcblxuICAgICAgZXhwZWN0KHRocm91Z2hwdXQpLnRvQmVHcmVhdGVyVGhhbig1MDApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBtYWludGFpbiB0aHJvdWdocHV0IHVuZGVyIHN1c3RhaW5lZCBsb2FkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N1cGFiYXNlLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgaWQ6ICdndWVzdC0xJyB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtZWFzdXJlbWVudHM6IG51bWJlcltdID0gW107XG5cbiAgICAgIC8vIFJ1biA1IGJhdGNoZXMgb2YgMTAwIHJlcXVlc3RzXG4gICAgICBmb3IgKGxldCBiYXRjaCA9IDA7IGJhdGNoIDwgNTsgYmF0Y2grKykge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IEFycmF5KDEwMClcbiAgICAgICAgICAuZmlsbChudWxsKVxuICAgICAgICAgIC5tYXAoKCkgPT4gZ3Vlc3RTZXJ2aWNlLmdldCgnZ3Vlc3QtMScpKTtcblxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IChlbmRUaW1lIC0gc3RhcnRUaW1lKSAvIDEwMDA7XG4gICAgICAgIGNvbnN0IHRocm91Z2hwdXQgPSAxMDAgLyBkdXJhdGlvbjtcbiAgICAgICAgbWVhc3VyZW1lbnRzLnB1c2godGhyb3VnaHB1dCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFsbCBiYXRjaGVzIHNob3VsZCBtYWludGFpbiBzaW1pbGFyIHRocm91Z2hwdXRcbiAgICAgIGNvbnN0IGF2Z1Rocm91Z2hwdXQgPVxuICAgICAgICBtZWFzdXJlbWVudHMucmVkdWNlKChzdW0sIHQpID0+IHN1bSArIHQsIDApIC8gbWVhc3VyZW1lbnRzLmxlbmd0aDtcbiAgICAgIGNvbnN0IG1pblRocm91Z2hwdXQgPSBNYXRoLm1pbiguLi5tZWFzdXJlbWVudHMpO1xuXG4gICAgICBleHBlY3QoYXZnVGhyb3VnaHB1dCkudG9CZUdyZWF0ZXJUaGFuKDUwMCk7XG4gICAgICBleHBlY3QobWluVGhyb3VnaHB1dCkudG9CZUdyZWF0ZXJUaGFuKDQwMCk7IC8vIE5vIG1vcmUgdGhhbiAyMCUgZGVncmFkYXRpb25cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Jlc291cmNlIFV0aWxpemF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgbm90IGV4Y2VlZCBtZW1vcnkgbGltaXRzIHVuZGVyIGxvYWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrU3VwYWJhc2Uuc2luZ2xlLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogeyBpZDogJ2d1ZXN0LTEnLCBmaXJzdE5hbWU6ICdKb2huJyB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBpbml0aWFsTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuXG4gICAgICAvLyBQZXJmb3JtIDUwMCBvcGVyYXRpb25zXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDUwMDsgaSsrKSB7XG4gICAgICAgIGF3YWl0IGd1ZXN0U2VydmljZS5nZXQoJ2d1ZXN0LTEnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmluYWxNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQ7XG4gICAgICBjb25zdCBtZW1vcnlJbmNyZWFzZSA9IChmaW5hbE1lbW9yeSAtIGluaXRpYWxNZW1vcnkpIC8gKDEwMjQgKiAxMDI0KTsgLy8gTUJcblxuICAgICAgLy8gTWVtb3J5IGluY3JlYXNlIHNob3VsZCBiZSBtaW5pbWFsIChsZXNzIHRoYW4gMjBNQilcbiAgICAgIGV4cGVjdChtZW1vcnlJbmNyZWFzZSkudG9CZUxlc3NUaGFuKDIwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGxhcmdlIHJlc3VsdCBzZXRzIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbGFyZ2VEYXRhc2V0ID0gQXJyYXkoMTAwMClcbiAgICAgICAgLmZpbGwobnVsbClcbiAgICAgICAgLm1hcCgoXywgaSkgPT4gKHtcbiAgICAgICAgICBpZDogYGd1ZXN0LSR7aX1gLFxuICAgICAgICAgIGZpcnN0TmFtZTogYEd1ZXN0JHtpfWAsXG4gICAgICAgICAgbGFzdE5hbWU6ICdEb2UnLFxuICAgICAgICAgIGVtYWlsOiBgZ3Vlc3Qke2l9QGV4YW1wbGUuY29tYCxcbiAgICAgICAgfSkpO1xuXG4gICAgICBtb2NrU3VwYWJhc2Uuc2VsZWN0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbGFyZ2VEYXRhc2V0LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBpbml0aWFsTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgIGF3YWl0IGd1ZXN0U2VydmljZS5saXN0KHsgcGFnZTogMSwgcGFnZVNpemU6IDEwMDAgfSk7XG5cbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IGZpbmFsTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuXG4gICAgICBjb25zdCBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBjb25zdCBtZW1vcnlJbmNyZWFzZSA9IChmaW5hbE1lbW9yeSAtIGluaXRpYWxNZW1vcnkpIC8gKDEwMjQgKiAxMDI0KTtcblxuICAgICAgZXhwZWN0KGR1cmF0aW9uKS50b0JlTGVzc1RoYW4oNTAwKTtcbiAgICAgIGV4cGVjdChtZW1vcnlJbmNyZWFzZSkudG9CZUxlc3NUaGFuKDUwKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImNyZWF0ZUNsaWVudCIsImZuIiwibW9ja1N1cGFiYXNlIiwiYjJTZXJ2aWNlIiwidXBsb2FkUGhvdG8iLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInN1Y2Nlc3MiLCJkYXRhIiwidXJsIiwiZW1haWxTZXJ2aWNlIiwic2VuZCIsImlkIiwiZ3Vlc3RTZXJ2aWNlIiwiZ3Vlc3RTZXJ2aWNlTW9kdWxlIiwicnN2cFNlcnZpY2UiLCJyc3ZwU2VydmljZU1vZHVsZSIsImV2ZW50U2VydmljZSIsImV2ZW50U2VydmljZU1vZHVsZSIsImFjdGl2aXR5U2VydmljZSIsImFjdGl2aXR5U2VydmljZU1vZHVsZSIsImZyb20iLCJtb2NrUmV0dXJuVGhpcyIsInNlbGVjdCIsImluc2VydCIsInVwZGF0ZSIsImRlbGV0ZSIsImVxIiwiaW4iLCJyYW5nZSIsInNpbmdsZSIsImF1dGgiLCJnZXRTZXNzaW9uIiwic2Vzc2lvbiIsInVzZXIiLCJlcnJvciIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJpdCIsImZpcnN0TmFtZSIsImxhc3ROYW1lIiwiZW1haWwiLCJncm91cElkIiwiYWdlVHlwZSIsImd1ZXN0VHlwZSIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwicHJvbWlzZXMiLCJBcnJheSIsImZpbGwiLCJtYXAiLCJfIiwiaSIsImdldCIsInJlc3VsdHMiLCJQcm9taXNlIiwiYWxsIiwiZW5kVGltZSIsImR1cmF0aW9uIiwiZXhwZWN0IiwidG9CZUxlc3NUaGFuIiwiZXZlcnkiLCJyIiwidG9CZSIsInRvSGF2ZUxlbmd0aCIsImd1ZXN0SWQiLCJldmVudElkIiwic3RhdHVzIiwiZ3Vlc3RDb3VudCIsImNyZWF0ZSIsIm1vY2tFdmVudHMiLCJuYW1lIiwic3RhcnREYXRlIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiY291bnQiLCJsaXN0IiwicGFnZSIsInBhZ2VTaXplIiwib3BlcmF0aW9uIiwiZ3Vlc3RzIiwiZyIsInJlc3VsdCIsImJ1bGtDcmVhdGUiLCJ1cGRhdGVzIiwiYnVsa1VwZGF0ZSIsImd1ZXN0SWRzIiwiYnVsa0RlbGV0ZSIsImV4cG9ydFRvQ1NWIiwic3BsaXQiLCJsZW5ndGgiLCJ0b0JlR3JlYXRlclRoYW4iLCJjc3ZEYXRhIiwiam9pbiIsImNzdldpdGhIZWFkZXJzIiwiaW1wb3J0RnJvbUNTViIsInJzdnBzIiwicnN2cCIsIm1lYXN1cmVtZW50cyIsInB1c2giLCJhdmdSZXNwb25zZVRpbWUiLCJyZWR1Y2UiLCJzdW0iLCJ0IiwibWF4UmVzcG9uc2VUaW1lIiwiTWF0aCIsIm1heCIsIm1vY2tHdWVzdHMiLCJzb3J0IiwiYSIsImIiLCJwNTAiLCJmbG9vciIsInA5NSIsInA5OSIsImF2Z1F1ZXJ5VGltZSIsIm1vY2tEYXRhIiwiZ3Vlc3QiLCJldmVudCIsImhlYWQiLCJyZXF1ZXN0cyIsInRocm91Z2hwdXQiLCJiYXRjaCIsImF2Z1Rocm91Z2hwdXQiLCJtaW5UaHJvdWdocHV0IiwibWluIiwiaW5pdGlhbE1lbW9yeSIsInByb2Nlc3MiLCJtZW1vcnlVc2FnZSIsImhlYXBVc2VkIiwi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