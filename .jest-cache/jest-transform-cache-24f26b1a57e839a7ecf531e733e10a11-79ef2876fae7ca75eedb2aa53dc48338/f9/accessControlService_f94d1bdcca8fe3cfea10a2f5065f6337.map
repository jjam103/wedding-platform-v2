{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/services/accessControlService.ts"],"sourcesContent":["import { createClient } from '@supabase/supabase-js';\nimport type { Result } from '@/types';\nimport { success, error, unauthorizedError, unknownError } from '@/utils/errors';\nimport { ERROR_CODES } from '@/types';\n\n/**\n * Access control service for managing role-based permissions.\n * Implements authorization checks for different user roles and resource access.\n */\n\nexport type UserRole = 'super_admin' | 'host' | 'guest';\n\nexport interface PermissionCheck {\n  userId: string;\n  role: UserRole;\n  resource: string;\n  action: 'create' | 'read' | 'update' | 'delete';\n}\n\nexport interface GroupAccessCheck {\n  userId: string;\n  groupId: string;\n}\n\n/**\n * Creates a Supabase client for access control operations.\n */\nfunction createAccessControlClient() {\n  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\n  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\n\n  if (!supabaseUrl || !supabaseAnonKey) {\n    throw new Error(\n      'Missing Supabase environment variables. Please set NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY'\n    );\n  }\n\n  return createClient(supabaseUrl, supabaseAnonKey);\n}\n\n/**\n * Checks if a user has a specific role.\n * \n * @param userId - User ID to check\n * @param requiredRole - Required role\n * @returns Result indicating if user has the role\n * \n * @example\n * const result = await accessControlService.hasRole('user-123', 'super_admin');\n * if (result.success && result.data.hasRole) {\n *   console.log('User is super admin');\n * }\n */\nexport async function hasRole(\n  userId: string,\n  requiredRole: UserRole\n): Promise<Result<{ hasRole: boolean; userRole: UserRole }>> {\n  try {\n    const supabase = createAccessControlClient();\n\n    const { data, error: dbError } = await supabase\n      .from('users')\n      .select('role')\n      .eq('id', userId)\n      .single();\n\n    if (dbError || !data) {\n      return error(\n        ERROR_CODES.NOT_FOUND,\n        'User not found',\n        dbError\n      );\n    }\n\n    const userRole = data.role as UserRole;\n    const hasRole = userRole === requiredRole;\n\n    return success({ hasRole, userRole });\n  } catch (err) {\n    return unknownError(err);\n  }\n}\n\n/**\n * Checks if a user has any of the specified roles.\n * \n * @param userId - User ID to check\n * @param allowedRoles - Array of allowed roles\n * @returns Result indicating if user has any of the roles\n * \n * @example\n * const result = await accessControlService.hasAnyRole('user-123', ['super_admin', 'host']);\n */\nexport async function hasAnyRole(\n  userId: string,\n  allowedRoles: UserRole[]\n): Promise<Result<{ hasRole: boolean; userRole: UserRole }>> {\n  try {\n    const supabase = createAccessControlClient();\n\n    const { data, error: dbError } = await supabase\n      .from('users')\n      .select('role')\n      .eq('id', userId)\n      .single();\n\n    if (dbError || !data) {\n      return error(\n        ERROR_CODES.NOT_FOUND,\n        'User not found',\n        dbError\n      );\n    }\n\n    const userRole = data.role as UserRole;\n    const hasRole = allowedRoles.includes(userRole);\n\n    return success({ hasRole, userRole });\n  } catch (err) {\n    return unknownError(err);\n  }\n}\n\n/**\n * Checks if a user can access a specific group.\n * Super admins can access all groups.\n * Group owners can access their assigned groups.\n * \n * @param check - User ID and group ID to check\n * @returns Result indicating if user can access the group\n * \n * @example\n * const result = await accessControlService.canAccessGroup({\n *   userId: 'user-123',\n *   groupId: 'group-456'\n * });\n */\nexport async function canAccessGroup(\n  check: GroupAccessCheck\n): Promise<Result<{ canAccess: boolean; role: UserRole }>> {\n  try {\n    const supabase = createAccessControlClient();\n\n    // Check user role\n    const { data: userData, error: userError } = await supabase\n      .from('users')\n      .select('role')\n      .eq('id', check.userId)\n      .single();\n\n    if (userError || !userData) {\n      return error(\n        ERROR_CODES.NOT_FOUND,\n        'User not found',\n        userError\n      );\n    }\n\n    const userRole = userData.role as UserRole;\n\n    // Super admins can access all groups\n    if (userRole === 'super_admin') {\n      return success({ canAccess: true, role: userRole });\n    }\n\n    // Check if user is a group member with owner role\n    const { data: memberData, error: memberError } = await supabase\n      .from('group_members')\n      .select('role')\n      .eq('user_id', check.userId)\n      .eq('group_id', check.groupId)\n      .single();\n\n    if (memberError || !memberData) {\n      return success({ canAccess: false, role: userRole });\n    }\n\n    const canAccess = memberData.role === 'owner';\n    return success({ canAccess, role: userRole });\n  } catch (err) {\n    return unknownError(err);\n  }\n}\n\n/**\n * Checks if a user can perform an action on a resource based on their role.\n * \n * Role hierarchy:\n * - super_admin: Can perform all actions on all resources\n * - host: Can perform all actions on wedding-related resources\n * - guest: Can only read and update their own information\n * \n * @param check - Permission check parameters\n * @returns Result indicating if action is allowed\n * \n * @example\n * const result = await accessControlService.canPerformAction({\n *   userId: 'user-123',\n *   role: 'host',\n *   resource: 'guests',\n *   action: 'create'\n * });\n */\nexport async function canPerformAction(\n  check: PermissionCheck\n): Promise<Result<{ allowed: boolean }>> {\n  try {\n    const { role, resource, action } = check;\n\n    // Super admins can do everything\n    if (role === 'super_admin') {\n      return success({ allowed: true });\n    }\n\n    // Hosts can manage wedding resources\n    if (role === 'host') {\n      const hostResources = [\n        'guests',\n        'events',\n        'activities',\n        'rsvps',\n        'vendors',\n        'accommodations',\n        'photos',\n        'emails',\n        'budget',\n        'transportation',\n      ];\n\n      if (hostResources.includes(resource)) {\n        return success({ allowed: true });\n      }\n\n      return success({ allowed: false });\n    }\n\n    // Guests have limited permissions\n    if (role === 'guest') {\n      // Guests can read public information\n      if (action === 'read') {\n        const publicResources = [\n          'events',\n          'activities',\n          'accommodations',\n          'photos',\n        ];\n        if (publicResources.includes(resource)) {\n          return success({ allowed: true });\n        }\n      }\n\n      // Guests can update their own information\n      if (action === 'update' && resource === 'guests') {\n        // Additional check needed to verify it's their own record\n        return success({ allowed: true });\n      }\n\n      // Guests can create RSVPs\n      if (action === 'create' && resource === 'rsvps') {\n        return success({ allowed: true });\n      }\n\n      // Guests can upload photos\n      if (action === 'create' && resource === 'photos') {\n        return success({ allowed: true });\n      }\n\n      return success({ allowed: false });\n    }\n\n    return success({ allowed: false });\n  } catch (err) {\n    return unknownError(err);\n  }\n}\n\n/**\n * Requires that a user has a specific role, returning an error if not.\n * \n * @param userId - User ID to check\n * @param requiredRole - Required role\n * @returns Result with success if user has role, error otherwise\n * \n * @example\n * const result = await accessControlService.requireRole('user-123', 'super_admin');\n * if (!result.success) {\n *   return result; // Return error to caller\n * }\n */\nexport async function requireRole(\n  userId: string,\n  requiredRole: UserRole\n): Promise<Result<{ userRole: UserRole }>> {\n  const result = await hasRole(userId, requiredRole);\n\n  if (!result.success) {\n    return result;\n  }\n\n  if (!result.data.hasRole) {\n    return error(\n      ERROR_CODES.INSUFFICIENT_PERMISSIONS,\n      `User does not have required role: ${requiredRole}`,\n      { userRole: result.data.userRole, requiredRole }\n    );\n  }\n\n  return success({ userRole: result.data.userRole });\n}\n\n/**\n * Requires that a user has any of the specified roles.\n * \n * @param userId - User ID to check\n * @param allowedRoles - Array of allowed roles\n * @returns Result with success if user has any role, error otherwise\n * \n * @example\n * const result = await accessControlService.requireAnyRole('user-123', ['super_admin', 'host']);\n */\nexport async function requireAnyRole(\n  userId: string,\n  allowedRoles: UserRole[]\n): Promise<Result<{ userRole: UserRole }>> {\n  const result = await hasAnyRole(userId, allowedRoles);\n\n  if (!result.success) {\n    return result;\n  }\n\n  if (!result.data.hasRole) {\n    return error(\n      ERROR_CODES.INSUFFICIENT_PERMISSIONS,\n      `User does not have any of the required roles: ${allowedRoles.join(', ')}`,\n      { userRole: result.data.userRole, allowedRoles }\n    );\n  }\n\n  return success({ userRole: result.data.userRole });\n}\n\n/**\n * Requires that a user can access a specific group.\n * \n * @param check - User ID and group ID to check\n * @returns Result with success if user can access, error otherwise\n */\nexport async function requireGroupAccess(\n  check: GroupAccessCheck\n): Promise<Result<{ role: UserRole }>> {\n  const result = await canAccessGroup(check);\n\n  if (!result.success) {\n    return result;\n  }\n\n  if (!result.data.canAccess) {\n    return error(\n      ERROR_CODES.INSUFFICIENT_PERMISSIONS,\n      'User does not have access to this group',\n      { userId: check.userId, groupId: check.groupId }\n    );\n  }\n\n  return success({ role: result.data.role });\n}\n\n/**\n * Gets all groups that a user can access.\n * \n * @param userId - User ID\n * @returns Result containing array of accessible group IDs\n * \n * @example\n * const result = await accessControlService.getUserGroups('user-123');\n * if (result.success) {\n *   console.log('User can access groups:', result.data.groupIds);\n * }\n */\nexport async function getUserGroups(\n  userId: string\n): Promise<Result<{ groupIds: string[]; role: UserRole }>> {\n  try {\n    const supabase = createAccessControlClient();\n\n    // Check user role\n    const { data: userData, error: userError } = await supabase\n      .from('users')\n      .select('role')\n      .eq('id', userId)\n      .single();\n\n    if (userError || !userData) {\n      return error(\n        ERROR_CODES.NOT_FOUND,\n        'User not found',\n        userError\n      );\n    }\n\n    const userRole = userData.role as UserRole;\n\n    // Super admins can access all groups\n    if (userRole === 'super_admin') {\n      const { data: allGroups, error: groupsError } = await supabase\n        .from('groups')\n        .select('id');\n\n      if (groupsError) {\n        return error(\n          ERROR_CODES.DATABASE_ERROR,\n          'Failed to fetch groups',\n          groupsError\n        );\n      }\n\n      const groupIds = allGroups?.map(g => g.id) || [];\n      return success({ groupIds, role: userRole });\n    }\n\n    // Get groups where user is an owner\n    const { data: memberGroups, error: memberError } = await supabase\n      .from('group_members')\n      .select('group_id')\n      .eq('user_id', userId)\n      .eq('role', 'owner');\n\n    if (memberError) {\n      return error(\n        ERROR_CODES.DATABASE_ERROR,\n        'Failed to fetch user groups',\n        memberError\n      );\n    }\n\n    const groupIds = memberGroups?.map(m => m.group_id) || [];\n    return success({ groupIds, role: userRole });\n  } catch (err) {\n    return unknownError(err);\n  }\n}\n"],"names":["canAccessGroup","canPerformAction","getUserGroups","hasAnyRole","hasRole","requireAnyRole","requireGroupAccess","requireRole","createAccessControlClient","supabaseUrl","process","env","NEXT_PUBLIC_SUPABASE_URL","supabaseAnonKey","NEXT_PUBLIC_SUPABASE_ANON_KEY","Error","createClient","userId","requiredRole","supabase","data","error","dbError","from","select","eq","single","ERROR_CODES","NOT_FOUND","userRole","role","success","err","unknownError","allowedRoles","includes","check","userData","userError","canAccess","memberData","memberError","groupId","resource","action","allowed","hostResources","publicResources","result","INSUFFICIENT_PERMISSIONS","join","allGroups","groupsError","DATABASE_ERROR","groupIds","map","g","id","memberGroups","m","group_id"],"mappings":"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"}