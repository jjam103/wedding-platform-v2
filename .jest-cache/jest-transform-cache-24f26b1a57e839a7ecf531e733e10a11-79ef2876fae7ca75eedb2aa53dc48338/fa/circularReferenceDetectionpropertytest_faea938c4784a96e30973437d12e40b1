a5c9213663e796ea7fe87ca09d879523
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _globals = require("@jest/globals");
const _sectionsService = require("./sectionsService");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Mock Supabase before importing services
const mockFrom = _globals.jest.fn();
const mockSupabase = {
    from: mockFrom
};
_globals.jest.mock('../lib/supabase', ()=>({
        supabase: mockSupabase
    }));
// Feature: destination-wedding-platform, Property 34: Circular Reference Detection
(0, _globals.describe)('Feature: destination-wedding-platform, Property 34: Circular Reference Detection', ()=>{
    (0, _globals.beforeEach)(()=>{
        _globals.jest.clearAllMocks();
    });
    (0, _globals.it)('should detect circular reference chains (A → B → C → A)', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
            pageAId: _fastcheck.uuid(),
            pageBId: _fastcheck.uuid(),
            pageCId: _fastcheck.uuid(),
            pageType: _fastcheck.constantFrom('activity', 'event', 'accommodation', 'room_type', 'custom')
        }).filter((data)=>{
            // Ensure all IDs are distinct for a true circular chain test
            return data.pageAId !== data.pageBId && data.pageBId !== data.pageCId && data.pageCId !== data.pageAId;
        }), async (testData)=>{
            // Create a circular chain: A → B → C → A
            // We're testing: detectCircularReferences(pageAId, [ref to B])
            // The algorithm will:
            // 1. Check if B leads back to A
            // 2. Get B's sections and columns
            // 3. Find B references C
            // 4. Check if C leads back to A
            // 5. Get C's sections and columns
            // 6. Find C references A - CIRCULAR!
            // Mock for checking page B (first reference we're adding)
            // Get sections for page B
            mockFrom.mockReturnValueOnce({
                select: _globals.jest.fn().mockReturnValue({
                    eq: _globals.jest.fn().mockReturnValue({
                        eq: _globals.jest.fn().mockResolvedValue({
                            data: [
                                {
                                    id: 'section-b'
                                }
                            ],
                            error: null
                        })
                    })
                })
            });
            // Get columns for page B (contains reference to C)
            mockFrom.mockReturnValueOnce({
                select: _globals.jest.fn().mockReturnValue({
                    in: _globals.jest.fn().mockReturnValue({
                        eq: _globals.jest.fn().mockResolvedValue({
                            data: [
                                {
                                    section_id: 'section-b',
                                    content_type: 'references',
                                    content_data: {
                                        references: [
                                            {
                                                type: testData.pageType,
                                                id: testData.pageCId
                                            }
                                        ]
                                    }
                                }
                            ],
                            error: null
                        })
                    })
                })
            });
            // Mock for checking page C (B references C)
            // Get sections for page C
            mockFrom.mockReturnValueOnce({
                select: _globals.jest.fn().mockReturnValue({
                    eq: _globals.jest.fn().mockReturnValue({
                        eq: _globals.jest.fn().mockResolvedValue({
                            data: [
                                {
                                    id: 'section-c'
                                }
                            ],
                            error: null
                        })
                    })
                })
            });
            // Get columns for page C (contains reference to A - creating the circle!)
            mockFrom.mockReturnValueOnce({
                select: _globals.jest.fn().mockReturnValue({
                    in: _globals.jest.fn().mockReturnValue({
                        eq: _globals.jest.fn().mockResolvedValue({
                            data: [
                                {
                                    section_id: 'section-c',
                                    content_type: 'references',
                                    content_data: {
                                        references: [
                                            {
                                                type: testData.pageType,
                                                id: testData.pageAId
                                            }
                                        ]
                                    }
                                }
                            ],
                            error: null
                        })
                    })
                })
            });
            // Test: Adding a reference from A to B should detect the circle
            const references = [
                {
                    type: testData.pageType,
                    id: testData.pageBId
                }
            ];
            const result = await (0, _sectionsService.detectCircularReferences)(testData.pageAId, references);
            // Property: Detection should succeed
            (0, _globals.expect)(result.success).toBe(true);
            if (!result.success) {
                return true;
            }
            // Property: Should detect the circular reference
            (0, _globals.expect)(result.data).toBe(true);
            return true;
        }), {
            numRuns: 50
        } // Fewer runs due to complex mocking
        );
    });
    (0, _globals.it)('should not detect circular references when none exist', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
            pageAId: _fastcheck.uuid(),
            pageBId: _fastcheck.uuid(),
            pageType: _fastcheck.constantFrom('activity', 'event', 'accommodation', 'room_type', 'custom')
        }).filter((data)=>data.pageAId !== data.pageBId), async (testData)=>{
            // Create a non-circular chain: A → B (B has no references)
            // Mock for checking page B (the reference we're adding)
            // Get sections for page B
            mockFrom.mockReturnValueOnce({
                select: _globals.jest.fn().mockReturnValue({
                    eq: _globals.jest.fn().mockReturnValue({
                        eq: _globals.jest.fn().mockResolvedValue({
                            data: [
                                {
                                    id: 'section-b'
                                }
                            ],
                            error: null
                        })
                    })
                })
            });
            // Get columns for page B (no references - empty array)
            mockFrom.mockReturnValueOnce({
                select: _globals.jest.fn().mockReturnValue({
                    in: _globals.jest.fn().mockReturnValue({
                        eq: _globals.jest.fn().mockResolvedValue({
                            data: [],
                            error: null
                        })
                    })
                })
            });
            // Test: Adding a reference from A to B should not detect a circle
            const references = [
                {
                    type: testData.pageType,
                    id: testData.pageBId
                }
            ];
            const result = await (0, _sectionsService.detectCircularReferences)(testData.pageAId, references);
            // Property: Detection should succeed
            (0, _globals.expect)(result.success).toBe(true);
            if (!result.success) {
                return true;
            }
            // Property: Should not detect circular reference
            (0, _globals.expect)(result.data).toBe(false);
            return true;
        }), {
            numRuns: 100
        });
    });
    (0, _globals.it)('should detect self-referencing pages (A → A)', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
            pageId: _fastcheck.uuid(),
            pageType: _fastcheck.constantFrom('activity', 'event', 'accommodation', 'room_type', 'custom')
        }), async (testData)=>{
            // Test: Adding a self-reference (A → A)
            // The algorithm should detect this immediately since we're checking
            // if adding a reference to pageId from pageId creates a circle
            // When we check the reference to itself, we'll traverse to the same page
            // Get sections for the page
            mockFrom.mockReturnValueOnce({
                select: _globals.jest.fn().mockReturnValue({
                    eq: _globals.jest.fn().mockReturnValue({
                        eq: _globals.jest.fn().mockResolvedValue({
                            data: [
                                {
                                    id: 'section-a'
                                }
                            ],
                            error: null
                        })
                    })
                })
            });
            // Get columns - doesn't matter what's here, the algorithm should detect
            // that we're back at the starting page
            mockFrom.mockReturnValueOnce({
                select: _globals.jest.fn().mockReturnValue({
                    in: _globals.jest.fn().mockReturnValue({
                        eq: _globals.jest.fn().mockResolvedValue({
                            data: [],
                            error: null
                        })
                    })
                })
            });
            // Test: Adding a self-reference should detect the circle
            const references = [
                {
                    type: testData.pageType,
                    id: testData.pageId
                }
            ];
            const result = await (0, _sectionsService.detectCircularReferences)(testData.pageId, references);
            // Property: Detection should succeed
            (0, _globals.expect)(result.success).toBe(true);
            if (!result.success) {
                return true;
            }
            // Property: Should detect the self-reference as circular
            (0, _globals.expect)(result.data).toBe(true);
            return true;
        }), {
            numRuns: 100
        });
    });
    (0, _globals.it)('should detect circular references when all IDs are identical (edge case)', async ()=>{
        await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
            pageId: _fastcheck.uuid(),
            pageType: _fastcheck.constantFrom('activity', 'event', 'accommodation', 'room_type', 'custom')
        }), async (testData)=>{
            // Edge case: When A, B, and C are all the same page
            // This is essentially a self-reference scenario
            // We're testing that the algorithm handles this correctly
            // Get sections for the page
            mockFrom.mockReturnValueOnce({
                select: _globals.jest.fn().mockReturnValue({
                    eq: _globals.jest.fn().mockReturnValue({
                        eq: _globals.jest.fn().mockResolvedValue({
                            data: [
                                {
                                    id: 'section-1'
                                }
                            ],
                            error: null
                        })
                    })
                })
            });
            // Get columns - empty is fine, the check happens before traversal
            mockFrom.mockReturnValueOnce({
                select: _globals.jest.fn().mockReturnValue({
                    in: _globals.jest.fn().mockReturnValue({
                        eq: _globals.jest.fn().mockResolvedValue({
                            data: [],
                            error: null
                        })
                    })
                })
            });
            // Test: Adding a reference to itself should detect the circle
            const references = [
                {
                    type: testData.pageType,
                    id: testData.pageId
                }
            ];
            const result = await (0, _sectionsService.detectCircularReferences)(testData.pageId, references);
            // Property: Detection should succeed
            (0, _globals.expect)(result.success).toBe(true);
            if (!result.success) {
                return true;
            }
            // Property: Should detect the circular reference
            (0, _globals.expect)(result.data).toBe(true);
            return true;
        }), {
            numRuns: 100
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvc2VydmljZXMvY2lyY3VsYXJSZWZlcmVuY2VEZXRlY3Rpb24ucHJvcGVydHkudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmYyBmcm9tICdmYXN0LWNoZWNrJztcbmltcG9ydCB7IGplc3QsIGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBiZWZvcmVFYWNoIH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5cbi8vIE1vY2sgU3VwYWJhc2UgYmVmb3JlIGltcG9ydGluZyBzZXJ2aWNlc1xuY29uc3QgbW9ja0Zyb20gPSBqZXN0LmZuKCk7XG5jb25zdCBtb2NrU3VwYWJhc2UgPSB7XG4gIGZyb206IG1vY2tGcm9tLFxufTtcblxuamVzdC5tb2NrKCcuLi9saWIvc3VwYWJhc2UnLCAoKSA9PiAoe1xuICBzdXBhYmFzZTogbW9ja1N1cGFiYXNlLFxufSkpO1xuXG4vLyBJbXBvcnQgYWZ0ZXIgbW9ja2luZ1xuaW1wb3J0IHsgZGV0ZWN0Q2lyY3VsYXJSZWZlcmVuY2VzIH0gZnJvbSAnLi9zZWN0aW9uc1NlcnZpY2UnO1xuaW1wb3J0IHR5cGUgeyBSZWZlcmVuY2UgfSBmcm9tICcuLi9zY2hlbWFzL2Ntc1NjaGVtYXMnO1xuXG4vLyBGZWF0dXJlOiBkZXN0aW5hdGlvbi13ZWRkaW5nLXBsYXRmb3JtLCBQcm9wZXJ0eSAzNDogQ2lyY3VsYXIgUmVmZXJlbmNlIERldGVjdGlvblxuXG5kZXNjcmliZSgnRmVhdHVyZTogZGVzdGluYXRpb24td2VkZGluZy1wbGF0Zm9ybSwgUHJvcGVydHkgMzQ6IENpcmN1bGFyIFJlZmVyZW5jZSBEZXRlY3Rpb24nLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGRldGVjdCBjaXJjdWxhciByZWZlcmVuY2UgY2hhaW5zIChBIOKGkiBCIOKGkiBDIOKGkiBBKScsIGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgIHBhZ2VBSWQ6IGZjLnV1aWQoKSxcbiAgICAgICAgICBwYWdlQklkOiBmYy51dWlkKCksXG4gICAgICAgICAgcGFnZUNJZDogZmMudXVpZCgpLFxuICAgICAgICAgIHBhZ2VUeXBlOiBmYy5jb25zdGFudEZyb20oJ2FjdGl2aXR5JywgJ2V2ZW50JywgJ2FjY29tbW9kYXRpb24nLCAncm9vbV90eXBlJywgJ2N1c3RvbScpLFxuICAgICAgICB9KS5maWx0ZXIoZGF0YSA9PiB7XG4gICAgICAgICAgLy8gRW5zdXJlIGFsbCBJRHMgYXJlIGRpc3RpbmN0IGZvciBhIHRydWUgY2lyY3VsYXIgY2hhaW4gdGVzdFxuICAgICAgICAgIHJldHVybiBkYXRhLnBhZ2VBSWQgIT09IGRhdGEucGFnZUJJZCAmJiBcbiAgICAgICAgICAgICAgICAgZGF0YS5wYWdlQklkICE9PSBkYXRhLnBhZ2VDSWQgJiYgXG4gICAgICAgICAgICAgICAgIGRhdGEucGFnZUNJZCAhPT0gZGF0YS5wYWdlQUlkO1xuICAgICAgICB9KSxcbiAgICAgICAgYXN5bmMgKHRlc3REYXRhKSA9PiB7XG4gICAgICAgICAgLy8gQ3JlYXRlIGEgY2lyY3VsYXIgY2hhaW46IEEg4oaSIEIg4oaSIEMg4oaSIEFcbiAgICAgICAgICAvLyBXZSdyZSB0ZXN0aW5nOiBkZXRlY3RDaXJjdWxhclJlZmVyZW5jZXMocGFnZUFJZCwgW3JlZiB0byBCXSlcbiAgICAgICAgICAvLyBUaGUgYWxnb3JpdGhtIHdpbGw6XG4gICAgICAgICAgLy8gMS4gQ2hlY2sgaWYgQiBsZWFkcyBiYWNrIHRvIEFcbiAgICAgICAgICAvLyAyLiBHZXQgQidzIHNlY3Rpb25zIGFuZCBjb2x1bW5zXG4gICAgICAgICAgLy8gMy4gRmluZCBCIHJlZmVyZW5jZXMgQ1xuICAgICAgICAgIC8vIDQuIENoZWNrIGlmIEMgbGVhZHMgYmFjayB0byBBXG4gICAgICAgICAgLy8gNS4gR2V0IEMncyBzZWN0aW9ucyBhbmQgY29sdW1uc1xuICAgICAgICAgIC8vIDYuIEZpbmQgQyByZWZlcmVuY2VzIEEgLSBDSVJDVUxBUiFcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBNb2NrIGZvciBjaGVja2luZyBwYWdlIEIgKGZpcnN0IHJlZmVyZW5jZSB3ZSdyZSBhZGRpbmcpXG4gICAgICAgICAgLy8gR2V0IHNlY3Rpb25zIGZvciBwYWdlIEJcbiAgICAgICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWVPbmNlKHtcbiAgICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgIGRhdGE6IFt7IGlkOiAnc2VjdGlvbi1iJyB9XSxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gR2V0IGNvbHVtbnMgZm9yIHBhZ2UgQiAoY29udGFpbnMgcmVmZXJlbmNlIHRvIEMpXG4gICAgICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlT25jZSh7XG4gICAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICBpbjogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICBkYXRhOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uX2lkOiAnc2VjdGlvbi1iJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudF90eXBlOiAncmVmZXJlbmNlcycsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRfZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0ZXN0RGF0YS5wYWdlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0ZXN0RGF0YS5wYWdlQ0lkLFxuICAgICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIE1vY2sgZm9yIGNoZWNraW5nIHBhZ2UgQyAoQiByZWZlcmVuY2VzIEMpXG4gICAgICAgICAgLy8gR2V0IHNlY3Rpb25zIGZvciBwYWdlIENcbiAgICAgICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWVPbmNlKHtcbiAgICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgIGRhdGE6IFt7IGlkOiAnc2VjdGlvbi1jJyB9XSxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gR2V0IGNvbHVtbnMgZm9yIHBhZ2UgQyAoY29udGFpbnMgcmVmZXJlbmNlIHRvIEEgLSBjcmVhdGluZyB0aGUgY2lyY2xlISlcbiAgICAgICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWVPbmNlKHtcbiAgICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgIGluOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgIGRhdGE6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb25faWQ6ICdzZWN0aW9uLWMnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50X3R5cGU6ICdyZWZlcmVuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudF9kYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHRlc3REYXRhLnBhZ2VUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRlc3REYXRhLnBhZ2VBSWQsIC8vIFJlZmVyZW5jZXMgYmFjayB0byBBIVxuICAgICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIFRlc3Q6IEFkZGluZyBhIHJlZmVyZW5jZSBmcm9tIEEgdG8gQiBzaG91bGQgZGV0ZWN0IHRoZSBjaXJjbGVcbiAgICAgICAgICBjb25zdCByZWZlcmVuY2VzOiBSZWZlcmVuY2VbXSA9IFt7XG4gICAgICAgICAgICB0eXBlOiB0ZXN0RGF0YS5wYWdlVHlwZSBhcyBhbnksXG4gICAgICAgICAgICBpZDogdGVzdERhdGEucGFnZUJJZCxcbiAgICAgICAgICB9XTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRldGVjdENpcmN1bGFyUmVmZXJlbmNlcyh0ZXN0RGF0YS5wYWdlQUlkLCByZWZlcmVuY2VzKTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBEZXRlY3Rpb24gc2hvdWxkIHN1Y2NlZWRcbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBQcm9wZXJ0eTogU2hvdWxkIGRldGVjdCB0aGUgY2lyY3VsYXIgcmVmZXJlbmNlXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhKS50b0JlKHRydWUpO1xuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDUwIH0gLy8gRmV3ZXIgcnVucyBkdWUgdG8gY29tcGxleCBtb2NraW5nXG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBub3QgZGV0ZWN0IGNpcmN1bGFyIHJlZmVyZW5jZXMgd2hlbiBub25lIGV4aXN0JywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgIGZjLnJlY29yZCh7XG4gICAgICAgICAgcGFnZUFJZDogZmMudXVpZCgpLFxuICAgICAgICAgIHBhZ2VCSWQ6IGZjLnV1aWQoKSxcbiAgICAgICAgICBwYWdlVHlwZTogZmMuY29uc3RhbnRGcm9tKCdhY3Rpdml0eScsICdldmVudCcsICdhY2NvbW1vZGF0aW9uJywgJ3Jvb21fdHlwZScsICdjdXN0b20nKSxcbiAgICAgICAgfSkuZmlsdGVyKGRhdGEgPT4gZGF0YS5wYWdlQUlkICE9PSBkYXRhLnBhZ2VCSWQpLCAvLyBFbnN1cmUgZGlzdGluY3QgSURzXG4gICAgICAgIGFzeW5jICh0ZXN0RGF0YSkgPT4ge1xuICAgICAgICAgIC8vIENyZWF0ZSBhIG5vbi1jaXJjdWxhciBjaGFpbjogQSDihpIgQiAoQiBoYXMgbm8gcmVmZXJlbmNlcylcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBNb2NrIGZvciBjaGVja2luZyBwYWdlIEIgKHRoZSByZWZlcmVuY2Ugd2UncmUgYWRkaW5nKVxuICAgICAgICAgIC8vIEdldCBzZWN0aW9ucyBmb3IgcGFnZSBCXG4gICAgICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlT25jZSh7XG4gICAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICBkYXRhOiBbeyBpZDogJ3NlY3Rpb24tYicgfV0sXG4gICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIEdldCBjb2x1bW5zIGZvciBwYWdlIEIgKG5vIHJlZmVyZW5jZXMgLSBlbXB0eSBhcnJheSlcbiAgICAgICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWVPbmNlKHtcbiAgICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgIGluOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgIGRhdGE6IFtdLCAvLyBObyByZWZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIFRlc3Q6IEFkZGluZyBhIHJlZmVyZW5jZSBmcm9tIEEgdG8gQiBzaG91bGQgbm90IGRldGVjdCBhIGNpcmNsZVxuICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZXM6IFJlZmVyZW5jZVtdID0gW3tcbiAgICAgICAgICAgIHR5cGU6IHRlc3REYXRhLnBhZ2VUeXBlIGFzIGFueSxcbiAgICAgICAgICAgIGlkOiB0ZXN0RGF0YS5wYWdlQklkLFxuICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGV0ZWN0Q2lyY3VsYXJSZWZlcmVuY2VzKHRlc3REYXRhLnBhZ2VBSWQsIHJlZmVyZW5jZXMpO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IERldGVjdGlvbiBzaG91bGQgc3VjY2VlZFxuICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcblxuICAgICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBTaG91bGQgbm90IGRldGVjdCBjaXJjdWxhciByZWZlcmVuY2VcbiAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEpLnRvQmUoZmFsc2UpO1xuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBkZXRlY3Qgc2VsZi1yZWZlcmVuY2luZyBwYWdlcyAoQSDihpIgQSknLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMucmVjb3JkKHtcbiAgICAgICAgICBwYWdlSWQ6IGZjLnV1aWQoKSxcbiAgICAgICAgICBwYWdlVHlwZTogZmMuY29uc3RhbnRGcm9tKCdhY3Rpdml0eScsICdldmVudCcsICdhY2NvbW1vZGF0aW9uJywgJ3Jvb21fdHlwZScsICdjdXN0b20nKSxcbiAgICAgICAgfSksXG4gICAgICAgIGFzeW5jICh0ZXN0RGF0YSkgPT4ge1xuICAgICAgICAgIC8vIFRlc3Q6IEFkZGluZyBhIHNlbGYtcmVmZXJlbmNlIChBIOKGkiBBKVxuICAgICAgICAgIC8vIFRoZSBhbGdvcml0aG0gc2hvdWxkIGRldGVjdCB0aGlzIGltbWVkaWF0ZWx5IHNpbmNlIHdlJ3JlIGNoZWNraW5nXG4gICAgICAgICAgLy8gaWYgYWRkaW5nIGEgcmVmZXJlbmNlIHRvIHBhZ2VJZCBmcm9tIHBhZ2VJZCBjcmVhdGVzIGEgY2lyY2xlXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gV2hlbiB3ZSBjaGVjayB0aGUgcmVmZXJlbmNlIHRvIGl0c2VsZiwgd2UnbGwgdHJhdmVyc2UgdG8gdGhlIHNhbWUgcGFnZVxuICAgICAgICAgIC8vIEdldCBzZWN0aW9ucyBmb3IgdGhlIHBhZ2VcbiAgICAgICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWVPbmNlKHtcbiAgICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgIGRhdGE6IFt7IGlkOiAnc2VjdGlvbi1hJyB9XSxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gR2V0IGNvbHVtbnMgLSBkb2Vzbid0IG1hdHRlciB3aGF0J3MgaGVyZSwgdGhlIGFsZ29yaXRobSBzaG91bGQgZGV0ZWN0XG4gICAgICAgICAgLy8gdGhhdCB3ZSdyZSBiYWNrIGF0IHRoZSBzdGFydGluZyBwYWdlXG4gICAgICAgICAgbW9ja0Zyb20ubW9ja1JldHVyblZhbHVlT25jZSh7XG4gICAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICBpbjogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gVGVzdDogQWRkaW5nIGEgc2VsZi1yZWZlcmVuY2Ugc2hvdWxkIGRldGVjdCB0aGUgY2lyY2xlXG4gICAgICAgICAgY29uc3QgcmVmZXJlbmNlczogUmVmZXJlbmNlW10gPSBbe1xuICAgICAgICAgICAgdHlwZTogdGVzdERhdGEucGFnZVR5cGUgYXMgYW55LFxuICAgICAgICAgICAgaWQ6IHRlc3REYXRhLnBhZ2VJZCxcbiAgICAgICAgICB9XTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRldGVjdENpcmN1bGFyUmVmZXJlbmNlcyh0ZXN0RGF0YS5wYWdlSWQsIHJlZmVyZW5jZXMpO1xuXG4gICAgICAgICAgLy8gUHJvcGVydHk6IERldGVjdGlvbiBzaG91bGQgc3VjY2VlZFxuICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcblxuICAgICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBTaG91bGQgZGV0ZWN0IHRoZSBzZWxmLXJlZmVyZW5jZSBhcyBjaXJjdWxhclxuICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YSkudG9CZSh0cnVlKTtcblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgeyBudW1SdW5zOiAxMDAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgZGV0ZWN0IGNpcmN1bGFyIHJlZmVyZW5jZXMgd2hlbiBhbGwgSURzIGFyZSBpZGVudGljYWwgKGVkZ2UgY2FzZSknLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgZmMucmVjb3JkKHtcbiAgICAgICAgICBwYWdlSWQ6IGZjLnV1aWQoKSxcbiAgICAgICAgICBwYWdlVHlwZTogZmMuY29uc3RhbnRGcm9tKCdhY3Rpdml0eScsICdldmVudCcsICdhY2NvbW1vZGF0aW9uJywgJ3Jvb21fdHlwZScsICdjdXN0b20nKSxcbiAgICAgICAgfSksXG4gICAgICAgIGFzeW5jICh0ZXN0RGF0YSkgPT4ge1xuICAgICAgICAgIC8vIEVkZ2UgY2FzZTogV2hlbiBBLCBCLCBhbmQgQyBhcmUgYWxsIHRoZSBzYW1lIHBhZ2VcbiAgICAgICAgICAvLyBUaGlzIGlzIGVzc2VudGlhbGx5IGEgc2VsZi1yZWZlcmVuY2Ugc2NlbmFyaW9cbiAgICAgICAgICAvLyBXZSdyZSB0ZXN0aW5nIHRoYXQgdGhlIGFsZ29yaXRobSBoYW5kbGVzIHRoaXMgY29ycmVjdGx5XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gR2V0IHNlY3Rpb25zIGZvciB0aGUgcGFnZVxuICAgICAgICAgIG1vY2tGcm9tLm1vY2tSZXR1cm5WYWx1ZU9uY2Uoe1xuICAgICAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgZGF0YTogW3sgaWQ6ICdzZWN0aW9uLTEnIH1dLFxuICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBHZXQgY29sdW1ucyAtIGVtcHR5IGlzIGZpbmUsIHRoZSBjaGVjayBoYXBwZW5zIGJlZm9yZSB0cmF2ZXJzYWxcbiAgICAgICAgICBtb2NrRnJvbS5tb2NrUmV0dXJuVmFsdWVPbmNlKHtcbiAgICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgIGluOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBUZXN0OiBBZGRpbmcgYSByZWZlcmVuY2UgdG8gaXRzZWxmIHNob3VsZCBkZXRlY3QgdGhlIGNpcmNsZVxuICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZXM6IFJlZmVyZW5jZVtdID0gW3tcbiAgICAgICAgICAgIHR5cGU6IHRlc3REYXRhLnBhZ2VUeXBlIGFzIGFueSxcbiAgICAgICAgICAgIGlkOiB0ZXN0RGF0YS5wYWdlSWQsXG4gICAgICAgICAgfV07XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkZXRlY3RDaXJjdWxhclJlZmVyZW5jZXModGVzdERhdGEucGFnZUlkLCByZWZlcmVuY2VzKTtcblxuICAgICAgICAgIC8vIFByb3BlcnR5OiBEZXRlY3Rpb24gc2hvdWxkIHN1Y2NlZWRcbiAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBQcm9wZXJ0eTogU2hvdWxkIGRldGVjdCB0aGUgY2lyY3VsYXIgcmVmZXJlbmNlXG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhKS50b0JlKHRydWUpO1xuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7IG51bVJ1bnM6IDEwMCB9XG4gICAgKTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJtb2NrRnJvbSIsImplc3QiLCJmbiIsIm1vY2tTdXBhYmFzZSIsImZyb20iLCJtb2NrIiwic3VwYWJhc2UiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiaXQiLCJmYyIsImFzc2VydCIsImFzeW5jUHJvcGVydHkiLCJyZWNvcmQiLCJwYWdlQUlkIiwidXVpZCIsInBhZ2VCSWQiLCJwYWdlQ0lkIiwicGFnZVR5cGUiLCJjb25zdGFudEZyb20iLCJmaWx0ZXIiLCJkYXRhIiwidGVzdERhdGEiLCJtb2NrUmV0dXJuVmFsdWVPbmNlIiwic2VsZWN0IiwibW9ja1JldHVyblZhbHVlIiwiZXEiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsImlkIiwiZXJyb3IiLCJpbiIsInNlY3Rpb25faWQiLCJjb250ZW50X3R5cGUiLCJjb250ZW50X2RhdGEiLCJyZWZlcmVuY2VzIiwidHlwZSIsInJlc3VsdCIsImRldGVjdENpcmN1bGFyUmVmZXJlbmNlcyIsImV4cGVjdCIsInN1Y2Nlc3MiLCJ0b0JlIiwibnVtUnVucyIsInBhZ2VJZCJdLCJtYXBwaW5ncyI6Ijs7Oztt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