{"version":3,"sources":["/Users/jaron/Desktop/wedding-platform-v2/services/circularReferenceDetection.property.test.ts"],"sourcesContent":["import * as fc from 'fast-check';\nimport { jest, describe, it, expect, beforeEach } from '@jest/globals';\n\n// Mock Supabase before importing services\nconst mockFrom = jest.fn();\nconst mockSupabase = {\n  from: mockFrom,\n};\n\njest.mock('../lib/supabase', () => ({\n  supabase: mockSupabase,\n}));\n\n// Import after mocking\nimport { detectCircularReferences } from './sectionsService';\nimport type { Reference } from '../schemas/cmsSchemas';\n\n// Feature: destination-wedding-platform, Property 34: Circular Reference Detection\n\ndescribe('Feature: destination-wedding-platform, Property 34: Circular Reference Detection', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('should detect circular reference chains (A → B → C → A)', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.record({\n          pageAId: fc.uuid(),\n          pageBId: fc.uuid(),\n          pageCId: fc.uuid(),\n          pageType: fc.constantFrom('activity', 'event', 'accommodation', 'room_type', 'custom'),\n        }).filter(data => {\n          // Ensure all IDs are distinct for a true circular chain test\n          return data.pageAId !== data.pageBId && \n                 data.pageBId !== data.pageCId && \n                 data.pageCId !== data.pageAId;\n        }),\n        async (testData) => {\n          // Create a circular chain: A → B → C → A\n          // We're testing: detectCircularReferences(pageAId, [ref to B])\n          // The algorithm will:\n          // 1. Check if B leads back to A\n          // 2. Get B's sections and columns\n          // 3. Find B references C\n          // 4. Check if C leads back to A\n          // 5. Get C's sections and columns\n          // 6. Find C references A - CIRCULAR!\n          \n          // Mock for checking page B (first reference we're adding)\n          // Get sections for page B\n          mockFrom.mockReturnValueOnce({\n            select: jest.fn().mockReturnValue({\n              eq: jest.fn().mockReturnValue({\n                eq: jest.fn().mockResolvedValue({\n                  data: [{ id: 'section-b' }],\n                  error: null,\n                }),\n              }),\n            }),\n          });\n\n          // Get columns for page B (contains reference to C)\n          mockFrom.mockReturnValueOnce({\n            select: jest.fn().mockReturnValue({\n              in: jest.fn().mockReturnValue({\n                eq: jest.fn().mockResolvedValue({\n                  data: [{\n                    section_id: 'section-b',\n                    content_type: 'references',\n                    content_data: {\n                      references: [{\n                        type: testData.pageType,\n                        id: testData.pageCId,\n                      }],\n                    },\n                  }],\n                  error: null,\n                }),\n              }),\n            }),\n          });\n\n          // Mock for checking page C (B references C)\n          // Get sections for page C\n          mockFrom.mockReturnValueOnce({\n            select: jest.fn().mockReturnValue({\n              eq: jest.fn().mockReturnValue({\n                eq: jest.fn().mockResolvedValue({\n                  data: [{ id: 'section-c' }],\n                  error: null,\n                }),\n              }),\n            }),\n          });\n\n          // Get columns for page C (contains reference to A - creating the circle!)\n          mockFrom.mockReturnValueOnce({\n            select: jest.fn().mockReturnValue({\n              in: jest.fn().mockReturnValue({\n                eq: jest.fn().mockResolvedValue({\n                  data: [{\n                    section_id: 'section-c',\n                    content_type: 'references',\n                    content_data: {\n                      references: [{\n                        type: testData.pageType,\n                        id: testData.pageAId, // References back to A!\n                      }],\n                    },\n                  }],\n                  error: null,\n                }),\n              }),\n            }),\n          });\n\n          // Test: Adding a reference from A to B should detect the circle\n          const references: Reference[] = [{\n            type: testData.pageType as any,\n            id: testData.pageBId,\n          }];\n\n          const result = await detectCircularReferences(testData.pageAId, references);\n\n          // Property: Detection should succeed\n          expect(result.success).toBe(true);\n\n          if (!result.success) {\n            return true;\n          }\n\n          // Property: Should detect the circular reference\n          expect(result.data).toBe(true);\n\n          return true;\n        }\n      ),\n      { numRuns: 50 } // Fewer runs due to complex mocking\n    );\n  });\n\n  it('should not detect circular references when none exist', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.record({\n          pageAId: fc.uuid(),\n          pageBId: fc.uuid(),\n          pageType: fc.constantFrom('activity', 'event', 'accommodation', 'room_type', 'custom'),\n        }).filter(data => data.pageAId !== data.pageBId), // Ensure distinct IDs\n        async (testData) => {\n          // Create a non-circular chain: A → B (B has no references)\n          \n          // Mock for checking page B (the reference we're adding)\n          // Get sections for page B\n          mockFrom.mockReturnValueOnce({\n            select: jest.fn().mockReturnValue({\n              eq: jest.fn().mockReturnValue({\n                eq: jest.fn().mockResolvedValue({\n                  data: [{ id: 'section-b' }],\n                  error: null,\n                }),\n              }),\n            }),\n          });\n\n          // Get columns for page B (no references - empty array)\n          mockFrom.mockReturnValueOnce({\n            select: jest.fn().mockReturnValue({\n              in: jest.fn().mockReturnValue({\n                eq: jest.fn().mockResolvedValue({\n                  data: [], // No references\n                  error: null,\n                }),\n              }),\n            }),\n          });\n\n          // Test: Adding a reference from A to B should not detect a circle\n          const references: Reference[] = [{\n            type: testData.pageType as any,\n            id: testData.pageBId,\n          }];\n\n          const result = await detectCircularReferences(testData.pageAId, references);\n\n          // Property: Detection should succeed\n          expect(result.success).toBe(true);\n\n          if (!result.success) {\n            return true;\n          }\n\n          // Property: Should not detect circular reference\n          expect(result.data).toBe(false);\n\n          return true;\n        }\n      ),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should detect self-referencing pages (A → A)', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.record({\n          pageId: fc.uuid(),\n          pageType: fc.constantFrom('activity', 'event', 'accommodation', 'room_type', 'custom'),\n        }),\n        async (testData) => {\n          // Test: Adding a self-reference (A → A)\n          // The algorithm should detect this immediately since we're checking\n          // if adding a reference to pageId from pageId creates a circle\n          \n          // When we check the reference to itself, we'll traverse to the same page\n          // Get sections for the page\n          mockFrom.mockReturnValueOnce({\n            select: jest.fn().mockReturnValue({\n              eq: jest.fn().mockReturnValue({\n                eq: jest.fn().mockResolvedValue({\n                  data: [{ id: 'section-a' }],\n                  error: null,\n                }),\n              }),\n            }),\n          });\n\n          // Get columns - doesn't matter what's here, the algorithm should detect\n          // that we're back at the starting page\n          mockFrom.mockReturnValueOnce({\n            select: jest.fn().mockReturnValue({\n              in: jest.fn().mockReturnValue({\n                eq: jest.fn().mockResolvedValue({\n                  data: [],\n                  error: null,\n                }),\n              }),\n            }),\n          });\n\n          // Test: Adding a self-reference should detect the circle\n          const references: Reference[] = [{\n            type: testData.pageType as any,\n            id: testData.pageId,\n          }];\n\n          const result = await detectCircularReferences(testData.pageId, references);\n\n          // Property: Detection should succeed\n          expect(result.success).toBe(true);\n\n          if (!result.success) {\n            return true;\n          }\n\n          // Property: Should detect the self-reference as circular\n          expect(result.data).toBe(true);\n\n          return true;\n        }\n      ),\n      { numRuns: 100 }\n    );\n  });\n\n  it('should detect circular references when all IDs are identical (edge case)', async () => {\n    await fc.assert(\n      fc.asyncProperty(\n        fc.record({\n          pageId: fc.uuid(),\n          pageType: fc.constantFrom('activity', 'event', 'accommodation', 'room_type', 'custom'),\n        }),\n        async (testData) => {\n          // Edge case: When A, B, and C are all the same page\n          // This is essentially a self-reference scenario\n          // We're testing that the algorithm handles this correctly\n          \n          // Get sections for the page\n          mockFrom.mockReturnValueOnce({\n            select: jest.fn().mockReturnValue({\n              eq: jest.fn().mockReturnValue({\n                eq: jest.fn().mockResolvedValue({\n                  data: [{ id: 'section-1' }],\n                  error: null,\n                }),\n              }),\n            }),\n          });\n\n          // Get columns - empty is fine, the check happens before traversal\n          mockFrom.mockReturnValueOnce({\n            select: jest.fn().mockReturnValue({\n              in: jest.fn().mockReturnValue({\n                eq: jest.fn().mockResolvedValue({\n                  data: [],\n                  error: null,\n                }),\n              }),\n            }),\n          });\n\n          // Test: Adding a reference to itself should detect the circle\n          const references: Reference[] = [{\n            type: testData.pageType as any,\n            id: testData.pageId,\n          }];\n\n          const result = await detectCircularReferences(testData.pageId, references);\n\n          // Property: Detection should succeed\n          expect(result.success).toBe(true);\n\n          if (!result.success) {\n            return true;\n          }\n\n          // Property: Should detect the circular reference\n          expect(result.data).toBe(true);\n\n          return true;\n        }\n      ),\n      { numRuns: 100 }\n    );\n  });\n});\n"],"names":["mockFrom","jest","fn","mockSupabase","from","mock","supabase","describe","beforeEach","clearAllMocks","it","fc","assert","asyncProperty","record","pageAId","uuid","pageBId","pageCId","pageType","constantFrom","filter","data","testData","mockReturnValueOnce","select","mockReturnValue","eq","mockResolvedValue","id","error","in","section_id","content_type","content_data","references","type","result","detectCircularReferences","expect","success","toBe","numRuns","pageId"],"mappings":"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"}