7ef18a1fb019afa1b41b32a179306e80
/**
 * Property-Based Tests for FormModal Component
 * 
 * Feature: admin-ui-modernization
 * Tests universal properties of the FormModal component across various inputs.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = require("@testing-library/react");
const _zod = require("zod");
const _fastcheck = /*#__PURE__*/ _interop_require_wildcard(require("fast-check"));
const _FormModal = require("./FormModal");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe('FormModal Property Tests', ()=>{
    // Clean up after each test to prevent DOM pollution
    afterEach(()=>{
        (0, _react.cleanup)();
    });
    /**
   * Property 7: Form validation prevents invalid submission
   * Validates: Requirements 4.7, 12.3
   * 
   * For any form with required fields, attempting to submit the form with missing
   * or invalid required fields should prevent submission and display field-level error messages.
   */ describe('Feature: admin-ui-modernization, Property 7: Form validation prevents invalid submission', ()=>{
        it('should prevent submission and show errors when required fields are missing', async ()=>{
            await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
                firstName: _fastcheck.string({
                    minLength: 1,
                    maxLength: 50
                }),
                lastName: _fastcheck.string({
                    minLength: 1,
                    maxLength: 50
                }),
                email: _fastcheck.emailAddress()
            }), async (validData)=>{
                const schema = _zod.z.object({
                    firstName: _zod.z.string().min(1, 'First name is required'),
                    lastName: _zod.z.string().min(1, 'Last name is required'),
                    email: _zod.z.string().email('Invalid email')
                });
                const fields = [
                    {
                        name: 'firstName',
                        label: 'First Name',
                        type: 'text',
                        required: true
                    },
                    {
                        name: 'lastName',
                        label: 'Last Name',
                        type: 'text',
                        required: true
                    },
                    {
                        name: 'email',
                        label: 'Email',
                        type: 'email',
                        required: true
                    }
                ];
                const onSubmit = jest.fn();
                const onClose = jest.fn();
                const { container, unmount } = (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_FormModal.FormModal, {
                    isOpen: true,
                    onClose: onClose,
                    title: "Test Form",
                    onSubmit: onSubmit,
                    schema: schema,
                    fields: fields,
                    initialData: {}
                }));
                try {
                    // Try to submit empty form
                    const submitButtons = _react.screen.getAllByRole('button', {
                        name: /submit/i
                    });
                    const submitButton = submitButtons[submitButtons.length - 1]; // Get the last one (most recent)
                    _react.fireEvent.click(submitButton);
                    // Wait for validation errors to appear
                    await (0, _react.waitFor)(()=>{
                        const errors = container.querySelectorAll('[role="alert"]');
                        expect(errors.length).toBeGreaterThan(0);
                    });
                    // Verify onSubmit was not called
                    expect(onSubmit).not.toHaveBeenCalled();
                } finally{
                    unmount();
                }
            }), {
                numRuns: 50
            } // Reduced runs for async operations
            );
        });
        it('should show field-level errors for invalid data', async ()=>{
            await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
                invalidEmail: _fastcheck.string({
                    minLength: 1,
                    maxLength: 50
                }).filter((s)=>!s.includes('@'))
            }), async ({ invalidEmail })=>{
                const schema = _zod.z.object({
                    email: _zod.z.string().email('Invalid email')
                });
                const fields = [
                    {
                        name: 'email',
                        label: 'Email',
                        type: 'email',
                        required: true
                    }
                ];
                const onSubmit = jest.fn();
                const onClose = jest.fn();
                const { unmount } = (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_FormModal.FormModal, {
                    isOpen: true,
                    onClose: onClose,
                    title: "Test Form",
                    onSubmit: onSubmit,
                    schema: schema,
                    fields: fields,
                    initialData: {
                        email: invalidEmail
                    }
                }));
                try {
                    const emailInput = _react.screen.getByLabelText(/email/i);
                    const submitButtons = _react.screen.getAllByRole('button', {
                        name: /submit/i
                    });
                    const submitButton = submitButtons[submitButtons.length - 1];
                    // Blur the field to trigger validation
                    _react.fireEvent.blur(emailInput);
                    // Try to submit
                    _react.fireEvent.click(submitButton);
                    // Wait for error message
                    await (0, _react.waitFor)(()=>{
                        expect(_react.screen.getByText(/invalid email/i)).toBeInTheDocument();
                    });
                    // Verify onSubmit was not called
                    expect(onSubmit).not.toHaveBeenCalled();
                } finally{
                    unmount();
                }
            }), {
                numRuns: 50
            });
        });
        it('should allow submission when all required fields are valid', async ()=>{
            // Unit test with specific example instead of property-based test
            // This validates the same behavior but runs much faster
            const validData = {
                firstName: 'John',
                lastName: 'Doe',
                email: 'john@example.com'
            };
            const schema = _zod.z.object({
                firstName: _zod.z.string().min(1),
                lastName: _zod.z.string().min(1),
                email: _zod.z.string().email()
            });
            const fields = [
                {
                    name: 'firstName',
                    label: 'First Name',
                    type: 'text',
                    required: true
                },
                {
                    name: 'lastName',
                    label: 'Last Name',
                    type: 'text',
                    required: true
                },
                {
                    name: 'email',
                    label: 'Email',
                    type: 'email',
                    required: true
                }
            ];
            const onSubmit = jest.fn().mockResolvedValue(undefined);
            const onClose = jest.fn();
            const { unmount } = (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_FormModal.FormModal, {
                isOpen: true,
                onClose: onClose,
                title: "Test Form",
                onSubmit: onSubmit,
                schema: schema,
                fields: fields,
                initialData: validData
            }));
            try {
                const submitButtons = _react.screen.getAllByRole('button', {
                    name: /submit/i
                });
                const submitButton = submitButtons[submitButtons.length - 1];
                _react.fireEvent.click(submitButton);
                // Wait for submission
                await (0, _react.waitFor)(()=>{
                    expect(onSubmit).toHaveBeenCalled();
                }, {
                    timeout: 1000
                });
                // Verify it was called with the correct data
                expect(onSubmit).toHaveBeenCalledWith(validData);
            } finally{
                unmount();
            }
        });
    });
    /**
   * Property 8: Modal closes on Escape key
   * Validates: Requirements 17.3
   * 
   * For any open modal dialog, pressing the Escape key should close the modal.
   */ describe('Feature: admin-ui-modernization, Property 8: Modal closes on Escape key', ()=>{
        it('should close modal when Escape key is pressed', async ()=>{
            await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
                title: _fastcheck.string({
                    minLength: 1,
                    maxLength: 100
                })
            }), async ({ title })=>{
                const schema = _zod.z.object({
                    name: _zod.z.string().min(1)
                });
                const fields = [
                    {
                        name: 'name',
                        label: 'Name',
                        type: 'text',
                        required: true
                    }
                ];
                const onSubmit = jest.fn();
                const onClose = jest.fn();
                const { unmount } = (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_FormModal.FormModal, {
                    isOpen: true,
                    onClose: onClose,
                    title: title,
                    onSubmit: onSubmit,
                    schema: schema,
                    fields: fields
                }));
                try {
                    // Press Escape key
                    _react.fireEvent.keyDown(document, {
                        key: 'Escape'
                    });
                    // Verify onClose was called
                    await (0, _react.waitFor)(()=>{
                        expect(onClose).toHaveBeenCalled();
                    });
                } finally{
                    unmount();
                }
            }), {
                numRuns: 50
            });
        });
        it('should close FormModalSimple when Escape key is pressed', async ()=>{
            await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
                title: _fastcheck.string({
                    minLength: 1,
                    maxLength: 100
                }),
                content: _fastcheck.string({
                    minLength: 1,
                    maxLength: 200
                })
            }), async ({ title, content })=>{
                const onClose = jest.fn();
                const { unmount } = (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_FormModal.FormModalSimple, {
                    isOpen: true,
                    onClose: onClose,
                    title: title,
                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        children: content
                    })
                }));
                try {
                    // Press Escape key
                    _react.fireEvent.keyDown(document, {
                        key: 'Escape'
                    });
                    // Verify onClose was called
                    await (0, _react.waitFor)(()=>{
                        expect(onClose).toHaveBeenCalled();
                    });
                } finally{
                    unmount();
                }
            }), {
                numRuns: 50
            });
        });
    });
    /**
   * Property 9: Form inputs have associated labels
   * Validates: Requirements 18.5
   * 
   * For any form input field, there should be an associated label element
   * and error messages should be displayed when the field is invalid.
   */ describe('Feature: admin-ui-modernization, Property 9: Form inputs have associated labels', ()=>{
        it('should have associated labels for all form inputs', async ()=>{
            await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.array(_fastcheck.record({
                name: _fastcheck.string({
                    minLength: 1,
                    maxLength: 20
                }).filter((s)=>/^[a-zA-Z]+$/.test(s)),
                label: _fastcheck.string({
                    minLength: 3,
                    maxLength: 50
                }).filter((s)=>{
                    const trimmed = s.trim();
                    return trimmed.length >= 3 && /[a-zA-Z]/.test(trimmed); // Must have at least 3 chars and contain a letter
                }),
                type: _fastcheck.constantFrom('text', 'email', 'number', 'select', 'textarea', 'date', 'checkbox')
            }), {
                minLength: 1,
                maxLength: 3
            } // Reduced max to speed up test
            ).map((fields)=>{
                // Ensure unique field names by appending index
                return fields.map((field, index)=>({
                        ...field,
                        name: `${field.name}${index}`
                    }));
            }), async (fieldConfigs)=>{
                // Create schema dynamically
                const schemaShape = {};
                fieldConfigs.forEach((field)=>{
                    schemaShape[field.name] = _zod.z.string().optional();
                });
                const schema = _zod.z.object(schemaShape);
                const fields = fieldConfigs.map((config)=>({
                        name: config.name,
                        label: config.label,
                        type: config.type,
                        required: false,
                        options: config.type === 'select' ? [
                            {
                                label: 'Option 1',
                                value: 'opt1'
                            },
                            {
                                label: 'Option 2',
                                value: 'opt2'
                            }
                        ] : undefined
                    }));
                const onSubmit = jest.fn();
                const onClose = jest.fn();
                const { unmount } = (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_FormModal.FormModal, {
                    isOpen: true,
                    onClose: onClose,
                    title: "Test Form",
                    onSubmit: onSubmit,
                    schema: schema,
                    fields: fields
                }));
                try {
                    // Verify each field has an associated label
                    for (const field of fieldConfigs){
                        // Use a more flexible query that handles special characters - FIXED: use \\$& instead of UUID
                        // Trim the label to match how it's rendered in the DOM
                        const trimmedLabel = field.label.trim();
                        const labelElement = _react.screen.getByLabelText(new RegExp(trimmedLabel.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i'));
                        expect(labelElement).toBeInTheDocument();
                        expect(labelElement).toHaveAttribute('id', field.name);
                    }
                } finally{
                    unmount();
                }
            }), {
                numRuns: 20
            } // Reduced runs
            );
        }, 10000); // Increased timeout to 10 seconds
        it('should display error messages with proper ARIA attributes', async ()=>{
            await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
                fieldName: _fastcheck.constantFrom('email', 'name', 'age'),
                errorMessage: _fastcheck.string({
                    minLength: 10,
                    maxLength: 100
                }).filter((s)=>s.trim().length >= 10)
            }), async ({ fieldName, errorMessage })=>{
                const schema = _zod.z.object({
                    [fieldName]: _zod.z.string().min(1, errorMessage)
                });
                const fields = [
                    {
                        name: fieldName,
                        label: fieldName.charAt(0).toUpperCase() + fieldName.slice(1),
                        type: 'text',
                        required: true
                    }
                ];
                const onSubmit = jest.fn();
                const onClose = jest.fn();
                const { unmount } = (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_FormModal.FormModal, {
                    isOpen: true,
                    onClose: onClose,
                    title: "Test Form",
                    onSubmit: onSubmit,
                    schema: schema,
                    fields: fields,
                    initialData: {
                        [fieldName]: ''
                    }
                }));
                try {
                    const input = _react.screen.getByLabelText(new RegExp(fieldName, 'i'));
                    const submitButtons = _react.screen.getAllByRole('button', {
                        name: /submit/i
                    });
                    const submitButton = submitButtons[submitButtons.length - 1];
                    // Trigger validation by submitting
                    _react.fireEvent.click(submitButton);
                    // Optimized: Check for error first, then verify ARIA attributes
                    await (0, _react.waitFor)(()=>{
                        const errorElement = _react.screen.getByRole('alert');
                        expect(errorElement).toBeInTheDocument();
                    }, {
                        timeout: 1000
                    });
                    // Verify error message content (normalize whitespace for comparison)
                    const errorElement = _react.screen.getByRole('alert');
                    const normalizedExpected = errorMessage.replace(/\s+/g, ' ').trim();
                    const normalizedActual = errorElement.textContent?.replace(/\s+/g, ' ').trim() || '';
                    expect(normalizedActual).toContain(normalizedExpected);
                    // Verify ARIA attributes
                    expect(input).toHaveAttribute('aria-invalid', 'true');
                    expect(input).toHaveAttribute('aria-describedby');
                } finally{
                    unmount();
                }
            }), {
                numRuns: 5
            } // Reduced from 10 to 5
            );
        }, 10000); // Reduced timeout to 10 seconds
    });
    /**
   * Property 32: Form submission button state
   * Validates: Requirements 11.3
   * 
   * For any form in a submitting state, the submit button should be disabled
   * and display a loading spinner.
   */ describe('Feature: admin-ui-modernization, Property 32: Form submission button state', ()=>{
        it('should disable submit button and show loading spinner during submission', async ()=>{
            await _fastcheck.assert(_fastcheck.asyncProperty(_fastcheck.record({
                name: _fastcheck.string({
                    minLength: 2,
                    maxLength: 50
                }).filter((s)=>s.trim().length >= 2)
            }), async (validData)=>{
                const schema = _zod.z.object({
                    name: _zod.z.string().min(1)
                });
                const fields = [
                    {
                        name: 'name',
                        label: 'Name',
                        type: 'text',
                        required: true
                    }
                ];
                // Create a promise that we can control
                let resolveSubmit;
                const submitPromise = new Promise((resolve)=>{
                    resolveSubmit = resolve;
                });
                const onSubmit = jest.fn().mockReturnValue(submitPromise);
                const onClose = jest.fn();
                const { unmount } = (0, _react.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_FormModal.FormModal, {
                    isOpen: true,
                    onClose: onClose,
                    title: "Test Form",
                    onSubmit: onSubmit,
                    schema: schema,
                    fields: fields,
                    initialData: validData
                }));
                try {
                    const submitButtons = _react.screen.getAllByRole('button', {
                        name: /submit/i
                    });
                    const submitButton = submitButtons[submitButtons.length - 1];
                    // Click submit
                    _react.fireEvent.click(submitButton);
                    // Wait for button to show loading state
                    await (0, _react.waitFor)(()=>{
                        expect(submitButton).toBeDisabled();
                    }, {
                        timeout: 2000
                    });
                    // Resolve the submission
                    resolveSubmit();
                    // Wait for submission to complete
                    await (0, _react.waitFor)(()=>{
                        expect(onSubmit).toHaveBeenCalled();
                    }, {
                        timeout: 2000
                    });
                } finally{
                    unmount();
                }
            }), {
                numRuns: 10
            } // Fewer runs for async operations
            );
        }, 15000); // Increase timeout for property-based test
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXJvbi9EZXNrdG9wL3dlZGRpbmctcGxhdGZvcm0tdjIvY29tcG9uZW50cy91aS9Gb3JtTW9kYWwucHJvcGVydHkudGVzdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQcm9wZXJ0eS1CYXNlZCBUZXN0cyBmb3IgRm9ybU1vZGFsIENvbXBvbmVudFxuICogXG4gKiBGZWF0dXJlOiBhZG1pbi11aS1tb2Rlcm5pemF0aW9uXG4gKiBUZXN0cyB1bml2ZXJzYWwgcHJvcGVydGllcyBvZiB0aGUgRm9ybU1vZGFsIGNvbXBvbmVudCBhY3Jvc3MgdmFyaW91cyBpbnB1dHMuXG4gKi9cblxuaW1wb3J0IHsgcmVuZGVyLCBzY3JlZW4sIGZpcmVFdmVudCwgd2FpdEZvciwgY2xlYW51cCB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xuaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5pbXBvcnQgKiBhcyBmYyBmcm9tICdmYXN0LWNoZWNrJztcbmltcG9ydCB7IEZvcm1Nb2RhbCwgRm9ybU1vZGFsU2ltcGxlIH0gZnJvbSAnLi9Gb3JtTW9kYWwnO1xuaW1wb3J0IHR5cGUgeyBGb3JtRmllbGQgfSBmcm9tICcuL0R5bmFtaWNGb3JtJztcblxuZGVzY3JpYmUoJ0Zvcm1Nb2RhbCBQcm9wZXJ0eSBUZXN0cycsICgpID0+IHtcbiAgLy8gQ2xlYW4gdXAgYWZ0ZXIgZWFjaCB0ZXN0IHRvIHByZXZlbnQgRE9NIHBvbGx1dGlvblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGNsZWFudXAoKTtcbiAgfSk7XG4gIC8qKlxuICAgKiBQcm9wZXJ0eSA3OiBGb3JtIHZhbGlkYXRpb24gcHJldmVudHMgaW52YWxpZCBzdWJtaXNzaW9uXG4gICAqIFZhbGlkYXRlczogUmVxdWlyZW1lbnRzIDQuNywgMTIuM1xuICAgKiBcbiAgICogRm9yIGFueSBmb3JtIHdpdGggcmVxdWlyZWQgZmllbGRzLCBhdHRlbXB0aW5nIHRvIHN1Ym1pdCB0aGUgZm9ybSB3aXRoIG1pc3NpbmdcbiAgICogb3IgaW52YWxpZCByZXF1aXJlZCBmaWVsZHMgc2hvdWxkIHByZXZlbnQgc3VibWlzc2lvbiBhbmQgZGlzcGxheSBmaWVsZC1sZXZlbCBlcnJvciBtZXNzYWdlcy5cbiAgICovXG4gIGRlc2NyaWJlKCdGZWF0dXJlOiBhZG1pbi11aS1tb2Rlcm5pemF0aW9uLCBQcm9wZXJ0eSA3OiBGb3JtIHZhbGlkYXRpb24gcHJldmVudHMgaW52YWxpZCBzdWJtaXNzaW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcHJldmVudCBzdWJtaXNzaW9uIGFuZCBzaG93IGVycm9ycyB3aGVuIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgICAgZmlyc3ROYW1lOiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogNTAgfSksXG4gICAgICAgICAgICBsYXN0TmFtZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLFxuICAgICAgICAgICAgZW1haWw6IGZjLmVtYWlsQWRkcmVzcygpLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGFzeW5jICh2YWxpZERhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHoub2JqZWN0KHtcbiAgICAgICAgICAgICAgZmlyc3ROYW1lOiB6LnN0cmluZygpLm1pbigxLCAnRmlyc3QgbmFtZSBpcyByZXF1aXJlZCcpLFxuICAgICAgICAgICAgICBsYXN0TmFtZTogei5zdHJpbmcoKS5taW4oMSwgJ0xhc3QgbmFtZSBpcyByZXF1aXJlZCcpLFxuICAgICAgICAgICAgICBlbWFpbDogei5zdHJpbmcoKS5lbWFpbCgnSW52YWxpZCBlbWFpbCcpLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGZpZWxkczogRm9ybUZpZWxkW10gPSBbXG4gICAgICAgICAgICAgIHsgbmFtZTogJ2ZpcnN0TmFtZScsIGxhYmVsOiAnRmlyc3QgTmFtZScsIHR5cGU6ICd0ZXh0JywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgICAgeyBuYW1lOiAnbGFzdE5hbWUnLCBsYWJlbDogJ0xhc3QgTmFtZScsIHR5cGU6ICd0ZXh0JywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgICAgeyBuYW1lOiAnZW1haWwnLCBsYWJlbDogJ0VtYWlsJywgdHlwZTogJ2VtYWlsJywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGNvbnN0IG9uU3VibWl0ID0gamVzdC5mbigpO1xuICAgICAgICAgICAgY29uc3Qgb25DbG9zZSA9IGplc3QuZm4oKTtcblxuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZXIsIHVubW91bnQgfSA9IHJlbmRlcihcbiAgICAgICAgICAgICAgPEZvcm1Nb2RhbFxuICAgICAgICAgICAgICAgIGlzT3Blbj17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvbkNsb3NlPXtvbkNsb3NlfVxuICAgICAgICAgICAgICAgIHRpdGxlPVwiVGVzdCBGb3JtXCJcbiAgICAgICAgICAgICAgICBvblN1Ym1pdD17b25TdWJtaXR9XG4gICAgICAgICAgICAgICAgc2NoZW1hPXtzY2hlbWF9XG4gICAgICAgICAgICAgICAgZmllbGRzPXtmaWVsZHN9XG4gICAgICAgICAgICAgICAgaW5pdGlhbERhdGE9e3t9fVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gVHJ5IHRvIHN1Ym1pdCBlbXB0eSBmb3JtXG4gICAgICAgICAgICAgIGNvbnN0IHN1Ym1pdEJ1dHRvbnMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCdidXR0b24nLCB7IG5hbWU6IC9zdWJtaXQvaSB9KTtcbiAgICAgICAgICAgICAgY29uc3Qgc3VibWl0QnV0dG9uID0gc3VibWl0QnV0dG9uc1tzdWJtaXRCdXR0b25zLmxlbmd0aCAtIDFdOyAvLyBHZXQgdGhlIGxhc3Qgb25lIChtb3N0IHJlY2VudClcbiAgICAgICAgICAgICAgZmlyZUV2ZW50LmNsaWNrKHN1Ym1pdEJ1dHRvbik7XG5cbiAgICAgICAgICAgICAgLy8gV2FpdCBmb3IgdmFsaWRhdGlvbiBlcnJvcnMgdG8gYXBwZWFyXG4gICAgICAgICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdbcm9sZT1cImFsZXJ0XCJdJyk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KGVycm9ycy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgLy8gVmVyaWZ5IG9uU3VibWl0IHdhcyBub3QgY2FsbGVkXG4gICAgICAgICAgICAgIGV4cGVjdChvblN1Ym1pdCkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHVubW91bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHsgbnVtUnVuczogNTAgfSAvLyBSZWR1Y2VkIHJ1bnMgZm9yIGFzeW5jIG9wZXJhdGlvbnNcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNob3cgZmllbGQtbGV2ZWwgZXJyb3JzIGZvciBpbnZhbGlkIGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgICAgZmMucmVjb3JkKHtcbiAgICAgICAgICAgIGludmFsaWRFbWFpbDogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUwIH0pLmZpbHRlcihzID0+ICFzLmluY2x1ZGVzKCdAJykpLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGFzeW5jICh7IGludmFsaWRFbWFpbCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSB6Lm9iamVjdCh7XG4gICAgICAgICAgICAgIGVtYWlsOiB6LnN0cmluZygpLmVtYWlsKCdJbnZhbGlkIGVtYWlsJyksXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgZmllbGRzOiBGb3JtRmllbGRbXSA9IFtcbiAgICAgICAgICAgICAgeyBuYW1lOiAnZW1haWwnLCBsYWJlbDogJ0VtYWlsJywgdHlwZTogJ2VtYWlsJywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGNvbnN0IG9uU3VibWl0ID0gamVzdC5mbigpO1xuICAgICAgICAgICAgY29uc3Qgb25DbG9zZSA9IGplc3QuZm4oKTtcblxuICAgICAgICAgICAgY29uc3QgeyB1bm1vdW50IH0gPSByZW5kZXIoXG4gICAgICAgICAgICAgIDxGb3JtTW9kYWxcbiAgICAgICAgICAgICAgICBpc09wZW49e3RydWV9XG4gICAgICAgICAgICAgICAgb25DbG9zZT17b25DbG9zZX1cbiAgICAgICAgICAgICAgICB0aXRsZT1cIlRlc3QgRm9ybVwiXG4gICAgICAgICAgICAgICAgb25TdWJtaXQ9e29uU3VibWl0fVxuICAgICAgICAgICAgICAgIHNjaGVtYT17c2NoZW1hfVxuICAgICAgICAgICAgICAgIGZpZWxkcz17ZmllbGRzfVxuICAgICAgICAgICAgICAgIGluaXRpYWxEYXRhPXt7IGVtYWlsOiBpbnZhbGlkRW1haWwgfX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGVtYWlsSW5wdXQgPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQoL2VtYWlsL2kpO1xuICAgICAgICAgICAgICBjb25zdCBzdWJtaXRCdXR0b25zID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgnYnV0dG9uJywgeyBuYW1lOiAvc3VibWl0L2kgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IHN1Ym1pdEJ1dHRvbiA9IHN1Ym1pdEJ1dHRvbnNbc3VibWl0QnV0dG9ucy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgICAvLyBCbHVyIHRoZSBmaWVsZCB0byB0cmlnZ2VyIHZhbGlkYXRpb25cbiAgICAgICAgICAgICAgZmlyZUV2ZW50LmJsdXIoZW1haWxJbnB1dCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBUcnkgdG8gc3VibWl0XG4gICAgICAgICAgICAgIGZpcmVFdmVudC5jbGljayhzdWJtaXRCdXR0b24pO1xuXG4gICAgICAgICAgICAgIC8vIFdhaXQgZm9yIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoL2ludmFsaWQgZW1haWwvaSkpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIC8vIFZlcmlmeSBvblN1Ym1pdCB3YXMgbm90IGNhbGxlZFxuICAgICAgICAgICAgICBleHBlY3Qob25TdWJtaXQpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB1bm1vdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDUwIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGFsbG93IHN1Ym1pc3Npb24gd2hlbiBhbGwgcmVxdWlyZWQgZmllbGRzIGFyZSB2YWxpZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFVuaXQgdGVzdCB3aXRoIHNwZWNpZmljIGV4YW1wbGUgaW5zdGVhZCBvZiBwcm9wZXJ0eS1iYXNlZCB0ZXN0XG4gICAgICAvLyBUaGlzIHZhbGlkYXRlcyB0aGUgc2FtZSBiZWhhdmlvciBidXQgcnVucyBtdWNoIGZhc3RlclxuICAgICAgY29uc3QgdmFsaWREYXRhID0ge1xuICAgICAgICBmaXJzdE5hbWU6ICdKb2huJyxcbiAgICAgICAgbGFzdE5hbWU6ICdEb2UnLFxuICAgICAgICBlbWFpbDogJ2pvaG5AZXhhbXBsZS5jb20nLFxuICAgICAgfTtcblxuICAgICAgY29uc3Qgc2NoZW1hID0gei5vYmplY3Qoe1xuICAgICAgICBmaXJzdE5hbWU6IHouc3RyaW5nKCkubWluKDEpLFxuICAgICAgICBsYXN0TmFtZTogei5zdHJpbmcoKS5taW4oMSksXG4gICAgICAgIGVtYWlsOiB6LnN0cmluZygpLmVtYWlsKCksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZmllbGRzOiBGb3JtRmllbGRbXSA9IFtcbiAgICAgICAgeyBuYW1lOiAnZmlyc3ROYW1lJywgbGFiZWw6ICdGaXJzdCBOYW1lJywgdHlwZTogJ3RleHQnLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICB7IG5hbWU6ICdsYXN0TmFtZScsIGxhYmVsOiAnTGFzdCBOYW1lJywgdHlwZTogJ3RleHQnLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICB7IG5hbWU6ICdlbWFpbCcsIGxhYmVsOiAnRW1haWwnLCB0eXBlOiAnZW1haWwnLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgXTtcblxuICAgICAgY29uc3Qgb25TdWJtaXQgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgIGNvbnN0IG9uQ2xvc2UgPSBqZXN0LmZuKCk7XG5cbiAgICAgIGNvbnN0IHsgdW5tb3VudCB9ID0gcmVuZGVyKFxuICAgICAgICA8Rm9ybU1vZGFsXG4gICAgICAgICAgaXNPcGVuPXt0cnVlfVxuICAgICAgICAgIG9uQ2xvc2U9e29uQ2xvc2V9XG4gICAgICAgICAgdGl0bGU9XCJUZXN0IEZvcm1cIlxuICAgICAgICAgIG9uU3VibWl0PXtvblN1Ym1pdH1cbiAgICAgICAgICBzY2hlbWE9e3NjaGVtYX1cbiAgICAgICAgICBmaWVsZHM9e2ZpZWxkc31cbiAgICAgICAgICBpbml0aWFsRGF0YT17dmFsaWREYXRhfVxuICAgICAgICAvPlxuICAgICAgKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3VibWl0QnV0dG9ucyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ2J1dHRvbicsIHsgbmFtZTogL3N1Ym1pdC9pIH0pO1xuICAgICAgICBjb25zdCBzdWJtaXRCdXR0b24gPSBzdWJtaXRCdXR0b25zW3N1Ym1pdEJ1dHRvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGZpcmVFdmVudC5jbGljayhzdWJtaXRCdXR0b24pO1xuXG4gICAgICAgIC8vIFdhaXQgZm9yIHN1Ym1pc3Npb25cbiAgICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgICAgZXhwZWN0KG9uU3VibWl0KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICAgIH0sIHsgdGltZW91dDogMTAwMCB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFZlcmlmeSBpdCB3YXMgY2FsbGVkIHdpdGggdGhlIGNvcnJlY3QgZGF0YVxuICAgICAgICBleHBlY3Qob25TdWJtaXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHZhbGlkRGF0YSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bm1vdW50KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQcm9wZXJ0eSA4OiBNb2RhbCBjbG9zZXMgb24gRXNjYXBlIGtleVxuICAgKiBWYWxpZGF0ZXM6IFJlcXVpcmVtZW50cyAxNy4zXG4gICAqIFxuICAgKiBGb3IgYW55IG9wZW4gbW9kYWwgZGlhbG9nLCBwcmVzc2luZyB0aGUgRXNjYXBlIGtleSBzaG91bGQgY2xvc2UgdGhlIG1vZGFsLlxuICAgKi9cbiAgZGVzY3JpYmUoJ0ZlYXR1cmU6IGFkbWluLXVpLW1vZGVybml6YXRpb24sIFByb3BlcnR5IDg6IE1vZGFsIGNsb3NlcyBvbiBFc2NhcGUga2V5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY2xvc2UgbW9kYWwgd2hlbiBFc2NhcGUga2V5IGlzIHByZXNzZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgICAgZmMucmVjb3JkKHtcbiAgICAgICAgICAgIHRpdGxlOiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTAwIH0pLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGFzeW5jICh7IHRpdGxlIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHoub2JqZWN0KHtcbiAgICAgICAgICAgICAgbmFtZTogei5zdHJpbmcoKS5taW4oMSksXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgZmllbGRzOiBGb3JtRmllbGRbXSA9IFtcbiAgICAgICAgICAgICAgeyBuYW1lOiAnbmFtZScsIGxhYmVsOiAnTmFtZScsIHR5cGU6ICd0ZXh0JywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGNvbnN0IG9uU3VibWl0ID0gamVzdC5mbigpO1xuICAgICAgICAgICAgY29uc3Qgb25DbG9zZSA9IGplc3QuZm4oKTtcblxuICAgICAgICAgICAgY29uc3QgeyB1bm1vdW50IH0gPSByZW5kZXIoXG4gICAgICAgICAgICAgIDxGb3JtTW9kYWxcbiAgICAgICAgICAgICAgICBpc09wZW49e3RydWV9XG4gICAgICAgICAgICAgICAgb25DbG9zZT17b25DbG9zZX1cbiAgICAgICAgICAgICAgICB0aXRsZT17dGl0bGV9XG4gICAgICAgICAgICAgICAgb25TdWJtaXQ9e29uU3VibWl0fVxuICAgICAgICAgICAgICAgIHNjaGVtYT17c2NoZW1hfVxuICAgICAgICAgICAgICAgIGZpZWxkcz17ZmllbGRzfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gUHJlc3MgRXNjYXBlIGtleVxuICAgICAgICAgICAgICBmaXJlRXZlbnQua2V5RG93bihkb2N1bWVudCwgeyBrZXk6ICdFc2NhcGUnIH0pO1xuXG4gICAgICAgICAgICAgIC8vIFZlcmlmeSBvbkNsb3NlIHdhcyBjYWxsZWRcbiAgICAgICAgICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KG9uQ2xvc2UpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB1bm1vdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDUwIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNsb3NlIEZvcm1Nb2RhbFNpbXBsZSB3aGVuIEVzY2FwZSBrZXkgaXMgcHJlc3NlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgICAgdGl0bGU6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxMDAgfSksXG4gICAgICAgICAgICBjb250ZW50OiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMjAwIH0pLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGFzeW5jICh7IHRpdGxlLCBjb250ZW50IH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9uQ2xvc2UgPSBqZXN0LmZuKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgdW5tb3VudCB9ID0gcmVuZGVyKFxuICAgICAgICAgICAgICA8Rm9ybU1vZGFsU2ltcGxlXG4gICAgICAgICAgICAgICAgaXNPcGVuPXt0cnVlfVxuICAgICAgICAgICAgICAgIG9uQ2xvc2U9e29uQ2xvc2V9XG4gICAgICAgICAgICAgICAgdGl0bGU9e3RpdGxlfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGRpdj57Y29udGVudH08L2Rpdj5cbiAgICAgICAgICAgICAgPC9Gb3JtTW9kYWxTaW1wbGU+XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBQcmVzcyBFc2NhcGUga2V5XG4gICAgICAgICAgICAgIGZpcmVFdmVudC5rZXlEb3duKGRvY3VtZW50LCB7IGtleTogJ0VzY2FwZScgfSk7XG5cbiAgICAgICAgICAgICAgLy8gVmVyaWZ5IG9uQ2xvc2Ugd2FzIGNhbGxlZFxuICAgICAgICAgICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgICAgICAgICBleHBlY3Qob25DbG9zZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHVubW91bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHsgbnVtUnVuczogNTAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFByb3BlcnR5IDk6IEZvcm0gaW5wdXRzIGhhdmUgYXNzb2NpYXRlZCBsYWJlbHNcbiAgICogVmFsaWRhdGVzOiBSZXF1aXJlbWVudHMgMTguNVxuICAgKiBcbiAgICogRm9yIGFueSBmb3JtIGlucHV0IGZpZWxkLCB0aGVyZSBzaG91bGQgYmUgYW4gYXNzb2NpYXRlZCBsYWJlbCBlbGVtZW50XG4gICAqIGFuZCBlcnJvciBtZXNzYWdlcyBzaG91bGQgYmUgZGlzcGxheWVkIHdoZW4gdGhlIGZpZWxkIGlzIGludmFsaWQuXG4gICAqL1xuICBkZXNjcmliZSgnRmVhdHVyZTogYWRtaW4tdWktbW9kZXJuaXphdGlvbiwgUHJvcGVydHkgOTogRm9ybSBpbnB1dHMgaGF2ZSBhc3NvY2lhdGVkIGxhYmVscycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhdmUgYXNzb2NpYXRlZCBsYWJlbHMgZm9yIGFsbCBmb3JtIGlucHV0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgICBmYy5hcnJheShcbiAgICAgICAgICAgIGZjLnJlY29yZCh7XG4gICAgICAgICAgICAgIG5hbWU6IGZjLnN0cmluZyh7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAyMCB9KS5maWx0ZXIocyA9PiAvXlthLXpBLVpdKyQvLnRlc3QocykpLFxuICAgICAgICAgICAgICBsYWJlbDogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAzLCBtYXhMZW5ndGg6IDUwIH0pLmZpbHRlcihzID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkID0gcy50cmltKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyaW1tZWQubGVuZ3RoID49IDMgJiYgL1thLXpBLVpdLy50ZXN0KHRyaW1tZWQpOyAvLyBNdXN0IGhhdmUgYXQgbGVhc3QgMyBjaGFycyBhbmQgY29udGFpbiBhIGxldHRlclxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgdHlwZTogZmMuY29uc3RhbnRGcm9tKCd0ZXh0JywgJ2VtYWlsJywgJ251bWJlcicsICdzZWxlY3QnLCAndGV4dGFyZWEnLCAnZGF0ZScsICdjaGVja2JveCcpLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAzIH0gLy8gUmVkdWNlZCBtYXggdG8gc3BlZWQgdXAgdGVzdFxuICAgICAgICAgICkubWFwKGZpZWxkcyA9PiB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgdW5pcXVlIGZpZWxkIG5hbWVzIGJ5IGFwcGVuZGluZyBpbmRleFxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcy5tYXAoKGZpZWxkLCBpbmRleCkgPT4gKHtcbiAgICAgICAgICAgICAgLi4uZmllbGQsXG4gICAgICAgICAgICAgIG5hbWU6IGAke2ZpZWxkLm5hbWV9JHtpbmRleH1gXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgYXN5bmMgKGZpZWxkQ29uZmlncykgPT4ge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHNjaGVtYSBkeW5hbWljYWxseVxuICAgICAgICAgICAgY29uc3Qgc2NoZW1hU2hhcGU6IFJlY29yZDxzdHJpbmcsIHouWm9kVHlwZUFueT4gPSB7fTtcbiAgICAgICAgICAgIGZpZWxkQ29uZmlncy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgICAgICAgc2NoZW1hU2hhcGVbZmllbGQubmFtZV0gPSB6LnN0cmluZygpLm9wdGlvbmFsKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHoub2JqZWN0KHNjaGVtYVNoYXBlKTtcblxuICAgICAgICAgICAgY29uc3QgZmllbGRzOiBGb3JtRmllbGRbXSA9IGZpZWxkQ29uZmlncy5tYXAoY29uZmlnID0+ICh7XG4gICAgICAgICAgICAgIG5hbWU6IGNvbmZpZy5uYW1lLFxuICAgICAgICAgICAgICBsYWJlbDogY29uZmlnLmxhYmVsLFxuICAgICAgICAgICAgICB0eXBlOiBjb25maWcudHlwZSBhcyBhbnksXG4gICAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgb3B0aW9uczogY29uZmlnLnR5cGUgPT09ICdzZWxlY3QnID8gW1xuICAgICAgICAgICAgICAgIHsgbGFiZWw6ICdPcHRpb24gMScsIHZhbHVlOiAnb3B0MScgfSxcbiAgICAgICAgICAgICAgICB7IGxhYmVsOiAnT3B0aW9uIDInLCB2YWx1ZTogJ29wdDInIH0sXG4gICAgICAgICAgICAgIF0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIGNvbnN0IG9uU3VibWl0ID0gamVzdC5mbigpO1xuICAgICAgICAgICAgY29uc3Qgb25DbG9zZSA9IGplc3QuZm4oKTtcblxuICAgICAgICAgICAgY29uc3QgeyB1bm1vdW50IH0gPSByZW5kZXIoXG4gICAgICAgICAgICAgIDxGb3JtTW9kYWxcbiAgICAgICAgICAgICAgICBpc09wZW49e3RydWV9XG4gICAgICAgICAgICAgICAgb25DbG9zZT17b25DbG9zZX1cbiAgICAgICAgICAgICAgICB0aXRsZT1cIlRlc3QgRm9ybVwiXG4gICAgICAgICAgICAgICAgb25TdWJtaXQ9e29uU3VibWl0fVxuICAgICAgICAgICAgICAgIHNjaGVtYT17c2NoZW1hfVxuICAgICAgICAgICAgICAgIGZpZWxkcz17ZmllbGRzfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gVmVyaWZ5IGVhY2ggZmllbGQgaGFzIGFuIGFzc29jaWF0ZWQgbGFiZWxcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZENvbmZpZ3MpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgYSBtb3JlIGZsZXhpYmxlIHF1ZXJ5IHRoYXQgaGFuZGxlcyBzcGVjaWFsIGNoYXJhY3RlcnMgLSBGSVhFRDogdXNlIFxcXFwkJiBpbnN0ZWFkIG9mIFVVSURcbiAgICAgICAgICAgICAgICAvLyBUcmltIHRoZSBsYWJlbCB0byBtYXRjaCBob3cgaXQncyByZW5kZXJlZCBpbiB0aGUgRE9NXG4gICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZExhYmVsID0gZmllbGQubGFiZWwudHJpbSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsRWxlbWVudCA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dChuZXcgUmVnRXhwKHRyaW1tZWRMYWJlbC5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpLCAnaScpKTtcbiAgICAgICAgICAgICAgICBleHBlY3QobGFiZWxFbGVtZW50KS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChsYWJlbEVsZW1lbnQpLnRvSGF2ZUF0dHJpYnV0ZSgnaWQnLCBmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdW5tb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgeyBudW1SdW5zOiAyMCB9IC8vIFJlZHVjZWQgcnVuc1xuICAgICAgKTtcbiAgICB9LCAxMDAwMCk7IC8vIEluY3JlYXNlZCB0aW1lb3V0IHRvIDEwIHNlY29uZHNcblxuICAgIGl0KCdzaG91bGQgZGlzcGxheSBlcnJvciBtZXNzYWdlcyB3aXRoIHByb3BlciBBUklBIGF0dHJpYnV0ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBmYy5hc3NlcnQoXG4gICAgICAgIGZjLmFzeW5jUHJvcGVydHkoXG4gICAgICAgICAgZmMucmVjb3JkKHtcbiAgICAgICAgICAgIGZpZWxkTmFtZTogZmMuY29uc3RhbnRGcm9tKCdlbWFpbCcsICduYW1lJywgJ2FnZScpLFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiBmYy5zdHJpbmcoeyBtaW5MZW5ndGg6IDEwLCBtYXhMZW5ndGg6IDEwMCB9KS5maWx0ZXIocyA9PiBzLnRyaW0oKS5sZW5ndGggPj0gMTApLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGFzeW5jICh7IGZpZWxkTmFtZSwgZXJyb3JNZXNzYWdlIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHoub2JqZWN0KHtcbiAgICAgICAgICAgICAgW2ZpZWxkTmFtZV06IHouc3RyaW5nKCkubWluKDEsIGVycm9yTWVzc2FnZSksXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgZmllbGRzOiBGb3JtRmllbGRbXSA9IFtcbiAgICAgICAgICAgICAgeyBuYW1lOiBmaWVsZE5hbWUsIGxhYmVsOiBmaWVsZE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBmaWVsZE5hbWUuc2xpY2UoMSksIHR5cGU6ICd0ZXh0JywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGNvbnN0IG9uU3VibWl0ID0gamVzdC5mbigpO1xuICAgICAgICAgICAgY29uc3Qgb25DbG9zZSA9IGplc3QuZm4oKTtcblxuICAgICAgICAgICAgY29uc3QgeyB1bm1vdW50IH0gPSByZW5kZXIoXG4gICAgICAgICAgICAgIDxGb3JtTW9kYWxcbiAgICAgICAgICAgICAgICBpc09wZW49e3RydWV9XG4gICAgICAgICAgICAgICAgb25DbG9zZT17b25DbG9zZX1cbiAgICAgICAgICAgICAgICB0aXRsZT1cIlRlc3QgRm9ybVwiXG4gICAgICAgICAgICAgICAgb25TdWJtaXQ9e29uU3VibWl0fVxuICAgICAgICAgICAgICAgIHNjaGVtYT17c2NoZW1hfVxuICAgICAgICAgICAgICAgIGZpZWxkcz17ZmllbGRzfVxuICAgICAgICAgICAgICAgIGluaXRpYWxEYXRhPXt7IFtmaWVsZE5hbWVdOiAnJyB9fVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQobmV3IFJlZ0V4cChmaWVsZE5hbWUsICdpJykpO1xuICAgICAgICAgICAgICBjb25zdCBzdWJtaXRCdXR0b25zID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgnYnV0dG9uJywgeyBuYW1lOiAvc3VibWl0L2kgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IHN1Ym1pdEJ1dHRvbiA9IHN1Ym1pdEJ1dHRvbnNbc3VibWl0QnV0dG9ucy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgICAvLyBUcmlnZ2VyIHZhbGlkYXRpb24gYnkgc3VibWl0dGluZ1xuICAgICAgICAgICAgICBmaXJlRXZlbnQuY2xpY2soc3VibWl0QnV0dG9uKTtcblxuICAgICAgICAgICAgICAvLyBPcHRpbWl6ZWQ6IENoZWNrIGZvciBlcnJvciBmaXJzdCwgdGhlbiB2ZXJpZnkgQVJJQSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yRWxlbWVudCA9IHNjcmVlbi5nZXRCeVJvbGUoJ2FsZXJ0Jyk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KGVycm9yRWxlbWVudCkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgICAgICAgICAgfSwgeyB0aW1lb3V0OiAxMDAwIH0pO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gVmVyaWZ5IGVycm9yIG1lc3NhZ2UgY29udGVudCAobm9ybWFsaXplIHdoaXRlc3BhY2UgZm9yIGNvbXBhcmlzb24pXG4gICAgICAgICAgICAgIGNvbnN0IGVycm9yRWxlbWVudCA9IHNjcmVlbi5nZXRCeVJvbGUoJ2FsZXJ0Jyk7XG4gICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRFeHBlY3RlZCA9IGVycm9yTWVzc2FnZS5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpO1xuICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkQWN0dWFsID0gZXJyb3JFbGVtZW50LnRleHRDb250ZW50Py5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpIHx8ICcnO1xuICAgICAgICAgICAgICBleHBlY3Qobm9ybWFsaXplZEFjdHVhbCkudG9Db250YWluKG5vcm1hbGl6ZWRFeHBlY3RlZCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBWZXJpZnkgQVJJQSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgIGV4cGVjdChpbnB1dCkudG9IYXZlQXR0cmlidXRlKCdhcmlhLWludmFsaWQnLCAndHJ1ZScpO1xuICAgICAgICAgICAgICBleHBlY3QoaW5wdXQpLnRvSGF2ZUF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdW5tb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgeyBudW1SdW5zOiA1IH0gLy8gUmVkdWNlZCBmcm9tIDEwIHRvIDVcbiAgICAgICk7XG4gICAgfSwgMTAwMDApOyAvLyBSZWR1Y2VkIHRpbWVvdXQgdG8gMTAgc2Vjb25kc1xuICB9KTtcblxuICAvKipcbiAgICogUHJvcGVydHkgMzI6IEZvcm0gc3VibWlzc2lvbiBidXR0b24gc3RhdGVcbiAgICogVmFsaWRhdGVzOiBSZXF1aXJlbWVudHMgMTEuM1xuICAgKiBcbiAgICogRm9yIGFueSBmb3JtIGluIGEgc3VibWl0dGluZyBzdGF0ZSwgdGhlIHN1Ym1pdCBidXR0b24gc2hvdWxkIGJlIGRpc2FibGVkXG4gICAqIGFuZCBkaXNwbGF5IGEgbG9hZGluZyBzcGlubmVyLlxuICAgKi9cbiAgZGVzY3JpYmUoJ0ZlYXR1cmU6IGFkbWluLXVpLW1vZGVybml6YXRpb24sIFByb3BlcnR5IDMyOiBGb3JtIHN1Ym1pc3Npb24gYnV0dG9uIHN0YXRlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZGlzYWJsZSBzdWJtaXQgYnV0dG9uIGFuZCBzaG93IGxvYWRpbmcgc3Bpbm5lciBkdXJpbmcgc3VibWlzc2lvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgICBmYy5yZWNvcmQoe1xuICAgICAgICAgICAgbmFtZTogZmMuc3RyaW5nKHsgbWluTGVuZ3RoOiAyLCBtYXhMZW5ndGg6IDUwIH0pLmZpbHRlcihzID0+IHMudHJpbSgpLmxlbmd0aCA+PSAyKSwgLy8gQXZvaWQgd2hpdGVzcGFjZS1vbmx5IG5hbWVzXG4gICAgICAgICAgfSksXG4gICAgICAgICAgYXN5bmMgKHZhbGlkRGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gei5vYmplY3Qoe1xuICAgICAgICAgICAgICBuYW1lOiB6LnN0cmluZygpLm1pbigxKSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBmaWVsZHM6IEZvcm1GaWVsZFtdID0gW1xuICAgICAgICAgICAgICB7IG5hbWU6ICduYW1lJywgbGFiZWw6ICdOYW1lJywgdHlwZTogJ3RleHQnLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgcHJvbWlzZSB0aGF0IHdlIGNhbiBjb250cm9sXG4gICAgICAgICAgICBsZXQgcmVzb2x2ZVN1Ym1pdDogKCkgPT4gdm9pZDtcbiAgICAgICAgICAgIGNvbnN0IHN1Ym1pdFByb21pc2UgPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlU3VibWl0ID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBvblN1Ym1pdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoc3VibWl0UHJvbWlzZSk7XG4gICAgICAgICAgICBjb25zdCBvbkNsb3NlID0gamVzdC5mbigpO1xuXG4gICAgICAgICAgICBjb25zdCB7IHVubW91bnQgfSA9IHJlbmRlcihcbiAgICAgICAgICAgICAgPEZvcm1Nb2RhbFxuICAgICAgICAgICAgICAgIGlzT3Blbj17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvbkNsb3NlPXtvbkNsb3NlfVxuICAgICAgICAgICAgICAgIHRpdGxlPVwiVGVzdCBGb3JtXCJcbiAgICAgICAgICAgICAgICBvblN1Ym1pdD17b25TdWJtaXR9XG4gICAgICAgICAgICAgICAgc2NoZW1hPXtzY2hlbWF9XG4gICAgICAgICAgICAgICAgZmllbGRzPXtmaWVsZHN9XG4gICAgICAgICAgICAgICAgaW5pdGlhbERhdGE9e3ZhbGlkRGF0YX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHN1Ym1pdEJ1dHRvbnMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCdidXR0b24nLCB7IG5hbWU6IC9zdWJtaXQvaSB9KTtcbiAgICAgICAgICAgICAgY29uc3Qgc3VibWl0QnV0dG9uID0gc3VibWl0QnV0dG9uc1tzdWJtaXRCdXR0b25zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gQ2xpY2sgc3VibWl0XG4gICAgICAgICAgICAgIGZpcmVFdmVudC5jbGljayhzdWJtaXRCdXR0b24pO1xuXG4gICAgICAgICAgICAgIC8vIFdhaXQgZm9yIGJ1dHRvbiB0byBzaG93IGxvYWRpbmcgc3RhdGVcbiAgICAgICAgICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHN1Ym1pdEJ1dHRvbikudG9CZURpc2FibGVkKCk7XG4gICAgICAgICAgICAgIH0sIHsgdGltZW91dDogMjAwMCB9KTtcblxuICAgICAgICAgICAgICAvLyBSZXNvbHZlIHRoZSBzdWJtaXNzaW9uXG4gICAgICAgICAgICAgIHJlc29sdmVTdWJtaXQhKCk7XG5cbiAgICAgICAgICAgICAgLy8gV2FpdCBmb3Igc3VibWlzc2lvbiB0byBjb21wbGV0ZVxuICAgICAgICAgICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgICAgICAgICBleHBlY3Qob25TdWJtaXQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgICAgICAgICAgfSwgeyB0aW1lb3V0OiAyMDAwIH0pO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdW5tb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgeyBudW1SdW5zOiAxMCB9IC8vIEZld2VyIHJ1bnMgZm9yIGFzeW5jIG9wZXJhdGlvbnNcbiAgICAgICk7XG4gICAgfSwgMTUwMDApOyAvLyBJbmNyZWFzZSB0aW1lb3V0IGZvciBwcm9wZXJ0eS1iYXNlZCB0ZXN0XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJhZnRlckVhY2giLCJjbGVhbnVwIiwiaXQiLCJmYyIsImFzc2VydCIsImFzeW5jUHJvcGVydHkiLCJyZWNvcmQiLCJmaXJzdE5hbWUiLCJzdHJpbmciLCJtaW5MZW5ndGgiLCJtYXhMZW5ndGgiLCJsYXN0TmFtZSIsImVtYWlsIiwiZW1haWxBZGRyZXNzIiwidmFsaWREYXRhIiwic2NoZW1hIiwieiIsIm9iamVjdCIsIm1pbiIsImZpZWxkcyIsIm5hbWUiLCJsYWJlbCIsInR5cGUiLCJyZXF1aXJlZCIsIm9uU3VibWl0IiwiamVzdCIsImZuIiwib25DbG9zZSIsImNvbnRhaW5lciIsInVubW91bnQiLCJyZW5kZXIiLCJGb3JtTW9kYWwiLCJpc09wZW4iLCJ0aXRsZSIsImluaXRpYWxEYXRhIiwic3VibWl0QnV0dG9ucyIsInNjcmVlbiIsImdldEFsbEJ5Um9sZSIsInN1Ym1pdEJ1dHRvbiIsImxlbmd0aCIsImZpcmVFdmVudCIsImNsaWNrIiwid2FpdEZvciIsImVycm9ycyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJleHBlY3QiLCJ0b0JlR3JlYXRlclRoYW4iLCJub3QiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwibnVtUnVucyIsImludmFsaWRFbWFpbCIsImZpbHRlciIsInMiLCJpbmNsdWRlcyIsImVtYWlsSW5wdXQiLCJnZXRCeUxhYmVsVGV4dCIsImJsdXIiLCJnZXRCeVRleHQiLCJ0b0JlSW5UaGVEb2N1bWVudCIsIm1vY2tSZXNvbHZlZFZhbHVlIiwidW5kZWZpbmVkIiwidGltZW91dCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwia2V5RG93biIsImRvY3VtZW50Iiwia2V5IiwiY29udGVudCIsIkZvcm1Nb2RhbFNpbXBsZSIsImRpdiIsImFycmF5IiwidGVzdCIsInRyaW1tZWQiLCJ0cmltIiwiY29uc3RhbnRGcm9tIiwibWFwIiwiZmllbGQiLCJpbmRleCIsImZpZWxkQ29uZmlncyIsInNjaGVtYVNoYXBlIiwiZm9yRWFjaCIsIm9wdGlvbmFsIiwiY29uZmlnIiwib3B0aW9ucyIsInZhbHVlIiwidHJpbW1lZExhYmVsIiwibGFiZWxFbGVtZW50IiwiUmVnRXhwIiwicmVwbGFjZSIsInRvSGF2ZUF0dHJpYnV0ZSIsImZpZWxkTmFtZSIsImVycm9yTWVzc2FnZSIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJpbnB1dCIsImVycm9yRWxlbWVudCIsImdldEJ5Um9sZSIsIm5vcm1hbGl6ZWRFeHBlY3RlZCIsIm5vcm1hbGl6ZWRBY3R1YWwiLCJ0ZXh0Q29udGVudCIsInRvQ29udGFpbiIsInJlc29sdmVTdWJtaXQiLCJzdWJtaXRQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJtb2NrUmV0dXJuVmFsdWUiLCJ0b0JlRGlzYWJsZWQiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztDQUtDOzs7Ozt1QkFFMkQ7cUJBQzFDO21FQUNFOzJCQUN1Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRzNDQSxTQUFTLDRCQUE0QjtJQUNuQyxvREFBb0Q7SUFDcERDLFVBQVU7UUFDUkMsSUFBQUEsY0FBTztJQUNUO0lBQ0E7Ozs7OztHQU1DLEdBQ0RGLFNBQVMsNEZBQTRGO1FBQ25HRyxHQUFHLDhFQUE4RTtZQUMvRSxNQUFNQyxXQUFHQyxNQUFNLENBQ2JELFdBQUdFLGFBQWEsQ0FDZEYsV0FBR0csTUFBTSxDQUFDO2dCQUNSQyxXQUFXSixXQUFHSyxNQUFNLENBQUM7b0JBQUVDLFdBQVc7b0JBQUdDLFdBQVc7Z0JBQUc7Z0JBQ25EQyxVQUFVUixXQUFHSyxNQUFNLENBQUM7b0JBQUVDLFdBQVc7b0JBQUdDLFdBQVc7Z0JBQUc7Z0JBQ2xERSxPQUFPVCxXQUFHVSxZQUFZO1lBQ3hCLElBQ0Es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