
> destination-wedding-platform@0.1.0 test
> npm run build && jest services/ --testPathIgnorePatterns=property.test


> destination-wedding-platform@0.1.0 build
> next build

▲ Next.js 16.1.1 (Turbopack)
- Environments: .env.local

⚠ The "middleware" file convention is deprecated. Please use "proxy" instead. Learn more: https://nextjs.org/docs/messages/middleware-to-proxy
  Creating an optimized production build ...
✓ Compiled successfully in 8.3s
  Running TypeScript ...
  Collecting page data using 7 workers ...
  Generating static pages using 7 workers (0/77) ...
  Generating static pages using 7 workers (19/77) 
  Generating static pages using 7 workers (38/77) 
  Generating static pages using 7 workers (57/77) 
✓ Generating static pages using 7 workers (77/77) in 330.4ms
  Finalizing page optimization ...

Route (app)
┌ ○ /
├ ○ /_not-found
├ ○ /admin
├ ○ /admin/accommodations
├ ƒ /admin/accommodations/[id]/room-types
├ ○ /admin/activities
├ ○ /admin/audit-logs
├ ○ /admin/budget
├ ○ /admin/content-pages
├ ○ /admin/debug-click
├ ○ /admin/design-system-demo
├ ○ /admin/emails
├ ○ /admin/events
├ ○ /admin/form-modal-demo
├ ○ /admin/guests
├ ○ /admin/home-page
├ ○ /admin/locations
├ ○ /admin/photos
├ ○ /admin/rsvp-analytics
├ ƒ /admin/settings
├ ○ /admin/simple-test
├ ○ /admin/test-buttons
├ ○ /admin/test-form
├ ○ /admin/transportation
├ ○ /admin/vendors
├ ƒ /api/admin/accommodations
├ ƒ /api/admin/accommodations/[id]
├ ƒ /api/admin/accommodations/[id]/room-types
├ ƒ /api/admin/activities
├ ƒ /api/admin/activities/[id]
├ ƒ /api/admin/activities/[id]/capacity
├ ƒ /api/admin/alerts
├ ƒ /api/admin/audit-logs
├ ƒ /api/admin/audit-logs/export
├ ƒ /api/admin/budget/breakdown
├ ƒ /api/admin/budget/payment-status
├ ƒ /api/admin/budget/subsidies
├ ƒ /api/admin/content-pages
├ ƒ /api/admin/content-pages/[id]
├ ƒ /api/admin/emails
├ ƒ /api/admin/emails/analytics
├ ƒ /api/admin/emails/send
├ ƒ /api/admin/emails/templates
├ ƒ /api/admin/emails/templates/[id]
├ ƒ /api/admin/events
├ ƒ /api/admin/events/[id]
├ ƒ /api/admin/example
├ ƒ /api/admin/groups
├ ƒ /api/admin/guests
├ ƒ /api/admin/guests/[id]
├ ƒ /api/admin/home-page
├ ƒ /api/admin/home-page/sections
├ ƒ /api/admin/locations
├ ƒ /api/admin/locations/[id]
├ ƒ /api/admin/locations/[id]/validate-parent
├ ƒ /api/admin/metrics
├ ƒ /api/admin/photos
├ ƒ /api/admin/photos/[id]
├ ƒ /api/admin/photos/[id]/moderate
├ ƒ /api/admin/photos/pending-count
├ ƒ /api/admin/references/[type]/[id]
├ ƒ /api/admin/references/search
├ ƒ /api/admin/room-types
├ ƒ /api/admin/room-types/[id]
├ ƒ /api/admin/room-types/[id]/sections
├ ƒ /api/admin/rsvp-analytics
├ ƒ /api/admin/rsvps
├ ƒ /api/admin/rsvps/[id]
├ ƒ /api/admin/sections
├ ƒ /api/admin/sections/[id]
├ ƒ /api/admin/sections/by-page/[pageType]/[pageId]
├ ƒ /api/admin/sections/check-circular
├ ƒ /api/admin/sections/reorder
├ ƒ /api/admin/sections/validate-refs
├ ƒ /api/admin/settings
├ ƒ /api/admin/transportation/arrivals
├ ƒ /api/admin/transportation/assign-shuttle
├ ƒ /api/admin/transportation/departures
├ ƒ /api/admin/transportation/driver-sheets
├ ƒ /api/admin/transportation/vehicle-requirements
├ ƒ /api/admin/vendors
├ ƒ /api/admin/vendors/[id]
├ ƒ /api/auth/create-user
├ ƒ /api/auth/logout
├ ƒ /api/guest/activities/list
├ ƒ /api/guest/events
├ ƒ /api/guest/events/list
├ ƒ /api/guest/family/[id]
├ ƒ /api/guest/photos/upload
├ ƒ /api/guest/rsvp
├ ƒ /api/guest/rsvps
├ ƒ /api/guest/transportation
├ ƒ /api/webhooks/resend
├ ƒ /auth/callback
├ ○ /auth/login
├ ○ /auth/signup
├ ○ /auth/unauthorized
├ ƒ /guest/accommodation
├ ƒ /guest/dashboard
├ ƒ /guest/family
├ ƒ /guest/itinerary
├ ƒ /guest/photos
├ ƒ /guest/rsvp
├ ƒ /guest/transportation
└ ○ /offline


ƒ Proxy (Middleware)

○  (Static)   prerendered as static content
ƒ  (Dynamic)  server-rendered on demand

FAIL services/locationService.test.ts
  ● Console

    console.warn
      GoTrueClient@sb-localhost-auth-token:1 (2.91.1) 2026-01-30T01:26:14.548Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

       97 |
       98 |     // 4. Database operation
    >  99 |     const supabase = createClient(
          |                                  ^
      100 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      101 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      102 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.create (services/locationService.ts:99:34)
      at Object.<anonymous> (services/locationService.test.ts:75:22)

    console.warn
      GoTrueClient@sb-localhost-auth-token:2 (2.91.1) 2026-01-30T01:26:14.654Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      136 | export async function get(id: string): Promise<Result<Location>> {
      137 |   try {
    > 138 |     const supabase = createClient(
          |                                  ^
      139 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      140 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      141 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at get (services/locationService.ts:138:34)
      at Object.get (services/locationService.ts:86:34)
      at Object.create (services/locationService.test.ts:112:44)

    console.warn
      GoTrueClient@sb-localhost-auth-token:3 (2.91.1) 2026-01-30T01:26:14.660Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

       97 |
       98 |     // 4. Database operation
    >  99 |     const supabase = createClient(
          |                                  ^
      100 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      101 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      102 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.create (services/locationService.ts:99:34)
      at Object.<anonymous> (services/locationService.test.ts:112:22)

    console.warn
      GoTrueClient@sb-localhost-auth-token:4 (2.91.1) 2026-01-30T01:26:14.667Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      136 | export async function get(id: string): Promise<Result<Location>> {
      137 |   try {
    > 138 |     const supabase = createClient(
          |                                  ^
      139 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      140 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      141 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at get (services/locationService.ts:138:34)
      at Object.get (services/locationService.ts:86:34)
      at Object.create (services/locationService.test.ts:133:44)

    console.warn
      GoTrueClient@sb-localhost-auth-token:5 (2.91.1) 2026-01-30T01:26:14.672Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

       97 |
       98 |     // 4. Database operation
    >  99 |     const supabase = createClient(
          |                                  ^
      100 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      101 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      102 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.create (services/locationService.ts:99:34)
      at Object.<anonymous> (services/locationService.test.ts:133:22)

    console.warn
      GoTrueClient@sb-localhost-auth-token:6 (2.91.1) 2026-01-30T01:26:14.704Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      136 | export async function get(id: string): Promise<Result<Location>> {
      137 |   try {
    > 138 |     const supabase = createClient(
          |                                  ^
      139 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      140 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      141 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at get (services/locationService.ts:138:34)
      at Object.get (services/locationService.ts:86:34)
      at Object.create (services/locationService.test.ts:166:44)

    console.warn
      GoTrueClient@sb-localhost-auth-token:7 (2.91.1) 2026-01-30T01:26:14.712Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

       97 |
       98 |     // 4. Database operation
    >  99 |     const supabase = createClient(
          |                                  ^
      100 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      101 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      102 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.create (services/locationService.ts:99:34)
      at Object.<anonymous> (services/locationService.test.ts:166:22)

    console.warn
      GoTrueClient@sb-localhost-auth-token:8 (2.91.1) 2026-01-30T01:26:14.718Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      136 | export async function get(id: string): Promise<Result<Location>> {
      137 |   try {
    > 138 |     const supabase = createClient(
          |                                  ^
      139 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      140 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      141 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.get (services/locationService.ts:138:34)
      at Object.get (services/locationService.test.ts:194:44)

    console.warn
      GoTrueClient@sb-localhost-auth-token:9 (2.91.1) 2026-01-30T01:26:14.724Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      136 | export async function get(id: string): Promise<Result<Location>> {
      137 |   try {
    > 138 |     const supabase = createClient(
          |                                  ^
      139 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      140 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      141 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.get (services/locationService.ts:138:34)
      at Object.get (services/locationService.test.ts:209:44)

    console.warn
      GoTrueClient@sb-localhost-auth-token:10 (2.91.1) 2026-01-30T01:26:14.728Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      136 | export async function get(id: string): Promise<Result<Location>> {
      137 |   try {
    > 138 |     const supabase = createClient(
          |                                  ^
      139 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      140 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      141 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.get (services/locationService.ts:138:34)
      at Object.get (services/locationService.test.ts:223:44)

    console.warn
      GoTrueClient@sb-localhost-auth-token:11 (2.91.1) 2026-01-30T01:26:14.740Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      245 |
      246 |     // 4. Database operation
    > 247 |     const supabase = createClient(
          |                                  ^
      248 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      249 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      250 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.update (services/locationService.ts:247:34)
      at Object.update (services/locationService.test.ts:254:44)

    console.warn
      GoTrueClient@sb-localhost-auth-token:12 (2.91.1) 2026-01-30T01:26:14.771Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      245 |
      246 |     // 4. Database operation
    > 247 |     const supabase = createClient(
          |                                  ^
      248 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      249 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      250 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.update (services/locationService.ts:247:34)
      at Object.update (services/locationService.test.ts:296:44)

    console.warn
      GoTrueClient@sb-localhost-auth-token:13 (2.91.1) 2026-01-30T01:26:14.777Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      292 | export async function deleteLocation(id: string): Promise<Result<void>> {
      293 |   try {
    > 294 |     const supabase = createClient(
          |                                  ^
      295 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      296 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      297 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.deleteLocation (services/locationService.ts:294:34)
      at Object.deleteLocation (services/locationService.test.ts:311:44)

    console.warn
      GoTrueClient@sb-localhost-auth-token:14 (2.91.1) 2026-01-30T01:26:14.780Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      292 | export async function deleteLocation(id: string): Promise<Result<void>> {
      293 |   try {
    > 294 |     const supabase = createClient(
          |                                  ^
      295 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      296 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      297 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.deleteLocation (services/locationService.ts:294:34)
      at Object.deleteLocation (services/locationService.test.ts:321:44)

    console.warn
      GoTrueClient@sb-localhost-auth-token:15 (2.91.1) 2026-01-30T01:26:14.785Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      345 |
      346 |     // 2. Database operation
    > 347 |     const supabase = createClient(
          |                                  ^
      348 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      349 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      350 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.list (services/locationService.ts:347:34)
      at Object.list (services/locationService.test.ts:360:44)

    console.warn
      GoTrueClient@sb-localhost-auth-token:16 (2.91.1) 2026-01-30T01:26:14.797Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      345 |
      346 |     // 2. Database operation
    > 347 |     const supabase = createClient(
          |                                  ^
      348 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      349 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      350 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.list (services/locationService.ts:347:34)
      at Object.list (services/locationService.test.ts:403:44)

    console.warn
      GoTrueClient@sb-localhost-auth-token:17 (2.91.1) 2026-01-30T01:26:14.803Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      345 |
      346 |     // 2. Database operation
    > 347 |     const supabase = createClient(
          |                                  ^
      348 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      349 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      350 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.list (services/locationService.ts:347:34)
      at Object.list (services/locationService.test.ts:415:44)

    console.warn
      GoTrueClient@sb-localhost-auth-token:18 (2.91.1) 2026-01-30T01:26:14.807Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      427 |
      428 |     // 3. Database operation
    > 429 |     const supabase = createClient(
          |                                  ^
      430 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      431 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      432 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.search (services/locationService.ts:429:34)
      at Object.search (services/locationService.test.ts:450:44)

    console.warn
      GoTrueClient@sb-localhost-auth-token:19 (2.91.1) 2026-01-30T01:26:14.818Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      427 |
      428 |     // 3. Database operation
    > 429 |     const supabase = createClient(
          |                                  ^
      430 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      431 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      432 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.search (services/locationService.ts:429:34)
      at Object.search (services/locationService.test.ts:472:44)

    console.warn
      GoTrueClient@sb-localhost-auth-token:20 (2.91.1) 2026-01-30T01:26:14.824Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      478 | export async function getHierarchy(): Promise<Result<LocationWithChildren[]>> {
      479 |   try {
    > 480 |     const supabase = createClient(
          |                                  ^
      481 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      482 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      483 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.getHierarchy (services/locationService.ts:480:34)
      at Object.getHierarchy (services/locationService.test.ts:528:44)

    console.warn
      GoTrueClient@sb-localhost-auth-token:21 (2.91.1) 2026-01-30T01:26:14.829Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      478 | export async function getHierarchy(): Promise<Result<LocationWithChildren[]>> {
      479 |   try {
    > 480 |     const supabase = createClient(
          |                                  ^
      481 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      482 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      483 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.getHierarchy (services/locationService.ts:480:34)
      at Object.getHierarchy (services/locationService.test.ts:547:44)

    console.warn
      GoTrueClient@sb-localhost-auth-token:22 (2.91.1) 2026-01-30T01:26:14.831Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      136 | export async function get(id: string): Promise<Result<Location>> {
      137 |   try {
    > 138 |     const supabase = createClient(
          |                                  ^
      139 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      140 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      141 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at get (services/locationService.ts:138:34)
      at Object.get (services/locationService.ts:546:32)
      at Object.getWithChildren (services/locationService.test.ts:599:44)

    console.warn
      GoTrueClient@sb-localhost-auth-token:23 (2.91.1) 2026-01-30T01:26:14.834Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      549 |     }
      550 |
    > 551 |     const supabase = createClient(
          |                                  ^
      552 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      553 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      554 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.getWithChildren (services/locationService.ts:551:34)
      at Object.<anonymous> (services/locationService.test.ts:599:22)

    console.warn
      GoTrueClient@sb-localhost-auth-token:24 (2.91.1) 2026-01-30T01:26:14.835Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      136 | export async function get(id: string): Promise<Result<Location>> {
      137 |   try {
    > 138 |     const supabase = createClient(
          |                                  ^
      139 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      140 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      141 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at get (services/locationService.ts:138:34)
      at Object.get (services/locationService.ts:546:32)
      at Object.getWithChildren (services/locationService.test.ts:615:44)

    console.warn
      GoTrueClient@sb-localhost-auth-token:25 (2.91.1) 2026-01-30T01:26:14.836Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      549 |     }
      550 |
    > 551 |     const supabase = createClient(
          |                                  ^
      552 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      553 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      554 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.getWithChildren (services/locationService.ts:551:34)
      at Object.<anonymous> (services/locationService.test.ts:615:22)

  ● locationService › create › should return success with location data when valid input provided

    expect(received).toBe(expected) // Object.is equality

    Expected: "location-1"
    Received: undefined

      77 |       expect(result.success).toBe(true);
      78 |       if (result.success) {
    > 79 |         expect(result.data.id).toBe('location-1');
         |                                ^
      80 |         expect(result.data.name).toBe('Tamarindo Beach');
      81 |         expect(result.data.parentLocationId).toBe(validData.parentLocationId);
      82 |       }

      at Object.toBe (services/locationService.test.ts:79:32)

  ● locationService › create › should return INVALID_PARENT when parent location does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      112 |       const result = await locationService.create(validData);
      113 |
    > 114 |       expect(result.success).toBe(false);
          |                              ^
      115 |       if (!result.success) {
      116 |         expect(result.error.code).toBe('INVALID_PARENT');
      117 |       }

      at Object.toBe (services/locationService.test.ts:114:30)

  ● locationService › create › should return DATABASE_ERROR when insert fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      133 |       const result = await locationService.create(validData);
      134 |
    > 135 |       expect(result.success).toBe(false);
          |                              ^
      136 |       if (!result.success) {
      137 |         expect(result.error.code).toBe('DATABASE_ERROR');
      138 |       }

      at Object.toBe (services/locationService.test.ts:135:30)

  ● locationService › create › should sanitize input to prevent XSS attacks

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "<script>alert(\"xss\")</script>Tamarindo"

    Number of calls: 0

      169 |       // Verify sanitization was called
      170 |       const { sanitizeInput, sanitizeRichText } = require('../utils/sanitization');
    > 171 |       expect(sanitizeInput).toHaveBeenCalledWith(maliciousData.name);
          |                             ^
      172 |       expect(sanitizeInput).toHaveBeenCalledWith(maliciousData.address);
      173 |       expect(sanitizeRichText).toHaveBeenCalledWith(maliciousData.description);
      174 |     });

      at Object.toHaveBeenCalledWith (services/locationService.test.ts:171:29)

  ● locationService › get › should return success with location data when location exists

    expect(received).toBe(expected) // Object.is equality

    Expected: "location-1"
    Received: undefined

      196 |       expect(result.success).toBe(true);
      197 |       if (result.success) {
    > 198 |         expect(result.data.id).toBe('location-1');
          |                                ^
      199 |         expect(result.data.name).toBe('Tamarindo Beach');
      200 |       }
      201 |     });

      at Object.toBe (services/locationService.test.ts:198:32)

  ● locationService › get › should return NOT_FOUND when location does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      209 |       const result = await locationService.get('nonexistent-id');
      210 |
    > 211 |       expect(result.success).toBe(false);
          |                              ^
      212 |       if (!result.success) {
      213 |         expect(result.error.code).toBe('NOT_FOUND');
      214 |       }

      at Object.toBe (services/locationService.test.ts:211:30)

  ● locationService › get › should return DATABASE_ERROR when database query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      223 |       const result = await locationService.get('location-1');
      224 |
    > 225 |       expect(result.success).toBe(false);
          |                              ^
      226 |       if (!result.success) {
      227 |         expect(result.error.code).toBe('DATABASE_ERROR');
      228 |       }

      at Object.toBe (services/locationService.test.ts:225:30)

  ● locationService › update › should return success with updated location data when valid input provided

    expect(received).toBe(expected) // Object.is equality

    Expected: "Updated Beach"
    Received: undefined

      256 |       expect(result.success).toBe(true);
      257 |       if (result.success) {
    > 258 |         expect(result.data.name).toBe('Updated Beach');
          |                                  ^
      259 |         expect(result.data.address).toBe('Updated Address');
      260 |       }
      261 |     });

      at Object.toBe (services/locationService.test.ts:258:34)

  ● locationService › update › should return CIRCULAR_REFERENCE when trying to set self as parent

    expect(received).toBe(expected) // Object.is equality

    Expected: "CIRCULAR_REFERENCE"
    Received: "VALIDATION_ERROR"

      267 |       expect(result.success).toBe(false);
      268 |       if (!result.success) {
    > 269 |         expect(result.error.code).toBe('CIRCULAR_REFERENCE');
          |                                   ^
      270 |       }
      271 |     });
      272 |

      at Object.toBe (services/locationService.test.ts:269:35)

  ● locationService › update › should return INVALID_PARENT when parent location does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: "INVALID_PARENT"
    Received: "VALIDATION_ERROR"

      284 |       expect(result.success).toBe(false);
      285 |       if (!result.success) {
    > 286 |         expect(result.error.code).toBe('INVALID_PARENT');
          |                                   ^
      287 |       }
      288 |     });
      289 |

      at Object.toBe (services/locationService.test.ts:286:35)

  ● locationService › update › should return NOT_FOUND when location to update does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      296 |       const result = await locationService.update('nonexistent-id', updateData);
      297 |
    > 298 |       expect(result.success).toBe(false);
          |                              ^
      299 |       if (!result.success) {
      300 |         expect(result.error.code).toBe('NOT_FOUND');
      301 |       }

      at Object.toBe (services/locationService.test.ts:298:30)

  ● locationService › deleteLocation › should return DATABASE_ERROR when delete fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      321 |       const result = await locationService.deleteLocation('location-1');
      322 |
    > 323 |       expect(result.success).toBe(false);
          |                              ^
      324 |       if (!result.success) {
      325 |         expect(result.error.code).toBe('DATABASE_ERROR');
      326 |       }

      at Object.toBe (services/locationService.test.ts:323:30)

  ● locationService › list › should return success with paginated locations when valid filters provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      360 |       const result = await locationService.list(filters);
      361 |
    > 362 |       expect(result.success).toBe(true);
          |                              ^
      363 |       if (result.success) {
      364 |         expect(result.data.locations).toHaveLength(2);
      365 |         expect(result.data.total).toBe(2);

      at Object.toBe (services/locationService.test.ts:362:30)

  ● locationService › list › should filter by parent location ID when provided

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "parent_location_id", "parent-1"

    Number of calls: 0

      384 |       const result = await locationService.list(filters);
      385 |
    > 386 |       expect(mockSupabase.eq).toHaveBeenCalledWith('parent_location_id', 'parent-1');
          |                               ^
      387 |       expect(result.success).toBe(true);
      388 |     });
      389 |

      at Object.toHaveBeenCalledWith (services/locationService.test.ts:386:31)

  ● locationService › list › should filter for root locations when parentLocationId is null

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "parent_location_id", null

    Number of calls: 0

      403 |       const result = await locationService.list(filters);
      404 |
    > 405 |       expect(mockSupabase.is).toHaveBeenCalledWith('parent_location_id', null);
          |                               ^
      406 |       expect(result.success).toBe(true);
      407 |     });
      408 |

      at Object.toHaveBeenCalledWith (services/locationService.test.ts:405:31)

  ● locationService › list › should return DATABASE_ERROR when query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "UNKNOWN_ERROR"

      417 |       expect(result.success).toBe(false);
      418 |       if (!result.success) {
    > 419 |         expect(result.error.code).toBe('DATABASE_ERROR');
          |                                   ^
      420 |       }
      421 |     });
      422 |   });

      at Object.toBe (services/locationService.test.ts:419:35)

  ● locationService › search › should return success with search results when valid query provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      450 |       const result = await locationService.search(searchParams);
      451 |
    > 452 |       expect(result.success).toBe(true);
          |                              ^
      453 |       if (result.success) {
      454 |         expect(result.data.locations).toHaveLength(1);
      455 |         expect(result.data.locations[0].name).toBe('Tamarindo Beach');

      at Object.toBe (services/locationService.test.ts:452:30)

  ● locationService › search › should sanitize search query to prevent injection attacks

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "<script>alert(\"xss\")</script>beach"

    Number of calls: 0

      474 |       // Verify sanitization was called
      475 |       const { sanitizeInput } = require('../utils/sanitization');
    > 476 |       expect(sanitizeInput).toHaveBeenCalledWith(maliciousSearch.query);
          |                             ^
      477 |       expect(result.success).toBe(true);
      478 |     });
      479 |

      at Object.toHaveBeenCalledWith (services/locationService.test.ts:476:29)

  ● locationService › getHierarchy › should return success with hierarchical location tree

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      528 |       const result = await locationService.getHierarchy();
      529 |
    > 530 |       expect(result.success).toBe(true);
          |                              ^
      531 |       if (result.success) {
      532 |         expect(result.data).toHaveLength(1); // One root location
      533 |         expect(result.data[0].name).toBe('Costa Rica');

      at Object.toBe (services/locationService.test.ts:530:30)

  ● locationService › getHierarchy › should return DATABASE_ERROR when query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "UNKNOWN_ERROR"

      549 |       expect(result.success).toBe(false);
      550 |       if (!result.success) {
    > 551 |         expect(result.error.code).toBe('DATABASE_ERROR');
          |                                   ^
      552 |       }
      553 |     });
      554 |   });

      at Object.toBe (services/locationService.test.ts:551:35)

  ● locationService › getWithChildren › should return success with location and its children

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      599 |       const result = await locationService.getWithChildren(parentId);
      600 |
    > 601 |       expect(result.success).toBe(true);
          |                              ^
      602 |       if (result.success) {
      603 |         expect(result.data.name).toBe('Costa Rica');
      604 |         expect(result.data.children).toHaveLength(1);

      at Object.toBe (services/locationService.test.ts:601:30)

  ● locationService › getWithChildren › should return NOT_FOUND when parent location does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: "NOT_FOUND"
    Received: "UNKNOWN_ERROR"

      617 |       expect(result.success).toBe(false);
      618 |       if (!result.success) {
    > 619 |         expect(result.error.code).toBe('NOT_FOUND');
          |                                   ^
      620 |       }
      621 |     });
      622 |   });

      at Object.toBe (services/locationService.test.ts:619:35)

FAIL services/rsvpService.test.ts
  ● rsvpService › create › should return success with RSVP data when valid input provided

    TypeError: Cannot read properties of null (reading 'id')

      87 |       expect(result.success).toBe(true);
      88 |       if (result.success) {
    > 89 |         expect(result.data.id).toBe('rsvp-1');
         |                            ^
      90 |         expect(result.data.guest_id).toBe(validData.guest_id);
      91 |         expect(result.data.status).toBe('attending');
      92 |         expect(result.data.guest_count).toBe(2);

      at Object.id (services/rsvpService.test.ts:89:28)

  ● rsvpService › create › should return DUPLICATE_ENTRY when RSVP already exists

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      136 |       const result = await rsvpService.create(validData);
      137 |
    > 138 |       expect(result.success).toBe(false);
          |                              ^
      139 |       if (!result.success) {
      140 |         expect(result.error.code).toBe('DUPLICATE_ENTRY');
      141 |       }

      at Object.toBe (services/rsvpService.test.ts:138:30)

  ● rsvpService › create › should return DATABASE_ERROR when insert fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      150 |       const result = await rsvpService.create(validData);
      151 |
    > 152 |       expect(result.success).toBe(false);
          |                              ^
      153 |       if (!result.success) {
      154 |         expect(result.error.code).toBe('DATABASE_ERROR');
      155 |       }

      at Object.toBe (services/rsvpService.test.ts:152:30)

  ● rsvpService › create › should sanitize input to prevent XSS attacks

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "<script>alert(\"xss\")</script>Vegetarian"

    Number of calls: 0

      180 |       // Verify sanitization was called
      181 |       const { sanitizeInput } = require('@/utils/sanitization');
    > 182 |       expect(sanitizeInput).toHaveBeenCalledWith(maliciousData.dietary_notes);
          |                             ^
      183 |       expect(sanitizeInput).toHaveBeenCalledWith(maliciousData.special_requirements);
      184 |       expect(sanitizeInput).toHaveBeenCalledWith(maliciousData.notes);
      185 |     });

      at Object.toHaveBeenCalledWith (services/rsvpService.test.ts:182:29)

  ● rsvpService › create › should set responded_at when status is not pending

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"responded_at": Any<String>, "status": "attending"}

    Number of calls: 0

      200 |
      201 |       expect(result.success).toBe(true);
    > 202 |       expect(mockSupabase.insert).toHaveBeenCalledWith(
          |                                   ^
      203 |         expect.objectContaining({
      204 |           status: 'attending',
      205 |           responded_at: expect.any(String),

      at Object.toHaveBeenCalledWith (services/rsvpService.test.ts:202:35)

  ● rsvpService › create › should not set responded_at when status is pending

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"responded_at": undefined, "status": "pending"}

    Number of calls: 0

      223 |
      224 |       expect(result.success).toBe(true);
    > 225 |       expect(mockSupabase.insert).toHaveBeenCalledWith(
          |                                   ^
      226 |         expect.objectContaining({
      227 |           status: 'pending',
      228 |           responded_at: undefined,

      at Object.toHaveBeenCalledWith (services/rsvpService.test.ts:225:35)

  ● rsvpService › get › should return success with RSVP data when RSVP exists

    TypeError: Cannot read properties of null (reading 'id')

      258 |       expect(result.success).toBe(true);
      259 |       if (result.success) {
    > 260 |         expect(result.data.id).toBe('rsvp-1');
          |                            ^
      261 |         expect(result.data.status).toBe('attending');
      262 |       }
      263 |     });

      at Object.id (services/rsvpService.test.ts:260:28)

  ● rsvpService › get › should return NOT_FOUND when RSVP does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      271 |       const result = await rsvpService.get('nonexistent-id');
      272 |
    > 273 |       expect(result.success).toBe(false);
          |                              ^
      274 |       if (!result.success) {
      275 |         expect(result.error.code).toBe('NOT_FOUND');
      276 |       }

      at Object.toBe (services/rsvpService.test.ts:273:30)

  ● rsvpService › get › should return DATABASE_ERROR when database query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      285 |       const result = await rsvpService.get('rsvp-1');
      286 |
    > 287 |       expect(result.success).toBe(false);
          |                              ^
      288 |       if (!result.success) {
      289 |         expect(result.error.code).toBe('DATABASE_ERROR');
      290 |       }

      at Object.toBe (services/rsvpService.test.ts:287:30)

  ● rsvpService › update › should return success with updated RSVP data when valid input provided

    TypeError: Cannot read properties of null (reading 'status')

      324 |       expect(result.success).toBe(true);
      325 |       if (result.success) {
    > 326 |         expect(result.data.status).toBe('declined');
          |                            ^
      327 |         expect(result.data.dietary_notes).toBe('No dietary restrictions');
      328 |         expect(result.data.notes).toBe('Cannot attend due to conflict');
      329 |       }

      at Object.status (services/rsvpService.test.ts:326:28)

  ● rsvpService › update › should set responded_at when status changes from pending

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"responded_at": Any<String>, "status": "attending"}

    Number of calls: 0

      345 |
      346 |       expect(result.success).toBe(true);
    > 347 |       expect(mockSupabase.update).toHaveBeenCalledWith(
          |                                   ^
      348 |         expect.objectContaining({
      349 |           status: 'attending',
      350 |           responded_at: expect.any(String),

      at Object.toHaveBeenCalledWith (services/rsvpService.test.ts:347:35)

  ● rsvpService › update › should return NOT_FOUND when RSVP to update does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      361 |       const result = await rsvpService.update('nonexistent-id', updateData);
      362 |
    > 363 |       expect(result.success).toBe(false);
          |                              ^
      364 |       if (!result.success) {
      365 |         expect(result.error.code).toBe('NOT_FOUND');
      366 |       }

      at Object.toBe (services/rsvpService.test.ts:363:30)

  ● rsvpService › update › should return DATABASE_ERROR when update fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      375 |       const result = await rsvpService.update('rsvp-1', updateData);
      376 |
    > 377 |       expect(result.success).toBe(false);
          |                              ^
      378 |       if (!result.success) {
      379 |         expect(result.error.code).toBe('DATABASE_ERROR');
      380 |       }

      at Object.toBe (services/rsvpService.test.ts:377:30)

  ● rsvpService › deleteRSVP › should return DATABASE_ERROR when delete fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      400 |       const result = await rsvpService.deleteRSVP('rsvp-1');
      401 |
    > 402 |       expect(result.success).toBe(false);
          |                              ^
      403 |       if (!result.success) {
      404 |         expect(result.error.code).toBe('DATABASE_ERROR');
      405 |       }

      at Object.toBe (services/rsvpService.test.ts:402:30)

  ● rsvpService › list › should return success with paginated RSVPs when valid filters provided

    expect(received).toHaveLength(expected)

    Expected length: 2
    Received length: 0
    Received array:  []

      451 |       expect(result.success).toBe(true);
      452 |       if (result.success) {
    > 453 |         expect(result.data.rsvps).toHaveLength(2);
          |                                   ^
      454 |         expect(result.data.total).toBe(2);
      455 |       }
      456 |     });

      at Object.toHaveLength (services/rsvpService.test.ts:453:35)

  ● rsvpService › list › should filter by guest_id when provided

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "guest_id", "123e4567-e89b-12d3-a456-426614174000"

    Number of calls: 0

      471 |       const result = await rsvpService.list(filters);
      472 |
    > 473 |       expect(mockSupabase.eq).toHaveBeenCalledWith('guest_id', '123e4567-e89b-12d3-a456-426614174000');
          |                               ^
      474 |       expect(result.success).toBe(true);
      475 |     });
      476 |

      at Object.toHaveBeenCalledWith (services/rsvpService.test.ts:473:31)

  ● rsvpService › list › should filter by status when provided

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "status", "attending"

    Number of calls: 0

      490 |       const result = await rsvpService.list(filters);
      491 |
    > 492 |       expect(mockSupabase.eq).toHaveBeenCalledWith('status', 'attending');
          |                               ^
      493 |       expect(result.success).toBe(true);
      494 |     });
      495 |

      at Object.toHaveBeenCalledWith (services/rsvpService.test.ts:492:31)

  ● rsvpService › list › should return DATABASE_ERROR when query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      502 |       const result = await rsvpService.list();
      503 |
    > 504 |       expect(result.success).toBe(false);
          |                              ^
      505 |       if (!result.success) {
      506 |         expect(result.error.code).toBe('DATABASE_ERROR');
      507 |       }

      at Object.toBe (services/rsvpService.test.ts:504:30)

  ● rsvpService › calculateActivityCapacity › should return success with capacity information when activity exists

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      537 |       const result = await rsvpService.calculateActivityCapacity('activity-1');
      538 |
    > 539 |       expect(result.success).toBe(true);
          |                              ^
      540 |       if (result.success) {
      541 |         expect(result.data.capacity).toBe(50);
      542 |         expect(result.data.attending_count).toBe(6); // 2 + 3 + 1

      at Object.toBe (services/rsvpService.test.ts:539:30)

  ● rsvpService › calculateActivityCapacity › should handle activities with no capacity limit

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      571 |       const result = await rsvpService.calculateActivityCapacity('activity-1');
      572 |
    > 573 |       expect(result.success).toBe(true);
          |                              ^
      574 |       if (result.success) {
      575 |         expect(result.data.capacity).toBeNull();
      576 |         expect(result.data.attending_count).toBe(8); // 5 + 3

      at Object.toBe (services/rsvpService.test.ts:573:30)

  ● rsvpService › calculateActivityCapacity › should return DATABASE_ERROR when activity query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "UNKNOWN_ERROR"

      589 |       expect(result.success).toBe(false);
      590 |       if (!result.success) {
    > 591 |         expect(result.error.code).toBe('DATABASE_ERROR');
          |                                   ^
      592 |       }
      593 |     });
      594 |   });

      at Object.toBe (services/rsvpService.test.ts:591:35)

  ● rsvpService › generateCapacityAlerts › should return success with alerts for activities approaching capacity

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      632 |       const result = await rsvpService.generateCapacityAlerts(0.9);
      633 |
    > 634 |       expect(result.success).toBe(true);
          |                              ^
      635 |       if (result.success) {
      636 |         expect(result.data).toHaveLength(2);
      637 |         

      at Object.toBe (services/rsvpService.test.ts:634:30)

  ● rsvpService › generateCapacityAlerts › should return empty array when no activities exceed threshold

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      672 |       const result = await rsvpService.generateCapacityAlerts(0.9);
      673 |
    > 674 |       expect(result.success).toBe(true);
          |                              ^
      675 |       if (result.success) {
      676 |         expect(result.data).toHaveLength(0);
      677 |       }

      at Object.toBe (services/rsvpService.test.ts:674:30)

  ● rsvpService › checkCapacityAvailable › should return available true when capacity is sufficient

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      697 |       const result = await rsvpService.checkCapacityAvailable('activity-1', 3);
      698 |
    > 699 |       expect(result.success).toBe(true);
          |                              ^
      700 |       if (result.success) {
      701 |         expect(result.data.available).toBe(true);
      702 |         expect(result.data.message).toContain('5 spots remaining');

      at Object.toBe (services/rsvpService.test.ts:699:30)

  ● rsvpService › checkCapacityAvailable › should return available false when capacity would be exceeded

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      721 |       const result = await rsvpService.checkCapacityAvailable('activity-1', 5);
      722 |
    > 723 |       expect(result.success).toBe(true);
          |                              ^
      724 |       if (result.success) {
      725 |         expect(result.data.available).toBe(false);
      726 |         expect(result.data.message).toContain('cannot add 5 more guest(s)');

      at Object.toBe (services/rsvpService.test.ts:723:30)

  ● rsvpService › checkCapacityAvailable › should return available true when no capacity limit is set

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      745 |       const result = await rsvpService.checkCapacityAvailable('activity-1', 50);
      746 |
    > 747 |       expect(result.success).toBe(true);
          |                              ^
      748 |       if (result.success) {
      749 |         expect(result.data.available).toBe(true);
      750 |         expect(result.data.message).toContain('No capacity limit');

      at Object.toBe (services/rsvpService.test.ts:747:30)

  ● rsvpService › enforceCapacityLimit › should return success when capacity limit is not exceeded

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      771 |       const result = await rsvpService.enforceCapacityLimit('activity-1', 3);
      772 |
    > 773 |       expect(result.success).toBe(true);
          |                              ^
      774 |     });
      775 |
      776 |     it('should return CAPACITY_EXCEEDED when limit would be exceeded', async () => {

      at Object.toBe (services/rsvpService.test.ts:773:30)

  ● rsvpService › enforceCapacityLimit › should return CAPACITY_EXCEEDED when limit would be exceeded

    expect(received).toBe(expected) // Object.is equality

    Expected: "CAPACITY_EXCEEDED"
    Received: "UNKNOWN_ERROR"

      793 |       expect(result.success).toBe(false);
      794 |       if (!result.success) {
    > 795 |         expect(result.error.code).toBe('CAPACITY_EXCEEDED');
          |                                   ^
      796 |         expect(result.error.message).toContain('13/10');
      797 |       }
      798 |     });

      at Object.toBe (services/rsvpService.test.ts:795:35)

  ● rsvpService › enforceCapacityLimit › should account for existing RSVP when updating

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      823 |       const result = await rsvpService.enforceCapacityLimit('activity-1', 4, 'existing-rsvp-id');
      824 |
    > 825 |       expect(result.success).toBe(true);
          |                              ^
      826 |     });
      827 |
      828 |     it('should return success when no capacity limit is set', async () => {

      at Object.toBe (services/rsvpService.test.ts:825:30)

  ● rsvpService › enforceCapacityLimit › should return success when no capacity limit is set

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      843 |       const result = await rsvpService.enforceCapacityLimit('activity-1', 50);
      844 |
    > 845 |       expect(result.success).toBe(true);
          |                              ^
      846 |     });
      847 |   });
      848 | });

      at Object.toBe (services/rsvpService.test.ts:845:30)

FAIL services/emailService.test.ts
  ● emailService › createTemplate › should return success with template data when valid input provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

       99 |       const result = await createTemplate(validTemplateData);
      100 |
    > 101 |       expect(result.success).toBe(true);
          |                              ^
      102 |       if (result.success) {
      103 |         expect(result.data.id).toBe('template-1');
      104 |         expect(result.data.name).toBe('Welcome Email');

      at Object.toBe (services/emailService.test.ts:101:30)

  ● emailService › createTemplate › should return DATABASE_ERROR when insert fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "UNKNOWN_ERROR"

      143 |       expect(result.success).toBe(false);
      144 |       if (!result.success) {
    > 145 |         expect(result.error.code).toBe(ERROR_CODES.DATABASE_ERROR);
          |                                   ^
      146 |         expect(result.error.message).toBe('Connection failed');
      147 |       }
      148 |     });

      at Object.toBe (services/emailService.test.ts:145:35)

  ● emailService › createTemplate › should sanitize HTML content to prevent XSS attacks

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      166 |       const result = await createTemplate(maliciousData);
      167 |
    > 168 |       expect(result.success).toBe(true);
          |                              ^
      169 |       if (result.success) {
      170 |         expect(result.data.body_html).not.toContain('<script>');
      171 |         expect(result.data.body_html).not.toContain('alert');

      at Object.toBe (services/emailService.test.ts:168:30)

  ● emailService › getTemplate › should return success with template data when template exists

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      191 |       const result = await getTemplate('template-1');
      192 |
    > 193 |       expect(result.success).toBe(true);
          |                              ^
      194 |       if (result.success) {
      195 |         expect(result.data.id).toBe('template-1');
      196 |         expect(result.data.name).toBe('Welcome Email');

      at Object.toBe (services/emailService.test.ts:193:30)

  ● emailService › getTemplate › should return NOT_FOUND when template does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: "NOT_FOUND"
    Received: "UNKNOWN_ERROR"

      205 |       expect(result.success).toBe(false);
      206 |       if (!result.success) {
    > 207 |         expect(result.error.code).toBe(ERROR_CODES.NOT_FOUND);
          |                                   ^
      208 |         expect(result.error.message).toBe('Template not found');
      209 |       }
      210 |     });

      at Object.toBe (services/emailService.test.ts:207:35)

  ● emailService › updateTemplate › should return success with updated template data when valid input provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      242 |       const result = await updateTemplate('template-1', updateData);
      243 |
    > 244 |       expect(result.success).toBe(true);
          |                              ^
      245 |       if (result.success) {
      246 |         expect(result.data.name).toBe('Updated Welcome Email');
      247 |         expect(result.data.subject).toBe('Welcome {{guest_name}}!');

      at Object.toBe (services/emailService.test.ts:244:30)

  ● emailService › updateTemplate › should return NOT_FOUND when template does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: "NOT_FOUND"
    Received: "UNKNOWN_ERROR"

      256 |       expect(result.success).toBe(false);
      257 |       if (!result.success) {
    > 258 |         expect(result.error.code).toBe(ERROR_CODES.NOT_FOUND);
          |                                   ^
      259 |       }
      260 |     });
      261 |   });

      at Object.toBe (services/emailService.test.ts:258:35)

  ● emailService › deleteTemplate › should return success when template is deleted

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      267 |       const result = await deleteTemplate('template-1');
      268 |
    > 269 |       expect(result.success).toBe(true);
          |                              ^
      270 |     });
      271 |
      272 |     it('should return DATABASE_ERROR when delete fails', async () => {

      at Object.toBe (services/emailService.test.ts:269:30)

  ● emailService › deleteTemplate › should return DATABASE_ERROR when delete fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "UNKNOWN_ERROR"

      277 |       expect(result.success).toBe(false);
      278 |       if (!result.success) {
    > 279 |         expect(result.error.code).toBe(ERROR_CODES.DATABASE_ERROR);
          |                                   ^
      280 |       }
      281 |     });
      282 |   });

      at Object.toBe (services/emailService.test.ts:279:35)

  ● emailService › listTemplates › should return success with templates list

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      311 |       const result = await listTemplates();
      312 |
    > 313 |       expect(result.success).toBe(true);
          |                              ^
      314 |       if (result.success) {
      315 |         expect(result.data).toHaveLength(2);
      316 |         expect(result.data[0].name).toBe('Welcome Email');

      at Object.toBe (services/emailService.test.ts:313:30)

  ● emailService › listTemplates › should return empty array when no templates exist

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      324 |       const result = await listTemplates();
      325 |
    > 326 |       expect(result.success).toBe(true);
          |                              ^
      327 |       if (result.success) {
      328 |         expect(result.data).toHaveLength(0);
      329 |       }

      at Object.toBe (services/emailService.test.ts:326:30)

  ● emailService › sendEmail › should return success with email ID when email is sent successfully

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      354 |       const result = await sendEmail(validEmailData);
      355 |
    > 356 |       expect(result.success).toBe(true);
          |                              ^
      357 |       if (result.success) {
      358 |         expect(result.data.id).toBe('email-123');
      359 |       }

      at Object.toBe (services/emailService.test.ts:356:30)

  ● emailService › sendEmail › should return EMAIL_SERVICE_ERROR when Resend fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "EMAIL_SERVICE_ERROR"
    Received: "UNKNOWN_ERROR"

      390 |       expect(result.success).toBe(false);
      391 |       if (!result.success) {
    > 392 |         expect(result.error.code).toBe(ERROR_CODES.EMAIL_SERVICE_ERROR);
          |                                   ^
      393 |         expect(result.error.message).toBe('API key invalid');
      394 |       }
      395 |     });

      at Object.toBe (services/emailService.test.ts:392:35)

  ● emailService › sendEmail › should substitute template variables when template_id provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      427 |       const result = await sendEmail(emailWithTemplate);
      428 |
    > 429 |       expect(result.success).toBe(true);
          |                              ^
      430 |       expect(mockResend.emails.send).toHaveBeenCalledWith({
      431 |         from: 'onboarding@resend.dev',
      432 |         to: 'guest@example.com',

      at Object.toBe (services/emailService.test.ts:429:30)

  ● emailService › sendEmail › should return NOT_FOUND when template_id does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: "NOT_FOUND"
    Received: "VALIDATION_ERROR"

      451 |       expect(result.success).toBe(false);
      452 |       if (!result.success) {
    > 453 |         expect(result.error.code).toBe(ERROR_CODES.NOT_FOUND);
          |                                   ^
      454 |         expect(result.error.message).toBe('Template not found');
      455 |       }
      456 |     });

      at Object.toBe (services/emailService.test.ts:453:35)

  ● emailService › sendBulkEmail › should return success with sent/failed counts when bulk email is sent

    expect(received).toBe(expected) // Object.is equality

    Expected: 2
    Received: 0

      479 |       expect(result.success).toBe(true);
      480 |       if (result.success) {
    > 481 |         expect(result.data.sent).toBe(2);
          |                                  ^
      482 |         expect(result.data.failed).toBe(1);
      483 |       }
      484 |

      at Object.toBe (services/emailService.test.ts:481:34)

  ● emailService › scheduleEmail › should return success with scheduled email ID when email is scheduled

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      525 |       const result = await scheduleEmail(scheduleData);
      526 |
    > 527 |       expect(result.success).toBe(true);
          |                              ^
      528 |       if (result.success) {
      529 |         expect(result.data.id).toBe('scheduled-1');
      530 |       }

      at Object.toBe (services/emailService.test.ts:527:30)

  ● emailService › sendEmailWithSMSFallback › should return email result when email sends successfully

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      569 |       const result = await sendEmailWithSMSFallback(emailData, '+15551234567');
      570 |
    > 571 |       expect(result.success).toBe(true);
          |                              ^
      572 |       if (result.success) {
      573 |         expect(result.data.id).toBe('email-123');
      574 |         expect(result.data.method).toBe('email');

      at Object.toBe (services/emailService.test.ts:571:30)

  ● emailService › sendEmailWithSMSFallback › should return email error when email fails and no phone number provided

    expect(received).toBe(expected) // Object.is equality

    Expected: "EMAIL_SERVICE_ERROR"
    Received: "UNKNOWN_ERROR"

      629 |       expect(result.success).toBe(false);
      630 |       if (!result.success) {
    > 631 |         expect(result.error.code).toBe(ERROR_CODES.EMAIL_SERVICE_ERROR);
          |                                   ^
      632 |       }
      633 |
      634 |       expect(sendSMSFallback).not.toHaveBeenCalled();

      at Object.toBe (services/emailService.test.ts:631:35)

  ● emailService › updateDeliveryStatus › should return success when delivery status is updated to delivered

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      671 |       const result = await updateDeliveryStatus('log-1', 'delivered');
      672 |
    > 673 |       expect(result.success).toBe(true);
          |                              ^
      674 |       expect(mockSupabase.update).toHaveBeenCalledWith({
      675 |         delivery_status: 'delivered',
      676 |         delivered_at: expect.any(String),

      at Object.toBe (services/emailService.test.ts:673:30)

  ● emailService › updateDeliveryStatus › should return success when delivery status is updated to failed with error message

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      683 |       const result = await updateDeliveryStatus('log-1', 'failed', 'Bounce detected');
      684 |
    > 685 |       expect(result.success).toBe(true);
          |                              ^
      686 |       expect(mockSupabase.update).toHaveBeenCalledWith({
      687 |         delivery_status: 'failed',
      688 |         error_message: 'Bounce detected',

      at Object.toBe (services/emailService.test.ts:685:30)

  ● emailService › updateDeliveryStatus › should return DATABASE_ERROR when update fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "UNKNOWN_ERROR"

      697 |       expect(result.success).toBe(false);
      698 |       if (!result.success) {
    > 699 |         expect(result.error.code).toBe(ERROR_CODES.DATABASE_ERROR);
          |                                   ^
      700 |       }
      701 |     });
      702 |   });

      at Object.toBe (services/emailService.test.ts:699:35)

  ● emailService › getEmailAnalytics › should return success with analytics data

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      716 |       const result = await getEmailAnalytics();
      717 |
    > 718 |       expect(result.success).toBe(true);
          |                              ^
      719 |       if (result.success) {
      720 |         expect(result.data.total).toBe(5);
      721 |         expect(result.data.sent).toBe(1);

      at Object.toBe (services/emailService.test.ts:718:30)

  ● emailService › getEmailAnalytics › should return empty analytics when no logs exist

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      731 |       const result = await getEmailAnalytics();
      732 |
    > 733 |       expect(result.success).toBe(true);
          |                              ^
      734 |       if (result.success) {
      735 |         expect(result.data.total).toBe(0);
      736 |         expect(result.data.sent).toBe(0);

      at Object.toBe (services/emailService.test.ts:733:30)

  ● emailService › getEmailLogs › should return success with all logs when no filters provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      767 |       const result = await getEmailLogs();
      768 |
    > 769 |       expect(result.success).toBe(true);
          |                              ^
      770 |       if (result.success) {
      771 |         expect(result.data).toHaveLength(2);
      772 |         expect(result.data[0].id).toBe('log-1');

      at Object.toBe (services/emailService.test.ts:769:30)

  ● emailService › getEmailLogs › should return success with filtered logs when filters provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      784 |       });
      785 |
    > 786 |       expect(result.success).toBe(true);
          |                              ^
      787 |       if (result.success) {
      788 |         expect(result.data).toHaveLength(1);
      789 |         expect(result.data[0].delivery_status).toBe('delivered');

      at Object.toBe (services/emailService.test.ts:786:30)

  ● emailService › getEmailLogs › should return empty array when no logs match filters

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      798 |       });
      799 |
    > 800 |       expect(result.success).toBe(true);
          |                              ^
      801 |       if (result.success) {
      802 |         expect(result.data).toHaveLength(0);
      803 |       }

      at Object.toBe (services/emailService.test.ts:800:30)

FAIL services/eventService.test.ts
  ● Console

    console.warn
      GoTrueClient@sb-localhost-auth-token:1 (2.91.1) 2026-01-30T01:26:14.714Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      148 | export async function get(id: string): Promise<Result<Event>> {
      149 |   try {
    > 150 |     const supabase = createClient(
          |                                  ^
      151 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      152 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      153 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.get (services/eventService.ts:150:34)
      at Object.get (services/eventService.test.ts:235:41)

    console.warn
      GoTrueClient@sb-localhost-auth-token:2 (2.91.1) 2026-01-30T01:26:14.804Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      148 | export async function get(id: string): Promise<Result<Event>> {
      149 |   try {
    > 150 |     const supabase = createClient(
          |                                  ^
      151 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      152 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      153 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.get (services/eventService.ts:150:34)
      at Object.get (services/eventService.test.ts:249:41)

    console.warn
      GoTrueClient@sb-localhost-auth-token:3 (2.91.1) 2026-01-30T01:26:14.827Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      300 | export async function deleteEvent(id: string): Promise<Result<void>> {
      301 |   try {
    > 302 |     const supabase = createClient(
          |                                  ^
      303 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      304 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      305 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.deleteEvent (services/eventService.ts:302:34)
      at Object.deleteEvent (services/eventService.test.ts:378:41)

    console.warn
      GoTrueClient@sb-localhost-auth-token:4 (2.91.1) 2026-01-30T01:26:14.836Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      300 | export async function deleteEvent(id: string): Promise<Result<void>> {
      301 |   try {
    > 302 |     const supabase = createClient(
          |                                  ^
      303 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      304 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      305 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.deleteEvent (services/eventService.ts:302:34)
      at Object.deleteEvent (services/eventService.test.ts:388:41)

    console.warn
      GoTrueClient@sb-localhost-auth-token:5 (2.91.1) 2026-01-30T01:26:14.840Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      352 |
      353 |     // 2. Database operation
    > 354 |     const supabase = createClient(
          |                                  ^
      355 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      356 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      357 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.list (services/eventService.ts:354:34)
      at Object.list (services/eventService.test.ts:433:41)

    console.warn
      GoTrueClient@sb-localhost-auth-token:6 (2.91.1) 2026-01-30T01:26:14.843Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      352 |
      353 |     // 2. Database operation
    > 354 |     const supabase = createClient(
          |                                  ^
      355 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      356 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      357 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.list (services/eventService.ts:354:34)
      at Object.list (services/eventService.test.ts:457:41)

    console.warn
      GoTrueClient@sb-localhost-auth-token:7 (2.91.1) 2026-01-30T01:26:14.850Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      352 |
      353 |     // 2. Database operation
    > 354 |     const supabase = createClient(
          |                                  ^
      355 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      356 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      357 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.list (services/eventService.ts:354:34)
      at Object.list (services/eventService.test.ts:477:41)

    console.warn
      GoTrueClient@sb-localhost-auth-token:8 (2.91.1) 2026-01-30T01:26:14.856Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      352 |
      353 |     // 2. Database operation
    > 354 |     const supabase = createClient(
          |                                  ^
      355 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      356 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      357 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.list (services/eventService.ts:354:34)
      at Object.list (services/eventService.test.ts:490:41)

    console.warn
      GoTrueClient@sb-localhost-auth-token:9 (2.91.1) 2026-01-30T01:26:14.858Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      442 |
      443 |     // 3. Database operation
    > 444 |     const supabase = createClient(
          |                                  ^
      445 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      446 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      447 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.search (services/eventService.ts:444:34)
      at Object.search (services/eventService.test.ts:528:41)

    console.warn
      GoTrueClient@sb-localhost-auth-token:10 (2.91.1) 2026-01-30T01:26:14.860Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      442 |
      443 |     // 3. Database operation
    > 444 |     const supabase = createClient(
          |                                  ^
      445 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      446 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      447 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.search (services/eventService.ts:444:34)
      at Object.search (services/eventService.test.ts:550:41)

    console.warn
      GoTrueClient@sb-localhost-auth-token:11 (2.91.1) 2026-01-30T01:26:14.863Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      512 |
      513 |     // 2. Database operation
    > 514 |     const supabase = createClient(
          |                                  ^
      515 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      516 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      517 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.checkSchedulingConflicts (services/eventService.ts:514:34)
      at Object.checkSchedulingConflicts (services/eventService.test.ts:582:41)

    console.warn
      GoTrueClient@sb-localhost-auth-token:12 (2.91.1) 2026-01-30T01:26:14.867Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      512 |
      513 |     // 2. Database operation
    > 514 |     const supabase = createClient(
          |                                  ^
      515 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      516 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      517 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.checkSchedulingConflicts (services/eventService.ts:514:34)
      at Object.checkSchedulingConflicts (services/eventService.test.ts:604:41)

    console.warn
      GoTrueClient@sb-localhost-auth-token:13 (2.91.1) 2026-01-30T01:26:14.869Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      512 |
      513 |     // 2. Database operation
    > 514 |     const supabase = createClient(
          |                                  ^
      515 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      516 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      517 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.checkSchedulingConflicts (services/eventService.ts:514:34)
      at Object.checkSchedulingConflicts (services/eventService.test.ts:646:41)

    console.warn
      GoTrueClient@sb-localhost-auth-token:14 (2.91.1) 2026-01-30T01:26:14.871Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      512 |
      513 |     // 2. Database operation
    > 514 |     const supabase = createClient(
          |                                  ^
      515 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      516 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      517 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.checkSchedulingConflicts (services/eventService.ts:514:34)
      at Object.checkSchedulingConflicts (services/eventService.test.ts:660:41)

  ● eventService › create › should return success with event data when valid input provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      84 |       const result = await eventService.create(validData);
      85 |
    > 86 |       expect(result.success).toBe(true);
         |                              ^
      87 |       if (result.success) {
      88 |         expect(result.data.id).toBe('event-1');
      89 |         expect(result.data.name).toBe('Wedding Ceremony');

      at Object.toBe (services/eventService.test.ts:86:30)

  ● eventService › create › should return SCHEDULING_CONFLICT when event conflicts with existing events

    expect(received).toBe(expected) // Object.is equality

    Expected: "SCHEDULING_CONFLICT"
    Received: "VALIDATION_ERROR"

      133 |       expect(result.success).toBe(false);
      134 |       if (!result.success) {
    > 135 |         expect(result.error.code).toBe('SCHEDULING_CONFLICT');
          |                                   ^
      136 |         expect(result.error.details).toHaveLength(1);
      137 |       }
      138 |     });

      at Object.toBe (services/eventService.test.ts:135:35)

  ● eventService › create › should return DATABASE_ERROR when insert fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "VALIDATION_ERROR"

      157 |       expect(result.success).toBe(false);
      158 |       if (!result.success) {
    > 159 |         expect(result.error.code).toBe('DATABASE_ERROR');
          |                                   ^
      160 |       }
      161 |     });
      162 |

      at Object.toBe (services/eventService.test.ts:159:35)

  ● eventService › create › should sanitize input to prevent XSS attacks

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      188 |       const result = await eventService.create(maliciousData);
      189 |
    > 190 |       expect(result.success).toBe(true);
          |                              ^
      191 |       
      192 |       // Verify sanitization was called
      193 |       const { sanitizeInput, sanitizeRichText } = require('../utils/sanitization');

      at Object.toBe (services/eventService.test.ts:190:30)

  ● eventService › get › should return success with event data when event exists

    expect(received).toBe(expected) // Object.is equality

    Expected: "event-1"
    Received: undefined

      221 |       expect(result.success).toBe(true);
      222 |       if (result.success) {
    > 223 |         expect(result.data.id).toBe('event-1');
          |                                ^
      224 |         expect(result.data.name).toBe('Wedding Ceremony');
      225 |         expect(result.data.eventType).toBe('ceremony');
      226 |       }

      at Object.toBe (services/eventService.test.ts:223:32)

  ● eventService › get › should return NOT_FOUND when event does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      235 |       const result = await eventService.get('nonexistent-id');
      236 |
    > 237 |       expect(result.success).toBe(false);
          |                              ^
      238 |       if (!result.success) {
      239 |         expect(result.error.code).toBe('NOT_FOUND');
      240 |       }

      at Object.toBe (services/eventService.test.ts:237:30)

  ● eventService › get › should return DATABASE_ERROR when database query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      249 |       const result = await eventService.get('event-1');
      250 |
    > 251 |       expect(result.success).toBe(false);
          |                              ^
      252 |       if (!result.success) {
      253 |         expect(result.error.code).toBe('DATABASE_ERROR');
      254 |       }

      at Object.toBe (services/eventService.test.ts:251:30)

  ● eventService › update › should return success with updated event data when valid input provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      284 |       const result = await eventService.update('event-1', updateData);
      285 |
    > 286 |       expect(result.success).toBe(true);
          |                              ^
      287 |       if (result.success) {
      288 |         expect(result.data.name).toBe('Updated Ceremony');
      289 |         expect(result.data.description).toBe('Updated description');

      at Object.toBe (services/eventService.test.ts:286:30)

  ● eventService › update › should check for scheduling conflicts when location or dates are updated

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      351 |       const result = await eventService.update('event-1', updateWithLocation);
      352 |
    > 353 |       expect(result.success).toBe(true);
          |                              ^
      354 |       expect(mockSupabase.neq).toHaveBeenCalledWith('id', 'event-1'); // Exclude current event from conflict check
      355 |     });
      356 |

      at Object.toBe (services/eventService.test.ts:353:30)

  ● eventService › update › should return NOT_FOUND when event to update does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: "NOT_FOUND"
    Received: "VALIDATION_ERROR"

      365 |       expect(result.success).toBe(false);
      366 |       if (!result.success) {
    > 367 |         expect(result.error.code).toBe('NOT_FOUND');
          |                                   ^
      368 |       }
      369 |     });
      370 |   });

      at Object.toBe (services/eventService.test.ts:367:35)

  ● eventService › deleteEvent › should return DATABASE_ERROR when delete fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      388 |       const result = await eventService.deleteEvent('event-1');
      389 |
    > 390 |       expect(result.success).toBe(false);
          |                              ^
      391 |       if (!result.success) {
      392 |         expect(result.error.code).toBe('DATABASE_ERROR');
      393 |       }

      at Object.toBe (services/eventService.test.ts:390:30)

  ● eventService › list › should return success with paginated events when valid filters provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      433 |       const result = await eventService.list(filters);
      434 |
    > 435 |       expect(result.success).toBe(true);
          |                              ^
      436 |       if (result.success) {
      437 |         expect(result.data.events).toHaveLength(2);
      438 |         expect(result.data.total).toBe(2);

      at Object.toBe (services/eventService.test.ts:435:30)

  ● eventService › list › should filter by event type when provided

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "event_type", "ceremony"

    Number of calls: 0

      457 |       const result = await eventService.list(filters);
      458 |
    > 459 |       expect(mockSupabase.eq).toHaveBeenCalledWith('event_type', 'ceremony');
          |                               ^
      460 |       expect(result.success).toBe(true);
      461 |     });
      462 |

      at Object.toHaveBeenCalledWith (services/eventService.test.ts:459:31)

  ● eventService › list › should filter by date range when provided

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "start_date", "2025-06-01T00:00:00Z"

    Number of calls: 0

      477 |       const result = await eventService.list(filters);
      478 |
    > 479 |       expect(mockSupabase.gte).toHaveBeenCalledWith('start_date', '2025-06-01T00:00:00Z');
          |                                ^
      480 |       expect(mockSupabase.lte).toHaveBeenCalledWith('start_date', '2025-06-30T23:59:59Z');
      481 |       expect(result.success).toBe(true);
      482 |     });

      at Object.toHaveBeenCalledWith (services/eventService.test.ts:479:32)

  ● eventService › list › should return DATABASE_ERROR when query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "UNKNOWN_ERROR"

      492 |       expect(result.success).toBe(false);
      493 |       if (!result.success) {
    > 494 |         expect(result.error.code).toBe('DATABASE_ERROR');
          |                                   ^
      495 |       }
      496 |     });
      497 |   });

      at Object.toBe (services/eventService.test.ts:494:35)

  ● eventService › search › should return success with search results when valid query provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      528 |       const result = await eventService.search(searchParams);
      529 |
    > 530 |       expect(result.success).toBe(true);
          |                              ^
      531 |       if (result.success) {
      532 |         expect(result.data.events).toHaveLength(1);
      533 |         expect(result.data.events[0].name).toBe('Wedding Ceremony');

      at Object.toBe (services/eventService.test.ts:530:30)

  ● eventService › search › should sanitize search query to prevent injection attacks

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "<script>alert(\"xss\")</script>ceremony"

    Number of calls: 0

      552 |       // Verify sanitization was called
      553 |       const { sanitizeInput } = require('../utils/sanitization');
    > 554 |       expect(sanitizeInput).toHaveBeenCalledWith(maliciousSearch.query);
          |                             ^
      555 |       expect(result.success).toBe(true);
      556 |     });
      557 |

      at Object.toHaveBeenCalledWith (services/eventService.test.ts:554:29)

  ● eventService › checkSchedulingConflicts › should return success with no conflicts when no overlapping events exist

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      582 |       const result = await eventService.checkSchedulingConflicts(conflictParams);
      583 |
    > 584 |       expect(result.success).toBe(true);
          |                              ^
      585 |       if (result.success) {
      586 |         expect(result.data.hasConflict).toBe(false);
      587 |         expect(result.data.conflictingEvents).toHaveLength(0);

      at Object.toBe (services/eventService.test.ts:584:30)

  ● eventService › checkSchedulingConflicts › should return success with conflicts when overlapping events exist

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      604 |       const result = await eventService.checkSchedulingConflicts(conflictParams);
      605 |
    > 606 |       expect(result.success).toBe(true);
          |                              ^
      607 |       if (result.success) {
      608 |         expect(result.data.hasConflict).toBe(true);
      609 |         expect(result.data.conflictingEvents).toHaveLength(1);

      at Object.toBe (services/eventService.test.ts:606:30)

  ● eventService › checkSchedulingConflicts › should exclude specified event ID from conflict check

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "id", "current-event-id"

    Number of calls: 0

      627 |       const result = await eventService.checkSchedulingConflicts(paramsWithExclusion);
      628 |
    > 629 |       expect(mockSupabase.neq).toHaveBeenCalledWith('id', 'current-event-id');
          |                                ^
      630 |       expect(result.success).toBe(true);
      631 |     });
      632 |

      at Object.toHaveBeenCalledWith (services/eventService.test.ts:629:32)

  ● eventService › checkSchedulingConflicts › should handle events without end dates correctly

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      646 |       const result = await eventService.checkSchedulingConflicts(conflictParams);
      647 |
    > 648 |       expect(result.success).toBe(true);
          |                              ^
      649 |       if (result.success) {
      650 |         expect(result.data.hasConflict).toBe(true); // Should still detect overlap
      651 |       }

      at Object.toBe (services/eventService.test.ts:648:30)

  ● eventService › checkSchedulingConflicts › should return DATABASE_ERROR when query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "UNKNOWN_ERROR"

      662 |       expect(result.success).toBe(false);
      663 |       if (!result.success) {
    > 664 |         expect(result.error.code).toBe('DATABASE_ERROR');
          |                                   ^
      665 |       }
      666 |     });
      667 |

      at Object.toBe (services/eventService.test.ts:664:35)

FAIL services/accommodationService.test.ts
  ● Console

    console.log
      CamelCase result: {
        "id": "accommodation-1",
        "name": "Costa Rica Beach Resort",
        "locationId": "123e4567-e89b-12d3-a456-426614174000",
        "description": "Beautiful beachfront resort",
        "address": "123 Beach Road, Costa Rica",
        "status": "published",
        "createdAt": "2024-01-01T00:00:00Z",
        "updatedAt": "2024-01-01T00:00:00Z"
      }

      at Object.log (services/accommodationService.test.ts:94:15)

    console.log
      Test result: {
        "success": true,
        "data": {}
      }

      at Object.log (services/accommodationService.test.ts:104:15)

    console.warn
      GoTrueClient@sb-test-auth-token:1 (2.91.1) 2026-01-30T01:26:14.718Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      88 |     };
      89 |
    > 90 |     const supabase = createClient(
         |                                  ^
      91 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      92 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      93 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.createAccommodation (services/accommodationService.ts:90:34)
      at Object.createAccommodation (services/accommodationService.test.ts:143:49)

    console.warn
      GoTrueClient@sb-test-auth-token:2 (2.91.1) 2026-01-30T01:26:14.756Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      88 |     };
      89 |
    > 90 |     const supabase = createClient(
         |                                  ^
      91 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      92 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      93 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.createAccommodation (services/accommodationService.ts:90:34)
      at Object.createAccommodation (services/accommodationService.test.ts:175:49)

    console.warn
      GoTrueClient@sb-test-auth-token:3 (2.91.1) 2026-01-30T01:26:14.768Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      124 | export async function getAccommodation(id: string): Promise<Result<Accommodation>> {
      125 |   try {
    > 126 |     const supabase = createClient(
          |                                  ^
      127 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      128 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      129 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.getAccommodation (services/accommodationService.ts:126:34)
      at Object.getAccommodation (services/accommodationService.test.ts:206:49)

    console.warn
      GoTrueClient@sb-test-auth-token:4 (2.91.1) 2026-01-30T01:26:14.773Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      124 | export async function getAccommodation(id: string): Promise<Result<Accommodation>> {
      125 |   try {
    > 126 |     const supabase = createClient(
          |                                  ^
      127 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      128 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      129 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.getAccommodation (services/accommodationService.ts:126:34)
      at Object.getAccommodation (services/accommodationService.test.ts:224:49)

    console.warn
      GoTrueClient@sb-test-auth-token:5 (2.91.1) 2026-01-30T01:26:14.778Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      124 | export async function getAccommodation(id: string): Promise<Result<Accommodation>> {
      125 |   try {
    > 126 |     const supabase = createClient(
          |                                  ^
      127 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      128 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      129 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.getAccommodation (services/accommodationService.ts:126:34)
      at Object.getAccommodation (services/accommodationService.test.ts:241:49)

    console.warn
      GoTrueClient@sb-test-auth-token:6 (2.91.1) 2026-01-30T01:26:14.787Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      427 |     };
      428 |
    > 429 |     const supabase = createClient(
          |                                  ^
      430 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      431 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      432 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.createRoomType (services/accommodationService.ts:429:34)
      at Object.createRoomType (services/accommodationService.test.ts:286:49)

    console.warn
      GoTrueClient@sb-test-auth-token:7 (2.91.1) 2026-01-30T01:26:14.796Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      427 |     };
      428 |
    > 429 |     const supabase = createClient(
          |                                  ^
      430 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      431 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      432 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.createRoomType (services/accommodationService.ts:429:34)
      at Object.createRoomType (services/accommodationService.test.ts:355:49)

    console.warn
      GoTrueClient@sb-test-auth-token:8 (2.91.1) 2026-01-30T01:26:14.799Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      598 | export async function listRoomTypes(accommodationId: string): Promise<Result<RoomType[]>> {
      599 |   try {
    > 600 |     const supabase = createClient(
          |                                  ^
      601 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      602 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      603 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.listRoomTypes (services/accommodationService.ts:600:34)
      at Object.listRoomTypes (services/accommodationService.test.ts:403:49)

    console.warn
      GoTrueClient@sb-test-auth-token:9 (2.91.1) 2026-01-30T01:26:14.805Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      598 | export async function listRoomTypes(accommodationId: string): Promise<Result<RoomType[]>> {
      599 |   try {
    > 600 |     const supabase = createClient(
          |                                  ^
      601 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      602 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      603 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.listRoomTypes (services/accommodationService.ts:600:34)
      at Object.listRoomTypes (services/accommodationService.test.ts:422:49)

    console.warn
      GoTrueClient@sb-test-auth-token:10 (2.91.1) 2026-01-30T01:26:14.819Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      688 |     };
      689 |
    > 690 |     const supabase = createClient(
          |                                  ^
      691 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      692 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      693 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.createRoomAssignment (services/accommodationService.ts:690:34)
      at Object.createRoomAssignment (services/accommodationService.test.ts:461:49)

    console.warn
      GoTrueClient@sb-test-auth-token:11 (2.91.1) 2026-01-30T01:26:14.824Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      688 |     };
      689 |
    > 690 |     const supabase = createClient(
          |                                  ^
      691 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      692 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      693 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.createRoomAssignment (services/accommodationService.ts:690:34)
      at Object.createRoomAssignment (services/accommodationService.test.ts:496:49)

    console.warn
      GoTrueClient@sb-test-auth-token:12 (2.91.1) 2026-01-30T01:26:14.828Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      688 |     };
      689 |
    > 690 |     const supabase = createClient(
          |                                  ^
      691 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      692 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      693 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.createRoomAssignment (services/accommodationService.ts:690:34)
      at Object.createRoomAssignment (services/accommodationService.test.ts:526:49)

    console.warn
      GoTrueClient@sb-test-auth-token:13 (2.91.1) 2026-01-30T01:26:14.840Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      865 | export async function listGuestRoomAssignments(guestId: string): Promise<Result<RoomAssignment[]>> {
      866 |   try {
    > 867 |     const supabase = createClient(
          |                                  ^
      868 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      869 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      870 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.listGuestRoomAssignments (services/accommodationService.ts:867:34)
      at Object.listGuestRoomAssignments (services/accommodationService.test.ts:557:49)

    console.warn
      GoTrueClient@sb-test-auth-token:14 (2.91.1) 2026-01-30T01:26:14.842Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      901 | export async function listRoomTypeAssignments(roomTypeId: string): Promise<Result<RoomAssignment[]>> {
      902 |   try {
    > 903 |     const supabase = createClient(
          |                                  ^
      904 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      905 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      906 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at Object.listRoomTypeAssignments (services/accommodationService.ts:903:34)
      at Object.listRoomTypeAssignments (services/accommodationService.test.ts:589:49)

    console.warn
      GoTrueClient@sb-test-auth-token:15 (2.91.1) 2026-01-30T01:26:14.846Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      463 | export async function getRoomType(id: string): Promise<Result<RoomType>> {
      464 |   try {
    > 465 |     const supabase = createClient(
          |                                  ^
      466 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      467 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      468 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at getRoomType (services/accommodationService.ts:465:34)
      at Object.getRoomType (services/accommodationService.ts:958:34)
      at Object.calculateRoomCost (services/accommodationService.test.ts:631:49)

    console.warn
      GoTrueClient@sb-test-auth-token:16 (2.91.1) 2026-01-30T01:26:14.852Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      463 | export async function getRoomType(id: string): Promise<Result<RoomType>> {
      464 |   try {
    > 465 |     const supabase = createClient(
          |                                  ^
      466 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      467 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      468 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at getRoomType (services/accommodationService.ts:465:34)
      at Object.getRoomType (services/accommodationService.ts:958:34)
      at Object.calculateRoomCost (services/accommodationService.test.ts:664:49)

    console.warn
      GoTrueClient@sb-test-auth-token:17 (2.91.1) 2026-01-30T01:26:14.859Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      463 | export async function getRoomType(id: string): Promise<Result<RoomType>> {
      464 |   try {
    > 465 |     const supabase = createClient(
          |                                  ^
      466 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      467 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      468 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at getRoomType (services/accommodationService.ts:465:34)
      at Object.getRoomType (services/accommodationService.ts:958:34)
      at Object.calculateRoomCost (services/accommodationService.test.ts:686:49)

  ● accommodationService › createAccommodation › should return success with accommodation data when valid input provided

    expect(received).toBe(expected) // Object.is equality

    Expected: "accommodation-1"
    Received: undefined

      106 |       expect(result.success).toBe(true);
      107 |       if (result.success) {
    > 108 |         expect(result.data.id).toBe('accommodation-1');
          |                                ^
      109 |         expect(result.data.name).toBe('Costa Rica Beach Resort');
      110 |         expect(result.data.locationId).toBe(validData.locationId);
      111 |       }

      at Object.toBe (services/accommodationService.test.ts:108:32)

  ● accommodationService › createAccommodation › should return DATABASE_ERROR when insert fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      143 |       const result = await accommodationService.createAccommodation(validData);
      144 |
    > 145 |       expect(result.success).toBe(false);
          |                              ^
      146 |       if (!result.success) {
      147 |         expect(result.error.code).toBe('DATABASE_ERROR');
      148 |       }

      at Object.toBe (services/accommodationService.test.ts:145:30)

  ● accommodationService › createAccommodation › should sanitize input to prevent XSS attacks

    expect(received).not.toContain(expected) // indexOf

    Matcher error: received value must not be null nor undefined

    Received has value: undefined

      177 |       expect(result.success).toBe(true);
      178 |       if (result.success) {
    > 179 |         expect(result.data.name).not.toContain('<script>');
          |                                      ^
      180 |         expect(result.data.description).not.toContain('<img');
      181 |         expect(result.data.address).not.toContain('<script>');
      182 |       }

      at Object.toContain (services/accommodationService.test.ts:179:38)

  ● accommodationService › getAccommodation › should return accommodation when valid ID provided

    expect(received).toBe(expected) // Object.is equality

    Expected: "123e4567-e89b-12d3-a456-426614174000"
    Received: undefined

      208 |       expect(result.success).toBe(true);
      209 |       if (result.success) {
    > 210 |         expect(result.data.id).toBe(validId);
          |                                ^
      211 |         expect(result.data.name).toBe('Costa Rica Beach Resort');
      212 |       }
      213 |     });

      at Object.toBe (services/accommodationService.test.ts:210:32)

  ● accommodationService › getAccommodation › should return NOT_FOUND when accommodation does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      224 |       const result = await accommodationService.getAccommodation(validId);
      225 |
    > 226 |       expect(result.success).toBe(false);
          |                              ^
      227 |       if (!result.success) {
      228 |         expect(result.error.code).toBe('NOT_FOUND');
      229 |       }

      at Object.toBe (services/accommodationService.test.ts:226:30)

  ● accommodationService › getAccommodation › should return DATABASE_ERROR when database query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      241 |       const result = await accommodationService.getAccommodation(validId);
      242 |
    > 243 |       expect(result.success).toBe(false);
          |                              ^
      244 |       if (!result.success) {
      245 |         expect(result.error.code).toBe('DATABASE_ERROR');
      246 |       }

      at Object.toBe (services/accommodationService.test.ts:243:30)

  ● accommodationService › createRoomType › should return success with room type data when valid input provided

    expect(received).toBe(expected) // Object.is equality

    Expected: "room-type-1"
    Received: undefined

      288 |       expect(result.success).toBe(true);
      289 |       if (result.success) {
    > 290 |         expect(result.data.id).toBe('room-type-1');
          |                                ^
      291 |         expect(result.data.name).toBe('Deluxe Ocean View');
      292 |         expect(result.data.capacity).toBe(2);
      293 |         expect(result.data.totalRooms).toBe(10);

      at Object.toBe (services/accommodationService.test.ts:290:32)

  ● accommodationService › createRoomType › should sanitize input to prevent XSS attacks

    expect(received).not.toContain(expected) // indexOf

    Matcher error: received value must not be null nor undefined

    Received has value: undefined

      357 |       expect(result.success).toBe(true);
      358 |       if (result.success) {
    > 359 |         expect(result.data.name).not.toContain('<script>');
          |                                      ^
      360 |         expect(result.data.description).not.toContain('<img');
      361 |       }
      362 |     });

      at Object.toContain (services/accommodationService.test.ts:359:38)

  ● accommodationService › listRoomTypes › should return room types for accommodation

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      403 |       const result = await accommodationService.listRoomTypes(accommodationId);
      404 |
    > 405 |       expect(result.success).toBe(true);
          |                              ^
      406 |       if (result.success) {
      407 |         expect(result.data).toHaveLength(2);
      408 |         expect(result.data[0].name).toBe('Standard Room');

      at Object.toBe (services/accommodationService.test.ts:405:30)

  ● accommodationService › listRoomTypes › should return DATABASE_ERROR when query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "UNKNOWN_ERROR"

      424 |       expect(result.success).toBe(false);
      425 |       if (!result.success) {
    > 426 |         expect(result.error.code).toBe('DATABASE_ERROR');
          |                                   ^
      427 |       }
      428 |     });
      429 |   });

      at Object.toBe (services/accommodationService.test.ts:426:35)

  ● accommodationService › createRoomAssignment › should return success with room assignment data when valid input provided

    expect(received).toBe(expected) // Object.is equality

    Expected: "assignment-1"
    Received: undefined

      463 |       expect(result.success).toBe(true);
      464 |       if (result.success) {
    > 465 |         expect(result.data.id).toBe('assignment-1');
          |                                ^
      466 |         expect(result.data.roomTypeId).toBe(validData.roomTypeId);
      467 |         expect(result.data.guestId).toBe(validData.guestId);
      468 |         expect(result.data.checkIn).toBe(validData.checkIn);

      at Object.toBe (services/accommodationService.test.ts:465:32)

  ● accommodationService › createRoomAssignment › should return CONFLICT when guest already has assignment for dates

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      496 |       const result = await accommodationService.createRoomAssignment(validData);
      497 |
    > 498 |       expect(result.success).toBe(false);
          |                              ^
      499 |       if (!result.success) {
      500 |         expect(result.error.code).toBe('CONFLICT');
      501 |       }

      at Object.toBe (services/accommodationService.test.ts:498:30)

  ● accommodationService › createRoomAssignment › should sanitize notes to prevent XSS attacks

    expect(received).not.toContain(expected) // indexOf

    Matcher error: received value must not be null nor undefined

    Received has value: undefined

      528 |       expect(result.success).toBe(true);
      529 |       if (result.success) {
    > 530 |         expect(result.data.notes).not.toContain('<script>');
          |                                       ^
      531 |       }
      532 |     });
      533 |   });

      at Object.toContain (services/accommodationService.test.ts:530:39)

  ● accommodationService › listGuestRoomAssignments › should return room assignments for guest

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      557 |       const result = await accommodationService.listGuestRoomAssignments(guestId);
      558 |
    > 559 |       expect(result.success).toBe(true);
          |                              ^
      560 |       if (result.success) {
      561 |         expect(result.data).toHaveLength(1);
      562 |         expect(result.data[0].guestId).toBe(guestId);

      at Object.toBe (services/accommodationService.test.ts:559:30)

  ● accommodationService › listRoomTypeAssignments › should return room assignments for room type

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      589 |       const result = await accommodationService.listRoomTypeAssignments(roomTypeId);
      590 |
    > 591 |       expect(result.success).toBe(true);
          |                              ^
      592 |       if (result.success) {
      593 |         expect(result.data).toHaveLength(1);
      594 |         expect(result.data[0].roomTypeId).toBe(roomTypeId);

      at Object.toBe (services/accommodationService.test.ts:591:30)

  ● accommodationService › calculateRoomCost › should calculate cost correctly with subsidy

    expect(received).toBe(expected) // Object.is equality

    Expected: 200
    Received: undefined

      634 |       if (result.success) {
      635 |         expect(result.data.numberOfNights).toBe(4); // June 1-5 = 4 nights
    > 636 |         expect(result.data.pricePerNight).toBe(200);
          |                                           ^
      637 |         expect(result.data.subsidyPerNight).toBe(50);
      638 |         expect(result.data.totalCost).toBe(800); // 200 * 4
      639 |         expect(result.data.totalSubsidy).toBe(200); // 50 * 4

      at Object.toBe (services/accommodationService.test.ts:636:43)

  ● accommodationService › calculateRoomCost › should calculate cost correctly without subsidy

    expect(received).toBe(expected) // Object.is equality

    Expected: 150
    Received: undefined

      667 |       if (result.success) {
      668 |         expect(result.data.numberOfNights).toBe(4);
    > 669 |         expect(result.data.pricePerNight).toBe(150);
          |                                           ^
      670 |         expect(result.data.subsidyPerNight).toBe(0);
      671 |         expect(result.data.totalCost).toBe(600); // 150 * 4
      672 |         expect(result.data.totalSubsidy).toBe(0);

      at Object.toBe (services/accommodationService.test.ts:669:43)

  ● accommodationService › calculateRoomCost › should return error when room type not found

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      686 |       const result = await accommodationService.calculateRoomCost(validParams);
      687 |
    > 688 |       expect(result.success).toBe(false);
          |                              ^
      689 |       if (!result.success) {
      690 |         expect(result.error.code).toBe('NOT_FOUND');
      691 |       }

      at Object.toBe (services/accommodationService.test.ts:688:30)

FAIL services/externalServiceGracefulDegradation.test.ts
  ● External Service Graceful Degradation › B2 Storage Failover to Supabase › should fallback to Supabase storage when B2 is unavailable

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      114 |
      115 |       // Upload should succeed using Supabase
    > 116 |       expect(uploadResult.success).toBe(true);
          |                                    ^
      117 |       if (uploadResult.success) {
      118 |         expect(uploadResult.data.storage_type).toBe('supabase');
      119 |         expect(mockSupabase.storage.from).toHaveBeenCalled();

      at Object.toBe (services/externalServiceGracefulDegradation.test.ts:116:36)

  ● External Service Graceful Degradation › B2 Storage Failover to Supabase › should use B2 when available and healthy

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      161 |
      162 |       // Upload should succeed using B2
    > 163 |       expect(uploadResult.success).toBe(true);
          |                                    ^
      164 |       if (uploadResult.success) {
      165 |         expect(uploadResult.data.storage_type).toBe('b2');
      166 |       }

      at Object.toBe (services/externalServiceGracefulDegradation.test.ts:163:36)

  ● External Service Graceful Degradation › Email to SMS Fallback › should fallback to SMS when email delivery fails

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      239 |
      240 |       // SMS should succeed
    > 241 |       expect(smsResult.success).toBe(true);
          |                                 ^
      242 |       expect(global.fetch).toHaveBeenCalledTimes(2);
      243 |     });
      244 |

      at Object.toBe (services/externalServiceGracefulDegradation.test.ts:241:33)

  ● External Service Graceful Degradation › Email to SMS Fallback › should use email when available

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      268 |
      269 |       // Email should succeed
    > 270 |       expect(emailResult.success).toBe(true);
          |                                   ^
      271 |       expect(global.fetch).toHaveBeenCalledTimes(1);
      272 |     });
      273 |

      at Object.toBe (services/externalServiceGracefulDegradation.test.ts:270:35)

  ● External Service Graceful Degradation › Email to SMS Fallback › should handle both email and SMS failures gracefully

    expect(jest.fn()).toHaveBeenCalledTimes(expected)

    Expected number of calls: 2
    Received number of calls: 1

      313 |
      314 |       // Both services attempted
    > 315 |       expect(global.fetch).toHaveBeenCalledTimes(2);
          |                            ^
      316 |     });
      317 |   });
      318 |

      at Object.toHaveBeenCalledTimes (services/externalServiceGracefulDegradation.test.ts:315:28)

  ● External Service Graceful Degradation › Graceful Degradation Patterns › should continue operation when non-critical services fail

    TypeError: Cannot read properties of undefined (reading 'value')

      321 |       // Mock B2 to fail
      322 |       const { S3Client } = require('@aws-sdk/client-s3');
    > 323 |       const mockSend = S3Client.mock.results[0].value.send;
          |                                                 ^
      324 |       mockSend.mockRejectedValue(new Error('B2 unavailable'));
      325 |
      326 |       // Mock Supabase storage to succeed

      at Object.value (services/externalServiceGracefulDegradation.test.ts:323:49)

  ● External Service Graceful Degradation › Graceful Degradation Patterns › should provide meaningful error messages when all fallbacks fail

    TypeError: Cannot read properties of undefined (reading 'value')

      352 |       // Mock both B2 and Supabase to fail
      353 |       const { S3Client } = require('@aws-sdk/client-s3');
    > 354 |       const mockSend = S3Client.mock.results[0].value.send;
          |                                                 ^
      355 |       mockSend.mockRejectedValue(new Error('B2 unavailable'));
      356 |
      357 |       const { createClient } = require('@supabase/supabase-js');

      at Object.value (services/externalServiceGracefulDegradation.test.ts:354:49)

FAIL services/photoService.test.ts
  ● Console

    console.warn
      GoTrueClient@sb-localhost-auth-token:1 (2.91.1) 2026-01-30T01:26:14.940Z Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.

      46 | function getSupabase() {
      47 |   if (!_supabase) {
    > 48 |     _supabase = createClient(
         |                             ^
      49 |       process.env.NEXT_PUBLIC_SUPABASE_URL!,
      50 |       process.env.SUPABASE_SERVICE_ROLE_KEY!
      51 |     );

      at new GoTrueClient (node_modules/@supabase/auth-js/src/GoTrueClient.ts:312:15)
      at new SupabaseAuthClient (node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts:6:5)
      at SupabaseClient._initSupabaseAuthClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:367:12)
      at new SupabaseClient (node_modules/@supabase/supabase-js/src/SupabaseClient.ts:141:24)
      at createClient (node_modules/@supabase/supabase-js/src/index.ts:60:10)
      at getSupabase (services/photoService.ts:48:29)
      at getSupabase (services/photoService.ts:196:35)
      at uploadToSupabaseStorage (services/photoService.ts:131:36)
      at Object.<anonymous> (services/photoService.test.ts:97:22)

  ● photoService › uploadPhoto - Upload Operations › should return success with photo data when B2 upload succeeds

    TypeError: Cannot read properties of null (reading 'storage_type')

      100 |       expect(result.success).toBe(true);
      101 |       if (result.success) {
    > 102 |         expect(result.data.storage_type).toBe('b2');
          |                            ^
      103 |         expect(result.data.photo_url).toBe('https://cdn.example.com/photo.jpg');
      104 |       }
      105 |       expect(mockB2Service.uploadToB2).toHaveBeenCalledWith(mockFile, mockFileName, mockContentType);

      at Object.storage_type (services/photoService.test.ts:102:28)

  ● photoService › uploadPhoto - Upload Operations › should fallback to Supabase Storage when B2 upload fails

    TypeError: Cannot read properties of null (reading 'storage_type')

      145 |       expect(result.success).toBe(true);
      146 |       if (result.success) {
    > 147 |         expect(result.data.storage_type).toBe('supabase');
          |                            ^
      148 |         expect(result.data.photo_url).toBe('https://supabase.example.com/photo.jpg');
      149 |       }
      150 |     });

      at Object.storage_type (services/photoService.test.ts:147:28)

  ● photoService › uploadPhoto - Upload Operations › should return DATABASE_ERROR when database insert fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      191 |
      192 |       // Assert
    > 193 |       expect(result.success).toBe(false);
          |                              ^
      194 |       if (!result.success) {
      195 |         expect(result.error.code).toBe('DATABASE_ERROR');
      196 |         expect(result.error.message).toBe('Database connection failed');

      at Object.toBe (services/photoService.test.ts:193:30)

  ● photoService › uploadPhoto - Upload Operations › should sanitize malicious input in caption and alt_text

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "<script>alert(\"xss\")</script>Malicious caption"

    Number of calls: 0

      225 |       // Assert
      226 |       expect(result.success).toBe(true);
    > 227 |       expect(mockSanitization.sanitizeInput).toHaveBeenCalledWith('<script>alert("xss")</script>Malicious caption');
          |                                              ^
      228 |       expect(mockSanitization.sanitizeInput).toHaveBeenCalledWith('<img src=x onerror=alert(1)>Malicious alt text');
      229 |     });
      230 |   });

      at Object.toHaveBeenCalledWith (services/photoService.test.ts:227:46)

  ● photoService › moderatePhoto - Moderation Workflow › should return success with updated photo when approving photo

    TypeError: Cannot read properties of null (reading 'moderation_status')

      262 |       expect(result.success).toBe(true);
      263 |       if (result.success) {
    > 264 |         expect(result.data.moderation_status).toBe('approved');
          |                            ^
      265 |         expect(result.data.moderation_reason).toBe('Photo meets guidelines');
      266 |         expect(result.data.moderated_at).toBeDefined();
      267 |       }

      at Object.moderation_status (services/photoService.test.ts:264:28)

  ● photoService › moderatePhoto - Moderation Workflow › should return success when rejecting photo with reason

    TypeError: Cannot read properties of null (reading 'moderation_status')

      298 |       expect(result.success).toBe(true);
      299 |       if (result.success) {
    > 300 |         expect(result.data.moderation_status).toBe('rejected');
          |                            ^
      301 |         expect(result.data.moderation_reason).toBe('Inappropriate content');
      302 |       }
      303 |     });

      at Object.moderation_status (services/photoService.test.ts:300:28)

  ● photoService › moderatePhoto - Moderation Workflow › should return NOT_FOUND when photo does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      342 |
      343 |       // Assert
    > 344 |       expect(result.success).toBe(false);
          |                              ^
      345 |       if (!result.success) {
      346 |         expect(result.error.code).toBe('NOT_FOUND');
      347 |       }

      at Object.toBe (services/photoService.test.ts:344:30)

  ● photoService › moderatePhoto - Moderation Workflow › should sanitize malicious input in moderation reason

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "<script>alert(\"xss\")</script>Inappropriate content"

    Number of calls: 0

      375 |       // Assert
      376 |       expect(result.success).toBe(true);
    > 377 |       expect(mockSanitization.sanitizeInput).toHaveBeenCalledWith('<script>alert("xss")</script>Inappropriate content');
          |                                              ^
      378 |     });
      379 |   });
      380 |

      at Object.toHaveBeenCalledWith (services/photoService.test.ts:377:46)

  ● photoService › getPhoto › should return success with photo data when photo exists

    TypeError: Cannot read properties of null (reading 'id')

      409 |       expect(result.success).toBe(true);
      410 |       if (result.success) {
    > 411 |         expect(result.data.id).toBe(mockPhotoId);
          |                            ^
      412 |         expect(result.data.moderation_status).toBe('approved');
      413 |       }
      414 |     });

      at Object.id (services/photoService.test.ts:411:28)

  ● photoService › getPhoto › should return NOT_FOUND when photo does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      430 |
      431 |       // Assert
    > 432 |       expect(result.success).toBe(false);
          |                              ^
      433 |       if (!result.success) {
      434 |         expect(result.error.code).toBe('NOT_FOUND');
      435 |       }

      at Object.toBe (services/photoService.test.ts:432:30)

  ● photoService › updatePhoto › should return success with updated photo when update succeeds

    TypeError: Cannot read properties of null (reading 'caption')

      470 |       expect(result.success).toBe(true);
      471 |       if (result.success) {
    > 472 |         expect(result.data.caption).toBe('Updated caption');
          |                            ^
      473 |         expect(result.data.alt_text).toBe('Updated alt text');
      474 |         expect(result.data.display_order).toBe(5);
      475 |       }

      at Object.caption (services/photoService.test.ts:472:28)

  ● photoService › deletePhoto › should return DATABASE_ERROR when database delete fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      532 |
      533 |       // Assert
    > 534 |       expect(result.success).toBe(false);
          |                              ^
      535 |       if (!result.success) {
      536 |         expect(result.error.code).toBe('DATABASE_ERROR');
      537 |         expect(result.error.message).toBe('Database connection failed');

      at Object.toBe (services/photoService.test.ts:534:30)

PASS services/transportationService.test.ts
PASS services/cleanupService.test.ts
  ● Console

    console.error
      Failed to clean up audit logs: {
        code: 'DATABASE_ERROR',
        message: 'Failed to delete old audit logs',
        details: { message: 'Database error', code: 'CONNECTION_ERROR' }
      }

      337 |     } else {
      338 |       totalFailed++;
    > 339 |       console.error('Failed to clean up audit logs:', auditLogsResult.error);
          |               ^
      340 |     }
      341 |
      342 |     // Clean up old cron logs (30 days)

      at error (services/cleanupService.ts:339:15)
      at services/cleanupService.test.ts:15:22
      at Object.<anonymous> (services/cleanupService.test.ts:372:22)

    console.error
      Failed to clean up cron logs: {
        code: 'DATABASE_ERROR',
        message: 'Failed to delete old cron job logs',
        details: { message: 'Database error', code: 'CONNECTION_ERROR' }
      }

      347 |     } else {
      348 |       totalFailed++;
    > 349 |       console.error('Failed to clean up cron logs:', cronLogsResult.error);
          |               ^
      350 |     }
      351 |
      352 |     // Clean up old email logs (180 days)

      at error (services/cleanupService.ts:349:15)
      at services/cleanupService.test.ts:15:22
      at Object.<anonymous> (services/cleanupService.test.ts:372:22)

    console.error
      Failed to clean up email logs: {
        code: 'DATABASE_ERROR',
        message: 'Failed to delete old email logs',
        details: { message: 'Database error', code: 'CONNECTION_ERROR' }
      }

      357 |     } else {
      358 |       totalFailed++;
    > 359 |       console.error('Failed to clean up email logs:', emailLogsResult.error);
          |               ^
      360 |     }
      361 |
      362 |     // Clean up old webhook logs (30 days)

      at error (services/cleanupService.ts:359:15)
      at services/cleanupService.test.ts:15:22
      at Object.<anonymous> (services/cleanupService.test.ts:372:22)

    console.error
      Failed to clean up webhook logs: {
        code: 'DATABASE_ERROR',
        message: 'Failed to delete old webhook logs',
        details: { message: 'Database error', code: 'CONNECTION_ERROR' }
      }

      367 |     } else {
      368 |       totalFailed++;
    > 369 |       console.error('Failed to clean up webhook logs:', webhookLogsResult.error);
          |               ^
      370 |     }
      371 |
      372 |     return {

      at error (services/cleanupService.ts:369:15)
      at services/cleanupService.test.ts:15:22
      at Object.<anonymous> (services/cleanupService.test.ts:372:22)

FAIL services/smsService.test.ts
  ● smsService › sendSMS › should return EXTERNAL_SERVICE_ERROR when Twilio not configured

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      102 |       const result = await sendSMS('+15551234567', 'Test message');
      103 |
    > 104 |       expect(result.success).toBe(false);
          |                              ^
      105 |       if (!result.success) {
      106 |         expect(result.error.code).toBe('EXTERNAL_SERVICE_ERROR');
      107 |         expect(result.error.message).toBe('SMS service not configured');

      at Object.toBe (services/smsService.test.ts:104:30)

  ● smsService › sendSMS › should return EXTERNAL_SERVICE_ERROR when credentials are test values

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      115 |       const result = await sendSMS('+15551234567', 'Test message');
      116 |
    > 117 |       expect(result.success).toBe(false);
          |                              ^
      118 |       if (!result.success) {
      119 |         expect(result.error.code).toBe('EXTERNAL_SERVICE_ERROR');
      120 |         expect(result.error.message).toBe('SMS service not configured');

      at Object.toBe (services/smsService.test.ts:117:30)

  ● smsService › sendSMS › should truncate message when longer than 160 characters

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: {"body": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...", "from": "+15551234567", "to": "+15551234567"}

    Number of calls: 0

      154 |
      155 |       expect(result.success).toBe(true);
    > 156 |       expect(mockTwilio.messages.create).toHaveBeenCalledWith({
          |                                          ^
      157 |         body: expectedMessage,
      158 |         from: '+15551234567',
      159 |         to: '+15551234567',

      at Object.toHaveBeenCalledWith (services/smsService.test.ts:156:42)

  ● smsService › sendSMS › should return EXTERNAL_SERVICE_ERROR when Twilio API fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      166 |       const result = await sendSMS('+15551234567', 'Test message');
      167 |
    > 168 |       expect(result.success).toBe(false);
          |                              ^
      169 |       if (!result.success) {
      170 |         expect(result.error.code).toBe('EXTERNAL_SERVICE_ERROR');
      171 |       }

      at Object.toBe (services/smsService.test.ts:168:30)

  ● smsService › sendSMS › should log successful SMS to database

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "sms_logs"

    Number of calls: 0

      180 |       await sendSMS('+15551234567', 'Test message');
      181 |
    > 182 |       expect(mockSupabaseFrom).toHaveBeenCalledWith('sms_logs');
          |                                ^
      183 |     });
      184 |
      185 |     it('should log failed SMS to database', async () => {

      at Object.toHaveBeenCalledWith (services/smsService.test.ts:182:32)

  ● smsService › sendSMS › should log failed SMS to database

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "sms_logs"

    Number of calls: 0

      188 |       await sendSMS('+15551234567', 'Test message');
      189 |
    > 190 |       expect(mockSupabaseFrom).toHaveBeenCalledWith('sms_logs');
          |                                ^
      191 |     });
      192 |   });
      193 |

      at Object.toHaveBeenCalledWith (services/smsService.test.ts:190:32)

  ● smsService › sendSMSFallback › should return success when SMS fallback sent successfully

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: {"body": "[RSVP Reminder] Please confirm your attendance", "from": "+15551234567", "to": "+15551234567"}

    Number of calls: 0

      205 |
      206 |       expect(result.success).toBe(true);
    > 207 |       expect(mockTwilio.messages.create).toHaveBeenCalledWith({
          |                                          ^
      208 |         body: '[RSVP Reminder] Please confirm your attendance',
      209 |         from: '+15551234567',
      210 |         to: '+15551234567',

      at Object.toHaveBeenCalledWith (services/smsService.test.ts:207:42)

  ● smsService › sendSMSFallback › should return UNKNOWN_ERROR when unexpected error occurs

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      222 |       );
      223 |
    > 224 |       expect(result.success).toBe(false);
          |                              ^
      225 |       if (!result.success) {
      226 |         expect(result.error.code).toBe('EXTERNAL_SERVICE_ERROR'); // sendSMS returns EXTERNAL_SERVICE_ERROR, not UNKNOWN_ERROR
      227 |       }

      at Object.toBe (services/smsService.test.ts:224:30)

  ● smsService › updateSMSDeliveryStatus › should return success when delivery status updated to delivered

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: {"delivered_at": Any<String>, "delivery_status": "delivered"}

    Number of calls: 0

      238 |
      239 |       expect(result.success).toBe(true);
    > 240 |       expect(mockUpdate).toHaveBeenCalledWith({
          |                          ^
      241 |         delivery_status: 'delivered',
      242 |         delivered_at: expect.any(String),
      243 |       });

      at Object.toHaveBeenCalledWith (services/smsService.test.ts:240:26)

  ● smsService › updateSMSDeliveryStatus › should return success when delivery status updated to failed with error message

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: {"delivery_status": "failed", "error_message": "Network error"}

    Number of calls: 0

      252 |
      253 |       expect(result.success).toBe(true);
    > 254 |       expect(mockUpdate).toHaveBeenCalledWith({
          |                          ^
      255 |         delivery_status: 'failed',
      256 |         error_message: 'Network error',
      257 |       });

      at Object.toHaveBeenCalledWith (services/smsService.test.ts:254:26)

  ● smsService › updateSMSDeliveryStatus › should return DATABASE_ERROR when update fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      265 |       const result = await updateSMSDeliveryStatus('sms-123', 'delivered');
      266 |
    > 267 |       expect(result.success).toBe(false);
          |                              ^
      268 |       if (!result.success) {
      269 |         expect(result.error.code).toBe('DATABASE_ERROR');
      270 |       }

      at Object.toBe (services/smsService.test.ts:267:30)

  ● smsService › updateSMSDeliveryStatus › should return UNKNOWN_ERROR when unexpected error occurs

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      278 |       const result = await updateSMSDeliveryStatus('sms-123', 'delivered');
      279 |
    > 280 |       expect(result.success).toBe(false);
          |                              ^
      281 |       if (!result.success) {
      282 |         expect(result.error.code).toBe('UNKNOWN_ERROR');
      283 |       }

      at Object.toBe (services/smsService.test.ts:280:30)

  ● smsService › getSMSAnalytics › should return success with SMS analytics when logs exist

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      301 |       const result = await getSMSAnalytics();
      302 |
    > 303 |       expect(result.success).toBe(true);
          |                              ^
      304 |       if (result.success) {
      305 |         expect(result.data.total).toBe(3);
      306 |         expect(result.data.delivered).toBe(1);

      at Object.toBe (services/smsService.test.ts:303:30)

  ● smsService › getSMSAnalytics › should return success with zero analytics when no logs exist

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      318 |       const result = await getSMSAnalytics();
      319 |
    > 320 |       expect(result.success).toBe(true);
          |                              ^
      321 |       if (result.success) {
      322 |         expect(result.data.total).toBe(0);
      323 |       }

      at Object.toBe (services/smsService.test.ts:320:30)

  ● smsService › getSMSAnalytics › should return DATABASE_ERROR when query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "UNKNOWN_ERROR"

      335 |       expect(result.success).toBe(false);
      336 |       if (!result.success) {
    > 337 |         expect(result.error.code).toBe('DATABASE_ERROR');
          |                                   ^
      338 |       }
      339 |     });
      340 |

      at Object.toBe (services/smsService.test.ts:337:35)

  ● smsService › getSMSLogs › should return success with SMS logs when no filters provided

    expect(received).toHaveLength(expected)

    Expected length: 2
    Received length: 0
    Received array:  []

      383 |       expect(result.success).toBe(true);
      384 |       if (result.success) {
    > 385 |         expect(result.data).toHaveLength(2);
          |                             ^
      386 |       }
      387 |     });
      388 |

      at Object.toHaveLength (services/smsService.test.ts:385:29)

  ● smsService › getSMSLogs › should return success with filtered logs when filters provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      412 |       });
      413 |
    > 414 |       expect(result.success).toBe(true);
          |                              ^
      415 |       if (result.success) {
      416 |         expect(result.data).toHaveLength(1);
      417 |       }

      at Object.toBe (services/smsService.test.ts:414:30)

  ● smsService › getSMSLogs › should return DATABASE_ERROR when query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      444 |       const result = await getSMSLogs();
      445 |
    > 446 |       expect(result.success).toBe(false);
          |                              ^
      447 |       if (!result.success) {
      448 |         expect(result.error.code).toBe('DATABASE_ERROR');
      449 |       }

      at Object.toBe (services/smsService.test.ts:446:30)

  ● smsService › getSMSLogs › should return UNKNOWN_ERROR when unexpected error occurs

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      457 |       const result = await getSMSLogs();
      458 |
    > 459 |       expect(result.success).toBe(false);
          |                              ^
      460 |       if (!result.success) {
      461 |         expect(result.error.code).toBe('UNKNOWN_ERROR');
      462 |       }

      at Object.toBe (services/smsService.test.ts:459:30)

PASS services/emailSMSFallback.test.ts
FAIL services/budgetService.test.ts
  ● budgetService › calculateTotal - validation logic › should accept valid vendor categories

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "category", ["photography", "flowers"]

    Number of calls: 0

      54 |
      55 |       // Should pass validation and attempt database query
    > 56 |       expect(mockIn).toHaveBeenCalledWith('category', ['photography', 'flowers']);
         |                      ^
      57 |     });
      58 |
      59 |     it('should use default options when none provided', async () => {

      at Object.toHaveBeenCalledWith (services/budgetService.test.ts:56:22)

  ● budgetService › calculateTotal - validation logic › should use default options when none provided

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "vendors"

    Number of calls: 0

      68 |
      69 |       // Should call vendor query since includeVendors defaults to true
    > 70 |       expect(mockSupabase.from).toHaveBeenCalledWith('vendors');
         |                                 ^
      71 |     });
      72 |   });
      73 |

      at Object.toHaveBeenCalledWith (services/budgetService.test.ts:70:33)

  ● budgetService › getPaymentStatusReport - vendor categorization logic › should correctly calculate payment totals for different vendor statuses

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      114 |       const result = await budgetService.getPaymentStatusReport();
      115 |
    > 116 |       expect(result.success).toBe(true);
          |                              ^
      117 |       if (result.success) {
      118 |         // Verify vendor categorization
      119 |         expect(result.data.unpaidVendors).toHaveLength(1);

      at Object.toBe (services/budgetService.test.ts:116:30)

  ● budgetService › getPaymentStatusReport - vendor categorization logic › should handle empty vendor list

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      147 |       const result = await budgetService.getPaymentStatusReport();
      148 |
    > 149 |       expect(result.success).toBe(true);
          |                              ^
      150 |       if (result.success) {
      151 |         expect(result.data.unpaidVendors).toHaveLength(0);
      152 |         expect(result.data.partiallyPaidVendors).toHaveLength(0);

      at Object.toBe (services/budgetService.test.ts:149:30)

  ● budgetService › trackSubsidies - subsidy calculation logic › should handle empty activity list

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      170 |       const result = await budgetService.trackSubsidies();
      171 |
    > 172 |       expect(result.success).toBe(true);
          |                              ^
      173 |       if (result.success) {
      174 |         expect(result.data.activitySubsidies).toHaveLength(0);
      175 |         expect(result.data.totalActivitySubsidies).toBe(0);

      at Object.toBe (services/budgetService.test.ts:172:30)

  ● budgetService › trackSubsidies - subsidy calculation logic › should query activities with subsidies only

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "activities"

    Number of calls: 0

      190 |
      191 |       // Verify it queries for activities with non-null host_subsidy
    > 192 |       expect(mockSupabase.from).toHaveBeenCalledWith('activities');
          |                                 ^
      193 |       expect(mockNot).toHaveBeenCalledWith('host_subsidy', 'is', null);
      194 |     });
      195 |   });

      at Object.toHaveBeenCalledWith (services/budgetService.test.ts:192:33)

  ● budgetService › generateReport - comprehensive report structure › should return complete budget breakdown structure

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      209 |       const result = await budgetService.generateReport();
      210 |
    > 211 |       expect(result.success).toBe(true);
          |                              ^
      212 |       if (result.success) {
      213 |         // Verify structure
      214 |         expect(result.data).toHaveProperty('vendors');

      at Object.toBe (services/budgetService.test.ts:211:30)

  ● budgetService › error handling › should return DATABASE_ERROR when query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "UNKNOWN_ERROR"

      251 |       expect(result.success).toBe(false);
      252 |       if (!result.success) {
    > 253 |         expect(result.error.code).toBe('DATABASE_ERROR');
          |                                   ^
      254 |         expect(result.error.message).toBe('Connection failed');
      255 |       }
      256 |     });

      at Object.toBe (services/budgetService.test.ts:253:35)

  ● budgetService › error handling › should return UNKNOWN_ERROR when unexpected error occurs

    expect(received).toBe(expected) // Object.is equality

    Expected: "Unexpected error"
    Received: "Cannot read properties of null (reading 'forEach')"

      267 |       if (!result.success) {
      268 |         expect(result.error.code).toBe('UNKNOWN_ERROR');
    > 269 |         expect(result.error.message).toBe('Unexpected error');
          |                                      ^
      270 |       }
      271 |     });
      272 |

      at Object.toBe (services/budgetService.test.ts:269:38)

  ● budgetService › error handling › should handle non-Error exceptions gracefully

    expect(received).toBe(expected) // Object.is equality

    Expected: "Unknown error occurred"
    Received: "Cannot read properties of null (reading 'forEach')"

      282 |       if (!result.success) {
      283 |         expect(result.error.code).toBe('UNKNOWN_ERROR');
    > 284 |         expect(result.error.message).toBe('Unknown error occurred');
          |                                      ^
      285 |       }
      286 |     });
      287 |   });

      at Object.toBe (services/budgetService.test.ts:284:38)

PASS services/webhookService.test.ts
PASS services/accessControlService.test.ts
PASS services/sectionsService.test.ts
PASS services/rsvpReminderService.test.ts
PASS services/cronService.test.ts
PASS services/csvImportExport.test.ts
PASS services/aiContentService.test.ts
PASS services/guestEngagementService.test.ts
PASS services/activityService.test.ts
PASS services/csvIntegration.test.ts
PASS services/contentPagesService.test.ts
PASS services/vendorBookingService.test.ts
PASS services/settingsService.test.ts
PASS services/guestService.test.ts
PASS services/test-mock.test.ts
  ● Console

    console.log
      Result: {
        "success": true,
        "data": []
      }

      at Object.log (services/test-mock.test.ts:45:13)

PASS services/photoStorageFailover.test.ts
PASS services/b2Service.test.ts
PASS services/gallerySettingsService.test.ts
PASS services/authService.test.ts
PASS services/sectionsService.versionHistory.test.ts
PASS services/auditLogService.test.ts
PASS services/capacityReportService.test.ts
PASS services/itineraryService.test.ts
PASS services/rsvpAnalyticsService.test.ts
PASS services/vendorService.test.ts
PASS services/emailQueueService.test.ts
  ● Console

    console.error
      Failed to send scheduled email email-1: { message: 'Email service error' }

      89 |
      90 |             failed++;
    > 91 |             console.error(
         |                     ^
      92 |               `Failed to send scheduled email ${scheduledEmail.id}:`,
      93 |               emailResult.error
      94 |             );

      at error (services/emailQueueService.ts:91:21)
      at services/emailQueueService.test.ts:10:22
      at Object.<anonymous> (services/emailQueueService.test.ts:221:22)

    console.error
      Error processing scheduled email email-1: Error: Unexpected error
          at Object.<anonymous> (/Users/jaron/Desktop/wedding-platform-v2/services/emailQueueService.test.ts:272:39)
          at Promise.then.completed (/Users/jaron/Desktop/wedding-platform-v2/node_modules/jest-circus/build/utils.js:298:28)
          at new Promise (<anonymous>)
          at callAsyncCircusFn (/Users/jaron/Desktop/wedding-platform-v2/node_modules/jest-circus/build/utils.js:231:10)
          at _callCircusTest (/Users/jaron/Desktop/wedding-platform-v2/node_modules/jest-circus/build/run.js:316:40)
          at processTicksAndRejections (node:internal/process/task_queues:95:5)
          at _runTest (/Users/jaron/Desktop/wedding-platform-v2/node_modules/jest-circus/build/run.js:252:3)
          at _runTestsForDescribeBlock (/Users/jaron/Desktop/wedding-platform-v2/node_modules/jest-circus/build/run.js:126:9)
          at _runTestsForDescribeBlock (/Users/jaron/Desktop/wedding-platform-v2/node_modules/jest-circus/build/run.js:121:9)
          at _runTestsForDescribeBlock (/Users/jaron/Desktop/wedding-platform-v2/node_modules/jest-circus/build/run.js:121:9)
          at run (/Users/jaron/Desktop/wedding-platform-v2/node_modules/jest-circus/build/run.js:71:3)
          at runAndTransformResultsToJestFormat (/Users/jaron/Desktop/wedding-platform-v2/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:122:21)
          at jestAdapter (/Users/jaron/Desktop/wedding-platform-v2/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:79:19)
          at runTestInternal (/Users/jaron/Desktop/wedding-platform-v2/node_modules/jest-runner/build/runTest.js:367:16)
          at runTest (/Users/jaron/Desktop/wedding-platform-v2/node_modules/jest-runner/build/runTest.js:444:34)
          at Object.worker (/Users/jaron/Desktop/wedding-platform-v2/node_modules/jest-runner/build/testWorker.js:106:12)

      105 |
      106 |           failed++;
    > 107 |           console.error(`Error processing scheduled email ${scheduledEmail.id}:`, error);
          |                   ^
      108 |         }
      109 |       }
      110 |

      at error (services/emailQueueService.ts:107:19)
      at services/emailQueueService.test.ts:10:22
      at Object.<anonymous> (services/emailQueueService.test.ts:274:22)


Summary of all failing tests
FAIL services/locationService.test.ts
  ● locationService › create › should return success with location data when valid input provided

    expect(received).toBe(expected) // Object.is equality

    Expected: "location-1"
    Received: undefined

      77 |       expect(result.success).toBe(true);
      78 |       if (result.success) {
    > 79 |         expect(result.data.id).toBe('location-1');
         |                                ^
      80 |         expect(result.data.name).toBe('Tamarindo Beach');
      81 |         expect(result.data.parentLocationId).toBe(validData.parentLocationId);
      82 |       }

      at Object.toBe (services/locationService.test.ts:79:32)

  ● locationService › create › should return INVALID_PARENT when parent location does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      112 |       const result = await locationService.create(validData);
      113 |
    > 114 |       expect(result.success).toBe(false);
          |                              ^
      115 |       if (!result.success) {
      116 |         expect(result.error.code).toBe('INVALID_PARENT');
      117 |       }

      at Object.toBe (services/locationService.test.ts:114:30)

  ● locationService › create › should return DATABASE_ERROR when insert fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      133 |       const result = await locationService.create(validData);
      134 |
    > 135 |       expect(result.success).toBe(false);
          |                              ^
      136 |       if (!result.success) {
      137 |         expect(result.error.code).toBe('DATABASE_ERROR');
      138 |       }

      at Object.toBe (services/locationService.test.ts:135:30)

  ● locationService › create › should sanitize input to prevent XSS attacks

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "<script>alert(\"xss\")</script>Tamarindo"

    Number of calls: 0

      169 |       // Verify sanitization was called
      170 |       const { sanitizeInput, sanitizeRichText } = require('../utils/sanitization');
    > 171 |       expect(sanitizeInput).toHaveBeenCalledWith(maliciousData.name);
          |                             ^
      172 |       expect(sanitizeInput).toHaveBeenCalledWith(maliciousData.address);
      173 |       expect(sanitizeRichText).toHaveBeenCalledWith(maliciousData.description);
      174 |     });

      at Object.toHaveBeenCalledWith (services/locationService.test.ts:171:29)

  ● locationService › get › should return success with location data when location exists

    expect(received).toBe(expected) // Object.is equality

    Expected: "location-1"
    Received: undefined

      196 |       expect(result.success).toBe(true);
      197 |       if (result.success) {
    > 198 |         expect(result.data.id).toBe('location-1');
          |                                ^
      199 |         expect(result.data.name).toBe('Tamarindo Beach');
      200 |       }
      201 |     });

      at Object.toBe (services/locationService.test.ts:198:32)

  ● locationService › get › should return NOT_FOUND when location does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      209 |       const result = await locationService.get('nonexistent-id');
      210 |
    > 211 |       expect(result.success).toBe(false);
          |                              ^
      212 |       if (!result.success) {
      213 |         expect(result.error.code).toBe('NOT_FOUND');
      214 |       }

      at Object.toBe (services/locationService.test.ts:211:30)

  ● locationService › get › should return DATABASE_ERROR when database query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      223 |       const result = await locationService.get('location-1');
      224 |
    > 225 |       expect(result.success).toBe(false);
          |                              ^
      226 |       if (!result.success) {
      227 |         expect(result.error.code).toBe('DATABASE_ERROR');
      228 |       }

      at Object.toBe (services/locationService.test.ts:225:30)

  ● locationService › update › should return success with updated location data when valid input provided

    expect(received).toBe(expected) // Object.is equality

    Expected: "Updated Beach"
    Received: undefined

      256 |       expect(result.success).toBe(true);
      257 |       if (result.success) {
    > 258 |         expect(result.data.name).toBe('Updated Beach');
          |                                  ^
      259 |         expect(result.data.address).toBe('Updated Address');
      260 |       }
      261 |     });

      at Object.toBe (services/locationService.test.ts:258:34)

  ● locationService › update › should return CIRCULAR_REFERENCE when trying to set self as parent

    expect(received).toBe(expected) // Object.is equality

    Expected: "CIRCULAR_REFERENCE"
    Received: "VALIDATION_ERROR"

      267 |       expect(result.success).toBe(false);
      268 |       if (!result.success) {
    > 269 |         expect(result.error.code).toBe('CIRCULAR_REFERENCE');
          |                                   ^
      270 |       }
      271 |     });
      272 |

      at Object.toBe (services/locationService.test.ts:269:35)

  ● locationService › update › should return INVALID_PARENT when parent location does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: "INVALID_PARENT"
    Received: "VALIDATION_ERROR"

      284 |       expect(result.success).toBe(false);
      285 |       if (!result.success) {
    > 286 |         expect(result.error.code).toBe('INVALID_PARENT');
          |                                   ^
      287 |       }
      288 |     });
      289 |

      at Object.toBe (services/locationService.test.ts:286:35)

  ● locationService › update › should return NOT_FOUND when location to update does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      296 |       const result = await locationService.update('nonexistent-id', updateData);
      297 |
    > 298 |       expect(result.success).toBe(false);
          |                              ^
      299 |       if (!result.success) {
      300 |         expect(result.error.code).toBe('NOT_FOUND');
      301 |       }

      at Object.toBe (services/locationService.test.ts:298:30)

  ● locationService › deleteLocation › should return DATABASE_ERROR when delete fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      321 |       const result = await locationService.deleteLocation('location-1');
      322 |
    > 323 |       expect(result.success).toBe(false);
          |                              ^
      324 |       if (!result.success) {
      325 |         expect(result.error.code).toBe('DATABASE_ERROR');
      326 |       }

      at Object.toBe (services/locationService.test.ts:323:30)

  ● locationService › list › should return success with paginated locations when valid filters provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      360 |       const result = await locationService.list(filters);
      361 |
    > 362 |       expect(result.success).toBe(true);
          |                              ^
      363 |       if (result.success) {
      364 |         expect(result.data.locations).toHaveLength(2);
      365 |         expect(result.data.total).toBe(2);

      at Object.toBe (services/locationService.test.ts:362:30)

  ● locationService › list › should filter by parent location ID when provided

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "parent_location_id", "parent-1"

    Number of calls: 0

      384 |       const result = await locationService.list(filters);
      385 |
    > 386 |       expect(mockSupabase.eq).toHaveBeenCalledWith('parent_location_id', 'parent-1');
          |                               ^
      387 |       expect(result.success).toBe(true);
      388 |     });
      389 |

      at Object.toHaveBeenCalledWith (services/locationService.test.ts:386:31)

  ● locationService › list › should filter for root locations when parentLocationId is null

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "parent_location_id", null

    Number of calls: 0

      403 |       const result = await locationService.list(filters);
      404 |
    > 405 |       expect(mockSupabase.is).toHaveBeenCalledWith('parent_location_id', null);
          |                               ^
      406 |       expect(result.success).toBe(true);
      407 |     });
      408 |

      at Object.toHaveBeenCalledWith (services/locationService.test.ts:405:31)

  ● locationService › list › should return DATABASE_ERROR when query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "UNKNOWN_ERROR"

      417 |       expect(result.success).toBe(false);
      418 |       if (!result.success) {
    > 419 |         expect(result.error.code).toBe('DATABASE_ERROR');
          |                                   ^
      420 |       }
      421 |     });
      422 |   });

      at Object.toBe (services/locationService.test.ts:419:35)

  ● locationService › search › should return success with search results when valid query provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      450 |       const result = await locationService.search(searchParams);
      451 |
    > 452 |       expect(result.success).toBe(true);
          |                              ^
      453 |       if (result.success) {
      454 |         expect(result.data.locations).toHaveLength(1);
      455 |         expect(result.data.locations[0].name).toBe('Tamarindo Beach');

      at Object.toBe (services/locationService.test.ts:452:30)

  ● locationService › search › should sanitize search query to prevent injection attacks

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "<script>alert(\"xss\")</script>beach"

    Number of calls: 0

      474 |       // Verify sanitization was called
      475 |       const { sanitizeInput } = require('../utils/sanitization');
    > 476 |       expect(sanitizeInput).toHaveBeenCalledWith(maliciousSearch.query);
          |                             ^
      477 |       expect(result.success).toBe(true);
      478 |     });
      479 |

      at Object.toHaveBeenCalledWith (services/locationService.test.ts:476:29)

  ● locationService › getHierarchy › should return success with hierarchical location tree

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      528 |       const result = await locationService.getHierarchy();
      529 |
    > 530 |       expect(result.success).toBe(true);
          |                              ^
      531 |       if (result.success) {
      532 |         expect(result.data).toHaveLength(1); // One root location
      533 |         expect(result.data[0].name).toBe('Costa Rica');

      at Object.toBe (services/locationService.test.ts:530:30)

  ● locationService › getHierarchy › should return DATABASE_ERROR when query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "UNKNOWN_ERROR"

      549 |       expect(result.success).toBe(false);
      550 |       if (!result.success) {
    > 551 |         expect(result.error.code).toBe('DATABASE_ERROR');
          |                                   ^
      552 |       }
      553 |     });
      554 |   });

      at Object.toBe (services/locationService.test.ts:551:35)

  ● locationService › getWithChildren › should return success with location and its children

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      599 |       const result = await locationService.getWithChildren(parentId);
      600 |
    > 601 |       expect(result.success).toBe(true);
          |                              ^
      602 |       if (result.success) {
      603 |         expect(result.data.name).toBe('Costa Rica');
      604 |         expect(result.data.children).toHaveLength(1);

      at Object.toBe (services/locationService.test.ts:601:30)

  ● locationService › getWithChildren › should return NOT_FOUND when parent location does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: "NOT_FOUND"
    Received: "UNKNOWN_ERROR"

      617 |       expect(result.success).toBe(false);
      618 |       if (!result.success) {
    > 619 |         expect(result.error.code).toBe('NOT_FOUND');
          |                                   ^
      620 |       }
      621 |     });
      622 |   });

      at Object.toBe (services/locationService.test.ts:619:35)

FAIL services/rsvpService.test.ts
  ● rsvpService › create › should return success with RSVP data when valid input provided

    TypeError: Cannot read properties of null (reading 'id')

      87 |       expect(result.success).toBe(true);
      88 |       if (result.success) {
    > 89 |         expect(result.data.id).toBe('rsvp-1');
         |                            ^
      90 |         expect(result.data.guest_id).toBe(validData.guest_id);
      91 |         expect(result.data.status).toBe('attending');
      92 |         expect(result.data.guest_count).toBe(2);

      at Object.id (services/rsvpService.test.ts:89:28)

  ● rsvpService › create › should return DUPLICATE_ENTRY when RSVP already exists

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      136 |       const result = await rsvpService.create(validData);
      137 |
    > 138 |       expect(result.success).toBe(false);
          |                              ^
      139 |       if (!result.success) {
      140 |         expect(result.error.code).toBe('DUPLICATE_ENTRY');
      141 |       }

      at Object.toBe (services/rsvpService.test.ts:138:30)

  ● rsvpService › create › should return DATABASE_ERROR when insert fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      150 |       const result = await rsvpService.create(validData);
      151 |
    > 152 |       expect(result.success).toBe(false);
          |                              ^
      153 |       if (!result.success) {
      154 |         expect(result.error.code).toBe('DATABASE_ERROR');
      155 |       }

      at Object.toBe (services/rsvpService.test.ts:152:30)

  ● rsvpService › create › should sanitize input to prevent XSS attacks

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "<script>alert(\"xss\")</script>Vegetarian"

    Number of calls: 0

      180 |       // Verify sanitization was called
      181 |       const { sanitizeInput } = require('@/utils/sanitization');
    > 182 |       expect(sanitizeInput).toHaveBeenCalledWith(maliciousData.dietary_notes);
          |                             ^
      183 |       expect(sanitizeInput).toHaveBeenCalledWith(maliciousData.special_requirements);
      184 |       expect(sanitizeInput).toHaveBeenCalledWith(maliciousData.notes);
      185 |     });

      at Object.toHaveBeenCalledWith (services/rsvpService.test.ts:182:29)

  ● rsvpService › create › should set responded_at when status is not pending

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"responded_at": Any<String>, "status": "attending"}

    Number of calls: 0

      200 |
      201 |       expect(result.success).toBe(true);
    > 202 |       expect(mockSupabase.insert).toHaveBeenCalledWith(
          |                                   ^
      203 |         expect.objectContaining({
      204 |           status: 'attending',
      205 |           responded_at: expect.any(String),

      at Object.toHaveBeenCalledWith (services/rsvpService.test.ts:202:35)

  ● rsvpService › create › should not set responded_at when status is pending

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"responded_at": undefined, "status": "pending"}

    Number of calls: 0

      223 |
      224 |       expect(result.success).toBe(true);
    > 225 |       expect(mockSupabase.insert).toHaveBeenCalledWith(
          |                                   ^
      226 |         expect.objectContaining({
      227 |           status: 'pending',
      228 |           responded_at: undefined,

      at Object.toHaveBeenCalledWith (services/rsvpService.test.ts:225:35)

  ● rsvpService › get › should return success with RSVP data when RSVP exists

    TypeError: Cannot read properties of null (reading 'id')

      258 |       expect(result.success).toBe(true);
      259 |       if (result.success) {
    > 260 |         expect(result.data.id).toBe('rsvp-1');
          |                            ^
      261 |         expect(result.data.status).toBe('attending');
      262 |       }
      263 |     });

      at Object.id (services/rsvpService.test.ts:260:28)

  ● rsvpService › get › should return NOT_FOUND when RSVP does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      271 |       const result = await rsvpService.get('nonexistent-id');
      272 |
    > 273 |       expect(result.success).toBe(false);
          |                              ^
      274 |       if (!result.success) {
      275 |         expect(result.error.code).toBe('NOT_FOUND');
      276 |       }

      at Object.toBe (services/rsvpService.test.ts:273:30)

  ● rsvpService › get › should return DATABASE_ERROR when database query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      285 |       const result = await rsvpService.get('rsvp-1');
      286 |
    > 287 |       expect(result.success).toBe(false);
          |                              ^
      288 |       if (!result.success) {
      289 |         expect(result.error.code).toBe('DATABASE_ERROR');
      290 |       }

      at Object.toBe (services/rsvpService.test.ts:287:30)

  ● rsvpService › update › should return success with updated RSVP data when valid input provided

    TypeError: Cannot read properties of null (reading 'status')

      324 |       expect(result.success).toBe(true);
      325 |       if (result.success) {
    > 326 |         expect(result.data.status).toBe('declined');
          |                            ^
      327 |         expect(result.data.dietary_notes).toBe('No dietary restrictions');
      328 |         expect(result.data.notes).toBe('Cannot attend due to conflict');
      329 |       }

      at Object.status (services/rsvpService.test.ts:326:28)

  ● rsvpService › update › should set responded_at when status changes from pending

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: ObjectContaining {"responded_at": Any<String>, "status": "attending"}

    Number of calls: 0

      345 |
      346 |       expect(result.success).toBe(true);
    > 347 |       expect(mockSupabase.update).toHaveBeenCalledWith(
          |                                   ^
      348 |         expect.objectContaining({
      349 |           status: 'attending',
      350 |           responded_at: expect.any(String),

      at Object.toHaveBeenCalledWith (services/rsvpService.test.ts:347:35)

  ● rsvpService › update › should return NOT_FOUND when RSVP to update does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      361 |       const result = await rsvpService.update('nonexistent-id', updateData);
      362 |
    > 363 |       expect(result.success).toBe(false);
          |                              ^
      364 |       if (!result.success) {
      365 |         expect(result.error.code).toBe('NOT_FOUND');
      366 |       }

      at Object.toBe (services/rsvpService.test.ts:363:30)

  ● rsvpService › update › should return DATABASE_ERROR when update fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      375 |       const result = await rsvpService.update('rsvp-1', updateData);
      376 |
    > 377 |       expect(result.success).toBe(false);
          |                              ^
      378 |       if (!result.success) {
      379 |         expect(result.error.code).toBe('DATABASE_ERROR');
      380 |       }

      at Object.toBe (services/rsvpService.test.ts:377:30)

  ● rsvpService › deleteRSVP › should return DATABASE_ERROR when delete fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      400 |       const result = await rsvpService.deleteRSVP('rsvp-1');
      401 |
    > 402 |       expect(result.success).toBe(false);
          |                              ^
      403 |       if (!result.success) {
      404 |         expect(result.error.code).toBe('DATABASE_ERROR');
      405 |       }

      at Object.toBe (services/rsvpService.test.ts:402:30)

  ● rsvpService › list › should return success with paginated RSVPs when valid filters provided

    expect(received).toHaveLength(expected)

    Expected length: 2
    Received length: 0
    Received array:  []

      451 |       expect(result.success).toBe(true);
      452 |       if (result.success) {
    > 453 |         expect(result.data.rsvps).toHaveLength(2);
          |                                   ^
      454 |         expect(result.data.total).toBe(2);
      455 |       }
      456 |     });

      at Object.toHaveLength (services/rsvpService.test.ts:453:35)

  ● rsvpService › list › should filter by guest_id when provided

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "guest_id", "123e4567-e89b-12d3-a456-426614174000"

    Number of calls: 0

      471 |       const result = await rsvpService.list(filters);
      472 |
    > 473 |       expect(mockSupabase.eq).toHaveBeenCalledWith('guest_id', '123e4567-e89b-12d3-a456-426614174000');
          |                               ^
      474 |       expect(result.success).toBe(true);
      475 |     });
      476 |

      at Object.toHaveBeenCalledWith (services/rsvpService.test.ts:473:31)

  ● rsvpService › list › should filter by status when provided

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "status", "attending"

    Number of calls: 0

      490 |       const result = await rsvpService.list(filters);
      491 |
    > 492 |       expect(mockSupabase.eq).toHaveBeenCalledWith('status', 'attending');
          |                               ^
      493 |       expect(result.success).toBe(true);
      494 |     });
      495 |

      at Object.toHaveBeenCalledWith (services/rsvpService.test.ts:492:31)

  ● rsvpService › list › should return DATABASE_ERROR when query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      502 |       const result = await rsvpService.list();
      503 |
    > 504 |       expect(result.success).toBe(false);
          |                              ^
      505 |       if (!result.success) {
      506 |         expect(result.error.code).toBe('DATABASE_ERROR');
      507 |       }

      at Object.toBe (services/rsvpService.test.ts:504:30)

  ● rsvpService › calculateActivityCapacity › should return success with capacity information when activity exists

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      537 |       const result = await rsvpService.calculateActivityCapacity('activity-1');
      538 |
    > 539 |       expect(result.success).toBe(true);
          |                              ^
      540 |       if (result.success) {
      541 |         expect(result.data.capacity).toBe(50);
      542 |         expect(result.data.attending_count).toBe(6); // 2 + 3 + 1

      at Object.toBe (services/rsvpService.test.ts:539:30)

  ● rsvpService › calculateActivityCapacity › should handle activities with no capacity limit

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      571 |       const result = await rsvpService.calculateActivityCapacity('activity-1');
      572 |
    > 573 |       expect(result.success).toBe(true);
          |                              ^
      574 |       if (result.success) {
      575 |         expect(result.data.capacity).toBeNull();
      576 |         expect(result.data.attending_count).toBe(8); // 5 + 3

      at Object.toBe (services/rsvpService.test.ts:573:30)

  ● rsvpService › calculateActivityCapacity › should return DATABASE_ERROR when activity query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "UNKNOWN_ERROR"

      589 |       expect(result.success).toBe(false);
      590 |       if (!result.success) {
    > 591 |         expect(result.error.code).toBe('DATABASE_ERROR');
          |                                   ^
      592 |       }
      593 |     });
      594 |   });

      at Object.toBe (services/rsvpService.test.ts:591:35)

  ● rsvpService › generateCapacityAlerts › should return success with alerts for activities approaching capacity

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      632 |       const result = await rsvpService.generateCapacityAlerts(0.9);
      633 |
    > 634 |       expect(result.success).toBe(true);
          |                              ^
      635 |       if (result.success) {
      636 |         expect(result.data).toHaveLength(2);
      637 |         

      at Object.toBe (services/rsvpService.test.ts:634:30)

  ● rsvpService › generateCapacityAlerts › should return empty array when no activities exceed threshold

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      672 |       const result = await rsvpService.generateCapacityAlerts(0.9);
      673 |
    > 674 |       expect(result.success).toBe(true);
          |                              ^
      675 |       if (result.success) {
      676 |         expect(result.data).toHaveLength(0);
      677 |       }

      at Object.toBe (services/rsvpService.test.ts:674:30)

  ● rsvpService › checkCapacityAvailable › should return available true when capacity is sufficient

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      697 |       const result = await rsvpService.checkCapacityAvailable('activity-1', 3);
      698 |
    > 699 |       expect(result.success).toBe(true);
          |                              ^
      700 |       if (result.success) {
      701 |         expect(result.data.available).toBe(true);
      702 |         expect(result.data.message).toContain('5 spots remaining');

      at Object.toBe (services/rsvpService.test.ts:699:30)

  ● rsvpService › checkCapacityAvailable › should return available false when capacity would be exceeded

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      721 |       const result = await rsvpService.checkCapacityAvailable('activity-1', 5);
      722 |
    > 723 |       expect(result.success).toBe(true);
          |                              ^
      724 |       if (result.success) {
      725 |         expect(result.data.available).toBe(false);
      726 |         expect(result.data.message).toContain('cannot add 5 more guest(s)');

      at Object.toBe (services/rsvpService.test.ts:723:30)

  ● rsvpService › checkCapacityAvailable › should return available true when no capacity limit is set

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      745 |       const result = await rsvpService.checkCapacityAvailable('activity-1', 50);
      746 |
    > 747 |       expect(result.success).toBe(true);
          |                              ^
      748 |       if (result.success) {
      749 |         expect(result.data.available).toBe(true);
      750 |         expect(result.data.message).toContain('No capacity limit');

      at Object.toBe (services/rsvpService.test.ts:747:30)

  ● rsvpService › enforceCapacityLimit › should return success when capacity limit is not exceeded

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      771 |       const result = await rsvpService.enforceCapacityLimit('activity-1', 3);
      772 |
    > 773 |       expect(result.success).toBe(true);
          |                              ^
      774 |     });
      775 |
      776 |     it('should return CAPACITY_EXCEEDED when limit would be exceeded', async () => {

      at Object.toBe (services/rsvpService.test.ts:773:30)

  ● rsvpService › enforceCapacityLimit › should return CAPACITY_EXCEEDED when limit would be exceeded

    expect(received).toBe(expected) // Object.is equality

    Expected: "CAPACITY_EXCEEDED"
    Received: "UNKNOWN_ERROR"

      793 |       expect(result.success).toBe(false);
      794 |       if (!result.success) {
    > 795 |         expect(result.error.code).toBe('CAPACITY_EXCEEDED');
          |                                   ^
      796 |         expect(result.error.message).toContain('13/10');
      797 |       }
      798 |     });

      at Object.toBe (services/rsvpService.test.ts:795:35)

  ● rsvpService › enforceCapacityLimit › should account for existing RSVP when updating

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      823 |       const result = await rsvpService.enforceCapacityLimit('activity-1', 4, 'existing-rsvp-id');
      824 |
    > 825 |       expect(result.success).toBe(true);
          |                              ^
      826 |     });
      827 |
      828 |     it('should return success when no capacity limit is set', async () => {

      at Object.toBe (services/rsvpService.test.ts:825:30)

  ● rsvpService › enforceCapacityLimit › should return success when no capacity limit is set

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      843 |       const result = await rsvpService.enforceCapacityLimit('activity-1', 50);
      844 |
    > 845 |       expect(result.success).toBe(true);
          |                              ^
      846 |     });
      847 |   });
      848 | });

      at Object.toBe (services/rsvpService.test.ts:845:30)

FAIL services/emailService.test.ts
  ● emailService › createTemplate › should return success with template data when valid input provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

       99 |       const result = await createTemplate(validTemplateData);
      100 |
    > 101 |       expect(result.success).toBe(true);
          |                              ^
      102 |       if (result.success) {
      103 |         expect(result.data.id).toBe('template-1');
      104 |         expect(result.data.name).toBe('Welcome Email');

      at Object.toBe (services/emailService.test.ts:101:30)

  ● emailService › createTemplate › should return DATABASE_ERROR when insert fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "UNKNOWN_ERROR"

      143 |       expect(result.success).toBe(false);
      144 |       if (!result.success) {
    > 145 |         expect(result.error.code).toBe(ERROR_CODES.DATABASE_ERROR);
          |                                   ^
      146 |         expect(result.error.message).toBe('Connection failed');
      147 |       }
      148 |     });

      at Object.toBe (services/emailService.test.ts:145:35)

  ● emailService › createTemplate › should sanitize HTML content to prevent XSS attacks

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      166 |       const result = await createTemplate(maliciousData);
      167 |
    > 168 |       expect(result.success).toBe(true);
          |                              ^
      169 |       if (result.success) {
      170 |         expect(result.data.body_html).not.toContain('<script>');
      171 |         expect(result.data.body_html).not.toContain('alert');

      at Object.toBe (services/emailService.test.ts:168:30)

  ● emailService › getTemplate › should return success with template data when template exists

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      191 |       const result = await getTemplate('template-1');
      192 |
    > 193 |       expect(result.success).toBe(true);
          |                              ^
      194 |       if (result.success) {
      195 |         expect(result.data.id).toBe('template-1');
      196 |         expect(result.data.name).toBe('Welcome Email');

      at Object.toBe (services/emailService.test.ts:193:30)

  ● emailService › getTemplate › should return NOT_FOUND when template does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: "NOT_FOUND"
    Received: "UNKNOWN_ERROR"

      205 |       expect(result.success).toBe(false);
      206 |       if (!result.success) {
    > 207 |         expect(result.error.code).toBe(ERROR_CODES.NOT_FOUND);
          |                                   ^
      208 |         expect(result.error.message).toBe('Template not found');
      209 |       }
      210 |     });

      at Object.toBe (services/emailService.test.ts:207:35)

  ● emailService › updateTemplate › should return success with updated template data when valid input provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      242 |       const result = await updateTemplate('template-1', updateData);
      243 |
    > 244 |       expect(result.success).toBe(true);
          |                              ^
      245 |       if (result.success) {
      246 |         expect(result.data.name).toBe('Updated Welcome Email');
      247 |         expect(result.data.subject).toBe('Welcome {{guest_name}}!');

      at Object.toBe (services/emailService.test.ts:244:30)

  ● emailService › updateTemplate › should return NOT_FOUND when template does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: "NOT_FOUND"
    Received: "UNKNOWN_ERROR"

      256 |       expect(result.success).toBe(false);
      257 |       if (!result.success) {
    > 258 |         expect(result.error.code).toBe(ERROR_CODES.NOT_FOUND);
          |                                   ^
      259 |       }
      260 |     });
      261 |   });

      at Object.toBe (services/emailService.test.ts:258:35)

  ● emailService › deleteTemplate › should return success when template is deleted

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      267 |       const result = await deleteTemplate('template-1');
      268 |
    > 269 |       expect(result.success).toBe(true);
          |                              ^
      270 |     });
      271 |
      272 |     it('should return DATABASE_ERROR when delete fails', async () => {

      at Object.toBe (services/emailService.test.ts:269:30)

  ● emailService › deleteTemplate › should return DATABASE_ERROR when delete fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "UNKNOWN_ERROR"

      277 |       expect(result.success).toBe(false);
      278 |       if (!result.success) {
    > 279 |         expect(result.error.code).toBe(ERROR_CODES.DATABASE_ERROR);
          |                                   ^
      280 |       }
      281 |     });
      282 |   });

      at Object.toBe (services/emailService.test.ts:279:35)

  ● emailService › listTemplates › should return success with templates list

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      311 |       const result = await listTemplates();
      312 |
    > 313 |       expect(result.success).toBe(true);
          |                              ^
      314 |       if (result.success) {
      315 |         expect(result.data).toHaveLength(2);
      316 |         expect(result.data[0].name).toBe('Welcome Email');

      at Object.toBe (services/emailService.test.ts:313:30)

  ● emailService › listTemplates › should return empty array when no templates exist

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      324 |       const result = await listTemplates();
      325 |
    > 326 |       expect(result.success).toBe(true);
          |                              ^
      327 |       if (result.success) {
      328 |         expect(result.data).toHaveLength(0);
      329 |       }

      at Object.toBe (services/emailService.test.ts:326:30)

  ● emailService › sendEmail › should return success with email ID when email is sent successfully

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      354 |       const result = await sendEmail(validEmailData);
      355 |
    > 356 |       expect(result.success).toBe(true);
          |                              ^
      357 |       if (result.success) {
      358 |         expect(result.data.id).toBe('email-123');
      359 |       }

      at Object.toBe (services/emailService.test.ts:356:30)

  ● emailService › sendEmail › should return EMAIL_SERVICE_ERROR when Resend fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "EMAIL_SERVICE_ERROR"
    Received: "UNKNOWN_ERROR"

      390 |       expect(result.success).toBe(false);
      391 |       if (!result.success) {
    > 392 |         expect(result.error.code).toBe(ERROR_CODES.EMAIL_SERVICE_ERROR);
          |                                   ^
      393 |         expect(result.error.message).toBe('API key invalid');
      394 |       }
      395 |     });

      at Object.toBe (services/emailService.test.ts:392:35)

  ● emailService › sendEmail › should substitute template variables when template_id provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      427 |       const result = await sendEmail(emailWithTemplate);
      428 |
    > 429 |       expect(result.success).toBe(true);
          |                              ^
      430 |       expect(mockResend.emails.send).toHaveBeenCalledWith({
      431 |         from: 'onboarding@resend.dev',
      432 |         to: 'guest@example.com',

      at Object.toBe (services/emailService.test.ts:429:30)

  ● emailService › sendEmail › should return NOT_FOUND when template_id does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: "NOT_FOUND"
    Received: "VALIDATION_ERROR"

      451 |       expect(result.success).toBe(false);
      452 |       if (!result.success) {
    > 453 |         expect(result.error.code).toBe(ERROR_CODES.NOT_FOUND);
          |                                   ^
      454 |         expect(result.error.message).toBe('Template not found');
      455 |       }
      456 |     });

      at Object.toBe (services/emailService.test.ts:453:35)

  ● emailService › sendBulkEmail › should return success with sent/failed counts when bulk email is sent

    expect(received).toBe(expected) // Object.is equality

    Expected: 2
    Received: 0

      479 |       expect(result.success).toBe(true);
      480 |       if (result.success) {
    > 481 |         expect(result.data.sent).toBe(2);
          |                                  ^
      482 |         expect(result.data.failed).toBe(1);
      483 |       }
      484 |

      at Object.toBe (services/emailService.test.ts:481:34)

  ● emailService › scheduleEmail › should return success with scheduled email ID when email is scheduled

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      525 |       const result = await scheduleEmail(scheduleData);
      526 |
    > 527 |       expect(result.success).toBe(true);
          |                              ^
      528 |       if (result.success) {
      529 |         expect(result.data.id).toBe('scheduled-1');
      530 |       }

      at Object.toBe (services/emailService.test.ts:527:30)

  ● emailService › sendEmailWithSMSFallback › should return email result when email sends successfully

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      569 |       const result = await sendEmailWithSMSFallback(emailData, '+15551234567');
      570 |
    > 571 |       expect(result.success).toBe(true);
          |                              ^
      572 |       if (result.success) {
      573 |         expect(result.data.id).toBe('email-123');
      574 |         expect(result.data.method).toBe('email');

      at Object.toBe (services/emailService.test.ts:571:30)

  ● emailService › sendEmailWithSMSFallback › should return email error when email fails and no phone number provided

    expect(received).toBe(expected) // Object.is equality

    Expected: "EMAIL_SERVICE_ERROR"
    Received: "UNKNOWN_ERROR"

      629 |       expect(result.success).toBe(false);
      630 |       if (!result.success) {
    > 631 |         expect(result.error.code).toBe(ERROR_CODES.EMAIL_SERVICE_ERROR);
          |                                   ^
      632 |       }
      633 |
      634 |       expect(sendSMSFallback).not.toHaveBeenCalled();

      at Object.toBe (services/emailService.test.ts:631:35)

  ● emailService › updateDeliveryStatus › should return success when delivery status is updated to delivered

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      671 |       const result = await updateDeliveryStatus('log-1', 'delivered');
      672 |
    > 673 |       expect(result.success).toBe(true);
          |                              ^
      674 |       expect(mockSupabase.update).toHaveBeenCalledWith({
      675 |         delivery_status: 'delivered',
      676 |         delivered_at: expect.any(String),

      at Object.toBe (services/emailService.test.ts:673:30)

  ● emailService › updateDeliveryStatus › should return success when delivery status is updated to failed with error message

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      683 |       const result = await updateDeliveryStatus('log-1', 'failed', 'Bounce detected');
      684 |
    > 685 |       expect(result.success).toBe(true);
          |                              ^
      686 |       expect(mockSupabase.update).toHaveBeenCalledWith({
      687 |         delivery_status: 'failed',
      688 |         error_message: 'Bounce detected',

      at Object.toBe (services/emailService.test.ts:685:30)

  ● emailService › updateDeliveryStatus › should return DATABASE_ERROR when update fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "UNKNOWN_ERROR"

      697 |       expect(result.success).toBe(false);
      698 |       if (!result.success) {
    > 699 |         expect(result.error.code).toBe(ERROR_CODES.DATABASE_ERROR);
          |                                   ^
      700 |       }
      701 |     });
      702 |   });

      at Object.toBe (services/emailService.test.ts:699:35)

  ● emailService › getEmailAnalytics › should return success with analytics data

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      716 |       const result = await getEmailAnalytics();
      717 |
    > 718 |       expect(result.success).toBe(true);
          |                              ^
      719 |       if (result.success) {
      720 |         expect(result.data.total).toBe(5);
      721 |         expect(result.data.sent).toBe(1);

      at Object.toBe (services/emailService.test.ts:718:30)

  ● emailService › getEmailAnalytics › should return empty analytics when no logs exist

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      731 |       const result = await getEmailAnalytics();
      732 |
    > 733 |       expect(result.success).toBe(true);
          |                              ^
      734 |       if (result.success) {
      735 |         expect(result.data.total).toBe(0);
      736 |         expect(result.data.sent).toBe(0);

      at Object.toBe (services/emailService.test.ts:733:30)

  ● emailService › getEmailLogs › should return success with all logs when no filters provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      767 |       const result = await getEmailLogs();
      768 |
    > 769 |       expect(result.success).toBe(true);
          |                              ^
      770 |       if (result.success) {
      771 |         expect(result.data).toHaveLength(2);
      772 |         expect(result.data[0].id).toBe('log-1');

      at Object.toBe (services/emailService.test.ts:769:30)

  ● emailService › getEmailLogs › should return success with filtered logs when filters provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      784 |       });
      785 |
    > 786 |       expect(result.success).toBe(true);
          |                              ^
      787 |       if (result.success) {
      788 |         expect(result.data).toHaveLength(1);
      789 |         expect(result.data[0].delivery_status).toBe('delivered');

      at Object.toBe (services/emailService.test.ts:786:30)

  ● emailService › getEmailLogs › should return empty array when no logs match filters

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      798 |       });
      799 |
    > 800 |       expect(result.success).toBe(true);
          |                              ^
      801 |       if (result.success) {
      802 |         expect(result.data).toHaveLength(0);
      803 |       }

      at Object.toBe (services/emailService.test.ts:800:30)

FAIL services/eventService.test.ts
  ● eventService › create › should return success with event data when valid input provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      84 |       const result = await eventService.create(validData);
      85 |
    > 86 |       expect(result.success).toBe(true);
         |                              ^
      87 |       if (result.success) {
      88 |         expect(result.data.id).toBe('event-1');
      89 |         expect(result.data.name).toBe('Wedding Ceremony');

      at Object.toBe (services/eventService.test.ts:86:30)

  ● eventService › create › should return SCHEDULING_CONFLICT when event conflicts with existing events

    expect(received).toBe(expected) // Object.is equality

    Expected: "SCHEDULING_CONFLICT"
    Received: "VALIDATION_ERROR"

      133 |       expect(result.success).toBe(false);
      134 |       if (!result.success) {
    > 135 |         expect(result.error.code).toBe('SCHEDULING_CONFLICT');
          |                                   ^
      136 |         expect(result.error.details).toHaveLength(1);
      137 |       }
      138 |     });

      at Object.toBe (services/eventService.test.ts:135:35)

  ● eventService › create › should return DATABASE_ERROR when insert fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "VALIDATION_ERROR"

      157 |       expect(result.success).toBe(false);
      158 |       if (!result.success) {
    > 159 |         expect(result.error.code).toBe('DATABASE_ERROR');
          |                                   ^
      160 |       }
      161 |     });
      162 |

      at Object.toBe (services/eventService.test.ts:159:35)

  ● eventService › create › should sanitize input to prevent XSS attacks

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      188 |       const result = await eventService.create(maliciousData);
      189 |
    > 190 |       expect(result.success).toBe(true);
          |                              ^
      191 |       
      192 |       // Verify sanitization was called
      193 |       const { sanitizeInput, sanitizeRichText } = require('../utils/sanitization');

      at Object.toBe (services/eventService.test.ts:190:30)

  ● eventService › get › should return success with event data when event exists

    expect(received).toBe(expected) // Object.is equality

    Expected: "event-1"
    Received: undefined

      221 |       expect(result.success).toBe(true);
      222 |       if (result.success) {
    > 223 |         expect(result.data.id).toBe('event-1');
          |                                ^
      224 |         expect(result.data.name).toBe('Wedding Ceremony');
      225 |         expect(result.data.eventType).toBe('ceremony');
      226 |       }

      at Object.toBe (services/eventService.test.ts:223:32)

  ● eventService › get › should return NOT_FOUND when event does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      235 |       const result = await eventService.get('nonexistent-id');
      236 |
    > 237 |       expect(result.success).toBe(false);
          |                              ^
      238 |       if (!result.success) {
      239 |         expect(result.error.code).toBe('NOT_FOUND');
      240 |       }

      at Object.toBe (services/eventService.test.ts:237:30)

  ● eventService › get › should return DATABASE_ERROR when database query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      249 |       const result = await eventService.get('event-1');
      250 |
    > 251 |       expect(result.success).toBe(false);
          |                              ^
      252 |       if (!result.success) {
      253 |         expect(result.error.code).toBe('DATABASE_ERROR');
      254 |       }

      at Object.toBe (services/eventService.test.ts:251:30)

  ● eventService › update › should return success with updated event data when valid input provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      284 |       const result = await eventService.update('event-1', updateData);
      285 |
    > 286 |       expect(result.success).toBe(true);
          |                              ^
      287 |       if (result.success) {
      288 |         expect(result.data.name).toBe('Updated Ceremony');
      289 |         expect(result.data.description).toBe('Updated description');

      at Object.toBe (services/eventService.test.ts:286:30)

  ● eventService › update › should check for scheduling conflicts when location or dates are updated

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      351 |       const result = await eventService.update('event-1', updateWithLocation);
      352 |
    > 353 |       expect(result.success).toBe(true);
          |                              ^
      354 |       expect(mockSupabase.neq).toHaveBeenCalledWith('id', 'event-1'); // Exclude current event from conflict check
      355 |     });
      356 |

      at Object.toBe (services/eventService.test.ts:353:30)

  ● eventService › update › should return NOT_FOUND when event to update does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: "NOT_FOUND"
    Received: "VALIDATION_ERROR"

      365 |       expect(result.success).toBe(false);
      366 |       if (!result.success) {
    > 367 |         expect(result.error.code).toBe('NOT_FOUND');
          |                                   ^
      368 |       }
      369 |     });
      370 |   });

      at Object.toBe (services/eventService.test.ts:367:35)

  ● eventService › deleteEvent › should return DATABASE_ERROR when delete fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      388 |       const result = await eventService.deleteEvent('event-1');
      389 |
    > 390 |       expect(result.success).toBe(false);
          |                              ^
      391 |       if (!result.success) {
      392 |         expect(result.error.code).toBe('DATABASE_ERROR');
      393 |       }

      at Object.toBe (services/eventService.test.ts:390:30)

  ● eventService › list › should return success with paginated events when valid filters provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      433 |       const result = await eventService.list(filters);
      434 |
    > 435 |       expect(result.success).toBe(true);
          |                              ^
      436 |       if (result.success) {
      437 |         expect(result.data.events).toHaveLength(2);
      438 |         expect(result.data.total).toBe(2);

      at Object.toBe (services/eventService.test.ts:435:30)

  ● eventService › list › should filter by event type when provided

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "event_type", "ceremony"

    Number of calls: 0

      457 |       const result = await eventService.list(filters);
      458 |
    > 459 |       expect(mockSupabase.eq).toHaveBeenCalledWith('event_type', 'ceremony');
          |                               ^
      460 |       expect(result.success).toBe(true);
      461 |     });
      462 |

      at Object.toHaveBeenCalledWith (services/eventService.test.ts:459:31)

  ● eventService › list › should filter by date range when provided

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "start_date", "2025-06-01T00:00:00Z"

    Number of calls: 0

      477 |       const result = await eventService.list(filters);
      478 |
    > 479 |       expect(mockSupabase.gte).toHaveBeenCalledWith('start_date', '2025-06-01T00:00:00Z');
          |                                ^
      480 |       expect(mockSupabase.lte).toHaveBeenCalledWith('start_date', '2025-06-30T23:59:59Z');
      481 |       expect(result.success).toBe(true);
      482 |     });

      at Object.toHaveBeenCalledWith (services/eventService.test.ts:479:32)

  ● eventService › list › should return DATABASE_ERROR when query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "UNKNOWN_ERROR"

      492 |       expect(result.success).toBe(false);
      493 |       if (!result.success) {
    > 494 |         expect(result.error.code).toBe('DATABASE_ERROR');
          |                                   ^
      495 |       }
      496 |     });
      497 |   });

      at Object.toBe (services/eventService.test.ts:494:35)

  ● eventService › search › should return success with search results when valid query provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      528 |       const result = await eventService.search(searchParams);
      529 |
    > 530 |       expect(result.success).toBe(true);
          |                              ^
      531 |       if (result.success) {
      532 |         expect(result.data.events).toHaveLength(1);
      533 |         expect(result.data.events[0].name).toBe('Wedding Ceremony');

      at Object.toBe (services/eventService.test.ts:530:30)

  ● eventService › search › should sanitize search query to prevent injection attacks

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "<script>alert(\"xss\")</script>ceremony"

    Number of calls: 0

      552 |       // Verify sanitization was called
      553 |       const { sanitizeInput } = require('../utils/sanitization');
    > 554 |       expect(sanitizeInput).toHaveBeenCalledWith(maliciousSearch.query);
          |                             ^
      555 |       expect(result.success).toBe(true);
      556 |     });
      557 |

      at Object.toHaveBeenCalledWith (services/eventService.test.ts:554:29)

  ● eventService › checkSchedulingConflicts › should return success with no conflicts when no overlapping events exist

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      582 |       const result = await eventService.checkSchedulingConflicts(conflictParams);
      583 |
    > 584 |       expect(result.success).toBe(true);
          |                              ^
      585 |       if (result.success) {
      586 |         expect(result.data.hasConflict).toBe(false);
      587 |         expect(result.data.conflictingEvents).toHaveLength(0);

      at Object.toBe (services/eventService.test.ts:584:30)

  ● eventService › checkSchedulingConflicts › should return success with conflicts when overlapping events exist

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      604 |       const result = await eventService.checkSchedulingConflicts(conflictParams);
      605 |
    > 606 |       expect(result.success).toBe(true);
          |                              ^
      607 |       if (result.success) {
      608 |         expect(result.data.hasConflict).toBe(true);
      609 |         expect(result.data.conflictingEvents).toHaveLength(1);

      at Object.toBe (services/eventService.test.ts:606:30)

  ● eventService › checkSchedulingConflicts › should exclude specified event ID from conflict check

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "id", "current-event-id"

    Number of calls: 0

      627 |       const result = await eventService.checkSchedulingConflicts(paramsWithExclusion);
      628 |
    > 629 |       expect(mockSupabase.neq).toHaveBeenCalledWith('id', 'current-event-id');
          |                                ^
      630 |       expect(result.success).toBe(true);
      631 |     });
      632 |

      at Object.toHaveBeenCalledWith (services/eventService.test.ts:629:32)

  ● eventService › checkSchedulingConflicts › should handle events without end dates correctly

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      646 |       const result = await eventService.checkSchedulingConflicts(conflictParams);
      647 |
    > 648 |       expect(result.success).toBe(true);
          |                              ^
      649 |       if (result.success) {
      650 |         expect(result.data.hasConflict).toBe(true); // Should still detect overlap
      651 |       }

      at Object.toBe (services/eventService.test.ts:648:30)

  ● eventService › checkSchedulingConflicts › should return DATABASE_ERROR when query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "UNKNOWN_ERROR"

      662 |       expect(result.success).toBe(false);
      663 |       if (!result.success) {
    > 664 |         expect(result.error.code).toBe('DATABASE_ERROR');
          |                                   ^
      665 |       }
      666 |     });
      667 |

      at Object.toBe (services/eventService.test.ts:664:35)

FAIL services/accommodationService.test.ts
  ● accommodationService › createAccommodation › should return success with accommodation data when valid input provided

    expect(received).toBe(expected) // Object.is equality

    Expected: "accommodation-1"
    Received: undefined

      106 |       expect(result.success).toBe(true);
      107 |       if (result.success) {
    > 108 |         expect(result.data.id).toBe('accommodation-1');
          |                                ^
      109 |         expect(result.data.name).toBe('Costa Rica Beach Resort');
      110 |         expect(result.data.locationId).toBe(validData.locationId);
      111 |       }

      at Object.toBe (services/accommodationService.test.ts:108:32)

  ● accommodationService › createAccommodation › should return DATABASE_ERROR when insert fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      143 |       const result = await accommodationService.createAccommodation(validData);
      144 |
    > 145 |       expect(result.success).toBe(false);
          |                              ^
      146 |       if (!result.success) {
      147 |         expect(result.error.code).toBe('DATABASE_ERROR');
      148 |       }

      at Object.toBe (services/accommodationService.test.ts:145:30)

  ● accommodationService › createAccommodation › should sanitize input to prevent XSS attacks

    expect(received).not.toContain(expected) // indexOf

    Matcher error: received value must not be null nor undefined

    Received has value: undefined

      177 |       expect(result.success).toBe(true);
      178 |       if (result.success) {
    > 179 |         expect(result.data.name).not.toContain('<script>');
          |                                      ^
      180 |         expect(result.data.description).not.toContain('<img');
      181 |         expect(result.data.address).not.toContain('<script>');
      182 |       }

      at Object.toContain (services/accommodationService.test.ts:179:38)

  ● accommodationService › getAccommodation › should return accommodation when valid ID provided

    expect(received).toBe(expected) // Object.is equality

    Expected: "123e4567-e89b-12d3-a456-426614174000"
    Received: undefined

      208 |       expect(result.success).toBe(true);
      209 |       if (result.success) {
    > 210 |         expect(result.data.id).toBe(validId);
          |                                ^
      211 |         expect(result.data.name).toBe('Costa Rica Beach Resort');
      212 |       }
      213 |     });

      at Object.toBe (services/accommodationService.test.ts:210:32)

  ● accommodationService › getAccommodation › should return NOT_FOUND when accommodation does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      224 |       const result = await accommodationService.getAccommodation(validId);
      225 |
    > 226 |       expect(result.success).toBe(false);
          |                              ^
      227 |       if (!result.success) {
      228 |         expect(result.error.code).toBe('NOT_FOUND');
      229 |       }

      at Object.toBe (services/accommodationService.test.ts:226:30)

  ● accommodationService › getAccommodation › should return DATABASE_ERROR when database query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      241 |       const result = await accommodationService.getAccommodation(validId);
      242 |
    > 243 |       expect(result.success).toBe(false);
          |                              ^
      244 |       if (!result.success) {
      245 |         expect(result.error.code).toBe('DATABASE_ERROR');
      246 |       }

      at Object.toBe (services/accommodationService.test.ts:243:30)

  ● accommodationService › createRoomType › should return success with room type data when valid input provided

    expect(received).toBe(expected) // Object.is equality

    Expected: "room-type-1"
    Received: undefined

      288 |       expect(result.success).toBe(true);
      289 |       if (result.success) {
    > 290 |         expect(result.data.id).toBe('room-type-1');
          |                                ^
      291 |         expect(result.data.name).toBe('Deluxe Ocean View');
      292 |         expect(result.data.capacity).toBe(2);
      293 |         expect(result.data.totalRooms).toBe(10);

      at Object.toBe (services/accommodationService.test.ts:290:32)

  ● accommodationService › createRoomType › should sanitize input to prevent XSS attacks

    expect(received).not.toContain(expected) // indexOf

    Matcher error: received value must not be null nor undefined

    Received has value: undefined

      357 |       expect(result.success).toBe(true);
      358 |       if (result.success) {
    > 359 |         expect(result.data.name).not.toContain('<script>');
          |                                      ^
      360 |         expect(result.data.description).not.toContain('<img');
      361 |       }
      362 |     });

      at Object.toContain (services/accommodationService.test.ts:359:38)

  ● accommodationService › listRoomTypes › should return room types for accommodation

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      403 |       const result = await accommodationService.listRoomTypes(accommodationId);
      404 |
    > 405 |       expect(result.success).toBe(true);
          |                              ^
      406 |       if (result.success) {
      407 |         expect(result.data).toHaveLength(2);
      408 |         expect(result.data[0].name).toBe('Standard Room');

      at Object.toBe (services/accommodationService.test.ts:405:30)

  ● accommodationService › listRoomTypes › should return DATABASE_ERROR when query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "UNKNOWN_ERROR"

      424 |       expect(result.success).toBe(false);
      425 |       if (!result.success) {
    > 426 |         expect(result.error.code).toBe('DATABASE_ERROR');
          |                                   ^
      427 |       }
      428 |     });
      429 |   });

      at Object.toBe (services/accommodationService.test.ts:426:35)

  ● accommodationService › createRoomAssignment › should return success with room assignment data when valid input provided

    expect(received).toBe(expected) // Object.is equality

    Expected: "assignment-1"
    Received: undefined

      463 |       expect(result.success).toBe(true);
      464 |       if (result.success) {
    > 465 |         expect(result.data.id).toBe('assignment-1');
          |                                ^
      466 |         expect(result.data.roomTypeId).toBe(validData.roomTypeId);
      467 |         expect(result.data.guestId).toBe(validData.guestId);
      468 |         expect(result.data.checkIn).toBe(validData.checkIn);

      at Object.toBe (services/accommodationService.test.ts:465:32)

  ● accommodationService › createRoomAssignment › should return CONFLICT when guest already has assignment for dates

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      496 |       const result = await accommodationService.createRoomAssignment(validData);
      497 |
    > 498 |       expect(result.success).toBe(false);
          |                              ^
      499 |       if (!result.success) {
      500 |         expect(result.error.code).toBe('CONFLICT');
      501 |       }

      at Object.toBe (services/accommodationService.test.ts:498:30)

  ● accommodationService › createRoomAssignment › should sanitize notes to prevent XSS attacks

    expect(received).not.toContain(expected) // indexOf

    Matcher error: received value must not be null nor undefined

    Received has value: undefined

      528 |       expect(result.success).toBe(true);
      529 |       if (result.success) {
    > 530 |         expect(result.data.notes).not.toContain('<script>');
          |                                       ^
      531 |       }
      532 |     });
      533 |   });

      at Object.toContain (services/accommodationService.test.ts:530:39)

  ● accommodationService › listGuestRoomAssignments › should return room assignments for guest

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      557 |       const result = await accommodationService.listGuestRoomAssignments(guestId);
      558 |
    > 559 |       expect(result.success).toBe(true);
          |                              ^
      560 |       if (result.success) {
      561 |         expect(result.data).toHaveLength(1);
      562 |         expect(result.data[0].guestId).toBe(guestId);

      at Object.toBe (services/accommodationService.test.ts:559:30)

  ● accommodationService › listRoomTypeAssignments › should return room assignments for room type

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      589 |       const result = await accommodationService.listRoomTypeAssignments(roomTypeId);
      590 |
    > 591 |       expect(result.success).toBe(true);
          |                              ^
      592 |       if (result.success) {
      593 |         expect(result.data).toHaveLength(1);
      594 |         expect(result.data[0].roomTypeId).toBe(roomTypeId);

      at Object.toBe (services/accommodationService.test.ts:591:30)

  ● accommodationService › calculateRoomCost › should calculate cost correctly with subsidy

    expect(received).toBe(expected) // Object.is equality

    Expected: 200
    Received: undefined

      634 |       if (result.success) {
      635 |         expect(result.data.numberOfNights).toBe(4); // June 1-5 = 4 nights
    > 636 |         expect(result.data.pricePerNight).toBe(200);
          |                                           ^
      637 |         expect(result.data.subsidyPerNight).toBe(50);
      638 |         expect(result.data.totalCost).toBe(800); // 200 * 4
      639 |         expect(result.data.totalSubsidy).toBe(200); // 50 * 4

      at Object.toBe (services/accommodationService.test.ts:636:43)

  ● accommodationService › calculateRoomCost › should calculate cost correctly without subsidy

    expect(received).toBe(expected) // Object.is equality

    Expected: 150
    Received: undefined

      667 |       if (result.success) {
      668 |         expect(result.data.numberOfNights).toBe(4);
    > 669 |         expect(result.data.pricePerNight).toBe(150);
          |                                           ^
      670 |         expect(result.data.subsidyPerNight).toBe(0);
      671 |         expect(result.data.totalCost).toBe(600); // 150 * 4
      672 |         expect(result.data.totalSubsidy).toBe(0);

      at Object.toBe (services/accommodationService.test.ts:669:43)

  ● accommodationService › calculateRoomCost › should return error when room type not found

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      686 |       const result = await accommodationService.calculateRoomCost(validParams);
      687 |
    > 688 |       expect(result.success).toBe(false);
          |                              ^
      689 |       if (!result.success) {
      690 |         expect(result.error.code).toBe('NOT_FOUND');
      691 |       }

      at Object.toBe (services/accommodationService.test.ts:688:30)

FAIL services/externalServiceGracefulDegradation.test.ts
  ● External Service Graceful Degradation › B2 Storage Failover to Supabase › should fallback to Supabase storage when B2 is unavailable

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      114 |
      115 |       // Upload should succeed using Supabase
    > 116 |       expect(uploadResult.success).toBe(true);
          |                                    ^
      117 |       if (uploadResult.success) {
      118 |         expect(uploadResult.data.storage_type).toBe('supabase');
      119 |         expect(mockSupabase.storage.from).toHaveBeenCalled();

      at Object.toBe (services/externalServiceGracefulDegradation.test.ts:116:36)

  ● External Service Graceful Degradation › B2 Storage Failover to Supabase › should use B2 when available and healthy

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      161 |
      162 |       // Upload should succeed using B2
    > 163 |       expect(uploadResult.success).toBe(true);
          |                                    ^
      164 |       if (uploadResult.success) {
      165 |         expect(uploadResult.data.storage_type).toBe('b2');
      166 |       }

      at Object.toBe (services/externalServiceGracefulDegradation.test.ts:163:36)

  ● External Service Graceful Degradation › Email to SMS Fallback › should fallback to SMS when email delivery fails

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      239 |
      240 |       // SMS should succeed
    > 241 |       expect(smsResult.success).toBe(true);
          |                                 ^
      242 |       expect(global.fetch).toHaveBeenCalledTimes(2);
      243 |     });
      244 |

      at Object.toBe (services/externalServiceGracefulDegradation.test.ts:241:33)

  ● External Service Graceful Degradation › Email to SMS Fallback › should use email when available

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      268 |
      269 |       // Email should succeed
    > 270 |       expect(emailResult.success).toBe(true);
          |                                   ^
      271 |       expect(global.fetch).toHaveBeenCalledTimes(1);
      272 |     });
      273 |

      at Object.toBe (services/externalServiceGracefulDegradation.test.ts:270:35)

  ● External Service Graceful Degradation › Email to SMS Fallback › should handle both email and SMS failures gracefully

    expect(jest.fn()).toHaveBeenCalledTimes(expected)

    Expected number of calls: 2
    Received number of calls: 1

      313 |
      314 |       // Both services attempted
    > 315 |       expect(global.fetch).toHaveBeenCalledTimes(2);
          |                            ^
      316 |     });
      317 |   });
      318 |

      at Object.toHaveBeenCalledTimes (services/externalServiceGracefulDegradation.test.ts:315:28)

  ● External Service Graceful Degradation › Graceful Degradation Patterns › should continue operation when non-critical services fail

    TypeError: Cannot read properties of undefined (reading 'value')

      321 |       // Mock B2 to fail
      322 |       const { S3Client } = require('@aws-sdk/client-s3');
    > 323 |       const mockSend = S3Client.mock.results[0].value.send;
          |                                                 ^
      324 |       mockSend.mockRejectedValue(new Error('B2 unavailable'));
      325 |
      326 |       // Mock Supabase storage to succeed

      at Object.value (services/externalServiceGracefulDegradation.test.ts:323:49)

  ● External Service Graceful Degradation › Graceful Degradation Patterns › should provide meaningful error messages when all fallbacks fail

    TypeError: Cannot read properties of undefined (reading 'value')

      352 |       // Mock both B2 and Supabase to fail
      353 |       const { S3Client } = require('@aws-sdk/client-s3');
    > 354 |       const mockSend = S3Client.mock.results[0].value.send;
          |                                                 ^
      355 |       mockSend.mockRejectedValue(new Error('B2 unavailable'));
      356 |
      357 |       const { createClient } = require('@supabase/supabase-js');

      at Object.value (services/externalServiceGracefulDegradation.test.ts:354:49)

FAIL services/photoService.test.ts
  ● photoService › uploadPhoto - Upload Operations › should return success with photo data when B2 upload succeeds

    TypeError: Cannot read properties of null (reading 'storage_type')

      100 |       expect(result.success).toBe(true);
      101 |       if (result.success) {
    > 102 |         expect(result.data.storage_type).toBe('b2');
          |                            ^
      103 |         expect(result.data.photo_url).toBe('https://cdn.example.com/photo.jpg');
      104 |       }
      105 |       expect(mockB2Service.uploadToB2).toHaveBeenCalledWith(mockFile, mockFileName, mockContentType);

      at Object.storage_type (services/photoService.test.ts:102:28)

  ● photoService › uploadPhoto - Upload Operations › should fallback to Supabase Storage when B2 upload fails

    TypeError: Cannot read properties of null (reading 'storage_type')

      145 |       expect(result.success).toBe(true);
      146 |       if (result.success) {
    > 147 |         expect(result.data.storage_type).toBe('supabase');
          |                            ^
      148 |         expect(result.data.photo_url).toBe('https://supabase.example.com/photo.jpg');
      149 |       }
      150 |     });

      at Object.storage_type (services/photoService.test.ts:147:28)

  ● photoService › uploadPhoto - Upload Operations › should return DATABASE_ERROR when database insert fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      191 |
      192 |       // Assert
    > 193 |       expect(result.success).toBe(false);
          |                              ^
      194 |       if (!result.success) {
      195 |         expect(result.error.code).toBe('DATABASE_ERROR');
      196 |         expect(result.error.message).toBe('Database connection failed');

      at Object.toBe (services/photoService.test.ts:193:30)

  ● photoService › uploadPhoto - Upload Operations › should sanitize malicious input in caption and alt_text

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "<script>alert(\"xss\")</script>Malicious caption"

    Number of calls: 0

      225 |       // Assert
      226 |       expect(result.success).toBe(true);
    > 227 |       expect(mockSanitization.sanitizeInput).toHaveBeenCalledWith('<script>alert("xss")</script>Malicious caption');
          |                                              ^
      228 |       expect(mockSanitization.sanitizeInput).toHaveBeenCalledWith('<img src=x onerror=alert(1)>Malicious alt text');
      229 |     });
      230 |   });

      at Object.toHaveBeenCalledWith (services/photoService.test.ts:227:46)

  ● photoService › moderatePhoto - Moderation Workflow › should return success with updated photo when approving photo

    TypeError: Cannot read properties of null (reading 'moderation_status')

      262 |       expect(result.success).toBe(true);
      263 |       if (result.success) {
    > 264 |         expect(result.data.moderation_status).toBe('approved');
          |                            ^
      265 |         expect(result.data.moderation_reason).toBe('Photo meets guidelines');
      266 |         expect(result.data.moderated_at).toBeDefined();
      267 |       }

      at Object.moderation_status (services/photoService.test.ts:264:28)

  ● photoService › moderatePhoto - Moderation Workflow › should return success when rejecting photo with reason

    TypeError: Cannot read properties of null (reading 'moderation_status')

      298 |       expect(result.success).toBe(true);
      299 |       if (result.success) {
    > 300 |         expect(result.data.moderation_status).toBe('rejected');
          |                            ^
      301 |         expect(result.data.moderation_reason).toBe('Inappropriate content');
      302 |       }
      303 |     });

      at Object.moderation_status (services/photoService.test.ts:300:28)

  ● photoService › moderatePhoto - Moderation Workflow › should return NOT_FOUND when photo does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      342 |
      343 |       // Assert
    > 344 |       expect(result.success).toBe(false);
          |                              ^
      345 |       if (!result.success) {
      346 |         expect(result.error.code).toBe('NOT_FOUND');
      347 |       }

      at Object.toBe (services/photoService.test.ts:344:30)

  ● photoService › moderatePhoto - Moderation Workflow › should sanitize malicious input in moderation reason

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "<script>alert(\"xss\")</script>Inappropriate content"

    Number of calls: 0

      375 |       // Assert
      376 |       expect(result.success).toBe(true);
    > 377 |       expect(mockSanitization.sanitizeInput).toHaveBeenCalledWith('<script>alert("xss")</script>Inappropriate content');
          |                                              ^
      378 |     });
      379 |   });
      380 |

      at Object.toHaveBeenCalledWith (services/photoService.test.ts:377:46)

  ● photoService › getPhoto › should return success with photo data when photo exists

    TypeError: Cannot read properties of null (reading 'id')

      409 |       expect(result.success).toBe(true);
      410 |       if (result.success) {
    > 411 |         expect(result.data.id).toBe(mockPhotoId);
          |                            ^
      412 |         expect(result.data.moderation_status).toBe('approved');
      413 |       }
      414 |     });

      at Object.id (services/photoService.test.ts:411:28)

  ● photoService › getPhoto › should return NOT_FOUND when photo does not exist

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      430 |
      431 |       // Assert
    > 432 |       expect(result.success).toBe(false);
          |                              ^
      433 |       if (!result.success) {
      434 |         expect(result.error.code).toBe('NOT_FOUND');
      435 |       }

      at Object.toBe (services/photoService.test.ts:432:30)

  ● photoService › updatePhoto › should return success with updated photo when update succeeds

    TypeError: Cannot read properties of null (reading 'caption')

      470 |       expect(result.success).toBe(true);
      471 |       if (result.success) {
    > 472 |         expect(result.data.caption).toBe('Updated caption');
          |                            ^
      473 |         expect(result.data.alt_text).toBe('Updated alt text');
      474 |         expect(result.data.display_order).toBe(5);
      475 |       }

      at Object.caption (services/photoService.test.ts:472:28)

  ● photoService › deletePhoto › should return DATABASE_ERROR when database delete fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      532 |
      533 |       // Assert
    > 534 |       expect(result.success).toBe(false);
          |                              ^
      535 |       if (!result.success) {
      536 |         expect(result.error.code).toBe('DATABASE_ERROR');
      537 |         expect(result.error.message).toBe('Database connection failed');

      at Object.toBe (services/photoService.test.ts:534:30)

FAIL services/smsService.test.ts
  ● smsService › sendSMS › should return EXTERNAL_SERVICE_ERROR when Twilio not configured

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      102 |       const result = await sendSMS('+15551234567', 'Test message');
      103 |
    > 104 |       expect(result.success).toBe(false);
          |                              ^
      105 |       if (!result.success) {
      106 |         expect(result.error.code).toBe('EXTERNAL_SERVICE_ERROR');
      107 |         expect(result.error.message).toBe('SMS service not configured');

      at Object.toBe (services/smsService.test.ts:104:30)

  ● smsService › sendSMS › should return EXTERNAL_SERVICE_ERROR when credentials are test values

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      115 |       const result = await sendSMS('+15551234567', 'Test message');
      116 |
    > 117 |       expect(result.success).toBe(false);
          |                              ^
      118 |       if (!result.success) {
      119 |         expect(result.error.code).toBe('EXTERNAL_SERVICE_ERROR');
      120 |         expect(result.error.message).toBe('SMS service not configured');

      at Object.toBe (services/smsService.test.ts:117:30)

  ● smsService › sendSMS › should truncate message when longer than 160 characters

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: {"body": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...", "from": "+15551234567", "to": "+15551234567"}

    Number of calls: 0

      154 |
      155 |       expect(result.success).toBe(true);
    > 156 |       expect(mockTwilio.messages.create).toHaveBeenCalledWith({
          |                                          ^
      157 |         body: expectedMessage,
      158 |         from: '+15551234567',
      159 |         to: '+15551234567',

      at Object.toHaveBeenCalledWith (services/smsService.test.ts:156:42)

  ● smsService › sendSMS › should return EXTERNAL_SERVICE_ERROR when Twilio API fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      166 |       const result = await sendSMS('+15551234567', 'Test message');
      167 |
    > 168 |       expect(result.success).toBe(false);
          |                              ^
      169 |       if (!result.success) {
      170 |         expect(result.error.code).toBe('EXTERNAL_SERVICE_ERROR');
      171 |       }

      at Object.toBe (services/smsService.test.ts:168:30)

  ● smsService › sendSMS › should log successful SMS to database

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "sms_logs"

    Number of calls: 0

      180 |       await sendSMS('+15551234567', 'Test message');
      181 |
    > 182 |       expect(mockSupabaseFrom).toHaveBeenCalledWith('sms_logs');
          |                                ^
      183 |     });
      184 |
      185 |     it('should log failed SMS to database', async () => {

      at Object.toHaveBeenCalledWith (services/smsService.test.ts:182:32)

  ● smsService › sendSMS › should log failed SMS to database

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "sms_logs"

    Number of calls: 0

      188 |       await sendSMS('+15551234567', 'Test message');
      189 |
    > 190 |       expect(mockSupabaseFrom).toHaveBeenCalledWith('sms_logs');
          |                                ^
      191 |     });
      192 |   });
      193 |

      at Object.toHaveBeenCalledWith (services/smsService.test.ts:190:32)

  ● smsService › sendSMSFallback › should return success when SMS fallback sent successfully

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: {"body": "[RSVP Reminder] Please confirm your attendance", "from": "+15551234567", "to": "+15551234567"}

    Number of calls: 0

      205 |
      206 |       expect(result.success).toBe(true);
    > 207 |       expect(mockTwilio.messages.create).toHaveBeenCalledWith({
          |                                          ^
      208 |         body: '[RSVP Reminder] Please confirm your attendance',
      209 |         from: '+15551234567',
      210 |         to: '+15551234567',

      at Object.toHaveBeenCalledWith (services/smsService.test.ts:207:42)

  ● smsService › sendSMSFallback › should return UNKNOWN_ERROR when unexpected error occurs

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      222 |       );
      223 |
    > 224 |       expect(result.success).toBe(false);
          |                              ^
      225 |       if (!result.success) {
      226 |         expect(result.error.code).toBe('EXTERNAL_SERVICE_ERROR'); // sendSMS returns EXTERNAL_SERVICE_ERROR, not UNKNOWN_ERROR
      227 |       }

      at Object.toBe (services/smsService.test.ts:224:30)

  ● smsService › updateSMSDeliveryStatus › should return success when delivery status updated to delivered

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: {"delivered_at": Any<String>, "delivery_status": "delivered"}

    Number of calls: 0

      238 |
      239 |       expect(result.success).toBe(true);
    > 240 |       expect(mockUpdate).toHaveBeenCalledWith({
          |                          ^
      241 |         delivery_status: 'delivered',
      242 |         delivered_at: expect.any(String),
      243 |       });

      at Object.toHaveBeenCalledWith (services/smsService.test.ts:240:26)

  ● smsService › updateSMSDeliveryStatus › should return success when delivery status updated to failed with error message

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: {"delivery_status": "failed", "error_message": "Network error"}

    Number of calls: 0

      252 |
      253 |       expect(result.success).toBe(true);
    > 254 |       expect(mockUpdate).toHaveBeenCalledWith({
          |                          ^
      255 |         delivery_status: 'failed',
      256 |         error_message: 'Network error',
      257 |       });

      at Object.toHaveBeenCalledWith (services/smsService.test.ts:254:26)

  ● smsService › updateSMSDeliveryStatus › should return DATABASE_ERROR when update fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      265 |       const result = await updateSMSDeliveryStatus('sms-123', 'delivered');
      266 |
    > 267 |       expect(result.success).toBe(false);
          |                              ^
      268 |       if (!result.success) {
      269 |         expect(result.error.code).toBe('DATABASE_ERROR');
      270 |       }

      at Object.toBe (services/smsService.test.ts:267:30)

  ● smsService › updateSMSDeliveryStatus › should return UNKNOWN_ERROR when unexpected error occurs

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      278 |       const result = await updateSMSDeliveryStatus('sms-123', 'delivered');
      279 |
    > 280 |       expect(result.success).toBe(false);
          |                              ^
      281 |       if (!result.success) {
      282 |         expect(result.error.code).toBe('UNKNOWN_ERROR');
      283 |       }

      at Object.toBe (services/smsService.test.ts:280:30)

  ● smsService › getSMSAnalytics › should return success with SMS analytics when logs exist

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      301 |       const result = await getSMSAnalytics();
      302 |
    > 303 |       expect(result.success).toBe(true);
          |                              ^
      304 |       if (result.success) {
      305 |         expect(result.data.total).toBe(3);
      306 |         expect(result.data.delivered).toBe(1);

      at Object.toBe (services/smsService.test.ts:303:30)

  ● smsService › getSMSAnalytics › should return success with zero analytics when no logs exist

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      318 |       const result = await getSMSAnalytics();
      319 |
    > 320 |       expect(result.success).toBe(true);
          |                              ^
      321 |       if (result.success) {
      322 |         expect(result.data.total).toBe(0);
      323 |       }

      at Object.toBe (services/smsService.test.ts:320:30)

  ● smsService › getSMSAnalytics › should return DATABASE_ERROR when query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "UNKNOWN_ERROR"

      335 |       expect(result.success).toBe(false);
      336 |       if (!result.success) {
    > 337 |         expect(result.error.code).toBe('DATABASE_ERROR');
          |                                   ^
      338 |       }
      339 |     });
      340 |

      at Object.toBe (services/smsService.test.ts:337:35)

  ● smsService › getSMSLogs › should return success with SMS logs when no filters provided

    expect(received).toHaveLength(expected)

    Expected length: 2
    Received length: 0
    Received array:  []

      383 |       expect(result.success).toBe(true);
      384 |       if (result.success) {
    > 385 |         expect(result.data).toHaveLength(2);
          |                             ^
      386 |       }
      387 |     });
      388 |

      at Object.toHaveLength (services/smsService.test.ts:385:29)

  ● smsService › getSMSLogs › should return success with filtered logs when filters provided

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      412 |       });
      413 |
    > 414 |       expect(result.success).toBe(true);
          |                              ^
      415 |       if (result.success) {
      416 |         expect(result.data).toHaveLength(1);
      417 |       }

      at Object.toBe (services/smsService.test.ts:414:30)

  ● smsService › getSMSLogs › should return DATABASE_ERROR when query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      444 |       const result = await getSMSLogs();
      445 |
    > 446 |       expect(result.success).toBe(false);
          |                              ^
      447 |       if (!result.success) {
      448 |         expect(result.error.code).toBe('DATABASE_ERROR');
      449 |       }

      at Object.toBe (services/smsService.test.ts:446:30)

  ● smsService › getSMSLogs › should return UNKNOWN_ERROR when unexpected error occurs

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      457 |       const result = await getSMSLogs();
      458 |
    > 459 |       expect(result.success).toBe(false);
          |                              ^
      460 |       if (!result.success) {
      461 |         expect(result.error.code).toBe('UNKNOWN_ERROR');
      462 |       }

      at Object.toBe (services/smsService.test.ts:459:30)

FAIL services/budgetService.test.ts
  ● budgetService › calculateTotal - validation logic › should accept valid vendor categories

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "category", ["photography", "flowers"]

    Number of calls: 0

      54 |
      55 |       // Should pass validation and attempt database query
    > 56 |       expect(mockIn).toHaveBeenCalledWith('category', ['photography', 'flowers']);
         |                      ^
      57 |     });
      58 |
      59 |     it('should use default options when none provided', async () => {

      at Object.toHaveBeenCalledWith (services/budgetService.test.ts:56:22)

  ● budgetService › calculateTotal - validation logic › should use default options when none provided

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "vendors"

    Number of calls: 0

      68 |
      69 |       // Should call vendor query since includeVendors defaults to true
    > 70 |       expect(mockSupabase.from).toHaveBeenCalledWith('vendors');
         |                                 ^
      71 |     });
      72 |   });
      73 |

      at Object.toHaveBeenCalledWith (services/budgetService.test.ts:70:33)

  ● budgetService › getPaymentStatusReport - vendor categorization logic › should correctly calculate payment totals for different vendor statuses

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      114 |       const result = await budgetService.getPaymentStatusReport();
      115 |
    > 116 |       expect(result.success).toBe(true);
          |                              ^
      117 |       if (result.success) {
      118 |         // Verify vendor categorization
      119 |         expect(result.data.unpaidVendors).toHaveLength(1);

      at Object.toBe (services/budgetService.test.ts:116:30)

  ● budgetService › getPaymentStatusReport - vendor categorization logic › should handle empty vendor list

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      147 |       const result = await budgetService.getPaymentStatusReport();
      148 |
    > 149 |       expect(result.success).toBe(true);
          |                              ^
      150 |       if (result.success) {
      151 |         expect(result.data.unpaidVendors).toHaveLength(0);
      152 |         expect(result.data.partiallyPaidVendors).toHaveLength(0);

      at Object.toBe (services/budgetService.test.ts:149:30)

  ● budgetService › trackSubsidies - subsidy calculation logic › should handle empty activity list

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      170 |       const result = await budgetService.trackSubsidies();
      171 |
    > 172 |       expect(result.success).toBe(true);
          |                              ^
      173 |       if (result.success) {
      174 |         expect(result.data.activitySubsidies).toHaveLength(0);
      175 |         expect(result.data.totalActivitySubsidies).toBe(0);

      at Object.toBe (services/budgetService.test.ts:172:30)

  ● budgetService › trackSubsidies - subsidy calculation logic › should query activities with subsidies only

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "activities"

    Number of calls: 0

      190 |
      191 |       // Verify it queries for activities with non-null host_subsidy
    > 192 |       expect(mockSupabase.from).toHaveBeenCalledWith('activities');
          |                                 ^
      193 |       expect(mockNot).toHaveBeenCalledWith('host_subsidy', 'is', null);
      194 |     });
      195 |   });

      at Object.toHaveBeenCalledWith (services/budgetService.test.ts:192:33)

  ● budgetService › generateReport - comprehensive report structure › should return complete budget breakdown structure

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      209 |       const result = await budgetService.generateReport();
      210 |
    > 211 |       expect(result.success).toBe(true);
          |                              ^
      212 |       if (result.success) {
      213 |         // Verify structure
      214 |         expect(result.data).toHaveProperty('vendors');

      at Object.toBe (services/budgetService.test.ts:211:30)

  ● budgetService › error handling › should return DATABASE_ERROR when query fails

    expect(received).toBe(expected) // Object.is equality

    Expected: "DATABASE_ERROR"
    Received: "UNKNOWN_ERROR"

      251 |       expect(result.success).toBe(false);
      252 |       if (!result.success) {
    > 253 |         expect(result.error.code).toBe('DATABASE_ERROR');
          |                                   ^
      254 |         expect(result.error.message).toBe('Connection failed');
      255 |       }
      256 |     });

      at Object.toBe (services/budgetService.test.ts:253:35)

  ● budgetService › error handling › should return UNKNOWN_ERROR when unexpected error occurs

    expect(received).toBe(expected) // Object.is equality

    Expected: "Unexpected error"
    Received: "Cannot read properties of null (reading 'forEach')"

      267 |       if (!result.success) {
      268 |         expect(result.error.code).toBe('UNKNOWN_ERROR');
    > 269 |         expect(result.error.message).toBe('Unexpected error');
          |                                      ^
      270 |       }
      271 |     });
      272 |

      at Object.toBe (services/budgetService.test.ts:269:38)

  ● budgetService › error handling › should handle non-Error exceptions gracefully

    expect(received).toBe(expected) // Object.is equality

    Expected: "Unknown error occurred"
    Received: "Cannot read properties of null (reading 'forEach')"

      282 |       if (!result.success) {
      283 |         expect(result.error.code).toBe('UNKNOWN_ERROR');
    > 284 |         expect(result.error.message).toBe('Unknown error occurred');
          |                                      ^
      285 |       }
      286 |     });
      287 |   });

      at Object.toBe (services/budgetService.test.ts:284:38)


Test Suites: 9 failed, 29 passed, 38 total
Tests:       167 failed, 1 skipped, 521 passed, 689 total
Snapshots:   0 total
Time:        2.936 s
Ran all test suites matching /services\//i.
