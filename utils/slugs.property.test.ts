/**
 * Property-Based Tests for Slug Generation
 * 
 * Feature: destination-wedding-platform
 * Property 19: Slug Auto-Generation
 * Validates: Requirements 31.1, 31.5
 */

import * as fc from 'fast-check';
import { generateSlug, isValidSlug, normalizeSlug, makeUniqueSlug } from './slugs';

describe('Feature: destination-wedding-platform, Property 19: Slug Auto-Generation', () => {
  describe('generateSlug', () => {
    it('should always produce lowercase slugs', () => {
      fc.assert(
        fc.property(
          fc.string({ minLength: 1, maxLength: 100 }),
          (title) => {
            const slug = generateSlug(title);
            // If slug is not empty, it should be lowercase
            if (slug.length > 0) {
              expect(slug).toBe(slug.toLowerCase());
            }
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should replace spaces with hyphens', () => {
      fc.assert(
        fc.property(
          fc.string({ minLength: 1, maxLength: 100 }),
          (title) => {
            const slug = generateSlug(title);
            // Slug should not contain spaces
            expect(slug).not.toContain(' ');
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should remove special characters except hyphens', () => {
      fc.assert(
        fc.property(
          fc.string({ minLength: 1, maxLength: 100 }),
          (title) => {
            const slug = generateSlug(title);
            // Slug should only contain lowercase letters, numbers, and hyphens
            if (slug.length > 0) {
              expect(slug).toMatch(/^[a-z0-9-]+$/);
            }
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should not have leading or trailing hyphens', () => {
      fc.assert(
        fc.property(
          fc.string({ minLength: 1, maxLength: 100 }),
          (title) => {
            const slug = generateSlug(title);
            if (slug.length > 0) {
              expect(slug).not.toMatch(/^-/);
              expect(slug).not.toMatch(/-$/);
            }
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should not have consecutive hyphens', () => {
      fc.assert(
        fc.property(
          fc.string({ minLength: 1, maxLength: 100 }),
          (title) => {
            const slug = generateSlug(title);
            expect(slug).not.toContain('--');
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should be idempotent (generating slug from slug produces same result)', () => {
      fc.assert(
        fc.property(
          fc.string({ minLength: 1, maxLength: 100 }),
          (title) => {
            const slug1 = generateSlug(title);
            const slug2 = generateSlug(slug1);
            expect(slug1).toBe(slug2);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should handle titles with only special characters by returning empty string', () => {
      const specialCharsOnly = ['!!!', '@@@', '###', '***', '...', '---'];
      specialCharsOnly.forEach((title) => {
        const slug = generateSlug(title);
        expect(slug).toBe('');
      });
    });

    it('should preserve alphanumeric characters', () => {
      fc.assert(
        fc.property(
          fc.stringOf(fc.constantFrom('a', 'b', 'c', '1', '2', '3', ' ', '-')),
          (title) => {
            const slug = generateSlug(title);
            // Count alphanumeric chars in title
            const alphanumericInTitle = (title.match(/[a-z0-9]/gi) || []).length;
            // Count alphanumeric chars in slug
            const alphanumericInSlug = (slug.match(/[a-z0-9]/g) || []).length;
            // Slug should preserve all alphanumeric characters
            expect(alphanumericInSlug).toBe(alphanumericInTitle);
          }
        ),
        { numRuns: 100 }
      );
    });
  });

  describe('isValidSlug', () => {
    it('should return false for empty strings', () => {
      expect(isValidSlug('')).toBe(false);
      expect(isValidSlug('   ')).toBe(false);
    });

    it('should return false for slugs with only special characters', () => {
      expect(isValidSlug('---')).toBe(false);
      expect(isValidSlug('-')).toBe(false);
    });

    it('should return true for valid slugs', () => {
      expect(isValidSlug('hello-world')).toBe(true);
      expect(isValidSlug('test123')).toBe(true);
      expect(isValidSlug('my-page-2')).toBe(true);
    });

    it('should return false for slugs with uppercase letters', () => {
      expect(isValidSlug('Hello-World')).toBe(false);
    });

    it('should return false for slugs with spaces', () => {
      expect(isValidSlug('hello world')).toBe(false);
    });

    it('should accept any valid slug generated by generateSlug', () => {
      fc.assert(
        fc.property(
          fc.string({ minLength: 1, maxLength: 100 }).filter((s) => /[a-z0-9]/i.test(s)),
          (title) => {
            const slug = generateSlug(title);
            if (slug.length > 0) {
              expect(isValidSlug(slug)).toBe(true);
            }
          }
        ),
        { numRuns: 100 }
      );
    });
  });

  describe('normalizeSlug', () => {
    it('should produce the same result as generateSlug', () => {
      fc.assert(
        fc.property(
          fc.string({ minLength: 1, maxLength: 100 }),
          (input) => {
            const normalized = normalizeSlug(input);
            const generated = generateSlug(input);
            expect(normalized).toBe(generated);
          }
        ),
        { numRuns: 100 }
      );
    });
  });

  describe('makeUniqueSlug', () => {
    it('should return the base slug if it does not exist', () => {
      fc.assert(
        fc.property(
          fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug).filter((s) => s.length > 0),
          fc.array(fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug)),
          (baseSlug, existingSlugs) => {
            fc.pre(!existingSlugs.includes(baseSlug));
            const unique = makeUniqueSlug(baseSlug, existingSlugs);
            expect(unique).toBe(baseSlug);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should append -2 if base slug exists', () => {
      const baseSlug = 'hello-world';
      const existingSlugs = ['hello-world'];
      const unique = makeUniqueSlug(baseSlug, existingSlugs);
      expect(unique).toBe('hello-world-2');
    });

    it('should increment counter until unique slug is found', () => {
      const baseSlug = 'hello-world';
      const existingSlugs = ['hello-world', 'hello-world-2', 'hello-world-3'];
      const unique = makeUniqueSlug(baseSlug, existingSlugs);
      expect(unique).toBe('hello-world-4');
    });

    it('should always produce a unique slug', () => {
      fc.assert(
        fc.property(
          fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug).filter((s) => s.length > 0),
          fc.array(fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug), { maxLength: 20 }),
          (baseSlug, existingSlugs) => {
            const unique = makeUniqueSlug(baseSlug, existingSlugs);
            expect(existingSlugs).not.toContain(unique);
          }
        ),
        { numRuns: 100 }
      );
    });

    it('should preserve the base slug structure', () => {
      fc.assert(
        fc.property(
          fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug).filter((s) => s.length > 0),
          fc.array(fc.string({ minLength: 1, maxLength: 50 }).map(generateSlug), { maxLength: 20 }),
          (baseSlug, existingSlugs) => {
            const unique = makeUniqueSlug(baseSlug, existingSlugs);
            // Unique slug should start with base slug
            expect(unique.startsWith(baseSlug) || unique === baseSlug).toBe(true);
          }
        ),
        { numRuns: 100 }
      );
    });
  });
});
